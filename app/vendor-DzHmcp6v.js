var oh = Object.defineProperty; var lh = (o, l, u) => l in o ? oh(o, l, { enumerable: !0, configurable: !0, writable: !0, value: u }) : o[l] = u; var wf = (o, l, u) => lh(o, typeof l != "symbol" ? l + "" : l, u); function _mergeNamespaces(o, l) { for (var u = 0; u < l.length; u++) { const f = l[u]; if (typeof f != "string" && !Array.isArray(f)) { for (const p in f) if (p !== "default" && !(p in o)) { const d = Object.getOwnPropertyDescriptor(f, p); d && Object.defineProperty(o, p, d.get ? d : { enumerable: !0, get: () => f[p] }) } } } return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, { value: "Module" })) } var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs$1(o) { return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o } function getAugmentedNamespace(o) { if (Object.prototype.hasOwnProperty.call(o, "__esModule")) return o; var l = o.default; if (typeof l == "function") { var u = function f() { return this instanceof f ? Reflect.construct(l, arguments, this.constructor) : l.apply(this, arguments) }; u.prototype = l.prototype } else u = {}; return Object.defineProperty(u, "__esModule", { value: !0 }), Object.keys(o).forEach(function (f) { var p = Object.getOwnPropertyDescriptor(o, f); Object.defineProperty(u, f, p.get ? p : { enumerable: !0, get: function () { return o[f] } }) }), u } var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {}, react = { exports: {} }, react_production_min = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReact_production_min; function requireReact_production_min() { if (hasRequiredReact_production_min) return react_production_min; hasRequiredReact_production_min = 1; var o = Symbol.for("react.element"), l = Symbol.for("react.portal"), u = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), m = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), I = Symbol.for("react.suspense"), F = Symbol.for("react.memo"), B = Symbol.for("react.lazy"), W = Symbol.iterator; function Z(X) { return X === null || typeof X != "object" ? null : (X = W && X[W] || X["@@iterator"], typeof X == "function" ? X : null) } var Q = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, re = Object.assign, ne = {}; function oe(X, ce, me) { this.props = X, this.context = ce, this.refs = ne, this.updater = me || Q } oe.prototype.isReactComponent = {}, oe.prototype.setState = function (X, ce) { if (typeof X != "object" && typeof X != "function" && X != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, X, ce, "setState") }, oe.prototype.forceUpdate = function (X) { this.updater.enqueueForceUpdate(this, X, "forceUpdate") }; function ae() { } ae.prototype = oe.prototype; function se(X, ce, me) { this.props = X, this.context = ce, this.refs = ne, this.updater = me || Q } var le = se.prototype = new ae; le.constructor = se, re(le, oe.prototype), le.isPureReactComponent = !0; var ue = Array.isArray, he = Object.prototype.hasOwnProperty, pe = { current: null }, ve = { key: !0, ref: !0, __self: !0, __source: !0 }; function _e(X, ce, me) { var Ae, Ie = {}, Be = null, Me = null; if (ce != null) for (Ae in ce.ref !== void 0 && (Me = ce.ref), ce.key !== void 0 && (Be = "" + ce.key), ce) he.call(ce, Ae) && !ve.hasOwnProperty(Ae) && (Ie[Ae] = ce[Ae]); var De = arguments.length - 2; if (De === 1) Ie.children = me; else if (1 < De) { for (var Ue = Array(De), Ke = 0; Ke < De; Ke++)Ue[Ke] = arguments[Ke + 2]; Ie.children = Ue } if (X && X.defaultProps) for (Ae in De = X.defaultProps, De) Ie[Ae] === void 0 && (Ie[Ae] = De[Ae]); return { $$typeof: o, type: X, key: Be, ref: Me, props: Ie, _owner: pe.current } } function Se(X, ce) { return { $$typeof: o, type: X.type, key: ce, ref: X.ref, props: X.props, _owner: X._owner } } function $e(X) { return typeof X == "object" && X !== null && X.$$typeof === o } function ie(X) { var ce = { "=": "=0", ":": "=2" }; return "$" + X.replace(/[=:]/g, function (me) { return ce[me] }) } var g = /\/+/g; function P(X, ce) { return typeof X == "object" && X !== null && X.key != null ? ie("" + X.key) : ce.toString(36) } function U(X, ce, me, Ae, Ie) { var Be = typeof X; (Be === "undefined" || Be === "boolean") && (X = null); var Me = !1; if (X === null) Me = !0; else switch (Be) { case "string": case "number": Me = !0; break; case "object": switch (X.$$typeof) { case o: case l: Me = !0 } }if (Me) return Me = X, Ie = Ie(Me), X = Ae === "" ? "." + P(Me, 0) : Ae, ue(Ie) ? (me = "", X != null && (me = X.replace(g, "$&/") + "/"), U(Ie, ce, me, "", function (Ke) { return Ke })) : Ie != null && ($e(Ie) && (Ie = Se(Ie, me + (!Ie.key || Me && Me.key === Ie.key ? "" : ("" + Ie.key).replace(g, "$&/") + "/") + X)), ce.push(Ie)), 1; if (Me = 0, Ae = Ae === "" ? "." : Ae + ":", ue(X)) for (var De = 0; De < X.length; De++) { Be = X[De]; var Ue = Ae + P(Be, De); Me += U(Be, ce, me, Ue, Ie) } else if (Ue = Z(X), typeof Ue == "function") for (X = Ue.call(X), De = 0; !(Be = X.next()).done;)Be = Be.value, Ue = Ae + P(Be, De++), Me += U(Be, ce, me, Ue, Ie); else if (Be === "object") throw ce = String(X), Error("Objects are not valid as a React child (found: " + (ce === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : ce) + "). If you meant to render a collection of children, use an array instead."); return Me } function K(X, ce, me) { if (X == null) return X; var Ae = [], Ie = 0; return U(X, Ae, "", "", function (Be) { return ce.call(me, Be, Ie++) }), Ae } function Y(X) { if (X._status === -1) { var ce = X._result; ce = ce(), ce.then(function (me) { (X._status === 0 || X._status === -1) && (X._status = 1, X._result = me) }, function (me) { (X._status === 0 || X._status === -1) && (X._status = 2, X._result = me) }), X._status === -1 && (X._status = 0, X._result = ce) } if (X._status === 1) return X._result.default; throw X._result } var te = { current: null }, ee = { transition: null }, G = { ReactCurrentDispatcher: te, ReactCurrentBatchConfig: ee, ReactCurrentOwner: pe }; function y() { throw Error("act(...) is not supported in production builds of React.") } return react_production_min.Children = { map: K, forEach: function (X, ce, me) { K(X, function () { ce.apply(this, arguments) }, me) }, count: function (X) { var ce = 0; return K(X, function () { ce++ }), ce }, toArray: function (X) { return K(X, function (ce) { return ce }) || [] }, only: function (X) { if (!$e(X)) throw Error("React.Children.only expected to receive a single React element child."); return X } }, react_production_min.Component = oe, react_production_min.Fragment = u, react_production_min.Profiler = p, react_production_min.PureComponent = se, react_production_min.StrictMode = f, react_production_min.Suspense = I, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = G, react_production_min.act = y, react_production_min.cloneElement = function (X, ce, me) { if (X == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + X + "."); var Ae = re({}, X.props), Ie = X.key, Be = X.ref, Me = X._owner; if (ce != null) { if (ce.ref !== void 0 && (Be = ce.ref, Me = pe.current), ce.key !== void 0 && (Ie = "" + ce.key), X.type && X.type.defaultProps) var De = X.type.defaultProps; for (Ue in ce) he.call(ce, Ue) && !ve.hasOwnProperty(Ue) && (Ae[Ue] = ce[Ue] === void 0 && De !== void 0 ? De[Ue] : ce[Ue]) } var Ue = arguments.length - 2; if (Ue === 1) Ae.children = me; else if (1 < Ue) { De = Array(Ue); for (var Ke = 0; Ke < Ue; Ke++)De[Ke] = arguments[Ke + 2]; Ae.children = De } return { $$typeof: o, type: X.type, key: Ie, ref: Be, props: Ae, _owner: Me } }, react_production_min.createContext = function (X) { return X = { $$typeof: m, _currentValue: X, _currentValue2: X, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, X.Provider = { $$typeof: d, _context: X }, X.Consumer = X }, react_production_min.createElement = _e, react_production_min.createFactory = function (X) { var ce = _e.bind(null, X); return ce.type = X, ce }, react_production_min.createRef = function () { return { current: null } }, react_production_min.forwardRef = function (X) { return { $$typeof: v, render: X } }, react_production_min.isValidElement = $e, react_production_min.lazy = function (X) { return { $$typeof: B, _payload: { _status: -1, _result: X }, _init: Y } }, react_production_min.memo = function (X, ce) { return { $$typeof: F, type: X, compare: ce === void 0 ? null : ce } }, react_production_min.startTransition = function (X) { var ce = ee.transition; ee.transition = {}; try { X() } finally { ee.transition = ce } }, react_production_min.unstable_act = y, react_production_min.useCallback = function (X, ce) { return te.current.useCallback(X, ce) }, react_production_min.useContext = function (X) { return te.current.useContext(X) }, react_production_min.useDebugValue = function () { }, react_production_min.useDeferredValue = function (X) { return te.current.useDeferredValue(X) }, react_production_min.useEffect = function (X, ce) { return te.current.useEffect(X, ce) }, react_production_min.useId = function () { return te.current.useId() }, react_production_min.useImperativeHandle = function (X, ce, me) { return te.current.useImperativeHandle(X, ce, me) }, react_production_min.useInsertionEffect = function (X, ce) { return te.current.useInsertionEffect(X, ce) }, react_production_min.useLayoutEffect = function (X, ce) { return te.current.useLayoutEffect(X, ce) }, react_production_min.useMemo = function (X, ce) { return te.current.useMemo(X, ce) }, react_production_min.useReducer = function (X, ce, me) { return te.current.useReducer(X, ce, me) }, react_production_min.useRef = function (X) { return te.current.useRef(X) }, react_production_min.useState = function (X) { return te.current.useState(X) }, react_production_min.useSyncExternalStore = function (X, ce, me) { return te.current.useSyncExternalStore(X, ce, me) }, react_production_min.useTransition = function () { return te.current.useTransition() }, react_production_min.version = "18.3.1", react_production_min } var hasRequiredReact; function requireReact() { return hasRequiredReact || (hasRequiredReact = 1, react.exports = requireReact_production_min()), react.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactJsxRuntime_production_min; function requireReactJsxRuntime_production_min() { if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min; hasRequiredReactJsxRuntime_production_min = 1; var o = requireReact(), l = Symbol.for("react.element"), u = Symbol.for("react.fragment"), f = Object.prototype.hasOwnProperty, p = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, d = { key: !0, ref: !0, __self: !0, __source: !0 }; function m(v, I, F) { var B, W = {}, Z = null, Q = null; F !== void 0 && (Z = "" + F), I.key !== void 0 && (Z = "" + I.key), I.ref !== void 0 && (Q = I.ref); for (B in I) f.call(I, B) && !d.hasOwnProperty(B) && (W[B] = I[B]); if (v && v.defaultProps) for (B in I = v.defaultProps, I) W[B] === void 0 && (W[B] = I[B]); return { $$typeof: l, type: v, key: Z, ref: Q, props: W, _owner: p.current } } return reactJsxRuntime_production_min.Fragment = u, reactJsxRuntime_production_min.jsx = m, reactJsxRuntime_production_min.jsxs = m, reactJsxRuntime_production_min } var hasRequiredJsxRuntime; function requireJsxRuntime() { return hasRequiredJsxRuntime || (hasRequiredJsxRuntime = 1, jsxRuntime.exports = requireReactJsxRuntime_production_min()), jsxRuntime.exports } var jsxRuntimeExports = requireJsxRuntime(); const consoleLogger = { type: "logger", log(o) { this.output("log", o) }, warn(o) { this.output("warn", o) }, error(o) { this.output("error", o) }, output(o, l) { console && console[o] && console[o].apply(console, l) } }; class Logger { constructor(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; this.init(l, u) } init(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; this.prefix = u.prefix || "i18next:", this.logger = l || consoleLogger, this.options = u, this.debug = u.debug } log() { for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)u[f] = arguments[f]; return this.forward(u, "log", "", !0) } warn() { for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)u[f] = arguments[f]; return this.forward(u, "warn", "", !0) } error() { for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)u[f] = arguments[f]; return this.forward(u, "error", "") } deprecate() { for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)u[f] = arguments[f]; return this.forward(u, "warn", "WARNING DEPRECATED: ", !0) } forward(l, u, f, p) { return p && !this.debug ? null : (typeof l[0] == "string" && (l[0] = `${f}${this.prefix} ${l[0]}`), this.logger[u](l)) } create(l) { return new Logger(this.logger, { prefix: `${this.prefix}:${l}:`, ...this.options }) } clone(l) { return l = l || this.options, l.prefix = l.prefix || this.prefix, new Logger(this.logger, l) } } var baseLogger = new Logger; class EventEmitter { constructor() { this.observers = {} } on(l, u) { return l.split(" ").forEach(f => { this.observers[f] || (this.observers[f] = new Map); const p = this.observers[f].get(u) || 0; this.observers[f].set(u, p + 1) }), this } off(l, u) { if (this.observers[l]) { if (!u) { delete this.observers[l]; return } this.observers[l].delete(u) } } emit(l) { for (var u = arguments.length, f = new Array(u > 1 ? u - 1 : 0), p = 1; p < u; p++)f[p - 1] = arguments[p]; this.observers[l] && Array.from(this.observers[l].entries()).forEach(m => { let [v, I] = m; for (let F = 0; F < I; F++)v(...f) }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(m => { let [v, I] = m; for (let F = 0; F < I; F++)v.apply(v, [l, ...f]) }) } } function defer() { let o, l; const u = new Promise((f, p) => { o = f, l = p }); return u.resolve = o, u.reject = l, u } function makeString(o) { return o == null ? "" : "" + o } function copy(o, l, u) { o.forEach(f => { l[f] && (u[f] = l[f]) }) } const lastOfPathSeparatorRegExp = /###/g; function getLastOfPath(o, l, u) { function f(v) { return v && v.indexOf("###") > -1 ? v.replace(lastOfPathSeparatorRegExp, ".") : v } function p() { return !o || typeof o == "string" } const d = typeof l != "string" ? l : l.split("."); let m = 0; for (; m < d.length - 1;) { if (p()) return {}; const v = f(d[m]); !o[v] && u && (o[v] = new u), Object.prototype.hasOwnProperty.call(o, v) ? o = o[v] : o = {}, ++m } return p() ? {} : { obj: o, k: f(d[m]) } } function setPath(o, l, u) { const { obj: f, k: p } = getLastOfPath(o, l, Object); if (f !== void 0 || l.length === 1) { f[p] = u; return } let d = l[l.length - 1], m = l.slice(0, l.length - 1), v = getLastOfPath(o, m, Object); for (; v.obj === void 0 && m.length;)d = `${m[m.length - 1]}.${d}`, m = m.slice(0, m.length - 1), v = getLastOfPath(o, m, Object), v && v.obj && typeof v.obj[`${v.k}.${d}`] < "u" && (v.obj = void 0); v.obj[`${v.k}.${d}`] = u } function pushPath(o, l, u, f) { const { obj: p, k: d } = getLastOfPath(o, l, Object); p[d] = p[d] || [], p[d].push(u) } function getPath(o, l) { const { obj: u, k: f } = getLastOfPath(o, l); if (u) return u[f] } function getPathWithDefaults(o, l, u) { const f = getPath(o, u); return f !== void 0 ? f : getPath(l, u) } function deepExtend(o, l, u) { for (const f in l) f !== "__proto__" && f !== "constructor" && (f in o ? typeof o[f] == "string" || o[f] instanceof String || typeof l[f] == "string" || l[f] instanceof String ? u && (o[f] = l[f]) : deepExtend(o[f], l[f], u) : o[f] = l[f]); return o } function regexEscape(o) { return o.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") } var _entityMap = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" }; function escape$1(o) { return typeof o == "string" ? o.replace(/[&<>"'\/]/g, l => _entityMap[l]) : o } class RegExpCache { constructor(l) { this.capacity = l, this.regExpMap = new Map, this.regExpQueue = [] } getRegExp(l) { const u = this.regExpMap.get(l); if (u !== void 0) return u; const f = new RegExp(l); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(l, f), this.regExpQueue.push(l), f } } const chars = [" ", ",", "?", "!", ";"], looksLikeObjectPathRegExpCache = new RegExpCache(20); function looksLikeObjectPath(o, l, u) { l = l || "", u = u || ""; const f = chars.filter(m => l.indexOf(m) < 0 && u.indexOf(m) < 0); if (f.length === 0) return !0; const p = looksLikeObjectPathRegExpCache.getRegExp(`(${f.map(m => m === "?" ? "\\?" : m).join("|")})`); let d = !p.test(o); if (!d) { const m = o.indexOf(u); m > 0 && !p.test(o.substring(0, m)) && (d = !0) } return d } function deepFind(o, l) { let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "."; if (!o) return; if (o[l]) return o[l]; const f = l.split(u); let p = o; for (let d = 0; d < f.length;) { if (!p || typeof p != "object") return; let m, v = ""; for (let I = d; I < f.length; ++I)if (I !== d && (v += u), v += f[I], m = p[v], m !== void 0) { if (["string", "number", "boolean"].indexOf(typeof m) > -1 && I < f.length - 1) continue; d += I - d + 1; break } p = m } return p } function getCleanedCode(o) { return o && o.indexOf("_") > 0 ? o.replace("_", "-") : o } class ResourceStore extends EventEmitter { constructor(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { ns: ["translation"], defaultNS: "translation" }; super(), this.data = l || {}, this.options = u, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0) } addNamespaces(l) { this.options.ns.indexOf(l) < 0 && this.options.ns.push(l) } removeNamespaces(l) { const u = this.options.ns.indexOf(l); u > -1 && this.options.ns.splice(u, 1) } getResource(l, u, f) { let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}; const d = p.keySeparator !== void 0 ? p.keySeparator : this.options.keySeparator, m = p.ignoreJSONStructure !== void 0 ? p.ignoreJSONStructure : this.options.ignoreJSONStructure; let v; l.indexOf(".") > -1 ? v = l.split(".") : (v = [l, u], f && (Array.isArray(f) ? v.push(...f) : typeof f == "string" && d ? v.push(...f.split(d)) : v.push(f))); const I = getPath(this.data, v); return !I && !u && !f && l.indexOf(".") > -1 && (l = v[0], u = v[1], f = v.slice(2).join(".")), I || !m || typeof f != "string" ? I : deepFind(this.data && this.data[l] && this.data[l][u], f, d) } addResource(l, u, f, p) { let d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : { silent: !1 }; const m = d.keySeparator !== void 0 ? d.keySeparator : this.options.keySeparator; let v = [l, u]; f && (v = v.concat(m ? f.split(m) : f)), l.indexOf(".") > -1 && (v = l.split("."), p = u, u = v[1]), this.addNamespaces(u), setPath(this.data, v, p), d.silent || this.emit("added", l, u, f, p) } addResources(l, u, f) { let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { silent: !1 }; for (const d in f) (typeof f[d] == "string" || Array.isArray(f[d])) && this.addResource(l, u, d, f[d], { silent: !0 }); p.silent || this.emit("added", l, u, f) } addResourceBundle(l, u, f, p, d) { let m = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : { silent: !1, skipCopy: !1 }, v = [l, u]; l.indexOf(".") > -1 && (v = l.split("."), p = f, f = u, u = v[1]), this.addNamespaces(u); let I = getPath(this.data, v) || {}; m.skipCopy || (f = JSON.parse(JSON.stringify(f))), p ? deepExtend(I, f, d) : I = { ...I, ...f }, setPath(this.data, v, I), m.silent || this.emit("added", l, u, f) } removeResourceBundle(l, u) { this.hasResourceBundle(l, u) && delete this.data[l][u], this.removeNamespaces(u), this.emit("removed", l, u) } hasResourceBundle(l, u) { return this.getResource(l, u) !== void 0 } getResourceBundle(l, u) { return u || (u = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? { ...this.getResource(l, u) } : this.getResource(l, u) } getDataByLanguage(l) { return this.data[l] } hasLanguageSomeTranslations(l) { const u = this.getDataByLanguage(l); return !!(u && Object.keys(u) || []).find(p => u[p] && Object.keys(u[p]).length > 0) } toJSON() { return this.data } } var postProcessor = { processors: {}, addPostProcessor(o) { this.processors[o.name] = o }, handle(o, l, u, f, p) { return o.forEach(d => { this.processors[d] && (l = this.processors[d].process(l, u, f, p)) }), l } }; const checkedLoadedFor = {}; class Translator extends EventEmitter { constructor(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; super(), copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], l, this), this.options = u, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = baseLogger.create("translator") } changeLanguage(l) { l && (this.language = l) } exists(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { interpolation: {} }; if (l == null) return !1; const f = this.resolve(l, u); return f && f.res !== void 0 } extractFromKey(l, u) { let f = u.nsSeparator !== void 0 ? u.nsSeparator : this.options.nsSeparator; f === void 0 && (f = ":"); const p = u.keySeparator !== void 0 ? u.keySeparator : this.options.keySeparator; let d = u.ns || this.options.defaultNS || []; const m = f && l.indexOf(f) > -1, v = !this.options.userDefinedKeySeparator && !u.keySeparator && !this.options.userDefinedNsSeparator && !u.nsSeparator && !looksLikeObjectPath(l, f, p); if (m && !v) { const I = l.match(this.interpolator.nestingRegexp); if (I && I.length > 0) return { key: l, namespaces: d }; const F = l.split(f); (f !== p || f === p && this.options.ns.indexOf(F[0]) > -1) && (d = F.shift()), l = F.join(p) } return typeof d == "string" && (d = [d]), { key: l, namespaces: d } } translate(l, u, f) { if (typeof u != "object" && this.options.overloadTranslationOptionHandler && (u = this.options.overloadTranslationOptionHandler(arguments)), typeof u == "object" && (u = { ...u }), u || (u = {}), l == null) return ""; Array.isArray(l) || (l = [String(l)]); const p = u.returnDetails !== void 0 ? u.returnDetails : this.options.returnDetails, d = u.keySeparator !== void 0 ? u.keySeparator : this.options.keySeparator, { key: m, namespaces: v } = this.extractFromKey(l[l.length - 1], u), I = v[v.length - 1], F = u.lng || this.language, B = u.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if (F && F.toLowerCase() === "cimode") { if (B) { const ue = u.nsSeparator || this.options.nsSeparator; return p ? { res: `${I}${ue}${m}`, usedKey: m, exactUsedKey: m, usedLng: F, usedNS: I, usedParams: this.getUsedParamsDetails(u) } : `${I}${ue}${m}` } return p ? { res: m, usedKey: m, exactUsedKey: m, usedLng: F, usedNS: I, usedParams: this.getUsedParamsDetails(u) } : m } const W = this.resolve(l, u); let Z = W && W.res; const Q = W && W.usedKey || m, re = W && W.exactUsedKey || m, ne = Object.prototype.toString.apply(Z), oe = ["[object Number]", "[object Function]", "[object RegExp]"], ae = u.joinArrays !== void 0 ? u.joinArrays : this.options.joinArrays, se = !this.i18nFormat || this.i18nFormat.handleAsObject; if (se && Z && (typeof Z != "string" && typeof Z != "boolean" && typeof Z != "number") && oe.indexOf(ne) < 0 && !(typeof ae == "string" && Array.isArray(Z))) { if (!u.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"); const ue = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(Q, Z, { ...u, ns: v }) : `key '${m} (${this.language})' returned an object instead of string.`; return p ? (W.res = ue, W.usedParams = this.getUsedParamsDetails(u), W) : ue } if (d) { const ue = Array.isArray(Z), he = ue ? [] : {}, pe = ue ? re : Q; for (const ve in Z) if (Object.prototype.hasOwnProperty.call(Z, ve)) { const _e = `${pe}${d}${ve}`; he[ve] = this.translate(_e, { ...u, joinArrays: !1, ns: v }), he[ve] === _e && (he[ve] = Z[ve]) } Z = he } } else if (se && typeof ae == "string" && Array.isArray(Z)) Z = Z.join(ae), Z && (Z = this.extendTranslation(Z, l, u, f)); else { let ue = !1, he = !1; const pe = u.count !== void 0 && typeof u.count != "string", ve = Translator.hasDefaultValue(u), _e = pe ? this.pluralResolver.getSuffix(F, u.count, u) : "", Se = u.ordinal && pe ? this.pluralResolver.getSuffix(F, u.count, { ordinal: !1 }) : "", $e = pe && !u.ordinal && u.count === 0 && this.pluralResolver.shouldUseIntlApi(), ie = $e && u[`defaultValue${this.options.pluralSeparator}zero`] || u[`defaultValue${_e}`] || u[`defaultValue${Se}`] || u.defaultValue; !this.isValidLookup(Z) && ve && (ue = !0, Z = ie), this.isValidLookup(Z) || (he = !0, Z = m); const P = (u.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && he ? void 0 : Z, U = ve && ie !== Z && this.options.updateMissing; if (he || ue || U) { if (this.logger.log(U ? "updateKey" : "missingKey", F, I, m, U ? ie : Z), d) { const ee = this.resolve(m, { ...u, keySeparator: !1 }); ee && ee.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.") } let K = []; const Y = this.languageUtils.getFallbackCodes(this.options.fallbackLng, u.lng || this.language); if (this.options.saveMissingTo === "fallback" && Y && Y[0]) for (let ee = 0; ee < Y.length; ee++)K.push(Y[ee]); else this.options.saveMissingTo === "all" ? K = this.languageUtils.toResolveHierarchy(u.lng || this.language) : K.push(u.lng || this.language); const te = (ee, G, y) => { const X = ve && y !== Z ? y : P; this.options.missingKeyHandler ? this.options.missingKeyHandler(ee, I, G, X, U, u) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(ee, I, G, X, U, u), this.emit("missingKey", ee, I, G, Z) }; this.options.saveMissing && (this.options.saveMissingPlurals && pe ? K.forEach(ee => { const G = this.pluralResolver.getSuffixes(ee, u); $e && u[`defaultValue${this.options.pluralSeparator}zero`] && G.indexOf(`${this.options.pluralSeparator}zero`) < 0 && G.push(`${this.options.pluralSeparator}zero`), G.forEach(y => { te([ee], m + y, u[`defaultValue${y}`] || ie) }) }) : te(K, m, ie)) } Z = this.extendTranslation(Z, l, u, W, f), he && Z === m && this.options.appendNamespaceToMissingKey && (Z = `${I}:${m}`), (he || ue) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? Z = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${I}:${m}` : m, ue ? Z : void 0) : Z = this.options.parseMissingKeyHandler(Z)) } return p ? (W.res = Z, W.usedParams = this.getUsedParamsDetails(u), W) : Z } extendTranslation(l, u, f, p, d) { var m = this; if (this.i18nFormat && this.i18nFormat.parse) l = this.i18nFormat.parse(l, { ...this.options.interpolation.defaultVariables, ...f }, f.lng || this.language || p.usedLng, p.usedNS, p.usedKey, { resolved: p }); else if (!f.skipInterpolation) { f.interpolation && this.interpolator.init({ ...f, interpolation: { ...this.options.interpolation, ...f.interpolation } }); const F = typeof l == "string" && (f && f.interpolation && f.interpolation.skipOnVariables !== void 0 ? f.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let B; if (F) { const Z = l.match(this.interpolator.nestingRegexp); B = Z && Z.length } let W = f.replace && typeof f.replace != "string" ? f.replace : f; if (this.options.interpolation.defaultVariables && (W = { ...this.options.interpolation.defaultVariables, ...W }), l = this.interpolator.interpolate(l, W, f.lng || this.language || p.usedLng, f), F) { const Z = l.match(this.interpolator.nestingRegexp), Q = Z && Z.length; B < Q && (f.nest = !1) } !f.lng && this.options.compatibilityAPI !== "v1" && p && p.res && (f.lng = this.language || p.usedLng), f.nest !== !1 && (l = this.interpolator.nest(l, function () { for (var Z = arguments.length, Q = new Array(Z), re = 0; re < Z; re++)Q[re] = arguments[re]; return d && d[0] === Q[0] && !f.context ? (m.logger.warn(`It seems you are nesting recursively key: ${Q[0]} in key: ${u[0]}`), null) : m.translate(...Q, u) }, f)), f.interpolation && this.interpolator.reset() } const v = f.postProcess || this.options.postProcess, I = typeof v == "string" ? [v] : v; return l != null && I && I.length && f.applyPostProcessor !== !1 && (l = postProcessor.handle(I, l, u, this.options && this.options.postProcessPassResolved ? { i18nResolved: { ...p, usedParams: this.getUsedParamsDetails(f) }, ...f } : f, this)), l } resolve(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f, p, d, m, v; return typeof l == "string" && (l = [l]), l.forEach(I => { if (this.isValidLookup(f)) return; const F = this.extractFromKey(I, u), B = F.key; p = B; let W = F.namespaces; this.options.fallbackNS && (W = W.concat(this.options.fallbackNS)); const Z = u.count !== void 0 && typeof u.count != "string", Q = Z && !u.ordinal && u.count === 0 && this.pluralResolver.shouldUseIntlApi(), re = u.context !== void 0 && (typeof u.context == "string" || typeof u.context == "number") && u.context !== "", ne = u.lngs ? u.lngs : this.languageUtils.toResolveHierarchy(u.lng || this.language, u.fallbackLng); W.forEach(oe => { this.isValidLookup(f) || (v = oe, !checkedLoadedFor[`${ne[0]}-${oe}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(v) && (checkedLoadedFor[`${ne[0]}-${oe}`] = !0, this.logger.warn(`key "${p}" for languages "${ne.join(", ")}" won't get resolved as namespace "${v}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ne.forEach(ae => { if (this.isValidLookup(f)) return; m = ae; const se = [B]; if (this.i18nFormat && this.i18nFormat.addLookupKeys) this.i18nFormat.addLookupKeys(se, B, ae, oe, u); else { let ue; Z && (ue = this.pluralResolver.getSuffix(ae, u.count, u)); const he = `${this.options.pluralSeparator}zero`, pe = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (Z && (se.push(B + ue), u.ordinal && ue.indexOf(pe) === 0 && se.push(B + ue.replace(pe, this.options.pluralSeparator)), Q && se.push(B + he)), re) { const ve = `${B}${this.options.contextSeparator}${u.context}`; se.push(ve), Z && (se.push(ve + ue), u.ordinal && ue.indexOf(pe) === 0 && se.push(ve + ue.replace(pe, this.options.pluralSeparator)), Q && se.push(ve + he)) } } let le; for (; le = se.pop();)this.isValidLookup(f) || (d = le, f = this.getResource(ae, oe, le, u)) })) }) }), { res: f, usedKey: p, exactUsedKey: d, usedLng: m, usedNS: v } } isValidLookup(l) { return l !== void 0 && !(!this.options.returnNull && l === null) && !(!this.options.returnEmptyString && l === "") } getResource(l, u, f) { let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}; return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(l, u, f, p) : this.resourceStore.getResource(l, u, f, p) } getUsedParamsDetails() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const u = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], f = l.replace && typeof l.replace != "string"; let p = f ? l.replace : l; if (f && typeof l.count < "u" && (p.count = l.count), this.options.interpolation.defaultVariables && (p = { ...this.options.interpolation.defaultVariables, ...p }), !f) { p = { ...p }; for (const d of u) delete p[d] } return p } static hasDefaultValue(l) { const u = "defaultValue"; for (const f in l) if (Object.prototype.hasOwnProperty.call(l, f) && u === f.substring(0, u.length) && l[f] !== void 0) return !0; return !1 } } function capitalize(o) { return o.charAt(0).toUpperCase() + o.slice(1) } class LanguageUtil { constructor(l) { this.options = l, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils") } getScriptPartFromCode(l) { if (l = getCleanedCode(l), !l || l.indexOf("-") < 0) return null; const u = l.split("-"); return u.length === 2 || (u.pop(), u[u.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(u.join("-")) } getLanguagePartFromCode(l) { if (l = getCleanedCode(l), !l || l.indexOf("-") < 0) return l; const u = l.split("-"); return this.formatLanguageCode(u[0]) } formatLanguageCode(l) { if (typeof l == "string" && l.indexOf("-") > -1) { const u = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"]; let f = l.split("-"); return this.options.lowerCaseLng ? f = f.map(p => p.toLowerCase()) : f.length === 2 ? (f[0] = f[0].toLowerCase(), f[1] = f[1].toUpperCase(), u.indexOf(f[1].toLowerCase()) > -1 && (f[1] = capitalize(f[1].toLowerCase()))) : f.length === 3 && (f[0] = f[0].toLowerCase(), f[1].length === 2 && (f[1] = f[1].toUpperCase()), f[0] !== "sgn" && f[2].length === 2 && (f[2] = f[2].toUpperCase()), u.indexOf(f[1].toLowerCase()) > -1 && (f[1] = capitalize(f[1].toLowerCase())), u.indexOf(f[2].toLowerCase()) > -1 && (f[2] = capitalize(f[2].toLowerCase()))), f.join("-") } return this.options.cleanCode || this.options.lowerCaseLng ? l.toLowerCase() : l } isSupportedCode(l) { return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (l = this.getLanguagePartFromCode(l)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(l) > -1 } getBestMatchFromCodes(l) { if (!l) return null; let u; return l.forEach(f => { if (u) return; const p = this.formatLanguageCode(f); (!this.options.supportedLngs || this.isSupportedCode(p)) && (u = p) }), !u && this.options.supportedLngs && l.forEach(f => { if (u) return; const p = this.getLanguagePartFromCode(f); if (this.isSupportedCode(p)) return u = p; u = this.options.supportedLngs.find(d => { if (d === p) return d; if (!(d.indexOf("-") < 0 && p.indexOf("-") < 0) && (d.indexOf("-") > 0 && p.indexOf("-") < 0 && d.substring(0, d.indexOf("-")) === p || d.indexOf(p) === 0 && p.length > 1)) return d }) }), u || (u = this.getFallbackCodes(this.options.fallbackLng)[0]), u } getFallbackCodes(l, u) { if (!l) return []; if (typeof l == "function" && (l = l(u)), typeof l == "string" && (l = [l]), Array.isArray(l)) return l; if (!u) return l.default || []; let f = l[u]; return f || (f = l[this.getScriptPartFromCode(u)]), f || (f = l[this.formatLanguageCode(u)]), f || (f = l[this.getLanguagePartFromCode(u)]), f || (f = l.default), f || [] } toResolveHierarchy(l, u) { const f = this.getFallbackCodes(u || this.options.fallbackLng || [], l), p = [], d = m => { m && (this.isSupportedCode(m) ? p.push(m) : this.logger.warn(`rejecting language code not found in supportedLngs: ${m}`)) }; return typeof l == "string" && (l.indexOf("-") > -1 || l.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && d(this.formatLanguageCode(l)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && d(this.getScriptPartFromCode(l)), this.options.load !== "currentOnly" && d(this.getLanguagePartFromCode(l))) : typeof l == "string" && d(this.formatLanguageCode(l)), f.forEach(m => { p.indexOf(m) < 0 && d(this.formatLanguageCode(m)) }), p } } let sets = [{ lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"], nr: [1, 2], fc: 1 }, { lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"], nr: [1, 2], fc: 2 }, { lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"], nr: [1], fc: 3 }, { lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"], nr: [1, 2, 5], fc: 4 }, { lngs: ["ar"], nr: [0, 1, 2, 3, 11, 100], fc: 5 }, { lngs: ["cs", "sk"], nr: [1, 2, 5], fc: 6 }, { lngs: ["csb", "pl"], nr: [1, 2, 5], fc: 7 }, { lngs: ["cy"], nr: [1, 2, 3, 8], fc: 8 }, { lngs: ["fr"], nr: [1, 2], fc: 9 }, { lngs: ["ga"], nr: [1, 2, 3, 7, 11], fc: 10 }, { lngs: ["gd"], nr: [1, 2, 3, 20], fc: 11 }, { lngs: ["is"], nr: [1, 2], fc: 12 }, { lngs: ["jv"], nr: [0, 1], fc: 13 }, { lngs: ["kw"], nr: [1, 2, 3, 4], fc: 14 }, { lngs: ["lt"], nr: [1, 2, 10], fc: 15 }, { lngs: ["lv"], nr: [1, 2, 0], fc: 16 }, { lngs: ["mk"], nr: [1, 2], fc: 17 }, { lngs: ["mnk"], nr: [0, 1, 2], fc: 18 }, { lngs: ["mt"], nr: [1, 2, 11, 20], fc: 19 }, { lngs: ["or"], nr: [2, 1], fc: 2 }, { lngs: ["ro"], nr: [1, 2, 20], fc: 20 }, { lngs: ["sl"], nr: [5, 1, 2, 3], fc: 21 }, { lngs: ["he", "iw"], nr: [1, 2, 20, 21], fc: 22 }], _rulesPluralsTypes = { 1: function (o) { return +(o > 1) }, 2: function (o) { return +(o != 1) }, 3: function (o) { return 0 }, 4: function (o) { return o % 10 == 1 && o % 100 != 11 ? 0 : o % 10 >= 2 && o % 10 <= 4 && (o % 100 < 10 || o % 100 >= 20) ? 1 : 2 }, 5: function (o) { return o == 0 ? 0 : o == 1 ? 1 : o == 2 ? 2 : o % 100 >= 3 && o % 100 <= 10 ? 3 : o % 100 >= 11 ? 4 : 5 }, 6: function (o) { return o == 1 ? 0 : o >= 2 && o <= 4 ? 1 : 2 }, 7: function (o) { return o == 1 ? 0 : o % 10 >= 2 && o % 10 <= 4 && (o % 100 < 10 || o % 100 >= 20) ? 1 : 2 }, 8: function (o) { return o == 1 ? 0 : o == 2 ? 1 : o != 8 && o != 11 ? 2 : 3 }, 9: function (o) { return +(o >= 2) }, 10: function (o) { return o == 1 ? 0 : o == 2 ? 1 : o < 7 ? 2 : o < 11 ? 3 : 4 }, 11: function (o) { return o == 1 || o == 11 ? 0 : o == 2 || o == 12 ? 1 : o > 2 && o < 20 ? 2 : 3 }, 12: function (o) { return +(o % 10 != 1 || o % 100 == 11) }, 13: function (o) { return +(o !== 0) }, 14: function (o) { return o == 1 ? 0 : o == 2 ? 1 : o == 3 ? 2 : 3 }, 15: function (o) { return o % 10 == 1 && o % 100 != 11 ? 0 : o % 10 >= 2 && (o % 100 < 10 || o % 100 >= 20) ? 1 : 2 }, 16: function (o) { return o % 10 == 1 && o % 100 != 11 ? 0 : o !== 0 ? 1 : 2 }, 17: function (o) { return o == 1 || o % 10 == 1 && o % 100 != 11 ? 0 : 1 }, 18: function (o) { return o == 0 ? 0 : o == 1 ? 1 : 2 }, 19: function (o) { return o == 1 ? 0 : o == 0 || o % 100 > 1 && o % 100 < 11 ? 1 : o % 100 > 10 && o % 100 < 20 ? 2 : 3 }, 20: function (o) { return o == 1 ? 0 : o == 0 || o % 100 > 0 && o % 100 < 20 ? 1 : 2 }, 21: function (o) { return o % 100 == 1 ? 1 : o % 100 == 2 ? 2 : o % 100 == 3 || o % 100 == 4 ? 3 : 0 }, 22: function (o) { return o == 1 ? 0 : o == 2 ? 1 : (o < 0 || o > 10) && o % 10 == 0 ? 2 : 3 } }; const nonIntlVersions = ["v1", "v2", "v3"], intlVersions = ["v4"], suffixesOrder = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }; function createRules() { const o = {}; return sets.forEach(l => { l.lngs.forEach(u => { o[u] = { numbers: l.nr, plurals: _rulesPluralsTypes[l.fc] } }) }), o } class PluralResolver { constructor(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; this.languageUtils = l, this.options = u, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules() } addRule(l, u) { this.rules[l] = u } getRule(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (this.shouldUseIntlApi()) try { return new Intl.PluralRules(getCleanedCode(l === "dev" ? "en" : l), { type: u.ordinal ? "ordinal" : "cardinal" }) } catch { return } return this.rules[l] || this.rules[this.languageUtils.getLanguagePartFromCode(l)] } needsPlural(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const f = this.getRule(l, u); return this.shouldUseIntlApi() ? f && f.resolvedOptions().pluralCategories.length > 1 : f && f.numbers.length > 1 } getPluralFormsOfKey(l, u) { let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; return this.getSuffixes(l, f).map(p => `${u}${p}`) } getSuffixes(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const f = this.getRule(l, u); return f ? this.shouldUseIntlApi() ? f.resolvedOptions().pluralCategories.sort((p, d) => suffixesOrder[p] - suffixesOrder[d]).map(p => `${this.options.prepend}${u.ordinal ? `ordinal${this.options.prepend}` : ""}${p}`) : f.numbers.map(p => this.getSuffix(l, p, u)) : [] } getSuffix(l, u) { let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; const p = this.getRule(l, f); return p ? this.shouldUseIntlApi() ? `${this.options.prepend}${f.ordinal ? `ordinal${this.options.prepend}` : ""}${p.select(u)}` : this.getSuffixRetroCompatible(p, u) : (this.logger.warn(`no plural rule found for: ${l}`), "") } getSuffixRetroCompatible(l, u) { const f = l.noAbs ? l.plurals(u) : l.plurals(Math.abs(u)); let p = l.numbers[f]; this.options.simplifyPluralSuffix && l.numbers.length === 2 && l.numbers[0] === 1 && (p === 2 ? p = "plural" : p === 1 && (p = "")); const d = () => this.options.prepend && p.toString() ? this.options.prepend + p.toString() : p.toString(); return this.options.compatibilityJSON === "v1" ? p === 1 ? "" : typeof p == "number" ? `_plural_${p.toString()}` : d() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && l.numbers.length === 2 && l.numbers[0] === 1 ? d() : this.options.prepend && f.toString() ? this.options.prepend + f.toString() : f.toString() } shouldUseIntlApi() { return !nonIntlVersions.includes(this.options.compatibilityJSON) } } function deepFindWithDefaults(o, l, u) { let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, d = getPathWithDefaults(o, l, u); return !d && p && typeof u == "string" && (d = deepFind(o, u, f), d === void 0 && (d = deepFind(l, u, f))), d } class Interpolator { constructor() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; this.logger = baseLogger.create("interpolator"), this.options = l, this.format = l.interpolation && l.interpolation.format || (u => u), this.init(l) } init() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; l.interpolation || (l.interpolation = { escapeValue: !0 }); const { escape: u, escapeValue: f, useRawValueToEscape: p, prefix: d, prefixEscaped: m, suffix: v, suffixEscaped: I, formatSeparator: F, unescapeSuffix: B, unescapePrefix: W, nestingPrefix: Z, nestingPrefixEscaped: Q, nestingSuffix: re, nestingSuffixEscaped: ne, nestingOptionsSeparator: oe, maxReplaces: ae, alwaysFormat: se } = l.interpolation; this.escape = u !== void 0 ? u : escape$1, this.escapeValue = f !== void 0 ? f : !0, this.useRawValueToEscape = p !== void 0 ? p : !1, this.prefix = d ? regexEscape(d) : m || "{{", this.suffix = v ? regexEscape(v) : I || "}}", this.formatSeparator = F || ",", this.unescapePrefix = B ? "" : W || "-", this.unescapeSuffix = this.unescapePrefix ? "" : B || "", this.nestingPrefix = Z ? regexEscape(Z) : Q || regexEscape("$t("), this.nestingSuffix = re ? regexEscape(re) : ne || regexEscape(")"), this.nestingOptionsSeparator = oe || ",", this.maxReplaces = ae || 1e3, this.alwaysFormat = se !== void 0 ? se : !1, this.resetRegExp() } reset() { this.options && this.init(this.options) } resetRegExp() { const l = (u, f) => u && u.source === f ? (u.lastIndex = 0, u) : new RegExp(f, "g"); this.regexp = l(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = l(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = l(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`) } interpolate(l, u, f, p) { let d, m, v; const I = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}; function F(re) { return re.replace(/\$/g, "$$$$") } const B = re => { if (re.indexOf(this.formatSeparator) < 0) { const se = deepFindWithDefaults(u, I, re, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(se, void 0, f, { ...p, ...u, interpolationkey: re }) : se } const ne = re.split(this.formatSeparator), oe = ne.shift().trim(), ae = ne.join(this.formatSeparator).trim(); return this.format(deepFindWithDefaults(u, I, oe, this.options.keySeparator, this.options.ignoreJSONStructure), ae, f, { ...p, ...u, interpolationkey: oe }) }; this.resetRegExp(); const W = p && p.missingInterpolationHandler || this.options.missingInterpolationHandler, Z = p && p.interpolation && p.interpolation.skipOnVariables !== void 0 ? p.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: re => F(re) }, { regex: this.regexp, safeValue: re => this.escapeValue ? F(this.escape(re)) : F(re) }].forEach(re => { for (v = 0; d = re.regex.exec(l);) { const ne = d[1].trim(); if (m = B(ne), m === void 0) if (typeof W == "function") { const ae = W(l, d, p); m = typeof ae == "string" ? ae : "" } else if (p && Object.prototype.hasOwnProperty.call(p, ne)) m = ""; else if (Z) { m = d[0]; continue } else this.logger.warn(`missed to pass in variable ${ne} for interpolating ${l}`), m = ""; else typeof m != "string" && !this.useRawValueToEscape && (m = makeString(m)); const oe = re.safeValue(m); if (l = l.replace(d[0], oe), Z ? (re.regex.lastIndex += m.length, re.regex.lastIndex -= d[0].length) : re.regex.lastIndex = 0, v++, v >= this.maxReplaces) break } }), l } nest(l, u) { let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, p, d, m; function v(I, F) { const B = this.nestingOptionsSeparator; if (I.indexOf(B) < 0) return I; const W = I.split(new RegExp(`${B}[ ]*{`)); let Z = `{${W[1]}`; I = W[0], Z = this.interpolate(Z, m); const Q = Z.match(/'/g), re = Z.match(/"/g); (Q && Q.length % 2 === 0 && !re || re.length % 2 !== 0) && (Z = Z.replace(/'/g, '"')); try { m = JSON.parse(Z), F && (m = { ...F, ...m }) } catch (ne) { return this.logger.warn(`failed parsing options string in nesting for key ${I}`, ne), `${I}${B}${Z}` } return m.defaultValue && m.defaultValue.indexOf(this.prefix) > -1 && delete m.defaultValue, I } for (; p = this.nestingRegexp.exec(l);) { let I = []; m = { ...f }, m = m.replace && typeof m.replace != "string" ? m.replace : m, m.applyPostProcessor = !1, delete m.defaultValue; let F = !1; if (p[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(p[1])) { const B = p[1].split(this.formatSeparator).map(W => W.trim()); p[1] = B.shift(), I = B, F = !0 } if (d = u(v.call(this, p[1].trim(), m), m), d && p[0] === l && typeof d != "string") return d; typeof d != "string" && (d = makeString(d)), d || (this.logger.warn(`missed to resolve ${p[1]} for nesting ${l}`), d = ""), F && (d = I.reduce((B, W) => this.format(B, W, f.lng, { ...f, interpolationkey: p[1].trim() }), d.trim())), l = l.replace(p[0], d), this.regexp.lastIndex = 0 } return l } } function parseFormatStr(o) { let l = o.toLowerCase().trim(); const u = {}; if (o.indexOf("(") > -1) { const f = o.split("("); l = f[0].toLowerCase().trim(); const p = f[1].substring(0, f[1].length - 1); l === "currency" && p.indexOf(":") < 0 ? u.currency || (u.currency = p.trim()) : l === "relativetime" && p.indexOf(":") < 0 ? u.range || (u.range = p.trim()) : p.split(";").forEach(m => { if (m) { const [v, ...I] = m.split(":"), F = I.join(":").trim().replace(/^'+|'+$/g, ""), B = v.trim(); u[B] || (u[B] = F), F === "false" && (u[B] = !1), F === "true" && (u[B] = !0), isNaN(F) || (u[B] = parseInt(F, 10)) } }) } return { formatName: l, formatOptions: u } } function createCachedFormatter(o) { const l = {}; return function (f, p, d) { const m = p + JSON.stringify(d); let v = l[m]; return v || (v = o(getCleanedCode(p), d), l[m] = v), v(f) } } class Formatter { constructor() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; this.logger = baseLogger.create("formatter"), this.options = l, this.formats = { number: createCachedFormatter((u, f) => { const p = new Intl.NumberFormat(u, { ...f }); return d => p.format(d) }), currency: createCachedFormatter((u, f) => { const p = new Intl.NumberFormat(u, { ...f, style: "currency" }); return d => p.format(d) }), datetime: createCachedFormatter((u, f) => { const p = new Intl.DateTimeFormat(u, { ...f }); return d => p.format(d) }), relativetime: createCachedFormatter((u, f) => { const p = new Intl.RelativeTimeFormat(u, { ...f }); return d => p.format(d, f.range || "day") }), list: createCachedFormatter((u, f) => { const p = new Intl.ListFormat(u, { ...f }); return d => p.format(d) }) }, this.init(l) } init(l) { const f = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { interpolation: {} }).interpolation; this.formatSeparator = f.formatSeparator ? f.formatSeparator : f.formatSeparator || "," } add(l, u) { this.formats[l.toLowerCase().trim()] = u } addCached(l, u) { this.formats[l.toLowerCase().trim()] = createCachedFormatter(u) } format(l, u, f) { let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}; return u.split(this.formatSeparator).reduce((v, I) => { const { formatName: F, formatOptions: B } = parseFormatStr(I); if (this.formats[F]) { let W = v; try { const Z = p && p.formatParams && p.formatParams[p.interpolationkey] || {}, Q = Z.locale || Z.lng || p.locale || p.lng || f; W = this.formats[F](v, Q, { ...B, ...p, ...Z }) } catch (Z) { this.logger.warn(Z) } return W } else this.logger.warn(`there was no format function for ${F}`); return v }, l) } } function removePending(o, l) { o.pending[l] !== void 0 && (delete o.pending[l], o.pendingCount--) } class Connector extends EventEmitter { constructor(l, u, f) { let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}; super(), this.backend = l, this.store = u, this.services = f, this.languageUtils = f.languageUtils, this.options = p, this.logger = baseLogger.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = p.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = p.maxRetries >= 0 ? p.maxRetries : 5, this.retryTimeout = p.retryTimeout >= 1 ? p.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(f, p.backend, p) } queueLoad(l, u, f, p) { const d = {}, m = {}, v = {}, I = {}; return l.forEach(F => { let B = !0; u.forEach(W => { const Z = `${F}|${W}`; !f.reload && this.store.hasResourceBundle(F, W) ? this.state[Z] = 2 : this.state[Z] < 0 || (this.state[Z] === 1 ? m[Z] === void 0 && (m[Z] = !0) : (this.state[Z] = 1, B = !1, m[Z] === void 0 && (m[Z] = !0), d[Z] === void 0 && (d[Z] = !0), I[W] === void 0 && (I[W] = !0))) }), B || (v[F] = !0) }), (Object.keys(d).length || Object.keys(m).length) && this.queue.push({ pending: m, pendingCount: Object.keys(m).length, loaded: {}, errors: [], callback: p }), { toLoad: Object.keys(d), pending: Object.keys(m), toLoadLanguages: Object.keys(v), toLoadNamespaces: Object.keys(I) } } loaded(l, u, f) { const p = l.split("|"), d = p[0], m = p[1]; u && this.emit("failedLoading", d, m, u), f && this.store.addResourceBundle(d, m, f, void 0, void 0, { skipCopy: !0 }), this.state[l] = u ? -1 : 2; const v = {}; this.queue.forEach(I => { pushPath(I.loaded, [d], m), removePending(I, l), u && I.errors.push(u), I.pendingCount === 0 && !I.done && (Object.keys(I.loaded).forEach(F => { v[F] || (v[F] = {}); const B = I.loaded[F]; B.length && B.forEach(W => { v[F][W] === void 0 && (v[F][W] = !0) }) }), I.done = !0, I.errors.length ? I.callback(I.errors) : I.callback()) }), this.emit("loaded", v), this.queue = this.queue.filter(I => !I.done) } read(l, u, f) { let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, m = arguments.length > 5 ? arguments[5] : void 0; if (!l.length) return m(null, {}); if (this.readingCalls >= this.maxParallelReads) { this.waitingReads.push({ lng: l, ns: u, fcName: f, tried: p, wait: d, callback: m }); return } this.readingCalls++; const v = (F, B) => { if (this.readingCalls--, this.waitingReads.length > 0) { const W = this.waitingReads.shift(); this.read(W.lng, W.ns, W.fcName, W.tried, W.wait, W.callback) } if (F && B && p < this.maxRetries) { setTimeout(() => { this.read.call(this, l, u, f, p + 1, d * 2, m) }, d); return } m(F, B) }, I = this.backend[f].bind(this.backend); if (I.length === 2) { try { const F = I(l, u); F && typeof F.then == "function" ? F.then(B => v(null, B)).catch(v) : v(null, F) } catch (F) { v(F) } return } return I(l, u, v) } prepareLoading(l, u) { let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, p = arguments.length > 3 ? arguments[3] : void 0; if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), p && p(); typeof l == "string" && (l = this.languageUtils.toResolveHierarchy(l)), typeof u == "string" && (u = [u]); const d = this.queueLoad(l, u, f, p); if (!d.toLoad.length) return d.pending.length || p(), null; d.toLoad.forEach(m => { this.loadOne(m) }) } load(l, u, f) { this.prepareLoading(l, u, {}, f) } reload(l, u, f) { this.prepareLoading(l, u, { reload: !0 }, f) } loadOne(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ""; const f = l.split("|"), p = f[0], d = f[1]; this.read(p, d, "read", void 0, void 0, (m, v) => { m && this.logger.warn(`${u}loading namespace ${d} for language ${p} failed`, m), !m && v && this.logger.log(`${u}loaded namespace ${d} for language ${p}`, v), this.loaded(l, m, v) }) } saveMissing(l, u, f, p, d) { let m = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, v = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => { }; if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(u)) { this.logger.warn(`did not save key "${f}" as the namespace "${u}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"); return } if (!(f == null || f === "")) { if (this.backend && this.backend.create) { const I = { ...m, isUpdate: d }, F = this.backend.create.bind(this.backend); if (F.length < 6) try { let B; F.length === 5 ? B = F(l, u, f, p, I) : B = F(l, u, f, p), B && typeof B.then == "function" ? B.then(W => v(null, W)).catch(v) : v(null, B) } catch (B) { v(B) } else F(l, u, f, p, v, I) } !l || !l[0] || this.store.addResource(l[0], u, f, p) } } } function get$1() { return { debug: !1, initImmediate: !0, ns: ["translation"], defaultNS: ["translation"], fallbackLng: ["dev"], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: "all", preload: !1, simplifyPluralSuffix: !0, keySeparator: ".", nsSeparator: ":", pluralSeparator: "_", contextSeparator: "_", partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: "fallback", saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !1, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: function (l) { let u = {}; if (typeof l[1] == "object" && (u = l[1]), typeof l[1] == "string" && (u.defaultValue = l[1]), typeof l[2] == "string" && (u.tDescription = l[2]), typeof l[2] == "object" || typeof l[3] == "object") { const f = l[3] || l[2]; Object.keys(f).forEach(p => { u[p] = f[p] }) } return u }, interpolation: { escapeValue: !0, format: o => o, prefix: "{{", suffix: "}}", formatSeparator: ",", unescapePrefix: "-", nestingPrefix: "$t(", nestingSuffix: ")", nestingOptionsSeparator: ",", maxReplaces: 1e3, skipOnVariables: !0 } } } function transformOptions(o) { return typeof o.ns == "string" && (o.ns = [o.ns]), typeof o.fallbackLng == "string" && (o.fallbackLng = [o.fallbackLng]), typeof o.fallbackNS == "string" && (o.fallbackNS = [o.fallbackNS]), o.supportedLngs && o.supportedLngs.indexOf("cimode") < 0 && (o.supportedLngs = o.supportedLngs.concat(["cimode"])), o } function noop$3() { } function bindMemberFunctions(o) { Object.getOwnPropertyNames(Object.getPrototypeOf(o)).forEach(u => { typeof o[u] == "function" && (o[u] = o[u].bind(o)) }) } class I18n extends EventEmitter { constructor() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 ? arguments[1] : void 0; if (super(), this.options = transformOptions(l), this.services = {}, this.logger = baseLogger, this.modules = { external: [] }, bindMemberFunctions(this), u && !this.isInitialized && !l.isClone) { if (!this.options.initImmediate) return this.init(l, u), this; setTimeout(() => { this.init(l, u) }, 0) } } init() { var l = this; let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, f = arguments.length > 1 ? arguments[1] : void 0; this.isInitializing = !0, typeof u == "function" && (f = u, u = {}), !u.defaultNS && u.defaultNS !== !1 && u.ns && (typeof u.ns == "string" ? u.defaultNS = u.ns : u.ns.indexOf("translation") < 0 && (u.defaultNS = u.ns[0])); const p = get$1(); this.options = { ...p, ...this.options, ...transformOptions(u) }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = { ...p.interpolation, ...this.options.interpolation }), u.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = u.keySeparator), u.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = u.nsSeparator); function d(B) { return B ? typeof B == "function" ? new B : B : null } if (!this.options.isClone) { this.modules.logger ? baseLogger.init(d(this.modules.logger), this.options) : baseLogger.init(null, this.options); let B; this.modules.formatter ? B = this.modules.formatter : typeof Intl < "u" && (B = Formatter); const W = new LanguageUtil(this.options); this.store = new ResourceStore(this.options.resources, this.options); const Z = this.services; Z.logger = baseLogger, Z.resourceStore = this.store, Z.languageUtils = W, Z.pluralResolver = new PluralResolver(W, { prepend: this.options.pluralSeparator, compatibilityJSON: this.options.compatibilityJSON, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), B && (!this.options.interpolation.format || this.options.interpolation.format === p.interpolation.format) && (Z.formatter = d(B), Z.formatter.init(Z, this.options), this.options.interpolation.format = Z.formatter.format.bind(Z.formatter)), Z.interpolator = new Interpolator(this.options), Z.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, Z.backendConnector = new Connector(d(this.modules.backend), Z.resourceStore, Z, this.options), Z.backendConnector.on("*", function (Q) { for (var re = arguments.length, ne = new Array(re > 1 ? re - 1 : 0), oe = 1; oe < re; oe++)ne[oe - 1] = arguments[oe]; l.emit(Q, ...ne) }), this.modules.languageDetector && (Z.languageDetector = d(this.modules.languageDetector), Z.languageDetector.init && Z.languageDetector.init(Z, this.options.detection, this.options)), this.modules.i18nFormat && (Z.i18nFormat = d(this.modules.i18nFormat), Z.i18nFormat.init && Z.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function (Q) { for (var re = arguments.length, ne = new Array(re > 1 ? re - 1 : 0), oe = 1; oe < re; oe++)ne[oe - 1] = arguments[oe]; l.emit(Q, ...ne) }), this.modules.external.forEach(Q => { Q.init && Q.init(this) }) } if (this.format = this.options.interpolation.format, f || (f = noop$3), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const B = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); B.length > 0 && B[0] !== "dev" && (this.options.lng = B[0]) } !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(B => { this[B] = function () { return l.store[B](...arguments) } }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(B => { this[B] = function () { return l.store[B](...arguments), l } }); const I = defer(), F = () => { const B = (W, Z) => { this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), I.resolve(Z), f(W, Z) }; if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return B(null, this.t.bind(this)); this.changeLanguage(this.options.lng, B) }; return this.options.resources || !this.options.initImmediate ? F() : setTimeout(F, 0), I } loadResources(l) { let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$3; const p = typeof l == "string" ? l : this.language; if (typeof l == "function" && (f = l), !this.options.resources || this.options.partialBundledLanguages) { if (p && p.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return f(); const d = [], m = v => { if (!v || v === "cimode") return; this.services.languageUtils.toResolveHierarchy(v).forEach(F => { F !== "cimode" && d.indexOf(F) < 0 && d.push(F) }) }; p ? m(p) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(I => m(I)), this.options.preload && this.options.preload.forEach(v => m(v)), this.services.backendConnector.load(d, this.options.ns, v => { !v && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), f(v) }) } else f(null) } reloadResources(l, u, f) { const p = defer(); return l || (l = this.languages), u || (u = this.options.ns), f || (f = noop$3), this.services.backendConnector.reload(l, u, d => { p.resolve(), f(d) }), p } use(l) { if (!l) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()"); if (!l.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()"); return l.type === "backend" && (this.modules.backend = l), (l.type === "logger" || l.log && l.warn && l.error) && (this.modules.logger = l), l.type === "languageDetector" && (this.modules.languageDetector = l), l.type === "i18nFormat" && (this.modules.i18nFormat = l), l.type === "postProcessor" && postProcessor.addPostProcessor(l), l.type === "formatter" && (this.modules.formatter = l), l.type === "3rdParty" && this.modules.external.push(l), this } setResolvedLanguage(l) { if (!(!l || !this.languages) && !(["cimode", "dev"].indexOf(l) > -1)) for (let u = 0; u < this.languages.length; u++) { const f = this.languages[u]; if (!(["cimode", "dev"].indexOf(f) > -1) && this.store.hasLanguageSomeTranslations(f)) { this.resolvedLanguage = f; break } } } changeLanguage(l, u) { var f = this; this.isLanguageChangingTo = l; const p = defer(); this.emit("languageChanging", l); const d = I => { this.language = I, this.languages = this.services.languageUtils.toResolveHierarchy(I), this.resolvedLanguage = void 0, this.setResolvedLanguage(I) }, m = (I, F) => { F ? (d(F), this.translator.changeLanguage(F), this.isLanguageChangingTo = void 0, this.emit("languageChanged", F), this.logger.log("languageChanged", F)) : this.isLanguageChangingTo = void 0, p.resolve(function () { return f.t(...arguments) }), u && u(I, function () { return f.t(...arguments) }) }, v = I => { !l && !I && this.services.languageDetector && (I = []); const F = typeof I == "string" ? I : this.services.languageUtils.getBestMatchFromCodes(I); F && (this.language || d(F), this.translator.language || this.translator.changeLanguage(F), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(F)), this.loadResources(F, B => { m(B, F) }) }; return !l && this.services.languageDetector && !this.services.languageDetector.async ? v(this.services.languageDetector.detect()) : !l && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(v) : this.services.languageDetector.detect(v) : v(l), p } getFixedT(l, u, f) { var p = this; const d = function (m, v) { let I; if (typeof v != "object") { for (var F = arguments.length, B = new Array(F > 2 ? F - 2 : 0), W = 2; W < F; W++)B[W - 2] = arguments[W]; I = p.options.overloadTranslationOptionHandler([m, v].concat(B)) } else I = { ...v }; I.lng = I.lng || d.lng, I.lngs = I.lngs || d.lngs, I.ns = I.ns || d.ns, I.keyPrefix !== "" && (I.keyPrefix = I.keyPrefix || f || d.keyPrefix); const Z = p.options.keySeparator || "."; let Q; return I.keyPrefix && Array.isArray(m) ? Q = m.map(re => `${I.keyPrefix}${Z}${re}`) : Q = I.keyPrefix ? `${I.keyPrefix}${Z}${m}` : m, p.t(Q, I) }; return typeof l == "string" ? d.lng = l : d.lngs = l, d.ns = u, d.keyPrefix = f, d } t() { return this.translator && this.translator.translate(...arguments) } exists() { return this.translator && this.translator.exists(...arguments) } setDefaultNamespace(l) { this.options.defaultNS = l } hasLoadedNamespace(l) { let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1; const f = u.lng || this.resolvedLanguage || this.languages[0], p = this.options ? this.options.fallbackLng : !1, d = this.languages[this.languages.length - 1]; if (f.toLowerCase() === "cimode") return !0; const m = (v, I) => { const F = this.services.backendConnector.state[`${v}|${I}`]; return F === -1 || F === 2 }; if (u.precheck) { const v = u.precheck(this, m); if (v !== void 0) return v } return !!(this.hasResourceBundle(f, l) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || m(f, l) && (!p || m(d, l))) } loadNamespaces(l, u) { const f = defer(); return this.options.ns ? (typeof l == "string" && (l = [l]), l.forEach(p => { this.options.ns.indexOf(p) < 0 && this.options.ns.push(p) }), this.loadResources(p => { f.resolve(), u && u(p) }), f) : (u && u(), Promise.resolve()) } loadLanguages(l, u) { const f = defer(); typeof l == "string" && (l = [l]); const p = this.options.preload || [], d = l.filter(m => p.indexOf(m) < 0 && this.services.languageUtils.isSupportedCode(m)); return d.length ? (this.options.preload = p.concat(d), this.loadResources(m => { f.resolve(), u && u(m) }), f) : (u && u(), Promise.resolve()) } dir(l) { if (l || (l = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !l) return "rtl"; const u = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], f = this.services && this.services.languageUtils || new LanguageUtil(get$1()); return u.indexOf(f.getLanguagePartFromCode(l)) > -1 || l.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr" } static createInstance() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 ? arguments[1] : void 0; return new I18n(l, u) } cloneInstance() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$3; const f = l.forkResourceStore; f && delete l.forkResourceStore; const p = { ...this.options, ...l, isClone: !0 }, d = new I18n(p); return (l.debug !== void 0 || l.prefix !== void 0) && (d.logger = d.logger.clone(l)), ["store", "services", "language"].forEach(v => { d[v] = this[v] }), d.services = { ...this.services }, d.services.utils = { hasLoadedNamespace: d.hasLoadedNamespace.bind(d) }, f && (d.store = new ResourceStore(this.store.data, p), d.services.resourceStore = d.store), d.translator = new Translator(d.services, p), d.translator.on("*", function (v) { for (var I = arguments.length, F = new Array(I > 1 ? I - 1 : 0), B = 1; B < I; B++)F[B - 1] = arguments[B]; d.emit(v, ...F) }), d.init(p, u), d.translator.options = p, d.translator.backendConnector.services.utils = { hasLoadedNamespace: d.hasLoadedNamespace.bind(d) }, d } toJSON() { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } } const instance = I18n.createInstance(); instance.createInstance = I18n.createInstance; instance.createInstance; instance.dir; instance.init; instance.loadResources; instance.reloadResources; instance.use; instance.changeLanguage; instance.getFixedT; const t$1 = instance.t; instance.exists; instance.setDefaultNamespace; instance.hasLoadedNamespace; instance.loadNamespaces; instance.loadLanguages; var reactExports = requireReact(); const React = getDefaultExportFromCjs$1(reactExports), React$1 = _mergeNamespaces({ __proto__: null, default: React }, [reactExports]); var voidElements, hasRequiredVoidElements; function requireVoidElements() { return hasRequiredVoidElements || (hasRequiredVoidElements = 1, voidElements = { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }), voidElements } var voidElementsExports = requireVoidElements(); const e = getDefaultExportFromCjs$1(voidElementsExports); var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g; function n(o) { var l = { type: "tag", name: "", voidElement: !1, attrs: {}, children: [] }, u = o.match(/<\/?([^\s]+?)[/\s>]/); if (u && (l.name = u[1], (e[u[1]] || o.charAt(o.length - 2) === "/") && (l.voidElement = !0), l.name.startsWith("!--"))) { var f = o.indexOf("-->"); return { type: "comment", comment: f !== -1 ? o.slice(4, f) : "" } } for (var p = new RegExp(t), d = null; (d = p.exec(o)) !== null;)if (d[0].trim()) if (d[1]) { var m = d[1].trim(), v = [m, ""]; m.indexOf("=") > -1 && (v = m.split("=")), l.attrs[v[0]] = v[1], p.lastIndex-- } else d[2] && (l.attrs[d[2]] = d[3].trim().substring(1, d[3].length - 1)); return l } var r$1 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i$1 = /^\s*$/, s = Object.create(null); function a(o, l) { switch (l.type) { case "text": return o + l.content; case "tag": return o += "<" + l.name + (l.attrs ? function (u) { var f = []; for (var p in u) f.push(p + '="' + u[p] + '"'); return f.length ? " " + f.join(" ") : "" }(l.attrs) : "") + (l.voidElement ? "/>" : ">"), l.voidElement ? o : o + l.children.reduce(a, "") + "</" + l.name + ">"; case "comment": return o + "<!--" + l.comment + "-->" } } var c = { parse: function (o, l) { l || (l = {}), l.components || (l.components = s); var u, f = [], p = [], d = -1, m = !1; if (o.indexOf("<") !== 0) { var v = o.indexOf("<"); f.push({ type: "text", content: v === -1 ? o : o.substring(0, v) }) } return o.replace(r$1, function (I, F) { if (m) { if (I !== "</" + u.name + ">") return; m = !1 } var B, W = I.charAt(1) !== "/", Z = I.startsWith("<!--"), Q = F + I.length, re = o.charAt(Q); if (Z) { var ne = n(I); return d < 0 ? (f.push(ne), f) : ((B = p[d]).children.push(ne), f) } if (W && (d++, (u = n(I)).type === "tag" && l.components[u.name] && (u.type = "component", m = !0), u.voidElement || m || !re || re === "<" || u.children.push({ type: "text", content: o.slice(Q, o.indexOf("<", Q)) }), d === 0 && f.push(u), (B = p[d - 1]) && B.children.push(u), p[d] = u), (!W || u.voidElement) && (d > -1 && (u.voidElement || u.name === I.slice(2, -1)) && (d--, u = d === -1 ? f : p[d]), !m && re !== "<" && re)) { B = d === -1 ? f : p[d].children; var oe = o.indexOf("<", Q), ae = o.slice(Q, oe === -1 ? void 0 : oe); i$1.test(ae) && (ae = " "), (oe > -1 && d + B.length >= 0 || ae !== " ") && B.push({ type: "text", content: ae }) } }), f }, stringify: function (o) { return o.reduce(function (l, u) { return l + a("", u) }, "") } }; function warn() { if (console && console.warn) { for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)l[u] = arguments[u]; isString$3(l[0]) && (l[0] = `react-i18next:: ${l[0]}`), console.warn(...l) } } const alreadyWarned$1 = {}; function warnOnce() { for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)l[u] = arguments[u]; isString$3(l[0]) && alreadyWarned$1[l[0]] || (isString$3(l[0]) && (alreadyWarned$1[l[0]] = new Date), warn(...l)) } const loadedClb = (o, l) => () => { if (o.isInitialized) l(); else { const u = () => { setTimeout(() => { o.off("initialized", u) }, 0), l() }; o.on("initialized", u) } }, loadNamespaces = (o, l, u) => { o.loadNamespaces(l, loadedClb(o, u)) }, loadLanguages = (o, l, u, f) => { isString$3(u) && (u = [u]), u.forEach(p => { o.options.ns.indexOf(p) < 0 && o.options.ns.push(p) }), o.loadLanguages(l, loadedClb(o, f)) }, oldI18nextHasLoadedNamespace = function (o, l) { let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; const f = l.languages[0], p = l.options ? l.options.fallbackLng : !1, d = l.languages[l.languages.length - 1]; if (f.toLowerCase() === "cimode") return !0; const m = (v, I) => { const F = l.services.backendConnector.state[`${v}|${I}`]; return F === -1 || F === 2 }; return u.bindI18n && u.bindI18n.indexOf("languageChanging") > -1 && l.services.backendConnector.backend && l.isLanguageChangingTo && !m(l.isLanguageChangingTo, o) ? !1 : !!(l.hasResourceBundle(f, o) || !l.services.backendConnector.backend || l.options.resources && !l.options.partialBundledLanguages || m(f, o) && (!p || m(d, o))) }, hasLoadedNamespace = function (o, l) { let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; return !l.languages || !l.languages.length ? (warnOnce("i18n.languages were undefined or empty", l.languages), !0) : l.options.ignoreJSONStructure !== void 0 ? l.hasLoadedNamespace(o, { lng: u.lng, precheck: (p, d) => { if (u.bindI18n && u.bindI18n.indexOf("languageChanging") > -1 && p.services.backendConnector.backend && p.isLanguageChangingTo && !d(p.isLanguageChangingTo, o)) return !1 } }) : oldI18nextHasLoadedNamespace(o, l, u) }, isString$3 = o => typeof o == "string", isObject$7 = o => typeof o == "object" && o !== null, matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, htmlEntities = { "&amp;": "&", "&#38;": "&", "&lt;": "<", "&#60;": "<", "&gt;": ">", "&#62;": ">", "&apos;": "'", "&#39;": "'", "&quot;": '"', "&#34;": '"', "&nbsp;": " ", "&#160;": " ", "&copy;": "", "&#169;": "", "&reg;": "", "&#174;": "", "&hellip;": "", "&#8230;": "", "&#x2F;": "/", "&#47;": "/" }, unescapeHtmlEntity = o => htmlEntities[o], unescape = o => o.replace(matchHtmlEntity, unescapeHtmlEntity); let defaultOptions$1 = { bindI18n: "languageChanged", bindI18nStore: "", transEmptyNodeValue: "", transSupportBasicHtmlNodes: !0, transWrapTextNodes: "", transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"], useSuspense: !0, unescape }; const setDefaults = function () { let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; defaultOptions$1 = { ...defaultOptions$1, ...o } }, getDefaults = () => defaultOptions$1; let i18nInstance; const setI18n = o => { i18nInstance = o }, getI18n = () => i18nInstance, hasChildren = (o, l) => { if (!o) return !1; const u = o.props ? o.props.children : o.children; return l ? u.length > 0 : !!u }, getChildren = o => { if (!o) return []; const l = o.props ? o.props.children : o.children; return o.props && o.props.i18nIsDynamicList ? getAsArray(l) : l }, hasValidReactChildren = o => Array.isArray(o) && o.every(reactExports.isValidElement), getAsArray = o => Array.isArray(o) ? o : [o], mergeProps = (o, l) => { const u = { ...l }; return u.props = Object.assign(o.props, l.props), u }, nodesToString = (o, l) => { if (!o) return ""; let u = ""; const f = getAsArray(o), p = l.transSupportBasicHtmlNodes && l.transKeepBasicHtmlNodesFor ? l.transKeepBasicHtmlNodesFor : []; return f.forEach((d, m) => { if (isString$3(d)) u += `${d}`; else if (reactExports.isValidElement(d)) { const { props: v, type: I } = d, F = Object.keys(v).length, B = p.indexOf(I) > -1, W = v.children; if (!W && B && !F) u += `<${I}/>`; else if (!W && (!B || F) || v.i18nIsDynamicList) u += `<${m}></${m}>`; else if (B && F === 1 && isString$3(W)) u += `<${I}>${W}</${I}>`; else { const Z = nodesToString(W, l); u += `<${m}>${Z}</${m}>` } } else if (d === null) warn("Trans: the passed in value is invalid - seems you passed in a null child."); else if (isObject$7(d)) { const { format: v, ...I } = d, F = Object.keys(I); if (F.length === 1) { const B = v ? `${F[0]}, ${v}` : F[0]; u += `{{${B}}}` } else warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", d) } else warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", d) }), u }, renderNodes = (o, l, u, f, p, d) => { if (l === "") return []; const m = f.transKeepBasicHtmlNodesFor || [], v = l && new RegExp(m.map(oe => `<${oe}`).join("|")).test(l); if (!o && !v && !d) return [l]; const I = {}, F = oe => { getAsArray(oe).forEach(se => { isString$3(se) || (hasChildren(se) ? F(getChildren(se)) : isObject$7(se) && !reactExports.isValidElement(se) && Object.assign(I, se)) }) }; F(o); const B = c.parse(`<0>${l}</0>`), W = { ...I, ...p }, Z = (oe, ae, se) => { const le = getChildren(oe), ue = re(le, ae.children, se); return hasValidReactChildren(le) && ue.length === 0 || oe.props && oe.props.i18nIsDynamicList ? le : ue }, Q = (oe, ae, se, le, ue) => { oe.dummy ? (oe.children = ae, se.push(reactExports.cloneElement(oe, { key: le }, ue ? void 0 : ae))) : se.push(...reactExports.Children.map([oe], he => { const pe = { ...he.props }; return delete pe.i18nIsDynamicList, reactExports.createElement(he.type, { ...pe, key: le, ref: he.ref }, ue ? null : ae) })) }, re = (oe, ae, se) => { const le = getAsArray(oe); return getAsArray(ae).reduce((he, pe, ve) => { const _e = pe.children && pe.children[0] && pe.children[0].content && u.services.interpolator.interpolate(pe.children[0].content, W, u.language); if (pe.type === "tag") { let Se = le[parseInt(pe.name, 10)]; se.length === 1 && !Se && (Se = se[0][pe.name]), Se || (Se = {}); const $e = Object.keys(pe.attrs).length !== 0 ? mergeProps({ props: pe.attrs }, Se) : Se, ie = reactExports.isValidElement($e), g = ie && hasChildren(pe, !0) && !pe.voidElement, P = v && isObject$7($e) && $e.dummy && !ie, U = isObject$7(o) && Object.hasOwnProperty.call(o, pe.name); if (isString$3($e)) { const K = u.services.interpolator.interpolate($e, W, u.language); he.push(K) } else if (hasChildren($e) || g) { const K = Z($e, pe, se); Q($e, K, he, ve) } else if (P) { const K = re(le, pe.children, se); Q($e, K, he, ve) } else if (Number.isNaN(parseFloat(pe.name))) if (U) { const K = Z($e, pe, se); Q($e, K, he, ve, pe.voidElement) } else if (f.transSupportBasicHtmlNodes && m.indexOf(pe.name) > -1) if (pe.voidElement) he.push(reactExports.createElement(pe.name, { key: `${pe.name}-${ve}` })); else { const K = re(le, pe.children, se); he.push(reactExports.createElement(pe.name, { key: `${pe.name}-${ve}` }, K)) } else if (pe.voidElement) he.push(`<${pe.name} />`); else { const K = re(le, pe.children, se); he.push(`<${pe.name}>${K}</${pe.name}>`) } else if (isObject$7($e) && !ie) { const K = pe.children[0] ? _e : null; K && he.push(K) } else Q($e, _e, he, ve, pe.children.length !== 1 || !_e) } else if (pe.type === "text") { const Se = f.transWrapTextNodes, $e = d ? f.unescape(u.services.interpolator.interpolate(pe.content, W, u.language)) : u.services.interpolator.interpolate(pe.content, W, u.language); Se ? he.push(reactExports.createElement(Se, { key: `${pe.name}-${ve}` }, $e)) : he.push($e) } return he }, []) }, ne = re([{ dummy: !0, children: o || [] }], B, getAsArray(o || [])); return getChildren(ne[0]) }; function Trans$1(o) { let { children: l, count: u, parent: f, i18nKey: p, context: d, tOptions: m = {}, values: v, defaults: I, components: F, ns: B, i18n: W, t: Z, shouldUnescape: Q, ...re } = o; const ne = W || getI18n(); if (!ne) return warnOnce("You will need to pass in an i18next instance by using i18nextReactModule"), l; const oe = Z || ne.t.bind(ne) || (g => g), ae = { ...getDefaults(), ...ne.options && ne.options.react }; let se = B || oe.ns || ne.options && ne.options.defaultNS; se = isString$3(se) ? [se] : se || ["translation"]; const le = nodesToString(l, ae), ue = I || le || ae.transEmptyNodeValue || p, { hashTransKey: he } = ae, pe = p || (he ? he(le || ue) : le || ue); ne.options && ne.options.interpolation && ne.options.interpolation.defaultVariables && (v = v && Object.keys(v).length > 0 ? { ...v, ...ne.options.interpolation.defaultVariables } : { ...ne.options.interpolation.defaultVariables }); const ve = v || u !== void 0 || !l ? m.interpolation : { interpolation: { ...m.interpolation, prefix: "#$?", suffix: "?$#" } }, _e = { ...m, context: d || m.context, count: u, ...v, ...ve, defaultValue: ue, ns: se }, Se = pe ? oe(pe, _e) : ue; F && Object.keys(F).forEach(g => { const P = F[g]; if (typeof P.type == "function" || !P.props || !P.props.children || Se.indexOf(`${g}/>`) < 0 && Se.indexOf(`${g} />`) < 0) return; function U() { return reactExports.createElement(reactExports.Fragment, null, P) } F[g] = reactExports.createElement(U) }); const $e = renderNodes(F || l, Se, ne, ae, _e, Q), ie = f !== void 0 ? f : ae.defaultTransParent; return ie ? reactExports.createElement(ie, re, $e) : $e } const initReactI18next = { type: "3rdParty", init(o) { setDefaults(o.options.react), setI18n(o) } }, I18nContext = reactExports.createContext(); class ReportNamespaces { constructor() { wf(this, "getUsedNamespaces", () => Object.keys(this.usedNamespaces)); this.usedNamespaces = {} } addUsedNamespaces(l) { l.forEach(u => { this.usedNamespaces[u] || (this.usedNamespaces[u] = !0) }) } } function Trans(o) { let { children: l, count: u, parent: f, i18nKey: p, context: d, tOptions: m = {}, values: v, defaults: I, components: F, ns: B, i18n: W, t: Z, shouldUnescape: Q, ...re } = o; const { i18n: ne, defaultNS: oe } = reactExports.useContext(I18nContext) || {}, ae = W || ne || getI18n(), se = Z || ae && ae.t.bind(ae); return Trans$1({ children: l, count: u, parent: f, i18nKey: p, context: d, tOptions: m, values: v, defaults: I, components: F, ns: B || se && se.ns || oe || ae && ae.options && ae.options.defaultNS, i18n: ae, t: Z, shouldUnescape: Q, ...re }) } const usePrevious = (o, l) => { const u = reactExports.useRef(); return reactExports.useEffect(() => { u.current = o }, [o, l]), u.current }, alwaysNewT = (o, l, u, f) => o.getFixedT(l, u, f), useMemoizedT = (o, l, u, f) => reactExports.useCallback(alwaysNewT(o, l, u, f), [o, l, u, f]), useTranslation = function (o) { let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { i18n: u } = l, { i18n: f, defaultNS: p } = reactExports.useContext(I18nContext) || {}, d = u || f || getI18n(); if (d && !d.reportNamespaces && (d.reportNamespaces = new ReportNamespaces), !d) { warnOnce("You will need to pass in an i18next instance by using initReactI18next"); const ue = (pe, ve) => isString$3(ve) ? ve : isObject$7(ve) && isString$3(ve.defaultValue) ? ve.defaultValue : Array.isArray(pe) ? pe[pe.length - 1] : pe, he = [ue, {}, !1]; return he.t = ue, he.i18n = {}, he.ready = !1, he } d.options.react && d.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour."); const m = { ...getDefaults(), ...d.options.react, ...l }, { useSuspense: v, keyPrefix: I } = m; let F = p || d.options && d.options.defaultNS; F = isString$3(F) ? [F] : F || ["translation"], d.reportNamespaces.addUsedNamespaces && d.reportNamespaces.addUsedNamespaces(F); const B = (d.isInitialized || d.initializedStoreOnce) && F.every(ue => hasLoadedNamespace(ue, d, m)), W = useMemoizedT(d, l.lng || null, m.nsMode === "fallback" ? F : F[0], I), Z = () => W, Q = () => alwaysNewT(d, l.lng || null, m.nsMode === "fallback" ? F : F[0], I), [re, ne] = reactExports.useState(Z); let oe = F.join(); l.lng && (oe = `${l.lng}${oe}`); const ae = usePrevious(oe), se = reactExports.useRef(!0); reactExports.useEffect(() => { const { bindI18n: ue, bindI18nStore: he } = m; se.current = !0, !B && !v && (l.lng ? loadLanguages(d, l.lng, F, () => { se.current && ne(Q) }) : loadNamespaces(d, F, () => { se.current && ne(Q) })), B && ae && ae !== oe && se.current && ne(Q); const pe = () => { se.current && ne(Q) }; return ue && d && d.on(ue, pe), he && d && d.store.on(he, pe), () => { se.current = !1, ue && d && ue.split(" ").forEach(ve => d.off(ve, pe)), he && d && he.split(" ").forEach(ve => d.store.off(ve, pe)) } }, [d, oe]), reactExports.useEffect(() => { se.current && B && ne(Z) }, [d, I, B]); const le = [re, d, B]; if (le.t = re, le.i18n = d, le.ready = B, B || !B && !v) return le; throw new Promise(ue => { l.lng ? loadLanguages(d, l.lng, F, () => ue()) : loadNamespaces(d, F, () => ue()) }) }, global$1 = globalThis || void 0 || self; function die(o) { for (var l = arguments.length, u = new Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)u[f - 1] = arguments[f]; throw new Error(typeof o == "number" ? "[MobX] minified error nr: " + o + (u.length ? " " + u.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + o) } var mockGlobal = {}; function getGlobal() { return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : mockGlobal } var assign$1 = Object.assign, getDescriptor = Object.getOwnPropertyDescriptor, defineProperty = Object.defineProperty, objectPrototype = Object.prototype, EMPTY_ARRAY = []; Object.freeze(EMPTY_ARRAY); var EMPTY_OBJECT = {}; Object.freeze(EMPTY_OBJECT); var hasProxy = typeof Proxy < "u", plainObjectString = Object.toString(); function assertProxies() { hasProxy || die("Proxy not available") } function once(o) { var l = !1; return function () { if (!l) return l = !0, o.apply(this, arguments) } } var noop$2 = function () { }; function isFunction(o) { return typeof o == "function" } function isStringish(o) { var l = typeof o; switch (l) { case "string": case "symbol": case "number": return !0 }return !1 } function isObject$6(o) { return o !== null && typeof o == "object" } function isPlainObject$1(o) { if (!isObject$6(o)) return !1; var l = Object.getPrototypeOf(o); if (l == null) return !0; var u = Object.hasOwnProperty.call(l, "constructor") && l.constructor; return typeof u == "function" && u.toString() === plainObjectString } function isGenerator(o) { var l = o == null ? void 0 : o.constructor; return l ? l.name === "GeneratorFunction" || l.displayName === "GeneratorFunction" : !1 } function addHiddenProp(o, l, u) { defineProperty(o, l, { enumerable: !1, writable: !0, configurable: !0, value: u }) } function addHiddenFinalProp(o, l, u) { defineProperty(o, l, { enumerable: !1, writable: !1, configurable: !0, value: u }) } function createInstanceofPredicate(o, l) { var u = "isMobX" + o; return l.prototype[u] = !0, function (f) { return isObject$6(f) && f[u] === !0 } } function isES6Map(o) { return o != null && Object.prototype.toString.call(o) === "[object Map]" } function isPlainES6Map(o) { var l = Object.getPrototypeOf(o), u = Object.getPrototypeOf(l), f = Object.getPrototypeOf(u); return f === null } function isES6Set(o) { return o != null && Object.prototype.toString.call(o) === "[object Set]" } var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols < "u"; function getPlainObjectKeys(o) { var l = Object.keys(o); if (!hasGetOwnPropertySymbols) return l; var u = Object.getOwnPropertySymbols(o); return u.length ? [].concat(l, u.filter(function (f) { return objectPrototype.propertyIsEnumerable.call(o, f) })) : l } var ownKeys = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (o) { return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o)) } : Object.getOwnPropertyNames; function toPrimitive$1(o) { return o === null ? null : typeof o == "object" ? "" + o : o } function hasProp$1(o, l) { return objectPrototype.hasOwnProperty.call(o, l) } var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function (l) { var u = {}; return ownKeys(l).forEach(function (f) { u[f] = getDescriptor(l, f) }), u }; function getFlag(o, l) { return !!(o & l) } function setFlag(o, l, u) { return u ? o |= l : o &= ~l, o } function _arrayLikeToArray$1(o, l) { (l == null || l > o.length) && (l = o.length); for (var u = 0, f = Array(l); u < l; u++)f[u] = o[u]; return f } function _defineProperties$1(o, l) { for (var u = 0; u < l.length; u++) { var f = l[u]; f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(o, _toPropertyKey(f.key), f) } } function _createClass$1(o, l, u) { return l && _defineProperties$1(o.prototype, l), Object.defineProperty(o, "prototype", { writable: !1 }), o } function _createForOfIteratorHelperLoose(o, l) {
  var u = typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"]; if (u) return (u = u.call(o)).next.bind(u); if (Array.isArray(o) || (u = _unsupportedIterableToArray$1(o)) || l) { u && (o = u); var f = 0; return function () { return f >= o.length ? { done: !0 } : { done: !1, value: o[f++] } } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function _extends$5() { return _extends$5 = Object.assign ? Object.assign.bind() : function (o) { for (var l = 1; l < arguments.length; l++) { var u = arguments[l]; for (var f in u) ({}).hasOwnProperty.call(u, f) && (o[f] = u[f]) } return o }, _extends$5.apply(null, arguments) } function _inheritsLoose$2(o, l) { o.prototype = Object.create(l.prototype), o.prototype.constructor = o, _setPrototypeOf$1(o, l) } function _setPrototypeOf$1(o, l) { return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (u, f) { return u.__proto__ = f, u }, _setPrototypeOf$1(o, l) } function _toPrimitive(o, l) { if (typeof o != "object" || !o) return o; var u = o[Symbol.toPrimitive]; if (u !== void 0) { var f = u.call(o, l); if (typeof f != "object") return f; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(o) } function _toPropertyKey(o) { var l = _toPrimitive(o, "string"); return typeof l == "symbol" ? l : l + "" } function _unsupportedIterableToArray$1(o, l) { if (o) { if (typeof o == "string") return _arrayLikeToArray$1(o, l); var u = {}.toString.call(o).slice(8, -1); return u === "Object" && o.constructor && (u = o.constructor.name), u === "Map" || u === "Set" ? Array.from(o) : u === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u) ? _arrayLikeToArray$1(o, l) : void 0 } } var storedAnnotationsSymbol = Symbol("mobx-stored-annotations"); function createDecoratorAnnotation(o) { function l(u, f) { if (is20223Decorator(f)) return o.decorate_20223_(u, f); storeAnnotation(u, f, o) } return Object.assign(l, o) } function storeAnnotation(o, l, u) { hasProp$1(o, storedAnnotationsSymbol) || addHiddenProp(o, storedAnnotationsSymbol, _extends$5({}, o[storedAnnotationsSymbol])), isOverride(u) || (o[storedAnnotationsSymbol][l] = u) } function collectStoredAnnotations(o) { return hasProp$1(o, storedAnnotationsSymbol) || addHiddenProp(o, storedAnnotationsSymbol, _extends$5({}, o[storedAnnotationsSymbol])), o[storedAnnotationsSymbol] } function is20223Decorator(o) { return typeof o == "object" && typeof o.kind == "string" } var $mobx = Symbol("mobx administration"), Atom = function () { function o(u) { u === void 0 && (u = "Atom"), this.name_ = void 0, this.flags_ = 0, this.observers_ = new Set, this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = u } var l = o.prototype; return l.onBO = function () { this.onBOL && this.onBOL.forEach(function (f) { return f() }) }, l.onBUO = function () { this.onBUOL && this.onBUOL.forEach(function (f) { return f() }) }, l.reportObserved = function () { return reportObserved(this) }, l.reportChanged = function () { startBatch(), propagateChanged(this), endBatch() }, l.toString = function () { return this.name_ }, _createClass$1(o, [{ key: "isBeingObserved", get: function () { return getFlag(this.flags_, o.isBeingObservedMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isBeingObservedMask_, f) } }, { key: "isPendingUnobservation", get: function () { return getFlag(this.flags_, o.isPendingUnobservationMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isPendingUnobservationMask_, f) } }, { key: "diffValue", get: function () { return getFlag(this.flags_, o.diffValueMask_) ? 1 : 0 }, set: function (f) { this.flags_ = setFlag(this.flags_, o.diffValueMask_, f === 1) } }]) }(); Atom.isBeingObservedMask_ = 1; Atom.isPendingUnobservationMask_ = 2; Atom.diffValueMask_ = 4; var isAtom = createInstanceofPredicate("Atom", Atom); function createAtom(o, l, u) { l === void 0 && (l = noop$2), u === void 0 && (u = noop$2); var f = new Atom(o); return l !== noop$2 && onBecomeObserved(f, l), u !== noop$2 && onBecomeUnobserved(f, u), f } function identityComparer(o, l) { return o === l } function structuralComparer(o, l) { return deepEqual(o, l) } function shallowComparer(o, l) { return deepEqual(o, l, 1) } function defaultComparer(o, l) { return Object.is ? Object.is(o, l) : o === l ? o !== 0 || 1 / o === 1 / l : o !== o && l !== l } var comparer = { identity: identityComparer, structural: structuralComparer, default: defaultComparer, shallow: shallowComparer }; function deepEnhancer(o, l, u) { return isObservable$1(o) ? o : Array.isArray(o) ? observable.array(o, { name: u }) : isPlainObject$1(o) ? observable.object(o, void 0, { name: u }) : isES6Map(o) ? observable.map(o, { name: u }) : isES6Set(o) ? observable.set(o, { name: u }) : typeof o == "function" && !isAction(o) && !isFlow(o) ? isGenerator(o) ? flow(o) : autoAction(u, o) : o } function shallowEnhancer(o, l, u) { if (o == null || isObservableObject(o) || isObservableArray(o) || isObservableMap(o) || isObservableSet(o)) return o; if (Array.isArray(o)) return observable.array(o, { name: u, deep: !1 }); if (isPlainObject$1(o)) return observable.object(o, void 0, { name: u, deep: !1 }); if (isES6Map(o)) return observable.map(o, { name: u, deep: !1 }); if (isES6Set(o)) return observable.set(o, { name: u, deep: !1 }) } function referenceEnhancer(o) { return o } function refStructEnhancer(o, l) { return deepEqual(o, l) ? l : o } var OVERRIDE = "override", override = createDecoratorAnnotation({ annotationType_: OVERRIDE, make_, extend_, decorate_20223_ }); function isOverride(o) { return o.annotationType_ === OVERRIDE } function make_(o, l) { return 0 } function extend_(o, l, u, f) { die("'" + this.annotationType_ + "' can only be used with 'makeObservable'") } function decorate_20223_(o, l) { console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op") } function createActionAnnotation(o, l) { return { annotationType_: o, options_: l, make_: make_$1, extend_: extend_$1, decorate_20223_: decorate_20223_$1 } } function make_$1(o, l, u, f) { var p; if ((p = this.options_) != null && p.bound) return this.extend_(o, l, u, !1) === null ? 0 : 1; if (f === o.target_) return this.extend_(o, l, u, !1) === null ? 0 : 2; if (isAction(u.value)) return 1; var d = createActionDescriptor(o, this, l, u, !1); return defineProperty(f, l, d), 2 } function extend_$1(o, l, u, f) { var p = createActionDescriptor(o, this, l, u); return o.defineProperty_(l, p, f) } function decorate_20223_$1(o, l) {
  var u = l.kind, f = l.name, p = l.addInitializer, d = this, m = function (F) { var B, W, Z, Q; return createAction((B = (W = d.options_) == null ? void 0 : W.name) != null ? B : f.toString(), F, (Z = (Q = d.options_) == null ? void 0 : Q.autoAction) != null ? Z : !1) }; if (u == "field") { p(function () { storeAnnotation(this, f, d) }); return } if (u == "method") { var v; return isAction(o) || (o = m(o)), (v = this.options_) != null && v.bound && p(function () { var I = this, F = I[f].bind(I); F.isMobxAction = !0, I[f] = F }), o } die("Cannot apply '" + d.annotationType_ + "' to '" + String(f) + "' (kind: " + u + "):" + (`
'`+ d.annotationType_ + "' can only be used on properties with a function value."))
} function assertActionDescriptor(o, l, u, f) { l.annotationType_, f.value } function createActionDescriptor(o, l, u, f, p) { var d, m, v, I, F, B, W; p === void 0 && (p = globalState.safeDescriptors), assertActionDescriptor(o, l, u, f); var Z = f.value; if ((d = l.options_) != null && d.bound) { var Q; Z = Z.bind((Q = o.proxy_) != null ? Q : o.target_) } return { value: createAction((m = (v = l.options_) == null ? void 0 : v.name) != null ? m : u.toString(), Z, (I = (F = l.options_) == null ? void 0 : F.autoAction) != null ? I : !1, (B = l.options_) != null && B.bound ? (W = o.proxy_) != null ? W : o.target_ : void 0), configurable: p ? o.isPlainObject_ : !0, enumerable: !1, writable: !p } } function createFlowAnnotation(o, l) { return { annotationType_: o, options_: l, make_: make_$2, extend_: extend_$2, decorate_20223_: decorate_20223_$2 } } function make_$2(o, l, u, f) { var p; if (f === o.target_) return this.extend_(o, l, u, !1) === null ? 0 : 2; if ((p = this.options_) != null && p.bound && (!hasProp$1(o.target_, l) || !isFlow(o.target_[l])) && this.extend_(o, l, u, !1) === null) return 0; if (isFlow(u.value)) return 1; var d = createFlowDescriptor(o, this, l, u, !1, !1); return defineProperty(f, l, d), 2 } function extend_$2(o, l, u, f) { var p, d = createFlowDescriptor(o, this, l, u, (p = this.options_) == null ? void 0 : p.bound); return o.defineProperty_(l, d, f) } function decorate_20223_$2(o, l) { var u, f = l.name, p = l.addInitializer; return isFlow(o) || (o = flow(o)), (u = this.options_) != null && u.bound && p(function () { var d = this, m = d[f].bind(d); m.isMobXFlow = !0, d[f] = m }), o } function assertFlowDescriptor(o, l, u, f) { l.annotationType_, f.value } function createFlowDescriptor(o, l, u, f, p, d) { d === void 0 && (d = globalState.safeDescriptors), assertFlowDescriptor(o, l, u, f); var m = f.value; if (isFlow(m) || (m = flow(m)), p) { var v; m = m.bind((v = o.proxy_) != null ? v : o.target_), m.isMobXFlow = !0 } return { value: m, configurable: d ? o.isPlainObject_ : !0, enumerable: !1, writable: !d } } function createComputedAnnotation(o, l) { return { annotationType_: o, options_: l, make_: make_$3, extend_: extend_$3, decorate_20223_: decorate_20223_$3 } } function make_$3(o, l, u) { return this.extend_(o, l, u, !1) === null ? 0 : 1 } function extend_$3(o, l, u, f) { return assertComputedDescriptor(o, this, l, u), o.defineComputedProperty_(l, _extends$5({}, this.options_, { get: u.get, set: u.set }), f) } function decorate_20223_$3(o, l) { var u = this, f = l.name, p = l.addInitializer; return p(function () { var d = asObservableObject(this)[$mobx], m = _extends$5({}, u.options_, { get: o, context: this }); m.name || (m.name = "ObservableObject." + f.toString()), d.values_.set(f, new ComputedValue(m)) }), function () { return this[$mobx].getObservablePropValue_(f) } } function assertComputedDescriptor(o, l, u, f) { l.annotationType_, f.get } function createObservableAnnotation(o, l) { return { annotationType_: o, options_: l, make_: make_$4, extend_: extend_$4, decorate_20223_: decorate_20223_$4 } } function make_$4(o, l, u) { return this.extend_(o, l, u, !1) === null ? 0 : 1 } function extend_$4(o, l, u, f) { var p, d; return assertObservableDescriptor(o, this), o.defineObservableProperty_(l, u.value, (p = (d = this.options_) == null ? void 0 : d.enhancer) != null ? p : deepEnhancer, f) } function decorate_20223_$4(o, l) { var u = this, f = l.kind, p = l.name, d = new WeakSet; function m(v, I) { var F, B, W = asObservableObject(v)[$mobx], Z = new ObservableValue(I, (F = (B = u.options_) == null ? void 0 : B.enhancer) != null ? F : deepEnhancer, "ObservableObject." + p.toString(), !1); W.values_.set(p, Z), d.add(v) } if (f == "accessor") return { get: function () { return d.has(this) || m(this, o.get.call(this)), this[$mobx].getObservablePropValue_(p) }, set: function (I) { return d.has(this) || m(this, I), this[$mobx].setObservablePropValue_(p, I) }, init: function (I) { return d.has(this) || m(this, I), I } } } function assertObservableDescriptor(o, l, u, f) { l.annotationType_ } var AUTO = "true", autoAnnotation = createAutoAnnotation(); function createAutoAnnotation(o) { return { annotationType_: AUTO, options_: o, make_: make_$5, extend_: extend_$5, decorate_20223_: decorate_20223_$5 } } function make_$5(o, l, u, f) { var p, d; if (u.get) return computed$1.make_(o, l, u, f); if (u.set) { var m = createAction(l.toString(), u.set); return f === o.target_ ? o.defineProperty_(l, { configurable: globalState.safeDescriptors ? o.isPlainObject_ : !0, set: m }) === null ? 0 : 2 : (defineProperty(f, l, { configurable: !0, set: m }), 2) } if (f !== o.target_ && typeof u.value == "function") { var v; if (isGenerator(u.value)) { var I, F = (I = this.options_) != null && I.autoBind ? flow.bound : flow; return F.make_(o, l, u, f) } var B = (v = this.options_) != null && v.autoBind ? autoAction.bound : autoAction; return B.make_(o, l, u, f) } var W = ((p = this.options_) == null ? void 0 : p.deep) === !1 ? observable.ref : observable; if (typeof u.value == "function" && (d = this.options_) != null && d.autoBind) { var Z; u.value = u.value.bind((Z = o.proxy_) != null ? Z : o.target_) } return W.make_(o, l, u, f) } function extend_$5(o, l, u, f) { var p, d; if (u.get) return computed$1.extend_(o, l, u, f); if (u.set) return o.defineProperty_(l, { configurable: globalState.safeDescriptors ? o.isPlainObject_ : !0, set: createAction(l.toString(), u.set) }, f); if (typeof u.value == "function" && (p = this.options_) != null && p.autoBind) { var m; u.value = u.value.bind((m = o.proxy_) != null ? m : o.target_) } var v = ((d = this.options_) == null ? void 0 : d.deep) === !1 ? observable.ref : observable; return v.extend_(o, l, u, f) } function decorate_20223_$5(o, l) { die("'" + this.annotationType_ + "' cannot be used as a decorator") } var OBSERVABLE = "observable", OBSERVABLE_REF = "observable.ref", OBSERVABLE_SHALLOW = "observable.shallow", OBSERVABLE_STRUCT = "observable.struct", defaultCreateObservableOptions = { deep: !0, name: void 0, defaultDecorator: void 0, proxy: !0 }; Object.freeze(defaultCreateObservableOptions); function asCreateObservableOptions(o) { return o || defaultCreateObservableOptions } var observableAnnotation = createObservableAnnotation(OBSERVABLE), observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, { enhancer: referenceEnhancer }), observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, { enhancer: shallowEnhancer }), observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, { enhancer: refStructEnhancer }), observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation); function getEnhancerFromOptions(o) { return o.deep === !0 ? deepEnhancer : o.deep === !1 ? referenceEnhancer : getEnhancerFromAnnotation(o.defaultDecorator) } function getAnnotationFromOptions(o) { var l; return o ? (l = o.defaultDecorator) != null ? l : createAutoAnnotation(o) : void 0 } function getEnhancerFromAnnotation(o) { var l, u; return o && (l = (u = o.options_) == null ? void 0 : u.enhancer) != null ? l : deepEnhancer } function createObservable(o, l, u) { if (is20223Decorator(l)) return observableAnnotation.decorate_20223_(o, l); if (isStringish(l)) { storeAnnotation(o, l, observableAnnotation); return } return isObservable$1(o) ? o : isPlainObject$1(o) ? observable.object(o, l, u) : Array.isArray(o) ? observable.array(o, l) : isES6Map(o) ? observable.map(o, l) : isES6Set(o) ? observable.set(o, l) : typeof o == "object" && o !== null ? o : observable.box(o, l) } assign$1(createObservable, observableDecoratorAnnotation); var observableFactories = { box: function (l, u) { var f = asCreateObservableOptions(u); return new ObservableValue(l, getEnhancerFromOptions(f), f.name, !0, f.equals) }, array: function (l, u) { var f = asCreateObservableOptions(u); return (globalState.useProxies === !1 || f.proxy === !1 ? createLegacyArray : createObservableArray)(l, getEnhancerFromOptions(f), f.name) }, map: function (l, u) { var f = asCreateObservableOptions(u); return new ObservableMap(l, getEnhancerFromOptions(f), f.name) }, set: function (l, u) { var f = asCreateObservableOptions(u); return new ObservableSet(l, getEnhancerFromOptions(f), f.name) }, object: function (l, u, f) { return initObservable(function () { return extendObservable(globalState.useProxies === !1 || (f == null ? void 0 : f.proxy) === !1 ? asObservableObject({}, f) : asDynamicObservableObject({}, f), l, u) }) }, ref: createDecoratorAnnotation(observableRefAnnotation), shallow: createDecoratorAnnotation(observableShallowAnnotation), deep: observableDecoratorAnnotation, struct: createDecoratorAnnotation(observableStructAnnotation) }, observable = assign$1(createObservable, observableFactories), COMPUTED = "computed", COMPUTED_STRUCT = "computed.struct", computedAnnotation = createComputedAnnotation(COMPUTED), computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, { equals: comparer.structural }), computed$1 = function (l, u) { if (is20223Decorator(u)) return computedAnnotation.decorate_20223_(l, u); if (isStringish(u)) return storeAnnotation(l, u, computedAnnotation); if (isPlainObject$1(l)) return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, l)); var f = isPlainObject$1(u) ? u : {}; return f.get = l, f.name || (f.name = l.name || ""), new ComputedValue(f) }; Object.assign(computed$1, computedAnnotation); computed$1.struct = createDecoratorAnnotation(computedStructAnnotation); var _getDescriptor$config, _getDescriptor, currentActionId = 0, nextActionId = 1, isFunctionNameConfigurable$1 = (_getDescriptor$config = (_getDescriptor = getDescriptor(function () { }, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : !1, tmpNameDescriptor = { value: "action", configurable: !0, writable: !1, enumerable: !1 }; function createAction(o, l, u, f) { u === void 0 && (u = !1); function p() { return executeAction(o, u, l, f || this, arguments) } return p.isMobxAction = !0, p.toString = function () { return l.toString() }, isFunctionNameConfigurable$1 && (tmpNameDescriptor.value = o, defineProperty(p, "name", tmpNameDescriptor)), p } function executeAction(o, l, u, f, p) { var d = _startAction(o, l); try { return u.apply(f, p) } catch (m) { throw d.error_ = m, m } finally { _endAction(d) } } function _startAction(o, l, u, f) { var p = !1, d = 0, m = globalState.trackingDerivation, v = !l || !m; startBatch(); var I = globalState.allowStateChanges; v && (untrackedStart(), I = allowStateChangesStart(!0)); var F = allowStateReadsStart(!0), B = { runAsAction_: v, prevDerivation_: m, prevAllowStateChanges_: I, prevAllowStateReads_: F, notifySpy_: p, startTime_: d, actionId_: nextActionId++, parentActionId_: currentActionId }; return currentActionId = B.actionId_, B } function _endAction(o) { currentActionId !== o.actionId_ && die(30), currentActionId = o.parentActionId_, o.error_ !== void 0 && (globalState.suppressReactionErrors = !0), allowStateChangesEnd(o.prevAllowStateChanges_), allowStateReadsEnd(o.prevAllowStateReads_), endBatch(), o.runAsAction_ && untrackedEnd(o.prevDerivation_), globalState.suppressReactionErrors = !1 } function allowStateChanges(o, l) { var u = allowStateChangesStart(o); try { return l() } finally { allowStateChangesEnd(u) } } function allowStateChangesStart(o) { var l = globalState.allowStateChanges; return globalState.allowStateChanges = o, l } function allowStateChangesEnd(o) { globalState.allowStateChanges = o } var ObservableValue = function (o) { function l(f, p, d, m, v) { var I; return d === void 0 && (d = "ObservableValue"), v === void 0 && (v = comparer.default), I = o.call(this, d) || this, I.enhancer = void 0, I.name_ = void 0, I.equals = void 0, I.hasUnreportedChange_ = !1, I.interceptors_ = void 0, I.changeListeners_ = void 0, I.value_ = void 0, I.dehancer = void 0, I.enhancer = p, I.name_ = d, I.equals = v, I.value_ = p(f, void 0, d), I } _inheritsLoose$2(l, o); var u = l.prototype; return u.dehanceValue = function (p) { return this.dehancer !== void 0 ? this.dehancer(p) : p }, u.set = function (p) { this.value_, p = this.prepareNewValue_(p), p !== globalState.UNCHANGED && this.setNewValue_(p) }, u.prepareNewValue_ = function (p) { if (hasInterceptors(this)) { var d = interceptChange(this, { object: this, type: UPDATE, newValue: p }); if (!d) return globalState.UNCHANGED; p = d.newValue } return p = this.enhancer(p, this.value_, this.name_), this.equals(this.value_, p) ? globalState.UNCHANGED : p }, u.setNewValue_ = function (p) { var d = this.value_; this.value_ = p, this.reportChanged(), hasListeners(this) && notifyListeners(this, { type: UPDATE, object: this, newValue: p, oldValue: d }) }, u.get = function () { return this.reportObserved(), this.dehanceValue(this.value_) }, u.intercept_ = function (p) { return registerInterceptor(this, p) }, u.observe_ = function (p, d) { return d && p({ observableKind: "value", debugObjectName: this.name_, object: this, type: UPDATE, newValue: this.value_, oldValue: void 0 }), registerListener(this, p) }, u.raw = function () { return this.value_ }, u.toJSON = function () { return this.get() }, u.toString = function () { return this.name_ + "[" + this.value_ + "]" }, u.valueOf = function () { return toPrimitive$1(this.get()) }, u[Symbol.toPrimitive] = function () { return this.valueOf() }, l }(Atom), isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue), ComputedValue = function () { function o(u) { this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = new Set, this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new CaughtException(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = TraceMode.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, u.get || die(31), this.derivation = u.get, this.name_ = u.name || "ComputedValue", u.set && (this.setter_ = createAction("ComputedValue-setter", u.set)), this.equals_ = u.equals || (u.compareStructural || u.struct ? comparer.structural : comparer.default), this.scope_ = u.context, this.requiresReaction_ = u.requiresReaction, this.keepAlive_ = !!u.keepAlive } var l = o.prototype; return l.onBecomeStale_ = function () { propagateMaybeChanged(this) }, l.onBO = function () { this.onBOL && this.onBOL.forEach(function (f) { return f() }) }, l.onBUO = function () { this.onBUOL && this.onBUOL.forEach(function (f) { return f() }) }, l.get = function () { if (this.isComputing && die(32, this.name_, this.derivation), globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) shouldCompute(this) && (this.warnAboutUntrackedRead_(), startBatch(), this.value_ = this.computeValue_(!1), endBatch()); else if (reportObserved(this), shouldCompute(this)) { var f = globalState.trackingContext; this.keepAlive_ && !f && (globalState.trackingContext = this), this.trackAndCompute() && propagateChangeConfirmed(this), globalState.trackingContext = f } var p = this.value_; if (isCaughtException(p)) throw p.cause; return p }, l.set = function (f) { if (this.setter_) { this.isRunningSetter && die(33, this.name_), this.isRunningSetter = !0; try { this.setter_.call(this.scope_, f) } finally { this.isRunningSetter = !1 } } else die(34, this.name_) }, l.trackAndCompute = function () { var f = this.value_, p = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_, d = this.computeValue_(!0), m = p || isCaughtException(f) || isCaughtException(d) || !this.equals_(f, d); return m && (this.value_ = d), m }, l.computeValue_ = function (f) { this.isComputing = !0; var p = allowStateChangesStart(!1), d; if (f) d = trackDerivedFunction(this, this.derivation, this.scope_); else if (globalState.disableErrorBoundaries === !0) d = this.derivation.call(this.scope_); else try { d = this.derivation.call(this.scope_) } catch (m) { d = new CaughtException(m) } return allowStateChangesEnd(p), this.isComputing = !1, d }, l.suspend_ = function () { this.keepAlive_ || (clearObserving(this), this.value_ = void 0) }, l.observe_ = function (f, p) { var d = this, m = !0, v = void 0; return autorun(function () { var I = d.get(); if (!m || p) { var F = untrackedStart(); f({ observableKind: "computed", debugObjectName: d.name_, type: UPDATE, object: d, newValue: I, oldValue: v }), untrackedEnd(F) } m = !1, v = I }) }, l.warnAboutUntrackedRead_ = function () { }, l.toString = function () { return this.name_ + "[" + this.derivation.toString() + "]" }, l.valueOf = function () { return toPrimitive$1(this.get()) }, l[Symbol.toPrimitive] = function () { return this.valueOf() }, _createClass$1(o, [{ key: "isComputing", get: function () { return getFlag(this.flags_, o.isComputingMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isComputingMask_, f) } }, { key: "isRunningSetter", get: function () { return getFlag(this.flags_, o.isRunningSetterMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isRunningSetterMask_, f) } }, { key: "isBeingObserved", get: function () { return getFlag(this.flags_, o.isBeingObservedMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isBeingObservedMask_, f) } }, { key: "isPendingUnobservation", get: function () { return getFlag(this.flags_, o.isPendingUnobservationMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isPendingUnobservationMask_, f) } }, { key: "diffValue", get: function () { return getFlag(this.flags_, o.diffValueMask_) ? 1 : 0 }, set: function (f) { this.flags_ = setFlag(this.flags_, o.diffValueMask_, f === 1) } }]) }(); ComputedValue.isComputingMask_ = 1; ComputedValue.isRunningSetterMask_ = 2; ComputedValue.isBeingObservedMask_ = 4; ComputedValue.isPendingUnobservationMask_ = 8; ComputedValue.diffValueMask_ = 16; var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue), IDerivationState_; (function (o) { o[o.NOT_TRACKING_ = -1] = "NOT_TRACKING_", o[o.UP_TO_DATE_ = 0] = "UP_TO_DATE_", o[o.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", o[o.STALE_ = 2] = "STALE_" })(IDerivationState_ || (IDerivationState_ = {})); var TraceMode; (function (o) { o[o.NONE = 0] = "NONE", o[o.LOG = 1] = "LOG", o[o.BREAK = 2] = "BREAK" })(TraceMode || (TraceMode = {})); var CaughtException = function (l) { this.cause = void 0, this.cause = l }; function isCaughtException(o) { return o instanceof CaughtException } function shouldCompute(o) { switch (o.dependenciesState_) { case IDerivationState_.UP_TO_DATE_: return !1; case IDerivationState_.NOT_TRACKING_: case IDerivationState_.STALE_: return !0; case IDerivationState_.POSSIBLY_STALE_: { for (var l = allowStateReadsStart(!0), u = untrackedStart(), f = o.observing_, p = f.length, d = 0; d < p; d++) { var m = f[d]; if (isComputedValue(m)) { if (globalState.disableErrorBoundaries) m.get(); else try { m.get() } catch { return untrackedEnd(u), allowStateReadsEnd(l), !0 } if (o.dependenciesState_ === IDerivationState_.STALE_) return untrackedEnd(u), allowStateReadsEnd(l), !0 } } return changeDependenciesStateTo0(o), untrackedEnd(u), allowStateReadsEnd(l), !1 } } } function isComputingDerivation() { return globalState.trackingDerivation !== null } function checkIfStateModificationsAreAllowed(o) { } function trackDerivedFunction(o, l, u) { var f = allowStateReadsStart(!0); changeDependenciesStateTo0(o), o.newObserving_ = new Array(o.runId_ === 0 ? 100 : o.observing_.length), o.unboundDepsCount_ = 0, o.runId_ = ++globalState.runId; var p = globalState.trackingDerivation; globalState.trackingDerivation = o, globalState.inBatch++; var d; if (globalState.disableErrorBoundaries === !0) d = l.call(u); else try { d = l.call(u) } catch (m) { d = new CaughtException(m) } return globalState.inBatch--, globalState.trackingDerivation = p, bindDependencies(o), allowStateReadsEnd(f), d } function bindDependencies(o) { for (var l = o.observing_, u = o.observing_ = o.newObserving_, f = IDerivationState_.UP_TO_DATE_, p = 0, d = o.unboundDepsCount_, m = 0; m < d; m++) { var v = u[m]; v.diffValue === 0 && (v.diffValue = 1, p !== m && (u[p] = v), p++), v.dependenciesState_ > f && (f = v.dependenciesState_) } for (u.length = p, o.newObserving_ = null, d = l.length; d--;) { var I = l[d]; I.diffValue === 0 && removeObserver(I, o), I.diffValue = 0 } for (; p--;) { var F = u[p]; F.diffValue === 1 && (F.diffValue = 0, addObserver(F, o)) } f !== IDerivationState_.UP_TO_DATE_ && (o.dependenciesState_ = f, o.onBecomeStale_()) } function clearObserving(o) { var l = o.observing_; o.observing_ = []; for (var u = l.length; u--;)removeObserver(l[u], o); o.dependenciesState_ = IDerivationState_.NOT_TRACKING_ } function untracked(o) { var l = untrackedStart(); try { return o() } finally { untrackedEnd(l) } } function untrackedStart() { var o = globalState.trackingDerivation; return globalState.trackingDerivation = null, o } function untrackedEnd(o) { globalState.trackingDerivation = o } function allowStateReadsStart(o) { var l = globalState.allowStateReads; return globalState.allowStateReads = o, l } function allowStateReadsEnd(o) { globalState.allowStateReads = o } function changeDependenciesStateTo0(o) { if (o.dependenciesState_ !== IDerivationState_.UP_TO_DATE_) { o.dependenciesState_ = IDerivationState_.UP_TO_DATE_; for (var l = o.observing_, u = l.length; u--;)l[u].lowestObserverState_ = IDerivationState_.UP_TO_DATE_ } } var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"], MobXGlobals = function () { this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0 }, canMergeGlobalState = !0, isolateCalled = !1, globalState = function () { var o = getGlobal(); return o.__mobxInstanceCount > 0 && !o.__mobxGlobals && (canMergeGlobalState = !1), o.__mobxGlobals && o.__mobxGlobals.version !== new MobXGlobals().version && (canMergeGlobalState = !1), canMergeGlobalState ? o.__mobxGlobals ? (o.__mobxInstanceCount += 1, o.__mobxGlobals.UNCHANGED || (o.__mobxGlobals.UNCHANGED = {}), o.__mobxGlobals) : (o.__mobxInstanceCount = 1, o.__mobxGlobals = new MobXGlobals) : (setTimeout(function () { isolateCalled || die(35) }, 1), new MobXGlobals) }(); function isolateGlobalState() { if ((globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) && die(36), isolateCalled = !0, canMergeGlobalState) { var o = getGlobal(); --o.__mobxInstanceCount === 0 && (o.__mobxGlobals = void 0), globalState = new MobXGlobals } } function getGlobalState() { return globalState } function resetGlobalState() { var o = new MobXGlobals; for (var l in o) persistentKeys.indexOf(l) === -1 && (globalState[l] = o[l]); globalState.allowStateChanges = !globalState.enforceActions } function hasObservers(o) { return o.observers_ && o.observers_.size > 0 } function getObservers(o) { return o.observers_ } function addObserver(o, l) { o.observers_.add(l), o.lowestObserverState_ > l.dependenciesState_ && (o.lowestObserverState_ = l.dependenciesState_) } function removeObserver(o, l) { o.observers_.delete(l), o.observers_.size === 0 && queueForUnobservation(o) } function queueForUnobservation(o) { o.isPendingUnobservation === !1 && (o.isPendingUnobservation = !0, globalState.pendingUnobservations.push(o)) } function startBatch() { globalState.inBatch++ } function endBatch() { if (--globalState.inBatch === 0) { runReactions(); for (var o = globalState.pendingUnobservations, l = 0; l < o.length; l++) { var u = o[l]; u.isPendingUnobservation = !1, u.observers_.size === 0 && (u.isBeingObserved && (u.isBeingObserved = !1, u.onBUO()), u instanceof ComputedValue && u.suspend_()) } globalState.pendingUnobservations = [] } } function reportObserved(o) { var l = globalState.trackingDerivation; return l !== null ? (l.runId_ !== o.lastAccessedBy_ && (o.lastAccessedBy_ = l.runId_, l.newObserving_[l.unboundDepsCount_++] = o, !o.isBeingObserved && globalState.trackingContext && (o.isBeingObserved = !0, o.onBO())), o.isBeingObserved) : (o.observers_.size === 0 && globalState.inBatch > 0 && queueForUnobservation(o), !1) } function propagateChanged(o) { o.lowestObserverState_ !== IDerivationState_.STALE_ && (o.lowestObserverState_ = IDerivationState_.STALE_, o.observers_.forEach(function (l) { l.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && l.onBecomeStale_(), l.dependenciesState_ = IDerivationState_.STALE_ })) } function propagateChangeConfirmed(o) { o.lowestObserverState_ !== IDerivationState_.STALE_ && (o.lowestObserverState_ = IDerivationState_.STALE_, o.observers_.forEach(function (l) { l.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_ ? l.dependenciesState_ = IDerivationState_.STALE_ : l.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (o.lowestObserverState_ = IDerivationState_.UP_TO_DATE_) })) } function propagateMaybeChanged(o) { o.lowestObserverState_ === IDerivationState_.UP_TO_DATE_ && (o.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_, o.observers_.forEach(function (l) { l.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (l.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_, l.onBecomeStale_()) })) } var Reaction = function () { function o(u, f, p, d) { u === void 0 && (u = "Reaction"), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = IDerivationState_.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = TraceMode.NONE, this.name_ = u, this.onInvalidate_ = f, this.errorHandler_ = p, this.requiresObservable_ = d } var l = o.prototype; return l.onBecomeStale_ = function () { this.schedule_() }, l.schedule_ = function () { this.isScheduled || (this.isScheduled = !0, globalState.pendingReactions.push(this), runReactions()) }, l.runReaction_ = function () { if (!this.isDisposed) { startBatch(), this.isScheduled = !1; var f = globalState.trackingContext; if (globalState.trackingContext = this, shouldCompute(this)) { this.isTrackPending = !0; try { this.onInvalidate_() } catch (p) { this.reportExceptionInDerivation_(p) } } globalState.trackingContext = f, endBatch() } }, l.track = function (f) { if (!this.isDisposed) { startBatch(), this.isRunning = !0; var p = globalState.trackingContext; globalState.trackingContext = this; var d = trackDerivedFunction(this, f, void 0); globalState.trackingContext = p, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && clearObserving(this), isCaughtException(d) && this.reportExceptionInDerivation_(d.cause), endBatch() } }, l.reportExceptionInDerivation_ = function (f) { var p = this; if (this.errorHandler_) { this.errorHandler_(f, this); return } if (globalState.disableErrorBoundaries) throw f; var d = "[mobx] uncaught error in '" + this + "'"; globalState.suppressReactionErrors || console.error(d, f), globalState.globalReactionErrorHandlers.forEach(function (m) { return m(f, p) }) }, l.dispose = function () { this.isDisposed || (this.isDisposed = !0, this.isRunning || (startBatch(), clearObserving(this), endBatch())) }, l.getDisposer_ = function (f) { var p = this, d = function m() { p.dispose(), f == null || f.removeEventListener == null || f.removeEventListener("abort", m) }; return f == null || f.addEventListener == null || f.addEventListener("abort", d), d[$mobx] = this, d }, l.toString = function () { return "Reaction[" + this.name_ + "]" }, l.trace = function (f) { }, _createClass$1(o, [{ key: "isDisposed", get: function () { return getFlag(this.flags_, o.isDisposedMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isDisposedMask_, f) } }, { key: "isScheduled", get: function () { return getFlag(this.flags_, o.isScheduledMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isScheduledMask_, f) } }, { key: "isTrackPending", get: function () { return getFlag(this.flags_, o.isTrackPendingMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isTrackPendingMask_, f) } }, { key: "isRunning", get: function () { return getFlag(this.flags_, o.isRunningMask_) }, set: function (f) { this.flags_ = setFlag(this.flags_, o.isRunningMask_, f) } }, { key: "diffValue", get: function () { return getFlag(this.flags_, o.diffValueMask_) ? 1 : 0 }, set: function (f) { this.flags_ = setFlag(this.flags_, o.diffValueMask_, f === 1) } }]) }(); Reaction.isDisposedMask_ = 1; Reaction.isScheduledMask_ = 2; Reaction.isTrackPendingMask_ = 4; Reaction.isRunningMask_ = 8; Reaction.diffValueMask_ = 16; function onReactionError(o) { return globalState.globalReactionErrorHandlers.push(o), function () { var l = globalState.globalReactionErrorHandlers.indexOf(o); l >= 0 && globalState.globalReactionErrorHandlers.splice(l, 1) } } var MAX_REACTION_ITERATIONS = 100, reactionScheduler = function (l) { return l() }; function runReactions() { globalState.inBatch > 0 || globalState.isRunningReactions || reactionScheduler(runReactionsHelper) } function runReactionsHelper() { globalState.isRunningReactions = !0; for (var o = globalState.pendingReactions, l = 0; o.length > 0;) { ++l === MAX_REACTION_ITERATIONS && (console.error("[mobx] cycle in reaction: " + o[0]), o.splice(0)); for (var u = o.splice(0), f = 0, p = u.length; f < p; f++)u[f].runReaction_() } globalState.isRunningReactions = !1 } var isReaction = createInstanceofPredicate("Reaction", Reaction); function setReactionScheduler(o) { var l = reactionScheduler; reactionScheduler = function (f) { return o(function () { return l(f) }) } } function isSpyEnabled() { return !1 } function spyReport(o) { } function spyReportStart(o) { } function spyReportEnd(o) { } function spy(o) { return console.warn("[mobx.spy] Is a no-op in production builds"), function () { } } var ACTION = "action", ACTION_BOUND = "action.bound", AUTOACTION = "autoAction", AUTOACTION_BOUND = "autoAction.bound", DEFAULT_ACTION_NAME = "<unnamed action>", actionAnnotation = createActionAnnotation(ACTION), actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, { bound: !0 }), autoActionAnnotation = createActionAnnotation(AUTOACTION, { autoAction: !0 }), autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, { autoAction: !0, bound: !0 }); function createActionFactory(o) { var l = function (f, p) { if (isFunction(f)) return createAction(f.name || DEFAULT_ACTION_NAME, f, o); if (isFunction(p)) return createAction(f, p, o); if (is20223Decorator(p)) return (o ? autoActionAnnotation : actionAnnotation).decorate_20223_(f, p); if (isStringish(p)) return storeAnnotation(f, p, o ? autoActionAnnotation : actionAnnotation); if (isStringish(f)) return createDecoratorAnnotation(createActionAnnotation(o ? AUTOACTION : ACTION, { name: f, autoAction: o })) }; return l } var action = createActionFactory(!1); Object.assign(action, actionAnnotation); var autoAction = createActionFactory(!0); Object.assign(autoAction, autoActionAnnotation); action.bound = createDecoratorAnnotation(actionBoundAnnotation); autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation); function runInAction(o) { return executeAction(o.name || DEFAULT_ACTION_NAME, !1, o, this, void 0) } function isAction(o) { return isFunction(o) && o.isMobxAction === !0 } function autorun(o, l) { var u, f, p, d; l === void 0 && (l = EMPTY_OBJECT); var m = (u = (f = l) == null ? void 0 : f.name) != null ? u : "Autorun", v = !l.scheduler && !l.delay, I; if (v) I = new Reaction(m, function () { this.track(W) }, l.onError, l.requiresObservable); else { var F = createSchedulerFromOptions(l), B = !1; I = new Reaction(m, function () { B || (B = !0, F(function () { B = !1, I.isDisposed || I.track(W) })) }, l.onError, l.requiresObservable) } function W() { o(I) } return (p = l) != null && (p = p.signal) != null && p.aborted || I.schedule_(), I.getDisposer_((d = l) == null ? void 0 : d.signal) } var run = function (l) { return l() }; function createSchedulerFromOptions(o) { return o.scheduler ? o.scheduler : o.delay ? function (l) { return setTimeout(l, o.delay) } : run } function reaction(o, l, u) { var f, p, d; u === void 0 && (u = EMPTY_OBJECT); var m = (f = u.name) != null ? f : "Reaction", v = action(m, u.onError ? wrapErrorHandler(u.onError, l) : l), I = !u.scheduler && !u.delay, F = createSchedulerFromOptions(u), B = !0, W = !1, Z, Q = u.compareStructural ? comparer.structural : u.equals || comparer.default, re = new Reaction(m, function () { B || I ? ne() : W || (W = !0, F(ne)) }, u.onError, u.requiresObservable); function ne() { if (W = !1, !re.isDisposed) { var oe = !1, ae = Z; re.track(function () { var se = allowStateChanges(!1, function () { return o(re) }); oe = B || !Q(Z, se), Z = se }), (B && u.fireImmediately || !B && oe) && v(Z, ae, re), B = !1 } } return (p = u) != null && (p = p.signal) != null && p.aborted || re.schedule_(), re.getDisposer_((d = u) == null ? void 0 : d.signal) } function wrapErrorHandler(o, l) { return function () { try { return l.apply(this, arguments) } catch (u) { o.call(this, u) } } } var ON_BECOME_OBSERVED = "onBO", ON_BECOME_UNOBSERVED = "onBUO"; function onBecomeObserved(o, l, u) { return interceptHook(ON_BECOME_OBSERVED, o, l, u) } function onBecomeUnobserved(o, l, u) { return interceptHook(ON_BECOME_UNOBSERVED, o, l, u) } function interceptHook(o, l, u, f) { var p = typeof f == "function" ? getAtom(l, u) : getAtom(l), d = isFunction(f) ? f : u, m = o + "L"; return p[m] ? p[m].add(d) : p[m] = new Set([d]), function () { var v = p[m]; v && (v.delete(d), v.size === 0 && delete p[m]) } } var NEVER = "never", ALWAYS = "always", OBSERVED = "observed"; function configure(o) { o.isolateGlobalState === !0 && isolateGlobalState(); var l = o.useProxies, u = o.enforceActions; if (l !== void 0 && (globalState.useProxies = l === ALWAYS ? !0 : l === NEVER ? !1 : typeof Proxy < "u"), l === "ifavailable" && (globalState.verifyProxies = !0), u !== void 0) { var f = u === ALWAYS ? ALWAYS : u === OBSERVED; globalState.enforceActions = f, globalState.allowStateChanges = !(f === !0 || f === ALWAYS) } ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (p) { p in o && (globalState[p] = !!o[p]) }), globalState.allowStateReads = !globalState.observableRequiresReaction, o.reactionScheduler && setReactionScheduler(o.reactionScheduler) } function extendObservable(o, l, u, f) { var p = getOwnPropertyDescriptors(l); return initObservable(function () { var d = asObservableObject(o, f)[$mobx]; ownKeys(p).forEach(function (m) { d.extend_(m, p[m], u && m in u ? u[m] : !0) }) }), o } function getDependencyTree(o, l) { return nodeToDependencyTree(getAtom(o, l)) } function nodeToDependencyTree(o) { var l = { name: o.name_ }; return o.observing_ && o.observing_.length > 0 && (l.dependencies = unique(o.observing_).map(nodeToDependencyTree)), l } function getObserverTree(o, l) { return nodeToObserverTree(getAtom(o, l)) } function nodeToObserverTree(o) { var l = { name: o.name_ }; return hasObservers(o) && (l.observers = Array.from(getObservers(o)).map(nodeToObserverTree)), l } function unique(o) { return Array.from(new Set(o)) } var generatorId = 0; function FlowCancellationError() { this.message = "FLOW_CANCELLED" } FlowCancellationError.prototype = Object.create(Error.prototype); function isFlowCancellationError(o) { return o instanceof FlowCancellationError } var flowAnnotation = createFlowAnnotation("flow"), flowBoundAnnotation = createFlowAnnotation("flow.bound", { bound: !0 }), flow = Object.assign(function (l, u) { if (is20223Decorator(u)) return flowAnnotation.decorate_20223_(l, u); if (isStringish(u)) return storeAnnotation(l, u, flowAnnotation); var f = l, p = f.name || "<unnamed flow>", d = function () { var v = this, I = arguments, F = ++generatorId, B = action(p + " - runid: " + F + " - init", f).apply(v, I), W, Z = void 0, Q = new Promise(function (re, ne) { var oe = 0; W = ne; function ae(ue) { Z = void 0; var he; try { he = action(p + " - runid: " + F + " - yield " + oe++, B.next).call(B, ue) } catch (pe) { return ne(pe) } le(he) } function se(ue) { Z = void 0; var he; try { he = action(p + " - runid: " + F + " - yield " + oe++, B.throw).call(B, ue) } catch (pe) { return ne(pe) } le(he) } function le(ue) { if (isFunction(ue == null ? void 0 : ue.then)) { ue.then(le, ne); return } return ue.done ? re(ue.value) : (Z = Promise.resolve(ue.value), Z.then(ae, se)) } ae(void 0) }); return Q.cancel = action(p + " - runid: " + F + " - cancel", function () { try { Z && cancelPromise(Z); var re = B.return(void 0), ne = Promise.resolve(re.value); ne.then(noop$2, noop$2), cancelPromise(ne), W(new FlowCancellationError) } catch (oe) { W(oe) } }), Q }; return d.isMobXFlow = !0, d }, flowAnnotation); flow.bound = createDecoratorAnnotation(flowBoundAnnotation); function cancelPromise(o) { isFunction(o.cancel) && o.cancel() } function flowResult(o) { return o } function isFlow(o) { return (o == null ? void 0 : o.isMobXFlow) === !0 } function interceptReads(o, l, u) { var f; return isObservableMap(o) || isObservableArray(o) || isObservableValue(o) ? f = getAdministration(o) : isObservableObject(o) && (f = getAdministration(o, l)), f.dehancer = typeof l == "function" ? l : u, function () { f.dehancer = void 0 } } function intercept(o, l, u) { return isFunction(u) ? interceptProperty(o, l, u) : interceptInterceptable(o, l) } function interceptInterceptable(o, l) { return getAdministration(o).intercept_(l) } function interceptProperty(o, l, u) { return getAdministration(o, l).intercept_(u) } function _isComputed(o, l) { if (l === void 0) return isComputedValue(o); if (isObservableObject(o) === !1 || !o[$mobx].values_.has(l)) return !1; var u = getAtom(o, l); return isComputedValue(u) } function isComputed(o) { return _isComputed(o) } function isComputedProp(o, l) { return _isComputed(o, l) } function _isObservable(o, l) { return o ? l !== void 0 ? isObservableObject(o) ? o[$mobx].values_.has(l) : !1 : isObservableObject(o) || !!o[$mobx] || isAtom(o) || isReaction(o) || isComputedValue(o) : !1 } function isObservable$1(o) { return _isObservable(o) } function isObservableProp(o, l) { return _isObservable(o, l) } function keys(o) { if (isObservableObject(o)) return o[$mobx].keys_(); if (isObservableMap(o) || isObservableSet(o)) return Array.from(o.keys()); if (isObservableArray(o)) return o.map(function (l, u) { return u }); die(5) } function values(o) { if (isObservableObject(o)) return keys(o).map(function (l) { return o[l] }); if (isObservableMap(o)) return keys(o).map(function (l) { return o.get(l) }); if (isObservableSet(o)) return Array.from(o.values()); if (isObservableArray(o)) return o.slice(); die(6) } function entries(o) { if (isObservableObject(o)) return keys(o).map(function (l) { return [l, o[l]] }); if (isObservableMap(o)) return keys(o).map(function (l) { return [l, o.get(l)] }); if (isObservableSet(o)) return Array.from(o.entries()); if (isObservableArray(o)) return o.map(function (l, u) { return [u, l] }); die(7) } function set2(o, l, u) { if (arguments.length === 2 && !isObservableSet(o)) { startBatch(); var f = l; try { for (var p in f) set2(o, p, f[p]) } finally { endBatch() } return } isObservableObject(o) ? o[$mobx].set_(l, u) : isObservableMap(o) ? o.set(l, u) : isObservableSet(o) ? o.add(l) : isObservableArray(o) ? (typeof l != "number" && (l = parseInt(l, 10)), l < 0 && die("Invalid index: '" + l + "'"), startBatch(), l >= o.length && (o.length = l + 1), o[l] = u, endBatch()) : die(8) } function remove(o, l) { isObservableObject(o) ? o[$mobx].delete_(l) : isObservableMap(o) || isObservableSet(o) ? o.delete(l) : isObservableArray(o) ? (typeof l != "number" && (l = parseInt(l, 10)), o.splice(l, 1)) : die(9) } function has$1(o, l) { if (isObservableObject(o)) return o[$mobx].has_(l); if (isObservableMap(o)) return o.has(l); if (isObservableSet(o)) return o.has(l); if (isObservableArray(o)) return l >= 0 && l < o.length; die(10) } function get(o, l) { if (has$1(o, l)) { if (isObservableObject(o)) return o[$mobx].get_(l); if (isObservableMap(o)) return o.get(l); if (isObservableArray(o)) return o[l]; die(11) } } function apiDefineProperty(o, l, u) { if (isObservableObject(o)) return o[$mobx].defineProperty_(l, u); die(39) } function apiOwnKeys(o) { if (isObservableObject(o)) return o[$mobx].ownKeys_(); die(38) } function observe(o, l, u, f) { return isFunction(u) ? observeObservableProperty(o, l, u, f) : observeObservable(o, l, u) } function observeObservable(o, l, u) { return getAdministration(o).observe_(l, u) } function observeObservableProperty(o, l, u, f) { return getAdministration(o, l).observe_(u, f) } function cache$4(o, l, u) { return o.set(l, u), u } function toJSHelper(o, l) { if (o == null || typeof o != "object" || o instanceof Date || !isObservable$1(o)) return o; if (isObservableValue(o) || isComputedValue(o)) return toJSHelper(o.get(), l); if (l.has(o)) return l.get(o); if (isObservableArray(o)) { var u = cache$4(l, o, new Array(o.length)); return o.forEach(function (m, v) { u[v] = toJSHelper(m, l) }), u } if (isObservableSet(o)) { var f = cache$4(l, o, new Set); return o.forEach(function (m) { f.add(toJSHelper(m, l)) }), f } if (isObservableMap(o)) { var p = cache$4(l, o, new Map); return o.forEach(function (m, v) { p.set(v, toJSHelper(m, l)) }), p } else { var d = cache$4(l, o, {}); return apiOwnKeys(o).forEach(function (m) { objectPrototype.propertyIsEnumerable.call(o, m) && (d[m] = toJSHelper(o[m], l)) }), d } } function toJS(o, l) { return toJSHelper(o, new Map) } function trace() { } function transaction(o, l) { l === void 0 && (l = void 0), startBatch(); try { return o.apply(l) } finally { endBatch() } } function when(o, l, u) { return arguments.length === 1 || l && typeof l == "object" ? whenPromise(o, l) : _when(o, l, u || {}) } function _when(o, l, u) { var f; if (typeof u.timeout == "number") { var p = new Error("WHEN_TIMEOUT"); f = setTimeout(function () { if (!m[$mobx].isDisposed) if (m(), u.onError) u.onError(p); else throw p }, u.timeout) } u.name = "When"; var d = createAction("When-effect", l), m = autorun(function (v) { var I = allowStateChanges(!1, o); I && (v.dispose(), f && clearTimeout(f), d()) }, u); return m } function whenPromise(o, l) { var u; if (l != null && (u = l.signal) != null && u.aborted) return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), { cancel: function () { return null } }); var f, p, d = new Promise(function (m, v) { var I, F = _when(o, m, _extends$5({}, l, { onError: v })); f = function () { F(), v(new Error("WHEN_CANCELLED")) }, p = function () { F(), v(new Error("WHEN_ABORTED")) }, l == null || (I = l.signal) == null || I.addEventListener == null || I.addEventListener("abort", p) }).finally(function () { var m; return l == null || (m = l.signal) == null || m.removeEventListener == null ? void 0 : m.removeEventListener("abort", p) }); return d.cancel = f, d } function getAdm(o) { return o[$mobx] } var objectProxyTraps = { has: function (l, u) { return getAdm(l).has_(u) }, get: function (l, u) { return getAdm(l).get_(u) }, set: function (l, u, f) { var p; return isStringish(u) ? (p = getAdm(l).set_(u, f, !0)) != null ? p : !0 : !1 }, deleteProperty: function (l, u) { var f; return isStringish(u) ? (f = getAdm(l).delete_(u, !0)) != null ? f : !0 : !1 }, defineProperty: function (l, u, f) { var p; return (p = getAdm(l).defineProperty_(u, f)) != null ? p : !0 }, ownKeys: function (l) { return getAdm(l).ownKeys_() }, preventExtensions: function (l) { die(13) } }; function asDynamicObservableObject(o, l) { var u, f; return assertProxies(), o = asObservableObject(o, l), (f = (u = o[$mobx]).proxy_) != null ? f : u.proxy_ = new Proxy(o, objectProxyTraps) } function hasInterceptors(o) { return o.interceptors_ !== void 0 && o.interceptors_.length > 0 } function registerInterceptor(o, l) { var u = o.interceptors_ || (o.interceptors_ = []); return u.push(l), once(function () { var f = u.indexOf(l); f !== -1 && u.splice(f, 1) }) } function interceptChange(o, l) { var u = untrackedStart(); try { for (var f = [].concat(o.interceptors_ || []), p = 0, d = f.length; p < d && (l = f[p](l), l && !l.type && die(14), !!l); p++); return l } finally { untrackedEnd(u) } } function hasListeners(o) { return o.changeListeners_ !== void 0 && o.changeListeners_.length > 0 } function registerListener(o, l) { var u = o.changeListeners_ || (o.changeListeners_ = []); return u.push(l), once(function () { var f = u.indexOf(l); f !== -1 && u.splice(f, 1) }) } function notifyListeners(o, l) { var u = untrackedStart(), f = o.changeListeners_; if (f) { f = f.slice(); for (var p = 0, d = f.length; p < d; p++)f[p](l); untrackedEnd(u) } } function makeObservable(o, l, u) { return initObservable(function () { var f, p = asObservableObject(o, u)[$mobx]; (f = l) != null || (l = collectStoredAnnotations(o)), ownKeys(l).forEach(function (d) { return p.make_(d, l[d]) }) }), o } var keysSymbol = Symbol("mobx-keys"); function makeAutoObservable(o, l, u) { return isPlainObject$1(o) ? extendObservable(o, o, l, u) : (initObservable(function () { var f = asObservableObject(o, u)[$mobx]; if (!o[keysSymbol]) { var p = Object.getPrototypeOf(o), d = new Set([].concat(ownKeys(o), ownKeys(p))); d.delete("constructor"), d.delete($mobx), addHiddenProp(p, keysSymbol, d) } o[keysSymbol].forEach(function (m) { return f.make_(m, l && m in l ? l[m] : !0) }) }), o) } var SPLICE = "splice", UPDATE = "update", MAX_SPLICE_SIZE = 1e4, arrayTraps = { get: function (l, u) { var f = l[$mobx]; return u === $mobx ? f : u === "length" ? f.getArrayLength_() : typeof u == "string" && !isNaN(u) ? f.get_(parseInt(u)) : hasProp$1(arrayExtensions, u) ? arrayExtensions[u] : l[u] }, set: function (l, u, f) { var p = l[$mobx]; return u === "length" && p.setArrayLength_(f), typeof u == "symbol" || isNaN(u) ? l[u] = f : p.set_(parseInt(u), f), !0 }, preventExtensions: function () { die(15) } }, ObservableArrayAdministration = function () { function o(u, f, p, d) { u === void 0 && (u = "ObservableArray"), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = p, this.legacyMode_ = d, this.atom_ = new Atom(u), this.enhancer_ = function (m, v) { return f(m, v, "ObservableArray[..]") } } var l = o.prototype; return l.dehanceValue_ = function (f) { return this.dehancer !== void 0 ? this.dehancer(f) : f }, l.dehanceValues_ = function (f) { return this.dehancer !== void 0 && f.length > 0 ? f.map(this.dehancer) : f }, l.intercept_ = function (f) { return registerInterceptor(this, f) }, l.observe_ = function (f, p) { return p === void 0 && (p = !1), p && f({ observableKind: "array", object: this.proxy_, debugObjectName: this.atom_.name_, type: "splice", index: 0, added: this.values_.slice(), addedCount: this.values_.length, removed: [], removedCount: 0 }), registerListener(this, f) }, l.getArrayLength_ = function () { return this.atom_.reportObserved(), this.values_.length }, l.setArrayLength_ = function (f) { (typeof f != "number" || isNaN(f) || f < 0) && die("Out of range: " + f); var p = this.values_.length; if (f !== p) if (f > p) { for (var d = new Array(f - p), m = 0; m < f - p; m++)d[m] = void 0; this.spliceWithArray_(p, 0, d) } else this.spliceWithArray_(f, p - f) }, l.updateArrayLength_ = function (f, p) { f !== this.lastKnownLength_ && die(16), this.lastKnownLength_ += p, this.legacyMode_ && p > 0 && reserveArrayBuffer(f + p + 1) }, l.spliceWithArray_ = function (f, p, d) { var m = this; this.atom_; var v = this.values_.length; if (f === void 0 ? f = 0 : f > v ? f = v : f < 0 && (f = Math.max(0, v + f)), arguments.length === 1 ? p = v - f : p == null ? p = 0 : p = Math.max(0, Math.min(p, v - f)), d === void 0 && (d = EMPTY_ARRAY), hasInterceptors(this)) { var I = interceptChange(this, { object: this.proxy_, type: SPLICE, index: f, removedCount: p, added: d }); if (!I) return EMPTY_ARRAY; p = I.removedCount, d = I.added } if (d = d.length === 0 ? d : d.map(function (W) { return m.enhancer_(W, void 0) }), this.legacyMode_) { var F = d.length - p; this.updateArrayLength_(v, F) } var B = this.spliceItemsIntoValues_(f, p, d); return (p !== 0 || d.length !== 0) && this.notifyArraySplice_(f, d, B), this.dehanceValues_(B) }, l.spliceItemsIntoValues_ = function (f, p, d) { if (d.length < MAX_SPLICE_SIZE) { var m; return (m = this.values_).splice.apply(m, [f, p].concat(d)) } else { var v = this.values_.slice(f, f + p), I = this.values_.slice(f + p); this.values_.length += d.length - p; for (var F = 0; F < d.length; F++)this.values_[f + F] = d[F]; for (var B = 0; B < I.length; B++)this.values_[f + d.length + B] = I[B]; return v } }, l.notifyArrayChildUpdate_ = function (f, p, d) { var m = !this.owned_ && isSpyEnabled(), v = hasListeners(this), I = v || m ? { observableKind: "array", object: this.proxy_, type: UPDATE, debugObjectName: this.atom_.name_, index: f, newValue: p, oldValue: d } : null; this.atom_.reportChanged(), v && notifyListeners(this, I) }, l.notifyArraySplice_ = function (f, p, d) { var m = !this.owned_ && isSpyEnabled(), v = hasListeners(this), I = v || m ? { observableKind: "array", object: this.proxy_, debugObjectName: this.atom_.name_, type: SPLICE, index: f, removed: d, added: p, removedCount: d.length, addedCount: p.length } : null; this.atom_.reportChanged(), v && notifyListeners(this, I) }, l.get_ = function (f) { if (this.legacyMode_ && f >= this.values_.length) { console.warn("[mobx] Out of bounds read: " + f); return } return this.atom_.reportObserved(), this.dehanceValue_(this.values_[f]) }, l.set_ = function (f, p) { var d = this.values_; if (this.legacyMode_ && f > d.length && die(17, f, d.length), f < d.length) { this.atom_; var m = d[f]; if (hasInterceptors(this)) { var v = interceptChange(this, { type: UPDATE, object: this.proxy_, index: f, newValue: p }); if (!v) return; p = v.newValue } p = this.enhancer_(p, m); var I = p !== m; I && (d[f] = p, this.notifyArrayChildUpdate_(f, p, m)) } else { for (var F = new Array(f + 1 - d.length), B = 0; B < F.length - 1; B++)F[B] = void 0; F[F.length - 1] = p, this.spliceWithArray_(d.length, 0, F) } }, o }(); function createObservableArray(o, l, u, f) { return u === void 0 && (u = "ObservableArray"), f === void 0 && (f = !1), assertProxies(), initObservable(function () { var p = new ObservableArrayAdministration(u, l, f, !1); addHiddenFinalProp(p.values_, $mobx, p); var d = new Proxy(p.values_, arrayTraps); return p.proxy_ = d, o && o.length && p.spliceWithArray_(0, 0, o), d }) } var arrayExtensions = { clear: function () { return this.splice(0) }, replace: function (l) { var u = this[$mobx]; return u.spliceWithArray_(0, u.values_.length, l) }, toJSON: function () { return this.slice() }, splice: function (l, u) { for (var f = arguments.length, p = new Array(f > 2 ? f - 2 : 0), d = 2; d < f; d++)p[d - 2] = arguments[d]; var m = this[$mobx]; switch (arguments.length) { case 0: return []; case 1: return m.spliceWithArray_(l); case 2: return m.spliceWithArray_(l, u) }return m.spliceWithArray_(l, u, p) }, spliceWithArray: function (l, u, f) { return this[$mobx].spliceWithArray_(l, u, f) }, push: function () { for (var l = this[$mobx], u = arguments.length, f = new Array(u), p = 0; p < u; p++)f[p] = arguments[p]; return l.spliceWithArray_(l.values_.length, 0, f), l.values_.length }, pop: function () { return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0] }, shift: function () { return this.splice(0, 1)[0] }, unshift: function () { for (var l = this[$mobx], u = arguments.length, f = new Array(u), p = 0; p < u; p++)f[p] = arguments[p]; return l.spliceWithArray_(0, 0, f), l.values_.length }, reverse: function () { return globalState.trackingDerivation && die(37, "reverse"), this.replace(this.slice().reverse()), this }, sort: function () { globalState.trackingDerivation && die(37, "sort"); var l = this.slice(); return l.sort.apply(l, arguments), this.replace(l), this }, remove: function (l) { var u = this[$mobx], f = u.dehanceValues_(u.values_).indexOf(l); return f > -1 ? (this.splice(f, 1), !0) : !1 } }; addArrayExtension("at", simpleFunc); addArrayExtension("concat", simpleFunc); addArrayExtension("flat", simpleFunc); addArrayExtension("includes", simpleFunc); addArrayExtension("indexOf", simpleFunc); addArrayExtension("join", simpleFunc); addArrayExtension("lastIndexOf", simpleFunc); addArrayExtension("slice", simpleFunc); addArrayExtension("toString", simpleFunc); addArrayExtension("toLocaleString", simpleFunc); addArrayExtension("toSorted", simpleFunc); addArrayExtension("toSpliced", simpleFunc); addArrayExtension("with", simpleFunc); addArrayExtension("every", mapLikeFunc); addArrayExtension("filter", mapLikeFunc); addArrayExtension("find", mapLikeFunc); addArrayExtension("findIndex", mapLikeFunc); addArrayExtension("findLast", mapLikeFunc); addArrayExtension("findLastIndex", mapLikeFunc); addArrayExtension("flatMap", mapLikeFunc); addArrayExtension("forEach", mapLikeFunc); addArrayExtension("map", mapLikeFunc); addArrayExtension("some", mapLikeFunc); addArrayExtension("toReversed", mapLikeFunc); addArrayExtension("reduce", reduceLikeFunc); addArrayExtension("reduceRight", reduceLikeFunc); function addArrayExtension(o, l) { typeof Array.prototype[o] == "function" && (arrayExtensions[o] = l(o)) } function simpleFunc(o) { return function () { var l = this[$mobx]; l.atom_.reportObserved(); var u = l.dehanceValues_(l.values_); return u[o].apply(u, arguments) } } function mapLikeFunc(o) { return function (l, u) { var f = this, p = this[$mobx]; p.atom_.reportObserved(); var d = p.dehanceValues_(p.values_); return d[o](function (m, v) { return l.call(u, m, v, f) }) } } function reduceLikeFunc(o) { return function () { var l = this, u = this[$mobx]; u.atom_.reportObserved(); var f = u.dehanceValues_(u.values_), p = arguments[0]; return arguments[0] = function (d, m, v) { return p(d, m, v, l) }, f[o].apply(f, arguments) } } var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration); function isObservableArray(o) { return isObject$6(o) && isObservableArrayAdministration(o[$mobx]) } var ObservableMapMarker = {}, ADD = "add", DELETE = "delete", ObservableMap = function () { function o(u, f, p) { var d = this; f === void 0 && (f = deepEnhancer), p === void 0 && (p = "ObservableMap"), this.enhancer_ = void 0, this.name_ = void 0, this[$mobx] = ObservableMapMarker, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = f, this.name_ = p, isFunction(Map) || die(18), initObservable(function () { d.keysAtom_ = createAtom("ObservableMap.keys()"), d.data_ = new Map, d.hasMap_ = new Map, u && d.merge(u) }) } var l = o.prototype; return l.has_ = function (f) { return this.data_.has(f) }, l.has = function (f) { var p = this; if (!globalState.trackingDerivation) return this.has_(f); var d = this.hasMap_.get(f); if (!d) { var m = d = new ObservableValue(this.has_(f), referenceEnhancer, "ObservableMap.key?", !1); this.hasMap_.set(f, m), onBecomeUnobserved(m, function () { return p.hasMap_.delete(f) }) } return d.get() }, l.set = function (f, p) { var d = this.has_(f); if (hasInterceptors(this)) { var m = interceptChange(this, { type: d ? UPDATE : ADD, object: this, newValue: p, name: f }); if (!m) return this; p = m.newValue } return d ? this.updateValue_(f, p) : this.addValue_(f, p), this }, l.delete = function (f) { var p = this; if (this.keysAtom_, hasInterceptors(this)) { var d = interceptChange(this, { type: DELETE, object: this, name: f }); if (!d) return !1 } if (this.has_(f)) { var m = isSpyEnabled(), v = hasListeners(this), I = v || m ? { observableKind: "map", debugObjectName: this.name_, type: DELETE, object: this, oldValue: this.data_.get(f).value_, name: f } : null; return transaction(function () { var F; p.keysAtom_.reportChanged(), (F = p.hasMap_.get(f)) == null || F.setNewValue_(!1); var B = p.data_.get(f); B.setNewValue_(void 0), p.data_.delete(f) }), v && notifyListeners(this, I), !0 } return !1 }, l.updateValue_ = function (f, p) { var d = this.data_.get(f); if (p = d.prepareNewValue_(p), p !== globalState.UNCHANGED) { var m = isSpyEnabled(), v = hasListeners(this), I = v || m ? { observableKind: "map", debugObjectName: this.name_, type: UPDATE, object: this, oldValue: d.value_, name: f, newValue: p } : null; d.setNewValue_(p), v && notifyListeners(this, I) } }, l.addValue_ = function (f, p) { var d = this; this.keysAtom_, transaction(function () { var F, B = new ObservableValue(p, d.enhancer_, "ObservableMap.key", !1); d.data_.set(f, B), p = B.value_, (F = d.hasMap_.get(f)) == null || F.setNewValue_(!0), d.keysAtom_.reportChanged() }); var m = isSpyEnabled(), v = hasListeners(this), I = v || m ? { observableKind: "map", debugObjectName: this.name_, type: ADD, object: this, name: f, newValue: p } : null; v && notifyListeners(this, I) }, l.get = function (f) { return this.has(f) ? this.dehanceValue_(this.data_.get(f).get()) : this.dehanceValue_(void 0) }, l.dehanceValue_ = function (f) { return this.dehancer !== void 0 ? this.dehancer(f) : f }, l.keys = function () { return this.keysAtom_.reportObserved(), this.data_.keys() }, l.values = function () { var f = this, p = this.keys(); return makeIterable({ next: function () { var m = p.next(), v = m.done, I = m.value; return { done: v, value: v ? void 0 : f.get(I) } } }) }, l.entries = function () { var f = this, p = this.keys(); return makeIterable({ next: function () { var m = p.next(), v = m.done, I = m.value; return { done: v, value: v ? void 0 : [I, f.get(I)] } } }) }, l[Symbol.iterator] = function () { return this.entries() }, l.forEach = function (f, p) { for (var d = _createForOfIteratorHelperLoose(this), m; !(m = d()).done;) { var v = m.value, I = v[0], F = v[1]; f.call(p, F, I, this) } }, l.merge = function (f) { var p = this; return isObservableMap(f) && (f = new Map(f)), transaction(function () { isPlainObject$1(f) ? getPlainObjectKeys(f).forEach(function (d) { return p.set(d, f[d]) }) : Array.isArray(f) ? f.forEach(function (d) { var m = d[0], v = d[1]; return p.set(m, v) }) : isES6Map(f) ? (isPlainES6Map(f) || die(19, f), f.forEach(function (d, m) { return p.set(m, d) })) : f != null && die(20, f) }), this }, l.clear = function () { var f = this; transaction(function () { untracked(function () { for (var p = _createForOfIteratorHelperLoose(f.keys()), d; !(d = p()).done;) { var m = d.value; f.delete(m) } }) }) }, l.replace = function (f) { var p = this; return transaction(function () { for (var d = convertToMap(f), m = new Map, v = !1, I = _createForOfIteratorHelperLoose(p.data_.keys()), F; !(F = I()).done;) { var B = F.value; if (!d.has(B)) { var W = p.delete(B); if (W) v = !0; else { var Z = p.data_.get(B); m.set(B, Z) } } } for (var Q = _createForOfIteratorHelperLoose(d.entries()), re; !(re = Q()).done;) { var ne = re.value, oe = ne[0], ae = ne[1], se = p.data_.has(oe); if (p.set(oe, ae), p.data_.has(oe)) { var le = p.data_.get(oe); m.set(oe, le), se || (v = !0) } } if (!v) if (p.data_.size !== m.size) p.keysAtom_.reportChanged(); else for (var ue = p.data_.keys(), he = m.keys(), pe = ue.next(), ve = he.next(); !pe.done;) { if (pe.value !== ve.value) { p.keysAtom_.reportChanged(); break } pe = ue.next(), ve = he.next() } p.data_ = m }), this }, l.toString = function () { return "[object ObservableMap]" }, l.toJSON = function () { return Array.from(this) }, l.observe_ = function (f, p) { return registerListener(this, f) }, l.intercept_ = function (f) { return registerInterceptor(this, f) }, _createClass$1(o, [{ key: "size", get: function () { return this.keysAtom_.reportObserved(), this.data_.size } }, { key: Symbol.toStringTag, get: function () { return "Map" } }]) }(), isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap); function convertToMap(o) { if (isES6Map(o) || isObservableMap(o)) return o; if (Array.isArray(o)) return new Map(o); if (isPlainObject$1(o)) { var l = new Map; for (var u in o) l.set(u, o[u]); return l } else return die(21, o) } var ObservableSetMarker = {}, ObservableSet = function () { function o(u, f, p) { var d = this; f === void 0 && (f = deepEnhancer), p === void 0 && (p = "ObservableSet"), this.name_ = void 0, this[$mobx] = ObservableSetMarker, this.data_ = new Set, this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = p, isFunction(Set) || die(22), this.enhancer_ = function (m, v) { return f(m, v, p) }, initObservable(function () { d.atom_ = createAtom(d.name_), u && d.replace(u) }) } var l = o.prototype; return l.dehanceValue_ = function (f) { return this.dehancer !== void 0 ? this.dehancer(f) : f }, l.clear = function () { var f = this; transaction(function () { untracked(function () { for (var p = _createForOfIteratorHelperLoose(f.data_.values()), d; !(d = p()).done;) { var m = d.value; f.delete(m) } }) }) }, l.forEach = function (f, p) { for (var d = _createForOfIteratorHelperLoose(this), m; !(m = d()).done;) { var v = m.value; f.call(p, v, v, this) } }, l.add = function (f) { var p = this; if (this.atom_, hasInterceptors(this)) { var d = interceptChange(this, { type: ADD, object: this, newValue: f }); if (!d) return this } if (!this.has(f)) { transaction(function () { p.data_.add(p.enhancer_(f, void 0)), p.atom_.reportChanged() }); var m = !1, v = hasListeners(this), I = v || m ? { observableKind: "set", debugObjectName: this.name_, type: ADD, object: this, newValue: f } : null; v && notifyListeners(this, I) } return this }, l.delete = function (f) { var p = this; if (hasInterceptors(this)) { var d = interceptChange(this, { type: DELETE, object: this, oldValue: f }); if (!d) return !1 } if (this.has(f)) { var m = !1, v = hasListeners(this), I = v || m ? { observableKind: "set", debugObjectName: this.name_, type: DELETE, object: this, oldValue: f } : null; return transaction(function () { p.atom_.reportChanged(), p.data_.delete(f) }), v && notifyListeners(this, I), !0 } return !1 }, l.has = function (f) { return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(f)) }, l.entries = function () { var f = 0, p = Array.from(this.keys()), d = Array.from(this.values()); return makeIterable({ next: function () { var v = f; return f += 1, v < d.length ? { value: [p[v], d[v]], done: !1 } : { done: !0 } } }) }, l.keys = function () { return this.values() }, l.values = function () { this.atom_.reportObserved(); var f = this, p = 0, d = Array.from(this.data_.values()); return makeIterable({ next: function () { return p < d.length ? { value: f.dehanceValue_(d[p++]), done: !1 } : { done: !0 } } }) }, l.intersection = function (f) { if (isES6Set(f)) return f.intersection(this); var p = new Set(this); return p.intersection(f) }, l.union = function (f) { if (isES6Set(f)) return f.union(this); var p = new Set(this); return p.union(f) }, l.difference = function (f) { return new Set(this).difference(f) }, l.symmetricDifference = function (f) { if (isES6Set(f)) return f.symmetricDifference(this); var p = new Set(this); return p.symmetricDifference(f) }, l.isSubsetOf = function (f) { return new Set(this).isSubsetOf(f) }, l.isSupersetOf = function (f) { return new Set(this).isSupersetOf(f) }, l.isDisjointFrom = function (f) { if (isES6Set(f)) return f.isDisjointFrom(this); var p = new Set(this); return p.isDisjointFrom(f) }, l.replace = function (f) { var p = this; return isObservableSet(f) && (f = new Set(f)), transaction(function () { Array.isArray(f) ? (p.clear(), f.forEach(function (d) { return p.add(d) })) : isES6Set(f) ? (p.clear(), f.forEach(function (d) { return p.add(d) })) : f != null && die("Cannot initialize set from " + f) }), this }, l.observe_ = function (f, p) { return registerListener(this, f) }, l.intercept_ = function (f) { return registerInterceptor(this, f) }, l.toJSON = function () { return Array.from(this) }, l.toString = function () { return "[object ObservableSet]" }, l[Symbol.iterator] = function () { return this.values() }, _createClass$1(o, [{ key: "size", get: function () { return this.atom_.reportObserved(), this.data_.size } }, { key: Symbol.toStringTag, get: function () { return "Set" } }]) }(), isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet), descriptorCache = Object.create(null), REMOVE = "remove", ObservableObjectAdministration = function () { function o(u, f, p, d) { f === void 0 && (f = new Map), d === void 0 && (d = autoAnnotation), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = u, this.values_ = f, this.name_ = p, this.defaultAnnotation_ = d, this.keysAtom_ = new Atom("ObservableObject.keys"), this.isPlainObject_ = isPlainObject$1(this.target_) } var l = o.prototype; return l.getObservablePropValue_ = function (f) { return this.values_.get(f).get() }, l.setObservablePropValue_ = function (f, p) { var d = this.values_.get(f); if (d instanceof ComputedValue) return d.set(p), !0; if (hasInterceptors(this)) { var m = interceptChange(this, { type: UPDATE, object: this.proxy_ || this.target_, name: f, newValue: p }); if (!m) return null; p = m.newValue } if (p = d.prepareNewValue_(p), p !== globalState.UNCHANGED) { var v = hasListeners(this), I = !1, F = v || I ? { type: UPDATE, observableKind: "object", debugObjectName: this.name_, object: this.proxy_ || this.target_, oldValue: d.value_, name: f, newValue: p } : null; d.setNewValue_(p), v && notifyListeners(this, F) } return !0 }, l.get_ = function (f) { return globalState.trackingDerivation && !hasProp$1(this.target_, f) && this.has_(f), this.target_[f] }, l.set_ = function (f, p, d) { return d === void 0 && (d = !1), hasProp$1(this.target_, f) ? this.values_.has(f) ? this.setObservablePropValue_(f, p) : d ? Reflect.set(this.target_, f, p) : (this.target_[f] = p, !0) : this.extend_(f, { value: p, enumerable: !0, writable: !0, configurable: !0 }, this.defaultAnnotation_, d) }, l.has_ = function (f) { if (!globalState.trackingDerivation) return f in this.target_; this.pendingKeys_ || (this.pendingKeys_ = new Map); var p = this.pendingKeys_.get(f); return p || (p = new ObservableValue(f in this.target_, referenceEnhancer, "ObservableObject.key?", !1), this.pendingKeys_.set(f, p)), p.get() }, l.make_ = function (f, p) { if (p === !0 && (p = this.defaultAnnotation_), p !== !1) { if (!(f in this.target_)) { var d; if ((d = this.target_[storedAnnotationsSymbol]) != null && d[f]) return; die(1, p.annotationType_, this.name_ + "." + f.toString()) } for (var m = this.target_; m && m !== objectPrototype;) { var v = getDescriptor(m, f); if (v) { var I = p.make_(this, f, v, m); if (I === 0) return; if (I === 1) break } m = Object.getPrototypeOf(m) } recordAnnotationApplied(this, p, f) } }, l.extend_ = function (f, p, d, m) { if (m === void 0 && (m = !1), d === !0 && (d = this.defaultAnnotation_), d === !1) return this.defineProperty_(f, p, m); var v = d.extend_(this, f, p, m); return v && recordAnnotationApplied(this, d, f), v }, l.defineProperty_ = function (f, p, d) { d === void 0 && (d = !1), this.keysAtom_; try { startBatch(); var m = this.delete_(f); if (!m) return m; if (hasInterceptors(this)) { var v = interceptChange(this, { object: this.proxy_ || this.target_, name: f, type: ADD, newValue: p.value }); if (!v) return null; var I = v.newValue; p.value !== I && (p = _extends$5({}, p, { value: I })) } if (d) { if (!Reflect.defineProperty(this.target_, f, p)) return !1 } else defineProperty(this.target_, f, p); this.notifyPropertyAddition_(f, p.value) } finally { endBatch() } return !0 }, l.defineObservableProperty_ = function (f, p, d, m) { m === void 0 && (m = !1), this.keysAtom_; try { startBatch(); var v = this.delete_(f); if (!v) return v; if (hasInterceptors(this)) { var I = interceptChange(this, { object: this.proxy_ || this.target_, name: f, type: ADD, newValue: p }); if (!I) return null; p = I.newValue } var F = getCachedObservablePropDescriptor(f), B = { configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0, enumerable: !0, get: F.get, set: F.set }; if (m) { if (!Reflect.defineProperty(this.target_, f, B)) return !1 } else defineProperty(this.target_, f, B); var W = new ObservableValue(p, d, "ObservableObject.key", !1); this.values_.set(f, W), this.notifyPropertyAddition_(f, W.value_) } finally { endBatch() } return !0 }, l.defineComputedProperty_ = function (f, p, d) { d === void 0 && (d = !1), this.keysAtom_; try { startBatch(); var m = this.delete_(f); if (!m) return m; if (hasInterceptors(this)) { var v = interceptChange(this, { object: this.proxy_ || this.target_, name: f, type: ADD, newValue: void 0 }); if (!v) return null } p.name || (p.name = "ObservableObject.key"), p.context = this.proxy_ || this.target_; var I = getCachedObservablePropDescriptor(f), F = { configurable: globalState.safeDescriptors ? this.isPlainObject_ : !0, enumerable: !1, get: I.get, set: I.set }; if (d) { if (!Reflect.defineProperty(this.target_, f, F)) return !1 } else defineProperty(this.target_, f, F); this.values_.set(f, new ComputedValue(p)), this.notifyPropertyAddition_(f, void 0) } finally { endBatch() } return !0 }, l.delete_ = function (f, p) { if (p === void 0 && (p = !1), this.keysAtom_, !hasProp$1(this.target_, f)) return !0; if (hasInterceptors(this)) { var d = interceptChange(this, { object: this.proxy_ || this.target_, name: f, type: REMOVE }); if (!d) return null } try { var m; startBatch(); var v = hasListeners(this), I = !1, F = this.values_.get(f), B = void 0; if (!F && (v || I)) { var W; B = (W = getDescriptor(this.target_, f)) == null ? void 0 : W.value } if (p) { if (!Reflect.deleteProperty(this.target_, f)) return !1 } else delete this.target_[f]; if (F && (this.values_.delete(f), F instanceof ObservableValue && (B = F.value_), propagateChanged(F)), this.keysAtom_.reportChanged(), (m = this.pendingKeys_) == null || (m = m.get(f)) == null || m.set(f in this.target_), v || I) { var Z = { type: REMOVE, observableKind: "object", object: this.proxy_ || this.target_, debugObjectName: this.name_, oldValue: B, name: f }; v && notifyListeners(this, Z) } } finally { endBatch() } return !0 }, l.observe_ = function (f, p) { return registerListener(this, f) }, l.intercept_ = function (f) { return registerInterceptor(this, f) }, l.notifyPropertyAddition_ = function (f, p) { var d, m = hasListeners(this), v = !1; if (m || v) { var I = m || v ? { type: ADD, observableKind: "object", debugObjectName: this.name_, object: this.proxy_ || this.target_, name: f, newValue: p } : null; m && notifyListeners(this, I) } (d = this.pendingKeys_) == null || (d = d.get(f)) == null || d.set(!0), this.keysAtom_.reportChanged() }, l.ownKeys_ = function () { return this.keysAtom_.reportObserved(), ownKeys(this.target_) }, l.keys_ = function () { return this.keysAtom_.reportObserved(), Object.keys(this.target_) }, o }(); function asObservableObject(o, l) { var u; if (hasProp$1(o, $mobx)) return o; var f = (u = l == null ? void 0 : l.name) != null ? u : "ObservableObject", p = new ObservableObjectAdministration(o, new Map, String(f), getAnnotationFromOptions(l)); return addHiddenProp(o, $mobx, p), o } var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration); function getCachedObservablePropDescriptor(o) { return descriptorCache[o] || (descriptorCache[o] = { get: function () { return this[$mobx].getObservablePropValue_(o) }, set: function (u) { return this[$mobx].setObservablePropValue_(o, u) } }) } function isObservableObject(o) { return isObject$6(o) ? isObservableObjectAdministration(o[$mobx]) : !1 } function recordAnnotationApplied(o, l, u) { var f; (f = o.target_[storedAnnotationsSymbol]) == null || delete f[u] } var ENTRY_0 = createArrayEntryDescriptor(0), safariPrototypeSetterInheritanceBug = function () { var o = !1, l = {}; return Object.defineProperty(l, "0", { set: function () { o = !0 } }), Object.create(l)[0] = 1, o === !1 }(), OBSERVABLE_ARRAY_BUFFER_SIZE = 0, StubArray = function () { }; function inherit(o, l) { Object.setPrototypeOf ? Object.setPrototypeOf(o.prototype, l) : o.prototype.__proto__ !== void 0 ? o.prototype.__proto__ = l : o.prototype = l } inherit(StubArray, Array.prototype); var LegacyObservableArray = function (o) { function l(f, p, d, m) { var v; return d === void 0 && (d = "ObservableArray"), m === void 0 && (m = !1), v = o.call(this) || this, initObservable(function () { var I = new ObservableArrayAdministration(d, p, m, !0); I.proxy_ = v, addHiddenFinalProp(v, $mobx, I), f && f.length && v.spliceWithArray(0, 0, f), safariPrototypeSetterInheritanceBug && Object.defineProperty(v, "0", ENTRY_0) }), v } _inheritsLoose$2(l, o); var u = l.prototype; return u.concat = function () { this[$mobx].atom_.reportObserved(); for (var p = arguments.length, d = new Array(p), m = 0; m < p; m++)d[m] = arguments[m]; return Array.prototype.concat.apply(this.slice(), d.map(function (v) { return isObservableArray(v) ? v.slice() : v })) }, u[Symbol.iterator] = function () { var f = this, p = 0; return makeIterable({ next: function () { return p < f.length ? { value: f[p++], done: !1 } : { done: !0, value: void 0 } } }) }, _createClass$1(l, [{ key: "length", get: function () { return this[$mobx].getArrayLength_() }, set: function (p) { this[$mobx].setArrayLength_(p) } }, { key: Symbol.toStringTag, get: function () { return "Array" } }]) }(StubArray); Object.entries(arrayExtensions).forEach(function (o) { var l = o[0], u = o[1]; l !== "concat" && addHiddenProp(LegacyObservableArray.prototype, l, u) }); function createArrayEntryDescriptor(o) { return { enumerable: !1, configurable: !0, get: function () { return this[$mobx].get_(o) }, set: function (u) { this[$mobx].set_(o, u) } } } function createArrayBufferItem(o) { defineProperty(LegacyObservableArray.prototype, "" + o, createArrayEntryDescriptor(o)) } function reserveArrayBuffer(o) { if (o > OBSERVABLE_ARRAY_BUFFER_SIZE) { for (var l = OBSERVABLE_ARRAY_BUFFER_SIZE; l < o + 100; l++)createArrayBufferItem(l); OBSERVABLE_ARRAY_BUFFER_SIZE = o } } reserveArrayBuffer(1e3); function createLegacyArray(o, l, u) { return new LegacyObservableArray(o, l, u) } function getAtom(o, l) { if (typeof o == "object" && o !== null) { if (isObservableArray(o)) return l !== void 0 && die(23), o[$mobx].atom_; if (isObservableSet(o)) return o.atom_; if (isObservableMap(o)) { if (l === void 0) return o.keysAtom_; var u = o.data_.get(l) || o.hasMap_.get(l); return u || die(25, l, getDebugName(o)), u } if (isObservableObject(o)) { if (!l) return die(26); var f = o[$mobx].values_.get(l); return f || die(27, l, getDebugName(o)), f } if (isAtom(o) || isComputedValue(o) || isReaction(o)) return o } else if (isFunction(o) && isReaction(o[$mobx])) return o[$mobx]; die(28) } function getAdministration(o, l) { if (o || die(29), l !== void 0) return getAdministration(getAtom(o, l)); if (isAtom(o) || isComputedValue(o) || isReaction(o) || isObservableMap(o) || isObservableSet(o)) return o; if (o[$mobx]) return o[$mobx]; die(24, o) } function getDebugName(o, l) { var u; if (l !== void 0) u = getAtom(o, l); else { if (isAction(o)) return o.name; isObservableObject(o) || isObservableMap(o) || isObservableSet(o) ? u = getAdministration(o) : u = getAtom(o) } return u.name_ } function initObservable(o) { var l = untrackedStart(), u = allowStateChangesStart(!0); startBatch(); try { return o() } finally { endBatch(), allowStateChangesEnd(u), untrackedEnd(l) } } var toString$2 = objectPrototype.toString; function deepEqual(o, l, u) { return u === void 0 && (u = -1), eq(o, l, u) } function eq(o, l, u, f, p) { if (o === l) return o !== 0 || 1 / o === 1 / l; if (o == null || l == null) return !1; if (o !== o) return l !== l; var d = typeof o; if (d !== "function" && d !== "object" && typeof l != "object") return !1; var m = toString$2.call(o); if (m !== toString$2.call(l)) return !1; switch (m) { case "[object RegExp]": case "[object String]": return "" + o == "" + l; case "[object Number]": return +o != +o ? +l != +l : +o == 0 ? 1 / +o === 1 / l : +o == +l; case "[object Date]": case "[object Boolean]": return +o == +l; case "[object Symbol]": return typeof Symbol < "u" && Symbol.valueOf.call(o) === Symbol.valueOf.call(l); case "[object Map]": case "[object Set]": u >= 0 && u++; break }o = unwrap(o), l = unwrap(l); var v = m === "[object Array]"; if (!v) { if (typeof o != "object" || typeof l != "object") return !1; var I = o.constructor, F = l.constructor; if (I !== F && !(isFunction(I) && I instanceof I && isFunction(F) && F instanceof F) && "constructor" in o && "constructor" in l) return !1 } if (u === 0) return !1; u < 0 && (u = -1), f = f || [], p = p || []; for (var B = f.length; B--;)if (f[B] === o) return p[B] === l; if (f.push(o), p.push(l), v) { if (B = o.length, B !== l.length) return !1; for (; B--;)if (!eq(o[B], l[B], u - 1, f, p)) return !1 } else { var W = Object.keys(o), Z; if (B = W.length, Object.keys(l).length !== B) return !1; for (; B--;)if (Z = W[B], !(hasProp$1(l, Z) && eq(o[Z], l[Z], u - 1, f, p))) return !1 } return f.pop(), p.pop(), !0 } function unwrap(o) { return isObservableArray(o) ? o.slice() : isES6Map(o) || isObservableMap(o) || isES6Set(o) || isObservableSet(o) ? Array.from(o.entries()) : o } function makeIterable(o) { return o[Symbol.iterator] = getSelf, o } function getSelf() { return this } ["Symbol", "Map", "Set"].forEach(function (o) { var l = getGlobal(); typeof l[o] > "u" && die("MobX requires global '" + o + "' to be available or polyfilled") }); typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy, extras: { getDebugName }, $mobx }); const mobx_esm = Object.freeze(Object.defineProperty({ __proto__: null, $mobx, FlowCancellationError, ObservableMap, ObservableSet, Reaction, _allowStateChanges: allowStateChanges, _allowStateChangesInsideComputed: runInAction, _allowStateReadsEnd: allowStateReadsEnd, _allowStateReadsStart: allowStateReadsStart, _autoAction: autoAction, _endAction, _getAdministration: getAdministration, _getGlobalState: getGlobalState, _interceptReads: interceptReads, _isComputingDerivation: isComputingDerivation, _resetGlobalState: resetGlobalState, _startAction, action, autorun, comparer, computed: computed$1, configure, createAtom, defineProperty: apiDefineProperty, entries, extendObservable, flow, flowResult, get, getAtom, getDebugName, getDependencyTree, getObserverTree, has: has$1, intercept, isAction, isBoxedObservable: isObservableValue, isComputed, isComputedProp, isFlow, isFlowCancellationError, isObservable: isObservable$1, isObservableArray, isObservableMap, isObservableObject, isObservableProp, isObservableSet, keys, makeAutoObservable, makeObservable, observable, observe, onBecomeObserved, onBecomeUnobserved, onReactionError, override, ownKeys: apiOwnKeys, reaction, remove, runInAction, set: set2, spy, toJS, trace, transaction, untracked, values, when }, Symbol.toStringTag, { value: "Module" })); class HTTPError extends Error { constructor(l, u, f) { const p = l.status || l.status === 0 ? l.status : "", d = l.statusText || "", m = `${p} ${d}`.trim(), v = m ? `status code ${m}` : "an unknown error"; super(`Request failed with ${v}: ${u.method} ${u.url}`), Object.defineProperty(this, "response", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "request", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "options", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.name = "HTTPError", this.response = l, this.request = u, this.options = f } } class TimeoutError extends Error { constructor(l) { super(`Request timed out: ${l.method} ${l.url}`), Object.defineProperty(this, "request", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.name = "TimeoutError", this.request = l } } const isObject$5 = o => o !== null && typeof o == "object", validateAndMerge = (...o) => { for (const l of o) if ((!isObject$5(l) || Array.isArray(l)) && l !== void 0) throw new TypeError("The `options` argument must be an object"); return deepMerge({}, ...o) }, mergeHeaders = (o = {}, l = {}) => { const u = new globalThis.Headers(o), f = l instanceof globalThis.Headers, p = new globalThis.Headers(l); for (const [d, m] of p.entries()) f && m === "undefined" || m === void 0 ? u.delete(d) : u.set(d, m); return u }, deepMerge = (...o) => { let l = {}, u = {}; for (const f of o) if (Array.isArray(f)) Array.isArray(l) || (l = []), l = [...l, ...f]; else if (isObject$5(f)) { for (let [p, d] of Object.entries(f)) isObject$5(d) && p in l && (d = deepMerge(l[p], d)), l = { ...l, [p]: d }; isObject$5(f.headers) && (u = mergeHeaders(u, f.headers), l.headers = u) } return l }, supportsRequestStreams = (() => { let o = !1, l = !1; const u = typeof globalThis.ReadableStream == "function", f = typeof globalThis.Request == "function"; if (u && f) try { l = new globalThis.Request("https://empty.invalid", { body: new globalThis.ReadableStream, method: "POST", get duplex() { return o = !0, "half" } }).headers.has("Content-Type") } catch (p) { if (p instanceof Error && p.message === "unsupported BodyInit type") return !1; throw p } return o && !l })(), supportsAbortController = typeof globalThis.AbortController == "function", supportsResponseStreams = typeof globalThis.ReadableStream == "function", supportsFormData = typeof globalThis.FormData == "function", requestMethods = ["get", "post", "put", "patch", "head", "delete"], responseTypes = { json: "application/json", text: "text/*", formData: "multipart/form-data", arrayBuffer: "*/*", blob: "*/*" }, maxSafeTimeout = 2147483647, stop = Symbol("stop"), kyOptionKeys = { json: !0, parseJson: !0, stringifyJson: !0, searchParams: !0, prefixUrl: !0, retry: !0, timeout: !0, hooks: !0, throwHttpErrors: !0, onDownloadProgress: !0, fetch: !0 }, requestOptionsRegistry = { method: !0, headers: !0, body: !0, mode: !0, credentials: !0, cache: !0, redirect: !0, referrer: !0, referrerPolicy: !0, integrity: !0, keepalive: !0, signal: !0, window: !0, dispatcher: !0, duplex: !0, priority: !0 }, normalizeRequestMethod = o => requestMethods.includes(o) ? o.toUpperCase() : o, retryMethods = ["get", "put", "head", "delete", "options", "trace"], retryStatusCodes = [408, 413, 429, 500, 502, 503, 504], retryAfterStatusCodes = [413, 429, 503], defaultRetryOptions = { limit: 2, methods: retryMethods, statusCodes: retryStatusCodes, afterStatusCodes: retryAfterStatusCodes, maxRetryAfter: Number.POSITIVE_INFINITY, backoffLimit: Number.POSITIVE_INFINITY, delay: o => .3 * 2 ** (o - 1) * 1e3 }, normalizeRetryOptions = (o = {}) => { if (typeof o == "number") return { ...defaultRetryOptions, limit: o }; if (o.methods && !Array.isArray(o.methods)) throw new Error("retry.methods must be an array"); if (o.statusCodes && !Array.isArray(o.statusCodes)) throw new Error("retry.statusCodes must be an array"); return { ...defaultRetryOptions, ...o, afterStatusCodes: retryAfterStatusCodes } }; async function timeout(o, l, u, f) { return new Promise((p, d) => { const m = setTimeout(() => { u && u.abort(), d(new TimeoutError(o)) }, f.timeout); f.fetch(o, l).then(p).catch(d).then(() => { clearTimeout(m) }) }) } async function delay$1(o, { signal: l }) { return new Promise((u, f) => { l && (l.throwIfAborted(), l.addEventListener("abort", p, { once: !0 })); function p() { clearTimeout(d), f(l.reason) } const d = setTimeout(() => { l == null || l.removeEventListener("abort", p), u() }, o) }) } const findUnknownOptions = (o, l) => { const u = {}; for (const f in l) !(f in requestOptionsRegistry) && !(f in kyOptionKeys) && !(f in o) && (u[f] = l[f]); return u }; class Ky { static create(l, u) { const f = new Ky(l, u), p = async () => { if (typeof f._options.timeout == "number" && f._options.timeout > maxSafeTimeout) throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`); await Promise.resolve(); let v = await f._fetch(); for (const I of f._options.hooks.afterResponse) { const F = await I(f.request, f._options, f._decorateResponse(v.clone())); F instanceof globalThis.Response && (v = F) } if (f._decorateResponse(v), !v.ok && f._options.throwHttpErrors) { let I = new HTTPError(v, f.request, f._options); for (const F of f._options.hooks.beforeError) I = await F(I); throw I } if (f._options.onDownloadProgress) { if (typeof f._options.onDownloadProgress != "function") throw new TypeError("The `onDownloadProgress` option must be a function"); if (!supportsResponseStreams) throw new Error("Streams are not supported in your environment. `ReadableStream` is missing."); return f._stream(v.clone(), f._options.onDownloadProgress) } return v }, m = f._options.retry.methods.includes(f.request.method.toLowerCase()) ? f._retry(p) : p(); for (const [v, I] of Object.entries(responseTypes)) m[v] = async () => { f.request.headers.set("accept", f.request.headers.get("accept") || I); const B = (await m).clone(); if (v === "json") { if (B.status === 204 || (await B.clone().arrayBuffer()).byteLength === 0) return ""; if (u.parseJson) return u.parseJson(await B.text()) } return B[v]() }; return m } constructor(l, u = {}) { var p, d; Object.defineProperty(this, "request", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "abortController", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_retryCount", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_input", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_options", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._input = l; const f = this._input instanceof Request && "credentials" in Request.prototype ? this._input.credentials : void 0; if (this._options = { ...f && { credentials: f }, ...u, headers: mergeHeaders(this._input.headers, u.headers), hooks: deepMerge({ beforeRequest: [], beforeRetry: [], beforeError: [], afterResponse: [] }, u.hooks), method: normalizeRequestMethod(u.method ?? this._input.method), prefixUrl: String(u.prefixUrl || ""), retry: normalizeRetryOptions(u.retry), throwHttpErrors: u.throwHttpErrors !== !1, timeout: u.timeout ?? 1e4, fetch: u.fetch ?? globalThis.fetch.bind(globalThis) }, typeof this._input != "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request)) throw new TypeError("`input` must be a string, URL, or Request"); if (this._options.prefixUrl && typeof this._input == "string") { if (this._input.startsWith("/")) throw new Error("`input` must not begin with a slash when using `prefixUrl`"); this._options.prefixUrl.endsWith("/") || (this._options.prefixUrl += "/"), this._input = this._options.prefixUrl + this._input } if (supportsAbortController) { if (this.abortController = new globalThis.AbortController, this._options.signal) { const m = this._options.signal; this._options.signal.addEventListener("abort", () => { this.abortController.abort(m.reason) }) } this._options.signal = this.abortController.signal } if (supportsRequestStreams && (this._options.duplex = "half"), this._options.json !== void 0 && (this._options.body = ((d = (p = this._options).stringifyJson) == null ? void 0 : d.call(p, this._options.json)) ?? JSON.stringify(this._options.json), this._options.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json")), this.request = new globalThis.Request(this._input, this._options), this._options.searchParams) { const v = "?" + (typeof this._options.searchParams == "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString()), I = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, v); (supportsFormData && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"]) && this.request.headers.delete("content-type"), this.request = new globalThis.Request(new globalThis.Request(I, { ...this.request }), this._options) } } _calculateRetryDelay(l) { if (this._retryCount++, this._retryCount <= this._options.retry.limit && !(l instanceof TimeoutError)) { if (l instanceof HTTPError) { if (!this._options.retry.statusCodes.includes(l.response.status)) return 0; const f = l.response.headers.get("Retry-After"); if (f && this._options.retry.afterStatusCodes.includes(l.response.status)) { let p = Number(f) * 1e3; Number.isNaN(p) && (p = Date.parse(f) - Date.now()); const d = this._options.retry.maxRetryAfter ?? p; return p < d ? p : d } if (l.response.status === 413) return 0 } const u = this._options.retry.delay(this._retryCount); return Math.min(this._options.retry.backoffLimit, u) } return 0 } _decorateResponse(l) { return this._options.parseJson && (l.json = async () => this._options.parseJson(await l.text())), l } async _retry(l) { try { return await l() } catch (u) { const f = Math.min(this._calculateRetryDelay(u), maxSafeTimeout); if (f !== 0 && this._retryCount > 0) { await delay$1(f, { signal: this._options.signal }); for (const p of this._options.hooks.beforeRetry) if (await p({ request: this.request, options: this._options, error: u, retryCount: this._retryCount }) === stop) return; return this._retry(l) } throw u } } async _fetch() { for (const f of this._options.hooks.beforeRequest) { const p = await f(this.request, this._options); if (p instanceof Request) { this.request = p; break } if (p instanceof Response) return p } const l = findUnknownOptions(this.request, this._options), u = this.request; return this.request = u.clone(), this._options.timeout === !1 ? this._options.fetch(u, l) : timeout(u, l, this.abortController, this._options) } _stream(l, u) { const f = Number(l.headers.get("content-length")) || 0; let p = 0; return l.status === 204 ? (u && u({ percent: 1, totalBytes: f, transferredBytes: p }, new Uint8Array), new globalThis.Response(null, { status: l.status, statusText: l.statusText, headers: l.headers })) : new globalThis.Response(new globalThis.ReadableStream({ async start(d) { const m = l.body.getReader(); u && u({ percent: 0, transferredBytes: 0, totalBytes: f }, new Uint8Array); async function v() { const { done: I, value: F } = await m.read(); if (I) { d.close(); return } if (u) { p += F.byteLength; const B = f === 0 ? 0 : p / f; u({ percent: B, transferredBytes: p, totalBytes: f }, F) } d.enqueue(F), await v() } await v() } }), { status: l.status, statusText: l.statusText, headers: l.headers }) } }/*! MIT License  Sindre Sorhus */const createInstance = o => { const l = (u, f) => Ky.create(u, validateAndMerge(o, f)); for (const u of requestMethods) l[u] = (f, p) => Ky.create(f, validateAndMerge(o, p, { method: u })); return l.create = u => createInstance(validateAndMerge(u)), l.extend = u => createInstance(validateAndMerge(o, u)), l.stop = stop, l }, ky = createInstance(), isObject$4 = o => typeof o == "object" && o !== null, isObjectCustom = o => isObject$4(o) && !(o instanceof RegExp) && !(o instanceof Error) && !(o instanceof Date), mapObjectSkip = Symbol("mapObjectSkip"), _mapObject = (o, l, u, f = new WeakMap) => { if (u = { deep: !1, target: {}, ...u }, f.has(o)) return f.get(o); f.set(o, u.target); const { target: p } = u; delete u.target; const d = m => m.map(v => isObjectCustom(v) ? _mapObject(v, l, u, f) : v); if (Array.isArray(o)) return d(o); for (const [m, v] of Object.entries(o)) { const I = l(m, v, o); if (I === mapObjectSkip) continue; let [F, B, { shouldRecurse: W = !0 } = {}] = I; F !== "__proto__" && (u.deep && W && isObjectCustom(B) && (B = Array.isArray(B) ? d(B) : _mapObject(B, l, u, f)), p[F] = B) } return p }; function mapObject(o, l, u) { if (!isObject$4(o)) throw new TypeError(`Expected an object, got \`${o}\` (${typeof o})`); return _mapObject(o, l, u) } const UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (o, l, u, f) => { let p = !1, d = !1, m = !1, v = !1; for (let I = 0; I < o.length; I++) { const F = o[I]; v = I > 2 ? o[I - 3] === "-" : !0, p && UPPERCASE.test(F) ? (o = o.slice(0, I) + "-" + o.slice(I), p = !1, m = d, d = !0, I++) : d && m && LOWERCASE.test(F) && (!v || f) ? (o = o.slice(0, I - 1) + "-" + o.slice(I - 1), m = d, d = !1, p = !0) : (p = l(F) === F && u(F) !== F, m = d, d = u(F) === F && l(F) !== F) } return o }, preserveConsecutiveUppercase = (o, l) => (LEADING_CAPITAL.lastIndex = 0, o.replaceAll(LEADING_CAPITAL, u => l(u))), postProcess = (o, l) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, o.replaceAll(NUMBERS_AND_IDENTIFIER, (u, f, p) => ["_", "-"].includes(o.charAt(p + u.length)) ? u : l(u)).replaceAll(SEPARATORS_AND_IDENTIFIER, (u, f) => l(f))); function camelCase$1(o, l) { if (!(typeof o == "string" || Array.isArray(o))) throw new TypeError("Expected the input to be `string | string[]`"); if (l = { pascalCase: !1, preserveConsecutiveUppercase: !1, ...l }, Array.isArray(o) ? o = o.map(d => d.trim()).filter(d => d.length).join("-") : o = o.trim(), o.length === 0) return ""; const u = l.locale === !1 ? d => d.toLowerCase() : d => d.toLocaleLowerCase(l.locale), f = l.locale === !1 ? d => d.toUpperCase() : d => d.toLocaleUpperCase(l.locale); return o.length === 1 ? SEPARATORS.test(o) ? "" : l.pascalCase ? f(o) : u(o) : (o !== u(o) && (o = preserveCamelCase(o, u, f, l.preserveConsecutiveUppercase)), o = o.replace(LEADING_SEPARATORS, ""), o = l.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(o, u) : u(o), l.pascalCase && (o = f(o.charAt(0)) + o.slice(1)), postProcess(o, f)) } class QuickLRU extends Map { constructor(l = {}) { if (super(), !(l.maxSize && l.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0"); if (typeof l.maxAge == "number" && l.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0"); this.maxSize = l.maxSize, this.maxAge = l.maxAge || Number.POSITIVE_INFINITY, this.onEviction = l.onEviction, this.cache = new Map, this.oldCache = new Map, this._size = 0 } _emitEvictions(l) { if (typeof this.onEviction == "function") for (const [u, f] of l) this.onEviction(u, f.value) } _deleteIfExpired(l, u) { return typeof u.expiry == "number" && u.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(l, u.value), this.delete(l)) : !1 } _getOrDeleteIfExpired(l, u) { if (this._deleteIfExpired(l, u) === !1) return u.value } _getItemValue(l, u) { return u.expiry ? this._getOrDeleteIfExpired(l, u) : u.value } _peek(l, u) { const f = u.get(l); return this._getItemValue(l, f) } _set(l, u) { this.cache.set(l, u), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = new Map) } _moveToRecent(l, u) { this.oldCache.delete(l), this._set(l, u) } *_entriesAscending() { for (const l of this.oldCache) { const [u, f] = l; this.cache.has(u) || this._deleteIfExpired(u, f) === !1 && (yield l) } for (const l of this.cache) { const [u, f] = l; this._deleteIfExpired(u, f) === !1 && (yield l) } } get(l) { if (this.cache.has(l)) { const u = this.cache.get(l); return this._getItemValue(l, u) } if (this.oldCache.has(l)) { const u = this.oldCache.get(l); if (this._deleteIfExpired(l, u) === !1) return this._moveToRecent(l, u), u.value } } set(l, u, { maxAge: f = this.maxAge } = {}) { const p = typeof f == "number" && f !== Number.POSITIVE_INFINITY ? Date.now() + f : void 0; return this.cache.has(l) ? this.cache.set(l, { value: u, expiry: p }) : this._set(l, { value: u, expiry: p }), this } has(l) { return this.cache.has(l) ? !this._deleteIfExpired(l, this.cache.get(l)) : this.oldCache.has(l) ? !this._deleteIfExpired(l, this.oldCache.get(l)) : !1 } peek(l) { if (this.cache.has(l)) return this._peek(l, this.cache); if (this.oldCache.has(l)) return this._peek(l, this.oldCache) } delete(l) { const u = this.cache.delete(l); return u && this._size--, this.oldCache.delete(l) || u } clear() { this.cache.clear(), this.oldCache.clear(), this._size = 0 } resize(l) { if (!(l && l > 0)) throw new TypeError("`maxSize` must be a number greater than 0"); const u = [...this._entriesAscending()], f = u.length - l; f < 0 ? (this.cache = new Map(u), this.oldCache = new Map, this._size = u.length) : (f > 0 && this._emitEvictions(u.slice(0, f)), this.oldCache = new Map(u.slice(f)), this.cache = new Map, this._size = 0), this.maxSize = l } *keys() { for (const [l] of this) yield l } *values() { for (const [, l] of this) yield l } *[Symbol.iterator]() { for (const l of this.cache) { const [u, f] = l; this._deleteIfExpired(u, f) === !1 && (yield [u, f.value]) } for (const l of this.oldCache) { const [u, f] = l; this.cache.has(u) || this._deleteIfExpired(u, f) === !1 && (yield [u, f.value]) } } *entriesDescending() { let l = [...this.cache]; for (let u = l.length - 1; u >= 0; --u) { const f = l[u], [p, d] = f; this._deleteIfExpired(p, d) === !1 && (yield [p, d.value]) } l = [...this.oldCache]; for (let u = l.length - 1; u >= 0; --u) { const f = l[u], [p, d] = f; this.cache.has(p) || this._deleteIfExpired(p, d) === !1 && (yield [p, d.value]) } } *entriesAscending() { for (const [l, u] of this._entriesAscending()) yield [l, u.value] } get size() { if (!this._size) return this.oldCache.size; let l = 0; for (const u of this.oldCache.keys()) this.cache.has(u) || l++; return Math.min(this._size + l, this.maxSize) } entries() { return this.entriesAscending() } forEach(l, u = this) { for (const [f, p] of this.entriesAscending()) l.call(u, p, f, this) } get [Symbol.toStringTag]() { return JSON.stringify([...this.entriesAscending()]) } } const has = (o, l) => o.some(u => typeof u == "string" ? u === l : (u.lastIndex = 0, u.test(l))), cache$3 = new QuickLRU({ maxSize: 1e5 }), isObject$3 = o => typeof o == "object" && o !== null && !(o instanceof RegExp) && !(o instanceof Error) && !(o instanceof Date), transform$1 = (o, l = {}) => { if (!isObject$3(o)) return o; const { exclude: u, pascalCase: f = !1, stopPaths: p, deep: d = !1, preserveConsecutiveUppercase: m = !1 } = l, v = new Set(p), I = F => (B, W) => { if (d && isObject$3(W)) { const Z = F === void 0 ? B : `${F}.${B}`; v.has(Z) || (W = mapObject(W, I(Z))) } if (!(u && has(u, B))) { const Z = f ? `${B}_` : B; if (cache$3.has(Z)) B = cache$3.get(Z); else { const Q = camelCase$1(B, { pascalCase: f, locale: !1, preserveConsecutiveUppercase: m }); B.length < 100 && cache$3.set(Z, Q), B = Q } } return [B, W] }; return mapObject(o, I(void 0)) }; function camelcaseKeys(o, l) { return Array.isArray(o) ? Object.keys(o).map(u => transform$1(o[u], l)) : transform$1(o, l) } var buffer$1 = {}, base64Js = {}; base64Js.byteLength = byteLength; base64Js.toByteArray = toByteArray; base64Js.fromByteArray = fromByteArray; var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; for (var i = 0, len = code.length; i < len; ++i)lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i; revLookup[45] = 62; revLookup[95] = 63; function getLens(o) { var l = o.length; if (l % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var u = o.indexOf("="); u === -1 && (u = l); var f = u === l ? 0 : 4 - u % 4; return [u, f] } function byteLength(o) { var l = getLens(o), u = l[0], f = l[1]; return (u + f) * 3 / 4 - f } function _byteLength(o, l, u) { return (l + u) * 3 / 4 - u } function toByteArray(o) { var l, u = getLens(o), f = u[0], p = u[1], d = new Arr(_byteLength(o, f, p)), m = 0, v = p > 0 ? f - 4 : f, I; for (I = 0; I < v; I += 4)l = revLookup[o.charCodeAt(I)] << 18 | revLookup[o.charCodeAt(I + 1)] << 12 | revLookup[o.charCodeAt(I + 2)] << 6 | revLookup[o.charCodeAt(I + 3)], d[m++] = l >> 16 & 255, d[m++] = l >> 8 & 255, d[m++] = l & 255; return p === 2 && (l = revLookup[o.charCodeAt(I)] << 2 | revLookup[o.charCodeAt(I + 1)] >> 4, d[m++] = l & 255), p === 1 && (l = revLookup[o.charCodeAt(I)] << 10 | revLookup[o.charCodeAt(I + 1)] << 4 | revLookup[o.charCodeAt(I + 2)] >> 2, d[m++] = l >> 8 & 255, d[m++] = l & 255), d } function tripletToBase64(o) { return lookup[o >> 18 & 63] + lookup[o >> 12 & 63] + lookup[o >> 6 & 63] + lookup[o & 63] } function encodeChunk(o, l, u) { for (var f, p = [], d = l; d < u; d += 3)f = (o[d] << 16 & 16711680) + (o[d + 1] << 8 & 65280) + (o[d + 2] & 255), p.push(tripletToBase64(f)); return p.join("") } function fromByteArray(o) { for (var l, u = o.length, f = u % 3, p = [], d = 16383, m = 0, v = u - f; m < v; m += d)p.push(encodeChunk(o, m, m + d > v ? v : m + d)); return f === 1 ? (l = o[u - 1], p.push(lookup[l >> 2] + lookup[l << 4 & 63] + "==")) : f === 2 && (l = (o[u - 2] << 8) + o[u - 1], p.push(lookup[l >> 10] + lookup[l >> 4 & 63] + lookup[l << 2 & 63] + "=")), p.join("") } var ieee754 = {};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ieee754.read = function (o, l, u, f, p) { var d, m, v = p * 8 - f - 1, I = (1 << v) - 1, F = I >> 1, B = -7, W = u ? p - 1 : 0, Z = u ? -1 : 1, Q = o[l + W]; for (W += Z, d = Q & (1 << -B) - 1, Q >>= -B, B += v; B > 0; d = d * 256 + o[l + W], W += Z, B -= 8); for (m = d & (1 << -B) - 1, d >>= -B, B += f; B > 0; m = m * 256 + o[l + W], W += Z, B -= 8); if (d === 0) d = 1 - F; else { if (d === I) return m ? NaN : (Q ? -1 : 1) * (1 / 0); m = m + Math.pow(2, f), d = d - F } return (Q ? -1 : 1) * m * Math.pow(2, d - f) }; ieee754.write = function (o, l, u, f, p, d) { var m, v, I, F = d * 8 - p - 1, B = (1 << F) - 1, W = B >> 1, Z = p === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Q = f ? 0 : d - 1, re = f ? 1 : -1, ne = l < 0 || l === 0 && 1 / l < 0 ? 1 : 0; for (l = Math.abs(l), isNaN(l) || l === 1 / 0 ? (v = isNaN(l) ? 1 : 0, m = B) : (m = Math.floor(Math.log(l) / Math.LN2), l * (I = Math.pow(2, -m)) < 1 && (m--, I *= 2), m + W >= 1 ? l += Z / I : l += Z * Math.pow(2, 1 - W), l * I >= 2 && (m++, I /= 2), m + W >= B ? (v = 0, m = B) : m + W >= 1 ? (v = (l * I - 1) * Math.pow(2, p), m = m + W) : (v = l * Math.pow(2, W - 1) * Math.pow(2, p), m = 0)); p >= 8; o[u + Q] = v & 255, Q += re, v /= 256, p -= 8); for (m = m << p | v, F += p; F > 0; o[u + Q] = m & 255, Q += re, m /= 256, F -= 8); o[u + Q - re] |= ne * 128 };/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function (o) { const l = base64Js, u = ieee754, f = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null; o.Buffer = B, o.SlowBuffer = he, o.INSPECT_MAX_BYTES = 50; const p = 2147483647; o.kMaxLength = p; const { Uint8Array: d, ArrayBuffer: m, SharedArrayBuffer: v } = globalThis; B.TYPED_ARRAY_SUPPORT = I(), !B.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."); function I() { try { const ye = new d(1), ge = { foo: function () { return 42 } }; return Object.setPrototypeOf(ge, d.prototype), Object.setPrototypeOf(ye, ge), ye.foo() === 42 } catch { return !1 } } Object.defineProperty(B.prototype, "parent", { enumerable: !0, get: function () { if (B.isBuffer(this)) return this.buffer } }), Object.defineProperty(B.prototype, "offset", { enumerable: !0, get: function () { if (B.isBuffer(this)) return this.byteOffset } }); function F(ye) { if (ye > p) throw new RangeError('The value "' + ye + '" is invalid for option "size"'); const ge = new d(ye); return Object.setPrototypeOf(ge, B.prototype), ge } function B(ye, ge, Ee) { if (typeof ye == "number") { if (typeof ge == "string") throw new TypeError('The "string" argument must be of type string. Received type number'); return re(ye) } return W(ye, ge, Ee) } B.poolSize = 8192; function W(ye, ge, Ee) { if (typeof ye == "string") return ne(ye, ge); if (m.isView(ye)) return ae(ye); if (ye == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ye); if (We(ye, m) || ye && We(ye.buffer, m) || typeof v < "u" && (We(ye, v) || ye && We(ye.buffer, v))) return se(ye, ge, Ee); if (typeof ye == "number") throw new TypeError('The "value" argument must not be of type number. Received type number'); const Oe = ye.valueOf && ye.valueOf(); if (Oe != null && Oe !== ye) return B.from(Oe, ge, Ee); const je = le(ye); if (je) return je; if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ye[Symbol.toPrimitive] == "function") return B.from(ye[Symbol.toPrimitive]("string"), ge, Ee); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ye) } B.from = function (ye, ge, Ee) { return W(ye, ge, Ee) }, Object.setPrototypeOf(B.prototype, d.prototype), Object.setPrototypeOf(B, d); function Z(ye) { if (typeof ye != "number") throw new TypeError('"size" argument must be of type number'); if (ye < 0) throw new RangeError('The value "' + ye + '" is invalid for option "size"') } function Q(ye, ge, Ee) { return Z(ye), ye <= 0 ? F(ye) : ge !== void 0 ? typeof Ee == "string" ? F(ye).fill(ge, Ee) : F(ye).fill(ge) : F(ye) } B.alloc = function (ye, ge, Ee) { return Q(ye, ge, Ee) }; function re(ye) { return Z(ye), F(ye < 0 ? 0 : ue(ye) | 0) } B.allocUnsafe = function (ye) { return re(ye) }, B.allocUnsafeSlow = function (ye) { return re(ye) }; function ne(ye, ge) { if ((typeof ge != "string" || ge === "") && (ge = "utf8"), !B.isEncoding(ge)) throw new TypeError("Unknown encoding: " + ge); const Ee = pe(ye, ge) | 0; let Oe = F(Ee); const je = Oe.write(ye, ge); return je !== Ee && (Oe = Oe.slice(0, je)), Oe } function oe(ye) { const ge = ye.length < 0 ? 0 : ue(ye.length) | 0, Ee = F(ge); for (let Oe = 0; Oe < ge; Oe += 1)Ee[Oe] = ye[Oe] & 255; return Ee } function ae(ye) { if (We(ye, d)) { const ge = new d(ye); return se(ge.buffer, ge.byteOffset, ge.byteLength) } return oe(ye) } function se(ye, ge, Ee) { if (ge < 0 || ye.byteLength < ge) throw new RangeError('"offset" is outside of buffer bounds'); if (ye.byteLength < ge + (Ee || 0)) throw new RangeError('"length" is outside of buffer bounds'); let Oe; return ge === void 0 && Ee === void 0 ? Oe = new d(ye) : Ee === void 0 ? Oe = new d(ye, ge) : Oe = new d(ye, ge, Ee), Object.setPrototypeOf(Oe, B.prototype), Oe } function le(ye) { if (B.isBuffer(ye)) { const ge = ue(ye.length) | 0, Ee = F(ge); return Ee.length === 0 || ye.copy(Ee, 0, 0, ge), Ee } if (ye.length !== void 0) return typeof ye.length != "number" || Ge(ye.length) ? F(0) : oe(ye); if (ye.type === "Buffer" && Array.isArray(ye.data)) return oe(ye.data) } function ue(ye) { if (ye >= p) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + p.toString(16) + " bytes"); return ye | 0 } function he(ye) { return +ye != ye && (ye = 0), B.alloc(+ye) } B.isBuffer = function (ge) { return ge != null && ge._isBuffer === !0 && ge !== B.prototype }, B.compare = function (ge, Ee) { if (We(ge, d) && (ge = B.from(ge, ge.offset, ge.byteLength)), We(Ee, d) && (Ee = B.from(Ee, Ee.offset, Ee.byteLength)), !B.isBuffer(ge) || !B.isBuffer(Ee)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (ge === Ee) return 0; let Oe = ge.length, je = Ee.length; for (let nt = 0, Xe = Math.min(Oe, je); nt < Xe; ++nt)if (ge[nt] !== Ee[nt]) { Oe = ge[nt], je = Ee[nt]; break } return Oe < je ? -1 : je < Oe ? 1 : 0 }, B.isEncoding = function (ge) { switch (String(ge).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, B.concat = function (ge, Ee) { if (!Array.isArray(ge)) throw new TypeError('"list" argument must be an Array of Buffers'); if (ge.length === 0) return B.alloc(0); let Oe; if (Ee === void 0) for (Ee = 0, Oe = 0; Oe < ge.length; ++Oe)Ee += ge[Oe].length; const je = B.allocUnsafe(Ee); let nt = 0; for (Oe = 0; Oe < ge.length; ++Oe) { let Xe = ge[Oe]; if (We(Xe, d)) nt + Xe.length > je.length ? (B.isBuffer(Xe) || (Xe = B.from(Xe)), Xe.copy(je, nt)) : d.prototype.set.call(je, Xe, nt); else if (B.isBuffer(Xe)) Xe.copy(je, nt); else throw new TypeError('"list" argument must be an Array of Buffers'); nt += Xe.length } return je }; function pe(ye, ge) { if (B.isBuffer(ye)) return ye.length; if (m.isView(ye) || We(ye, m)) return ye.byteLength; if (typeof ye != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ye); const Ee = ye.length, Oe = arguments.length > 2 && arguments[2] === !0; if (!Oe && Ee === 0) return 0; let je = !1; for (; ;)switch (ge) { case "ascii": case "latin1": case "binary": return Ee; case "utf8": case "utf-8": return Gt(ye).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return Ee * 2; case "hex": return Ee >>> 1; case "base64": return zt(ye).length; default: if (je) return Oe ? -1 : Gt(ye).length; ge = ("" + ge).toLowerCase(), je = !0 } } B.byteLength = pe; function ve(ye, ge, Ee) { let Oe = !1; if ((ge === void 0 || ge < 0) && (ge = 0), ge > this.length || ((Ee === void 0 || Ee > this.length) && (Ee = this.length), Ee <= 0) || (Ee >>>= 0, ge >>>= 0, Ee <= ge)) return ""; for (ye || (ye = "utf8"); ;)switch (ye) { case "hex": return ce(this, ge, Ee); case "utf8": case "utf-8": return te(this, ge, Ee); case "ascii": return y(this, ge, Ee); case "latin1": case "binary": return X(this, ge, Ee); case "base64": return Y(this, ge, Ee); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return me(this, ge, Ee); default: if (Oe) throw new TypeError("Unknown encoding: " + ye); ye = (ye + "").toLowerCase(), Oe = !0 } } B.prototype._isBuffer = !0; function _e(ye, ge, Ee) { const Oe = ye[ge]; ye[ge] = ye[Ee], ye[Ee] = Oe } B.prototype.swap16 = function () { const ge = this.length; if (ge % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let Ee = 0; Ee < ge; Ee += 2)_e(this, Ee, Ee + 1); return this }, B.prototype.swap32 = function () { const ge = this.length; if (ge % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let Ee = 0; Ee < ge; Ee += 4)_e(this, Ee, Ee + 3), _e(this, Ee + 1, Ee + 2); return this }, B.prototype.swap64 = function () { const ge = this.length; if (ge % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let Ee = 0; Ee < ge; Ee += 8)_e(this, Ee, Ee + 7), _e(this, Ee + 1, Ee + 6), _e(this, Ee + 2, Ee + 5), _e(this, Ee + 3, Ee + 4); return this }, B.prototype.toString = function () { const ge = this.length; return ge === 0 ? "" : arguments.length === 0 ? te(this, 0, ge) : ve.apply(this, arguments) }, B.prototype.toLocaleString = B.prototype.toString, B.prototype.equals = function (ge) { if (!B.isBuffer(ge)) throw new TypeError("Argument must be a Buffer"); return this === ge ? !0 : B.compare(this, ge) === 0 }, B.prototype.inspect = function () { let ge = ""; const Ee = o.INSPECT_MAX_BYTES; return ge = this.toString("hex", 0, Ee).replace(/(.{2})/g, "$1 ").trim(), this.length > Ee && (ge += " ... "), "<Buffer " + ge + ">" }, f && (B.prototype[f] = B.prototype.inspect), B.prototype.compare = function (ge, Ee, Oe, je, nt) { if (We(ge, d) && (ge = B.from(ge, ge.offset, ge.byteLength)), !B.isBuffer(ge)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ge); if (Ee === void 0 && (Ee = 0), Oe === void 0 && (Oe = ge ? ge.length : 0), je === void 0 && (je = 0), nt === void 0 && (nt = this.length), Ee < 0 || Oe > ge.length || je < 0 || nt > this.length) throw new RangeError("out of range index"); if (je >= nt && Ee >= Oe) return 0; if (je >= nt) return -1; if (Ee >= Oe) return 1; if (Ee >>>= 0, Oe >>>= 0, je >>>= 0, nt >>>= 0, this === ge) return 0; let Xe = nt - je, it = Oe - Ee; const Tt = Math.min(Xe, it), tt = this.slice(je, nt), yt = ge.slice(Ee, Oe); for (let kt = 0; kt < Tt; ++kt)if (tt[kt] !== yt[kt]) { Xe = tt[kt], it = yt[kt]; break } return Xe < it ? -1 : it < Xe ? 1 : 0 }; function Se(ye, ge, Ee, Oe, je) { if (ye.length === 0) return -1; if (typeof Ee == "string" ? (Oe = Ee, Ee = 0) : Ee > 2147483647 ? Ee = 2147483647 : Ee < -2147483648 && (Ee = -2147483648), Ee = +Ee, Ge(Ee) && (Ee = je ? 0 : ye.length - 1), Ee < 0 && (Ee = ye.length + Ee), Ee >= ye.length) { if (je) return -1; Ee = ye.length - 1 } else if (Ee < 0) if (je) Ee = 0; else return -1; if (typeof ge == "string" && (ge = B.from(ge, Oe)), B.isBuffer(ge)) return ge.length === 0 ? -1 : $e(ye, ge, Ee, Oe, je); if (typeof ge == "number") return ge = ge & 255, typeof d.prototype.indexOf == "function" ? je ? d.prototype.indexOf.call(ye, ge, Ee) : d.prototype.lastIndexOf.call(ye, ge, Ee) : $e(ye, [ge], Ee, Oe, je); throw new TypeError("val must be string, number or Buffer") } function $e(ye, ge, Ee, Oe, je) { let nt = 1, Xe = ye.length, it = ge.length; if (Oe !== void 0 && (Oe = String(Oe).toLowerCase(), Oe === "ucs2" || Oe === "ucs-2" || Oe === "utf16le" || Oe === "utf-16le")) { if (ye.length < 2 || ge.length < 2) return -1; nt = 2, Xe /= 2, it /= 2, Ee /= 2 } function Tt(yt, kt) { return nt === 1 ? yt[kt] : yt.readUInt16BE(kt * nt) } let tt; if (je) { let yt = -1; for (tt = Ee; tt < Xe; tt++)if (Tt(ye, tt) === Tt(ge, yt === -1 ? 0 : tt - yt)) { if (yt === -1 && (yt = tt), tt - yt + 1 === it) return yt * nt } else yt !== -1 && (tt -= tt - yt), yt = -1 } else for (Ee + it > Xe && (Ee = Xe - it), tt = Ee; tt >= 0; tt--) { let yt = !0; for (let kt = 0; kt < it; kt++)if (Tt(ye, tt + kt) !== Tt(ge, kt)) { yt = !1; break } if (yt) return tt } return -1 } B.prototype.includes = function (ge, Ee, Oe) { return this.indexOf(ge, Ee, Oe) !== -1 }, B.prototype.indexOf = function (ge, Ee, Oe) { return Se(this, ge, Ee, Oe, !0) }, B.prototype.lastIndexOf = function (ge, Ee, Oe) { return Se(this, ge, Ee, Oe, !1) }; function ie(ye, ge, Ee, Oe) { Ee = Number(Ee) || 0; const je = ye.length - Ee; Oe ? (Oe = Number(Oe), Oe > je && (Oe = je)) : Oe = je; const nt = ge.length; Oe > nt / 2 && (Oe = nt / 2); let Xe; for (Xe = 0; Xe < Oe; ++Xe) { const it = parseInt(ge.substr(Xe * 2, 2), 16); if (Ge(it)) return Xe; ye[Ee + Xe] = it } return Xe } function g(ye, ge, Ee, Oe) { return bt(Gt(ge, ye.length - Ee), ye, Ee, Oe) } function P(ye, ge, Ee, Oe) { return bt(pt(ge), ye, Ee, Oe) } function U(ye, ge, Ee, Oe) { return bt(zt(ge), ye, Ee, Oe) } function K(ye, ge, Ee, Oe) { return bt(_t(ge, ye.length - Ee), ye, Ee, Oe) } B.prototype.write = function (ge, Ee, Oe, je) { if (Ee === void 0) je = "utf8", Oe = this.length, Ee = 0; else if (Oe === void 0 && typeof Ee == "string") je = Ee, Oe = this.length, Ee = 0; else if (isFinite(Ee)) Ee = Ee >>> 0, isFinite(Oe) ? (Oe = Oe >>> 0, je === void 0 && (je = "utf8")) : (je = Oe, Oe = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); const nt = this.length - Ee; if ((Oe === void 0 || Oe > nt) && (Oe = nt), ge.length > 0 && (Oe < 0 || Ee < 0) || Ee > this.length) throw new RangeError("Attempt to write outside buffer bounds"); je || (je = "utf8"); let Xe = !1; for (; ;)switch (je) { case "hex": return ie(this, ge, Ee, Oe); case "utf8": case "utf-8": return g(this, ge, Ee, Oe); case "ascii": case "latin1": case "binary": return P(this, ge, Ee, Oe); case "base64": return U(this, ge, Ee, Oe); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return K(this, ge, Ee, Oe); default: if (Xe) throw new TypeError("Unknown encoding: " + je); je = ("" + je).toLowerCase(), Xe = !0 } }, B.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function Y(ye, ge, Ee) { return ge === 0 && Ee === ye.length ? l.fromByteArray(ye) : l.fromByteArray(ye.slice(ge, Ee)) } function te(ye, ge, Ee) { Ee = Math.min(ye.length, Ee); const Oe = []; let je = ge; for (; je < Ee;) { const nt = ye[je]; let Xe = null, it = nt > 239 ? 4 : nt > 223 ? 3 : nt > 191 ? 2 : 1; if (je + it <= Ee) { let Tt, tt, yt, kt; switch (it) { case 1: nt < 128 && (Xe = nt); break; case 2: Tt = ye[je + 1], (Tt & 192) === 128 && (kt = (nt & 31) << 6 | Tt & 63, kt > 127 && (Xe = kt)); break; case 3: Tt = ye[je + 1], tt = ye[je + 2], (Tt & 192) === 128 && (tt & 192) === 128 && (kt = (nt & 15) << 12 | (Tt & 63) << 6 | tt & 63, kt > 2047 && (kt < 55296 || kt > 57343) && (Xe = kt)); break; case 4: Tt = ye[je + 1], tt = ye[je + 2], yt = ye[je + 3], (Tt & 192) === 128 && (tt & 192) === 128 && (yt & 192) === 128 && (kt = (nt & 15) << 18 | (Tt & 63) << 12 | (tt & 63) << 6 | yt & 63, kt > 65535 && kt < 1114112 && (Xe = kt)) } } Xe === null ? (Xe = 65533, it = 1) : Xe > 65535 && (Xe -= 65536, Oe.push(Xe >>> 10 & 1023 | 55296), Xe = 56320 | Xe & 1023), Oe.push(Xe), je += it } return G(Oe) } const ee = 4096; function G(ye) { const ge = ye.length; if (ge <= ee) return String.fromCharCode.apply(String, ye); let Ee = "", Oe = 0; for (; Oe < ge;)Ee += String.fromCharCode.apply(String, ye.slice(Oe, Oe += ee)); return Ee } function y(ye, ge, Ee) { let Oe = ""; Ee = Math.min(ye.length, Ee); for (let je = ge; je < Ee; ++je)Oe += String.fromCharCode(ye[je] & 127); return Oe } function X(ye, ge, Ee) { let Oe = ""; Ee = Math.min(ye.length, Ee); for (let je = ge; je < Ee; ++je)Oe += String.fromCharCode(ye[je]); return Oe } function ce(ye, ge, Ee) { const Oe = ye.length; (!ge || ge < 0) && (ge = 0), (!Ee || Ee < 0 || Ee > Oe) && (Ee = Oe); let je = ""; for (let nt = ge; nt < Ee; ++nt)je += ze[ye[nt]]; return je } function me(ye, ge, Ee) { const Oe = ye.slice(ge, Ee); let je = ""; for (let nt = 0; nt < Oe.length - 1; nt += 2)je += String.fromCharCode(Oe[nt] + Oe[nt + 1] * 256); return je } B.prototype.slice = function (ge, Ee) { const Oe = this.length; ge = ~~ge, Ee = Ee === void 0 ? Oe : ~~Ee, ge < 0 ? (ge += Oe, ge < 0 && (ge = 0)) : ge > Oe && (ge = Oe), Ee < 0 ? (Ee += Oe, Ee < 0 && (Ee = 0)) : Ee > Oe && (Ee = Oe), Ee < ge && (Ee = ge); const je = this.subarray(ge, Ee); return Object.setPrototypeOf(je, B.prototype), je }; function Ae(ye, ge, Ee) { if (ye % 1 !== 0 || ye < 0) throw new RangeError("offset is not uint"); if (ye + ge > Ee) throw new RangeError("Trying to access beyond buffer length") } B.prototype.readUintLE = B.prototype.readUIntLE = function (ge, Ee, Oe) { ge = ge >>> 0, Ee = Ee >>> 0, Oe || Ae(ge, Ee, this.length); let je = this[ge], nt = 1, Xe = 0; for (; ++Xe < Ee && (nt *= 256);)je += this[ge + Xe] * nt; return je }, B.prototype.readUintBE = B.prototype.readUIntBE = function (ge, Ee, Oe) { ge = ge >>> 0, Ee = Ee >>> 0, Oe || Ae(ge, Ee, this.length); let je = this[ge + --Ee], nt = 1; for (; Ee > 0 && (nt *= 256);)je += this[ge + --Ee] * nt; return je }, B.prototype.readUint8 = B.prototype.readUInt8 = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 1, this.length), this[ge] }, B.prototype.readUint16LE = B.prototype.readUInt16LE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 2, this.length), this[ge] | this[ge + 1] << 8 }, B.prototype.readUint16BE = B.prototype.readUInt16BE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 2, this.length), this[ge] << 8 | this[ge + 1] }, B.prototype.readUint32LE = B.prototype.readUInt32LE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 4, this.length), (this[ge] | this[ge + 1] << 8 | this[ge + 2] << 16) + this[ge + 3] * 16777216 }, B.prototype.readUint32BE = B.prototype.readUInt32BE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 4, this.length), this[ge] * 16777216 + (this[ge + 1] << 16 | this[ge + 2] << 8 | this[ge + 3]) }, B.prototype.readBigUInt64LE = Ze(function (ge) { ge = ge >>> 0, ht(ge, "offset"); const Ee = this[ge], Oe = this[ge + 7]; (Ee === void 0 || Oe === void 0) && Bt(ge, this.length - 8); const je = Ee + this[++ge] * 2 ** 8 + this[++ge] * 2 ** 16 + this[++ge] * 2 ** 24, nt = this[++ge] + this[++ge] * 2 ** 8 + this[++ge] * 2 ** 16 + Oe * 2 ** 24; return BigInt(je) + (BigInt(nt) << BigInt(32)) }), B.prototype.readBigUInt64BE = Ze(function (ge) { ge = ge >>> 0, ht(ge, "offset"); const Ee = this[ge], Oe = this[ge + 7]; (Ee === void 0 || Oe === void 0) && Bt(ge, this.length - 8); const je = Ee * 2 ** 24 + this[++ge] * 2 ** 16 + this[++ge] * 2 ** 8 + this[++ge], nt = this[++ge] * 2 ** 24 + this[++ge] * 2 ** 16 + this[++ge] * 2 ** 8 + Oe; return (BigInt(je) << BigInt(32)) + BigInt(nt) }), B.prototype.readIntLE = function (ge, Ee, Oe) { ge = ge >>> 0, Ee = Ee >>> 0, Oe || Ae(ge, Ee, this.length); let je = this[ge], nt = 1, Xe = 0; for (; ++Xe < Ee && (nt *= 256);)je += this[ge + Xe] * nt; return nt *= 128, je >= nt && (je -= Math.pow(2, 8 * Ee)), je }, B.prototype.readIntBE = function (ge, Ee, Oe) { ge = ge >>> 0, Ee = Ee >>> 0, Oe || Ae(ge, Ee, this.length); let je = Ee, nt = 1, Xe = this[ge + --je]; for (; je > 0 && (nt *= 256);)Xe += this[ge + --je] * nt; return nt *= 128, Xe >= nt && (Xe -= Math.pow(2, 8 * Ee)), Xe }, B.prototype.readInt8 = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 1, this.length), this[ge] & 128 ? (255 - this[ge] + 1) * -1 : this[ge] }, B.prototype.readInt16LE = function (ge, Ee) { ge = ge >>> 0, Ee || Ae(ge, 2, this.length); const Oe = this[ge] | this[ge + 1] << 8; return Oe & 32768 ? Oe | 4294901760 : Oe }, B.prototype.readInt16BE = function (ge, Ee) { ge = ge >>> 0, Ee || Ae(ge, 2, this.length); const Oe = this[ge + 1] | this[ge] << 8; return Oe & 32768 ? Oe | 4294901760 : Oe }, B.prototype.readInt32LE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 4, this.length), this[ge] | this[ge + 1] << 8 | this[ge + 2] << 16 | this[ge + 3] << 24 }, B.prototype.readInt32BE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 4, this.length), this[ge] << 24 | this[ge + 1] << 16 | this[ge + 2] << 8 | this[ge + 3] }, B.prototype.readBigInt64LE = Ze(function (ge) { ge = ge >>> 0, ht(ge, "offset"); const Ee = this[ge], Oe = this[ge + 7]; (Ee === void 0 || Oe === void 0) && Bt(ge, this.length - 8); const je = this[ge + 4] + this[ge + 5] * 2 ** 8 + this[ge + 6] * 2 ** 16 + (Oe << 24); return (BigInt(je) << BigInt(32)) + BigInt(Ee + this[++ge] * 2 ** 8 + this[++ge] * 2 ** 16 + this[++ge] * 2 ** 24) }), B.prototype.readBigInt64BE = Ze(function (ge) { ge = ge >>> 0, ht(ge, "offset"); const Ee = this[ge], Oe = this[ge + 7]; (Ee === void 0 || Oe === void 0) && Bt(ge, this.length - 8); const je = (Ee << 24) + this[++ge] * 2 ** 16 + this[++ge] * 2 ** 8 + this[++ge]; return (BigInt(je) << BigInt(32)) + BigInt(this[++ge] * 2 ** 24 + this[++ge] * 2 ** 16 + this[++ge] * 2 ** 8 + Oe) }), B.prototype.readFloatLE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 4, this.length), u.read(this, ge, !0, 23, 4) }, B.prototype.readFloatBE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 4, this.length), u.read(this, ge, !1, 23, 4) }, B.prototype.readDoubleLE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 8, this.length), u.read(this, ge, !0, 52, 8) }, B.prototype.readDoubleBE = function (ge, Ee) { return ge = ge >>> 0, Ee || Ae(ge, 8, this.length), u.read(this, ge, !1, 52, 8) }; function Ie(ye, ge, Ee, Oe, je, nt) { if (!B.isBuffer(ye)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (ge > je || ge < nt) throw new RangeError('"value" argument is out of bounds'); if (Ee + Oe > ye.length) throw new RangeError("Index out of range") } B.prototype.writeUintLE = B.prototype.writeUIntLE = function (ge, Ee, Oe, je) { if (ge = +ge, Ee = Ee >>> 0, Oe = Oe >>> 0, !je) { const it = Math.pow(2, 8 * Oe) - 1; Ie(this, ge, Ee, Oe, it, 0) } let nt = 1, Xe = 0; for (this[Ee] = ge & 255; ++Xe < Oe && (nt *= 256);)this[Ee + Xe] = ge / nt & 255; return Ee + Oe }, B.prototype.writeUintBE = B.prototype.writeUIntBE = function (ge, Ee, Oe, je) { if (ge = +ge, Ee = Ee >>> 0, Oe = Oe >>> 0, !je) { const it = Math.pow(2, 8 * Oe) - 1; Ie(this, ge, Ee, Oe, it, 0) } let nt = Oe - 1, Xe = 1; for (this[Ee + nt] = ge & 255; --nt >= 0 && (Xe *= 256);)this[Ee + nt] = ge / Xe & 255; return Ee + Oe }, B.prototype.writeUint8 = B.prototype.writeUInt8 = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 1, 255, 0), this[Ee] = ge & 255, Ee + 1 }, B.prototype.writeUint16LE = B.prototype.writeUInt16LE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 2, 65535, 0), this[Ee] = ge & 255, this[Ee + 1] = ge >>> 8, Ee + 2 }, B.prototype.writeUint16BE = B.prototype.writeUInt16BE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 2, 65535, 0), this[Ee] = ge >>> 8, this[Ee + 1] = ge & 255, Ee + 2 }, B.prototype.writeUint32LE = B.prototype.writeUInt32LE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 4, 4294967295, 0), this[Ee + 3] = ge >>> 24, this[Ee + 2] = ge >>> 16, this[Ee + 1] = ge >>> 8, this[Ee] = ge & 255, Ee + 4 }, B.prototype.writeUint32BE = B.prototype.writeUInt32BE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 4, 4294967295, 0), this[Ee] = ge >>> 24, this[Ee + 1] = ge >>> 16, this[Ee + 2] = ge >>> 8, this[Ee + 3] = ge & 255, Ee + 4 }; function Be(ye, ge, Ee, Oe, je) { lt(ge, Oe, je, ye, Ee, 7); let nt = Number(ge & BigInt(4294967295)); ye[Ee++] = nt, nt = nt >> 8, ye[Ee++] = nt, nt = nt >> 8, ye[Ee++] = nt, nt = nt >> 8, ye[Ee++] = nt; let Xe = Number(ge >> BigInt(32) & BigInt(4294967295)); return ye[Ee++] = Xe, Xe = Xe >> 8, ye[Ee++] = Xe, Xe = Xe >> 8, ye[Ee++] = Xe, Xe = Xe >> 8, ye[Ee++] = Xe, Ee } function Me(ye, ge, Ee, Oe, je) { lt(ge, Oe, je, ye, Ee, 7); let nt = Number(ge & BigInt(4294967295)); ye[Ee + 7] = nt, nt = nt >> 8, ye[Ee + 6] = nt, nt = nt >> 8, ye[Ee + 5] = nt, nt = nt >> 8, ye[Ee + 4] = nt; let Xe = Number(ge >> BigInt(32) & BigInt(4294967295)); return ye[Ee + 3] = Xe, Xe = Xe >> 8, ye[Ee + 2] = Xe, Xe = Xe >> 8, ye[Ee + 1] = Xe, Xe = Xe >> 8, ye[Ee] = Xe, Ee + 8 } B.prototype.writeBigUInt64LE = Ze(function (ge, Ee = 0) { return Be(this, ge, Ee, BigInt(0), BigInt("0xffffffffffffffff")) }), B.prototype.writeBigUInt64BE = Ze(function (ge, Ee = 0) { return Me(this, ge, Ee, BigInt(0), BigInt("0xffffffffffffffff")) }), B.prototype.writeIntLE = function (ge, Ee, Oe, je) { if (ge = +ge, Ee = Ee >>> 0, !je) { const Tt = Math.pow(2, 8 * Oe - 1); Ie(this, ge, Ee, Oe, Tt - 1, -Tt) } let nt = 0, Xe = 1, it = 0; for (this[Ee] = ge & 255; ++nt < Oe && (Xe *= 256);)ge < 0 && it === 0 && this[Ee + nt - 1] !== 0 && (it = 1), this[Ee + nt] = (ge / Xe >> 0) - it & 255; return Ee + Oe }, B.prototype.writeIntBE = function (ge, Ee, Oe, je) { if (ge = +ge, Ee = Ee >>> 0, !je) { const Tt = Math.pow(2, 8 * Oe - 1); Ie(this, ge, Ee, Oe, Tt - 1, -Tt) } let nt = Oe - 1, Xe = 1, it = 0; for (this[Ee + nt] = ge & 255; --nt >= 0 && (Xe *= 256);)ge < 0 && it === 0 && this[Ee + nt + 1] !== 0 && (it = 1), this[Ee + nt] = (ge / Xe >> 0) - it & 255; return Ee + Oe }, B.prototype.writeInt8 = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 1, 127, -128), ge < 0 && (ge = 255 + ge + 1), this[Ee] = ge & 255, Ee + 1 }, B.prototype.writeInt16LE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 2, 32767, -32768), this[Ee] = ge & 255, this[Ee + 1] = ge >>> 8, Ee + 2 }, B.prototype.writeInt16BE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 2, 32767, -32768), this[Ee] = ge >>> 8, this[Ee + 1] = ge & 255, Ee + 2 }, B.prototype.writeInt32LE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 4, 2147483647, -2147483648), this[Ee] = ge & 255, this[Ee + 1] = ge >>> 8, this[Ee + 2] = ge >>> 16, this[Ee + 3] = ge >>> 24, Ee + 4 }, B.prototype.writeInt32BE = function (ge, Ee, Oe) { return ge = +ge, Ee = Ee >>> 0, Oe || Ie(this, ge, Ee, 4, 2147483647, -2147483648), ge < 0 && (ge = 4294967295 + ge + 1), this[Ee] = ge >>> 24, this[Ee + 1] = ge >>> 16, this[Ee + 2] = ge >>> 8, this[Ee + 3] = ge & 255, Ee + 4 }, B.prototype.writeBigInt64LE = Ze(function (ge, Ee = 0) { return Be(this, ge, Ee, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }), B.prototype.writeBigInt64BE = Ze(function (ge, Ee = 0) { return Me(this, ge, Ee, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }); function De(ye, ge, Ee, Oe, je, nt) { if (Ee + Oe > ye.length) throw new RangeError("Index out of range"); if (Ee < 0) throw new RangeError("Index out of range") } function Ue(ye, ge, Ee, Oe, je) { return ge = +ge, Ee = Ee >>> 0, je || De(ye, ge, Ee, 4), u.write(ye, ge, Ee, Oe, 23, 4), Ee + 4 } B.prototype.writeFloatLE = function (ge, Ee, Oe) { return Ue(this, ge, Ee, !0, Oe) }, B.prototype.writeFloatBE = function (ge, Ee, Oe) { return Ue(this, ge, Ee, !1, Oe) }; function Ke(ye, ge, Ee, Oe, je) { return ge = +ge, Ee = Ee >>> 0, je || De(ye, ge, Ee, 8), u.write(ye, ge, Ee, Oe, 52, 8), Ee + 8 } B.prototype.writeDoubleLE = function (ge, Ee, Oe) { return Ke(this, ge, Ee, !0, Oe) }, B.prototype.writeDoubleBE = function (ge, Ee, Oe) { return Ke(this, ge, Ee, !1, Oe) }, B.prototype.copy = function (ge, Ee, Oe, je) { if (!B.isBuffer(ge)) throw new TypeError("argument should be a Buffer"); if (Oe || (Oe = 0), !je && je !== 0 && (je = this.length), Ee >= ge.length && (Ee = ge.length), Ee || (Ee = 0), je > 0 && je < Oe && (je = Oe), je === Oe || ge.length === 0 || this.length === 0) return 0; if (Ee < 0) throw new RangeError("targetStart out of bounds"); if (Oe < 0 || Oe >= this.length) throw new RangeError("Index out of range"); if (je < 0) throw new RangeError("sourceEnd out of bounds"); je > this.length && (je = this.length), ge.length - Ee < je - Oe && (je = ge.length - Ee + Oe); const nt = je - Oe; return this === ge && typeof d.prototype.copyWithin == "function" ? this.copyWithin(Ee, Oe, je) : d.prototype.set.call(ge, this.subarray(Oe, je), Ee), nt }, B.prototype.fill = function (ge, Ee, Oe, je) { if (typeof ge == "string") { if (typeof Ee == "string" ? (je = Ee, Ee = 0, Oe = this.length) : typeof Oe == "string" && (je = Oe, Oe = this.length), je !== void 0 && typeof je != "string") throw new TypeError("encoding must be a string"); if (typeof je == "string" && !B.isEncoding(je)) throw new TypeError("Unknown encoding: " + je); if (ge.length === 1) { const Xe = ge.charCodeAt(0); (je === "utf8" && Xe < 128 || je === "latin1") && (ge = Xe) } } else typeof ge == "number" ? ge = ge & 255 : typeof ge == "boolean" && (ge = Number(ge)); if (Ee < 0 || this.length < Ee || this.length < Oe) throw new RangeError("Out of range index"); if (Oe <= Ee) return this; Ee = Ee >>> 0, Oe = Oe === void 0 ? this.length : Oe >>> 0, ge || (ge = 0); let nt; if (typeof ge == "number") for (nt = Ee; nt < Oe; ++nt)this[nt] = ge; else { const Xe = B.isBuffer(ge) ? ge : B.from(ge, je), it = Xe.length; if (it === 0) throw new TypeError('The value "' + ge + '" is invalid for argument "value"'); for (nt = 0; nt < Oe - Ee; ++nt)this[nt + Ee] = Xe[nt % it] } return this }; const Ve = {}; function ke(ye, ge, Ee) { Ve[ye] = class extends Ee { constructor() { super(), Object.defineProperty(this, "message", { value: ge.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${ye}]`, this.stack, delete this.name } get code() { return ye } set code(je) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: je, writable: !0 }) } toString() { return `${this.name} [${ye}]: ${this.message}` } } } ke("ERR_BUFFER_OUT_OF_BOUNDS", function (ye) { return ye ? `${ye} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }, RangeError), ke("ERR_INVALID_ARG_TYPE", function (ye, ge) { return `The "${ye}" argument must be of type number. Received type ${typeof ge}` }, TypeError), ke("ERR_OUT_OF_RANGE", function (ye, ge, Ee) { let Oe = `The value of "${ye}" is out of range.`, je = Ee; return Number.isInteger(Ee) && Math.abs(Ee) > 2 ** 32 ? je = Je(String(Ee)) : typeof Ee == "bigint" && (je = String(Ee), (Ee > BigInt(2) ** BigInt(32) || Ee < -(BigInt(2) ** BigInt(32))) && (je = Je(je)), je += "n"), Oe += ` It must be ${ge}. Received ${je}`, Oe }, RangeError); function Je(ye) { let ge = "", Ee = ye.length; const Oe = ye[0] === "-" ? 1 : 0; for (; Ee >= Oe + 4; Ee -= 3)ge = `_${ye.slice(Ee - 3, Ee)}${ge}`; return `${ye.slice(0, Ee)}${ge}` } function dt(ye, ge, Ee) { ht(ge, "offset"), (ye[ge] === void 0 || ye[ge + Ee] === void 0) && Bt(ge, ye.length - (Ee + 1)) } function lt(ye, ge, Ee, Oe, je, nt) { if (ye > Ee || ye < ge) { const Xe = typeof ge == "bigint" ? "n" : ""; let it; throw ge === 0 || ge === BigInt(0) ? it = `>= 0${Xe} and < 2${Xe} ** ${(nt + 1) * 8}${Xe}` : it = `>= -(2${Xe} ** ${(nt + 1) * 8 - 1}${Xe}) and < 2 ** ${(nt + 1) * 8 - 1}${Xe}`, new Ve.ERR_OUT_OF_RANGE("value", it, ye) } dt(Oe, je, nt) } function ht(ye, ge) { if (typeof ye != "number") throw new Ve.ERR_INVALID_ARG_TYPE(ge, "number", ye) } function Bt(ye, ge, Ee) { throw Math.floor(ye) !== ye ? (ht(ye, Ee), new Ve.ERR_OUT_OF_RANGE("offset", "an integer", ye)) : ge < 0 ? new Ve.ERR_BUFFER_OUT_OF_BOUNDS : new Ve.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${ge}`, ye) } const mt = /[^+/0-9A-Za-z-_]/g; function et(ye) { if (ye = ye.split("=")[0], ye = ye.trim().replace(mt, ""), ye.length < 2) return ""; for (; ye.length % 4 !== 0;)ye = ye + "="; return ye } function Gt(ye, ge) { ge = ge || 1 / 0; let Ee; const Oe = ye.length; let je = null; const nt = []; for (let Xe = 0; Xe < Oe; ++Xe) { if (Ee = ye.charCodeAt(Xe), Ee > 55295 && Ee < 57344) { if (!je) { if (Ee > 56319) { (ge -= 3) > -1 && nt.push(239, 191, 189); continue } else if (Xe + 1 === Oe) { (ge -= 3) > -1 && nt.push(239, 191, 189); continue } je = Ee; continue } if (Ee < 56320) { (ge -= 3) > -1 && nt.push(239, 191, 189), je = Ee; continue } Ee = (je - 55296 << 10 | Ee - 56320) + 65536 } else je && (ge -= 3) > -1 && nt.push(239, 191, 189); if (je = null, Ee < 128) { if ((ge -= 1) < 0) break; nt.push(Ee) } else if (Ee < 2048) { if ((ge -= 2) < 0) break; nt.push(Ee >> 6 | 192, Ee & 63 | 128) } else if (Ee < 65536) { if ((ge -= 3) < 0) break; nt.push(Ee >> 12 | 224, Ee >> 6 & 63 | 128, Ee & 63 | 128) } else if (Ee < 1114112) { if ((ge -= 4) < 0) break; nt.push(Ee >> 18 | 240, Ee >> 12 & 63 | 128, Ee >> 6 & 63 | 128, Ee & 63 | 128) } else throw new Error("Invalid code point") } return nt } function pt(ye) { const ge = []; for (let Ee = 0; Ee < ye.length; ++Ee)ge.push(ye.charCodeAt(Ee) & 255); return ge } function _t(ye, ge) { let Ee, Oe, je; const nt = []; for (let Xe = 0; Xe < ye.length && !((ge -= 2) < 0); ++Xe)Ee = ye.charCodeAt(Xe), Oe = Ee >> 8, je = Ee % 256, nt.push(je), nt.push(Oe); return nt } function zt(ye) { return l.toByteArray(et(ye)) } function bt(ye, ge, Ee, Oe) { let je; for (je = 0; je < Oe && !(je + Ee >= ge.length || je >= ye.length); ++je)ge[je + Ee] = ye[je]; return je } function We(ye, ge) { return ye instanceof ge || ye != null && ye.constructor != null && ye.constructor.name != null && ye.constructor.name === ge.name } function Ge(ye) { return ye !== ye } const ze = function () { const ye = "0123456789abcdef", ge = new Array(256); for (let Ee = 0; Ee < 16; ++Ee) { const Oe = Ee * 16; for (let je = 0; je < 16; ++je)ge[Oe + je] = ye[Ee] + ye[je] } return ge }(); function Ze(ye) { return typeof BigInt > "u" ? ut : ye } function ut() { throw new Error("BigInt not supported") } })(buffer$1); const Buffer = buffer$1.Buffer; var mapObj = { exports: {} }, hasRequiredMapObj; function requireMapObj() { if (hasRequiredMapObj) return mapObj.exports; hasRequiredMapObj = 1; const o = p => typeof p == "object" && p !== null, l = Symbol("skip"), u = p => o(p) && !(p instanceof RegExp) && !(p instanceof Error) && !(p instanceof Date), f = (p, d, m, v = new WeakMap) => { if (m = { deep: !1, target: {}, ...m }, v.has(p)) return v.get(p); v.set(p, m.target); const { target: I } = m; delete m.target; const F = B => B.map(W => u(W) ? f(W, d, m, v) : W); if (Array.isArray(p)) return F(p); for (const [B, W] of Object.entries(p)) { const Z = d(B, W, p); if (Z === l) continue; let [Q, re, { shouldRecurse: ne = !0 } = {}] = Z; Q !== "__proto__" && (m.deep && ne && u(re) && (re = Array.isArray(re) ? F(re) : f(re, d, m, v)), I[Q] = re) } return I }; return mapObj.exports = (p, d, m) => { if (!o(p)) throw new TypeError(`Expected an object, got \`${p}\` (${typeof p})`); return f(p, d, m) }, mapObj.exports.mapObjectSkip = l, mapObj.exports } var __assign$3 = function () { return __assign$3 = Object.assign || function (l) { for (var u, f = 1, p = arguments.length; f < p; f++) { u = arguments[f]; for (var d in u) Object.prototype.hasOwnProperty.call(u, d) && (l[d] = u[d]) } return l }, __assign$3.apply(this, arguments) }; typeof SuppressedError == "function" && SuppressedError; function lowerCase(o) { return o.toLowerCase() } var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g], DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi; function noCase(o, l) { l === void 0 && (l = {}); for (var u = l.splitRegexp, f = u === void 0 ? DEFAULT_SPLIT_REGEXP : u, p = l.stripRegexp, d = p === void 0 ? DEFAULT_STRIP_REGEXP : p, m = l.transform, v = m === void 0 ? lowerCase : m, I = l.delimiter, F = I === void 0 ? " " : I, B = replace(replace(o, f, "$1\0$2"), d, "\0"), W = 0, Z = B.length; B.charAt(W) === "\0";)W++; for (; B.charAt(Z - 1) === "\0";)Z--; return B.slice(W, Z).split("\0").map(v).join(F) } function replace(o, l, u) { return l instanceof RegExp ? o.replace(l, u) : l.reduce(function (f, p) { return f.replace(p, u) }, o) } function dotCase(o, l) { return l === void 0 && (l = {}), noCase(o, __assign$3({ delimiter: "." }, l)) } function snakeCase(o, l) { return l === void 0 && (l = {}), dotCase(o, __assign$3({ delimiter: "_" }, l)) } const dist_es2015 = Object.freeze(Object.defineProperty({ __proto__: null, snakeCase }, Symbol.toStringTag, { value: "Module" })), require$$1$2 = getAugmentedNamespace(dist_es2015); var snakecaseKeys, hasRequiredSnakecaseKeys; function requireSnakecaseKeys() { if (hasRequiredSnakecaseKeys) return snakecaseKeys; hasRequiredSnakecaseKeys = 1; const o = requireMapObj(), { snakeCase: l } = require$$1$2, u = {}.constructor; snakecaseKeys = function (d, m) { if (Array.isArray(d)) { if (d.some(v => v.constructor !== u)) throw new Error("obj must be array of plain objects") } else if (d.constructor !== u) throw new Error("obj must be an plain object"); return m = Object.assign({ deep: !0, exclude: [], parsingOptions: {} }, m), o(d, function (v, I) { return [f(m.exclude, v) ? v : l(v, m.parsingOptions), I, p(v, I, m)] }, m) }; function f(d, m) { return d.some(function (v) { return typeof v == "string" ? v === m : v.test(m) }) } function p(d, m, v) { return v.shouldRecurse ? { shouldRecurse: v.shouldRecurse(d, m) } : void 0 } return snakecaseKeys } var snakecaseKeysExports = requireSnakecaseKeys(); const snakeKeys = getDefaultExportFromCjs$1(snakecaseKeysExports);/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */const Z_FIXED$1 = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN$1 = 2; function zero$1(o) { let l = o.length; for (; --l >= 0;)o[l] = 0 } const STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH$1 = 3, MAX_MATCH$1 = 258, LENGTH_CODES$1 = 29, LITERALS$1 = 256, L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1, D_CODES$1 = 30, BL_CODES$1 = 19, HEAP_SIZE$1 = 2 * L_CODES$1 + 1, MAX_BITS$1 = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES$1 + 2) * 2); zero$1(static_ltree); const static_dtree = new Array(D_CODES$1 * 2); zero$1(static_dtree); const _dist_code = new Array(DIST_CODE_LEN); zero$1(_dist_code); const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1); zero$1(_length_code); const base_length = new Array(LENGTH_CODES$1); zero$1(base_length); const base_dist = new Array(D_CODES$1); zero$1(base_dist); function StaticTreeDesc(o, l, u, f, p) { this.static_tree = o, this.extra_bits = l, this.extra_base = u, this.elems = f, this.max_length = p, this.has_stree = o && o.length } let static_l_desc, static_d_desc, static_bl_desc; function TreeDesc(o, l) { this.dyn_tree = o, this.max_code = 0, this.stat_desc = l } const d_code = o => o < 256 ? _dist_code[o] : _dist_code[256 + (o >>> 7)], put_short = (o, l) => { o.pending_buf[o.pending++] = l & 255, o.pending_buf[o.pending++] = l >>> 8 & 255 }, send_bits = (o, l, u) => { o.bi_valid > Buf_size - u ? (o.bi_buf |= l << o.bi_valid & 65535, put_short(o, o.bi_buf), o.bi_buf = l >> Buf_size - o.bi_valid, o.bi_valid += u - Buf_size) : (o.bi_buf |= l << o.bi_valid & 65535, o.bi_valid += u) }, send_code = (o, l, u) => { send_bits(o, u[l * 2], u[l * 2 + 1]) }, bi_reverse = (o, l) => { let u = 0; do u |= o & 1, o >>>= 1, u <<= 1; while (--l > 0); return u >>> 1 }, bi_flush = o => { o.bi_valid === 16 ? (put_short(o, o.bi_buf), o.bi_buf = 0, o.bi_valid = 0) : o.bi_valid >= 8 && (o.pending_buf[o.pending++] = o.bi_buf & 255, o.bi_buf >>= 8, o.bi_valid -= 8) }, gen_bitlen = (o, l) => { const u = l.dyn_tree, f = l.max_code, p = l.stat_desc.static_tree, d = l.stat_desc.has_stree, m = l.stat_desc.extra_bits, v = l.stat_desc.extra_base, I = l.stat_desc.max_length; let F, B, W, Z, Q, re, ne = 0; for (Z = 0; Z <= MAX_BITS$1; Z++)o.bl_count[Z] = 0; for (u[o.heap[o.heap_max] * 2 + 1] = 0, F = o.heap_max + 1; F < HEAP_SIZE$1; F++)B = o.heap[F], Z = u[u[B * 2 + 1] * 2 + 1] + 1, Z > I && (Z = I, ne++), u[B * 2 + 1] = Z, !(B > f) && (o.bl_count[Z]++, Q = 0, B >= v && (Q = m[B - v]), re = u[B * 2], o.opt_len += re * (Z + Q), d && (o.static_len += re * (p[B * 2 + 1] + Q))); if (ne !== 0) { do { for (Z = I - 1; o.bl_count[Z] === 0;)Z--; o.bl_count[Z]--, o.bl_count[Z + 1] += 2, o.bl_count[I]--, ne -= 2 } while (ne > 0); for (Z = I; Z !== 0; Z--)for (B = o.bl_count[Z]; B !== 0;)W = o.heap[--F], !(W > f) && (u[W * 2 + 1] !== Z && (o.opt_len += (Z - u[W * 2 + 1]) * u[W * 2], u[W * 2 + 1] = Z), B--) } }, gen_codes = (o, l, u) => { const f = new Array(MAX_BITS$1 + 1); let p = 0, d, m; for (d = 1; d <= MAX_BITS$1; d++)p = p + u[d - 1] << 1, f[d] = p; for (m = 0; m <= l; m++) { let v = o[m * 2 + 1]; v !== 0 && (o[m * 2] = bi_reverse(f[v]++, v)) } }, tr_static_init = () => { let o, l, u, f, p; const d = new Array(MAX_BITS$1 + 1); for (u = 0, f = 0; f < LENGTH_CODES$1 - 1; f++)for (base_length[f] = u, o = 0; o < 1 << extra_lbits[f]; o++)_length_code[u++] = f; for (_length_code[u - 1] = f, p = 0, f = 0; f < 16; f++)for (base_dist[f] = p, o = 0; o < 1 << extra_dbits[f]; o++)_dist_code[p++] = f; for (p >>= 7; f < D_CODES$1; f++)for (base_dist[f] = p << 7, o = 0; o < 1 << extra_dbits[f] - 7; o++)_dist_code[256 + p++] = f; for (l = 0; l <= MAX_BITS$1; l++)d[l] = 0; for (o = 0; o <= 143;)static_ltree[o * 2 + 1] = 8, o++, d[8]++; for (; o <= 255;)static_ltree[o * 2 + 1] = 9, o++, d[9]++; for (; o <= 279;)static_ltree[o * 2 + 1] = 7, o++, d[7]++; for (; o <= 287;)static_ltree[o * 2 + 1] = 8, o++, d[8]++; for (gen_codes(static_ltree, L_CODES$1 + 1, d), o = 0; o < D_CODES$1; o++)static_dtree[o * 2 + 1] = 5, static_dtree[o * 2] = bi_reverse(o, 5); static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS) }, init_block = o => { let l; for (l = 0; l < L_CODES$1; l++)o.dyn_ltree[l * 2] = 0; for (l = 0; l < D_CODES$1; l++)o.dyn_dtree[l * 2] = 0; for (l = 0; l < BL_CODES$1; l++)o.bl_tree[l * 2] = 0; o.dyn_ltree[END_BLOCK * 2] = 1, o.opt_len = o.static_len = 0, o.sym_next = o.matches = 0 }, bi_windup = o => { o.bi_valid > 8 ? put_short(o, o.bi_buf) : o.bi_valid > 0 && (o.pending_buf[o.pending++] = o.bi_buf), o.bi_buf = 0, o.bi_valid = 0 }, smaller = (o, l, u, f) => { const p = l * 2, d = u * 2; return o[p] < o[d] || o[p] === o[d] && f[l] <= f[u] }, pqdownheap = (o, l, u) => { const f = o.heap[u]; let p = u << 1; for (; p <= o.heap_len && (p < o.heap_len && smaller(l, o.heap[p + 1], o.heap[p], o.depth) && p++, !smaller(l, f, o.heap[p], o.depth));)o.heap[u] = o.heap[p], u = p, p <<= 1; o.heap[u] = f }, compress_block = (o, l, u) => { let f, p, d = 0, m, v; if (o.sym_next !== 0) do f = o.pending_buf[o.sym_buf + d++] & 255, f += (o.pending_buf[o.sym_buf + d++] & 255) << 8, p = o.pending_buf[o.sym_buf + d++], f === 0 ? send_code(o, p, l) : (m = _length_code[p], send_code(o, m + LITERALS$1 + 1, l), v = extra_lbits[m], v !== 0 && (p -= base_length[m], send_bits(o, p, v)), f--, m = d_code(f), send_code(o, m, u), v = extra_dbits[m], v !== 0 && (f -= base_dist[m], send_bits(o, f, v))); while (d < o.sym_next); send_code(o, END_BLOCK, l) }, build_tree = (o, l) => { const u = l.dyn_tree, f = l.stat_desc.static_tree, p = l.stat_desc.has_stree, d = l.stat_desc.elems; let m, v, I = -1, F; for (o.heap_len = 0, o.heap_max = HEAP_SIZE$1, m = 0; m < d; m++)u[m * 2] !== 0 ? (o.heap[++o.heap_len] = I = m, o.depth[m] = 0) : u[m * 2 + 1] = 0; for (; o.heap_len < 2;)F = o.heap[++o.heap_len] = I < 2 ? ++I : 0, u[F * 2] = 1, o.depth[F] = 0, o.opt_len--, p && (o.static_len -= f[F * 2 + 1]); for (l.max_code = I, m = o.heap_len >> 1; m >= 1; m--)pqdownheap(o, u, m); F = d; do m = o.heap[1], o.heap[1] = o.heap[o.heap_len--], pqdownheap(o, u, 1), v = o.heap[1], o.heap[--o.heap_max] = m, o.heap[--o.heap_max] = v, u[F * 2] = u[m * 2] + u[v * 2], o.depth[F] = (o.depth[m] >= o.depth[v] ? o.depth[m] : o.depth[v]) + 1, u[m * 2 + 1] = u[v * 2 + 1] = F, o.heap[1] = F++, pqdownheap(o, u, 1); while (o.heap_len >= 2); o.heap[--o.heap_max] = o.heap[1], gen_bitlen(o, l), gen_codes(u, I, o.bl_count) }, scan_tree = (o, l, u) => { let f, p = -1, d, m = l[0 * 2 + 1], v = 0, I = 7, F = 4; for (m === 0 && (I = 138, F = 3), l[(u + 1) * 2 + 1] = 65535, f = 0; f <= u; f++)d = m, m = l[(f + 1) * 2 + 1], !(++v < I && d === m) && (v < F ? o.bl_tree[d * 2] += v : d !== 0 ? (d !== p && o.bl_tree[d * 2]++, o.bl_tree[REP_3_6 * 2]++) : v <= 10 ? o.bl_tree[REPZ_3_10 * 2]++ : o.bl_tree[REPZ_11_138 * 2]++, v = 0, p = d, m === 0 ? (I = 138, F = 3) : d === m ? (I = 6, F = 3) : (I = 7, F = 4)) }, send_tree = (o, l, u) => { let f, p = -1, d, m = l[0 * 2 + 1], v = 0, I = 7, F = 4; for (m === 0 && (I = 138, F = 3), f = 0; f <= u; f++)if (d = m, m = l[(f + 1) * 2 + 1], !(++v < I && d === m)) { if (v < F) do send_code(o, d, o.bl_tree); while (--v !== 0); else d !== 0 ? (d !== p && (send_code(o, d, o.bl_tree), v--), send_code(o, REP_3_6, o.bl_tree), send_bits(o, v - 3, 2)) : v <= 10 ? (send_code(o, REPZ_3_10, o.bl_tree), send_bits(o, v - 3, 3)) : (send_code(o, REPZ_11_138, o.bl_tree), send_bits(o, v - 11, 7)); v = 0, p = d, m === 0 ? (I = 138, F = 3) : d === m ? (I = 6, F = 3) : (I = 7, F = 4) } }, build_bl_tree = o => { let l; for (scan_tree(o, o.dyn_ltree, o.l_desc.max_code), scan_tree(o, o.dyn_dtree, o.d_desc.max_code), build_tree(o, o.bl_desc), l = BL_CODES$1 - 1; l >= 3 && o.bl_tree[bl_order[l] * 2 + 1] === 0; l--); return o.opt_len += 3 * (l + 1) + 5 + 5 + 4, l }, send_all_trees = (o, l, u, f) => { let p; for (send_bits(o, l - 257, 5), send_bits(o, u - 1, 5), send_bits(o, f - 4, 4), p = 0; p < f; p++)send_bits(o, o.bl_tree[bl_order[p] * 2 + 1], 3); send_tree(o, o.dyn_ltree, l - 1), send_tree(o, o.dyn_dtree, u - 1) }, detect_data_type = o => { let l = 4093624447, u; for (u = 0; u <= 31; u++, l >>>= 1)if (l & 1 && o.dyn_ltree[u * 2] !== 0) return Z_BINARY; if (o.dyn_ltree[9 * 2] !== 0 || o.dyn_ltree[10 * 2] !== 0 || o.dyn_ltree[13 * 2] !== 0) return Z_TEXT; for (u = 32; u < LITERALS$1; u++)if (o.dyn_ltree[u * 2] !== 0) return Z_TEXT; return Z_BINARY }; let static_init_done = !1; const _tr_init$1 = o => { static_init_done || (tr_static_init(), static_init_done = !0), o.l_desc = new TreeDesc(o.dyn_ltree, static_l_desc), o.d_desc = new TreeDesc(o.dyn_dtree, static_d_desc), o.bl_desc = new TreeDesc(o.bl_tree, static_bl_desc), o.bi_buf = 0, o.bi_valid = 0, init_block(o) }, _tr_stored_block$1 = (o, l, u, f) => { send_bits(o, (STORED_BLOCK << 1) + (f ? 1 : 0), 3), bi_windup(o), put_short(o, u), put_short(o, ~u), u && o.pending_buf.set(o.window.subarray(l, l + u), o.pending), o.pending += u }, _tr_align$1 = o => { send_bits(o, STATIC_TREES << 1, 3), send_code(o, END_BLOCK, static_ltree), bi_flush(o) }, _tr_flush_block$1 = (o, l, u, f) => { let p, d, m = 0; o.level > 0 ? (o.strm.data_type === Z_UNKNOWN$1 && (o.strm.data_type = detect_data_type(o)), build_tree(o, o.l_desc), build_tree(o, o.d_desc), m = build_bl_tree(o), p = o.opt_len + 3 + 7 >>> 3, d = o.static_len + 3 + 7 >>> 3, d <= p && (p = d)) : p = d = u + 5, u + 4 <= p && l !== -1 ? _tr_stored_block$1(o, l, u, f) : o.strategy === Z_FIXED$1 || d === p ? (send_bits(o, (STATIC_TREES << 1) + (f ? 1 : 0), 3), compress_block(o, static_ltree, static_dtree)) : (send_bits(o, (DYN_TREES << 1) + (f ? 1 : 0), 3), send_all_trees(o, o.l_desc.max_code + 1, o.d_desc.max_code + 1, m + 1), compress_block(o, o.dyn_ltree, o.dyn_dtree)), init_block(o), f && bi_windup(o) }, _tr_tally$1 = (o, l, u) => (o.pending_buf[o.sym_buf + o.sym_next++] = l, o.pending_buf[o.sym_buf + o.sym_next++] = l >> 8, o.pending_buf[o.sym_buf + o.sym_next++] = u, l === 0 ? o.dyn_ltree[u * 2]++ : (o.matches++, l--, o.dyn_ltree[(_length_code[u] + LITERALS$1 + 1) * 2]++, o.dyn_dtree[d_code(l) * 2]++), o.sym_next === o.sym_end); var _tr_init_1 = _tr_init$1, _tr_stored_block_1 = _tr_stored_block$1, _tr_flush_block_1 = _tr_flush_block$1, _tr_tally_1 = _tr_tally$1, _tr_align_1 = _tr_align$1, trees = { _tr_init: _tr_init_1, _tr_stored_block: _tr_stored_block_1, _tr_flush_block: _tr_flush_block_1, _tr_tally: _tr_tally_1, _tr_align: _tr_align_1 }; const adler32 = (o, l, u, f) => { let p = o & 65535 | 0, d = o >>> 16 & 65535 | 0, m = 0; for (; u !== 0;) { m = u > 2e3 ? 2e3 : u, u -= m; do p = p + l[f++] | 0, d = d + p | 0; while (--m); p %= 65521, d %= 65521 } return p | d << 16 | 0 }; var adler32_1 = adler32; const makeTable = () => { let o, l = []; for (var u = 0; u < 256; u++) { o = u; for (var f = 0; f < 8; f++)o = o & 1 ? 3988292384 ^ o >>> 1 : o >>> 1; l[u] = o } return l }, crcTable = new Uint32Array(makeTable()), crc32 = (o, l, u, f) => { const p = crcTable, d = f + u; o ^= -1; for (let m = f; m < d; m++)o = o >>> 8 ^ p[(o ^ l[m]) & 255]; return o ^ -1 }; var crc32_1 = crc32, messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, constants$2 = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees, { Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2, MAX_MEM_LEVEL = 9, MAX_WBITS$1 = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, GZIP_STATE = 57, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3, err = (o, l) => (o.msg = messages[l], l), rank = o => o * 2 - (o > 4 ? 9 : 0), zero = o => { let l = o.length; for (; --l >= 0;)o[l] = 0 }, slide_hash = o => { let l, u, f, p = o.w_size; l = o.hash_size, f = l; do u = o.head[--f], o.head[f] = u >= p ? u - p : 0; while (--l); l = p, f = l; do u = o.prev[--f], o.prev[f] = u >= p ? u - p : 0; while (--l) }; let HASH_ZLIB = (o, l, u) => (l << o.hash_shift ^ u) & o.hash_mask, HASH = HASH_ZLIB; const flush_pending = o => { const l = o.state; let u = l.pending; u > o.avail_out && (u = o.avail_out), u !== 0 && (o.output.set(l.pending_buf.subarray(l.pending_out, l.pending_out + u), o.next_out), o.next_out += u, l.pending_out += u, o.total_out += u, o.avail_out -= u, l.pending -= u, l.pending === 0 && (l.pending_out = 0)) }, flush_block_only = (o, l) => { _tr_flush_block(o, o.block_start >= 0 ? o.block_start : -1, o.strstart - o.block_start, l), o.block_start = o.strstart, flush_pending(o.strm) }, put_byte = (o, l) => { o.pending_buf[o.pending++] = l }, putShortMSB = (o, l) => { o.pending_buf[o.pending++] = l >>> 8 & 255, o.pending_buf[o.pending++] = l & 255 }, read_buf = (o, l, u, f) => { let p = o.avail_in; return p > f && (p = f), p === 0 ? 0 : (o.avail_in -= p, l.set(o.input.subarray(o.next_in, o.next_in + p), u), o.state.wrap === 1 ? o.adler = adler32_1(o.adler, l, p, u) : o.state.wrap === 2 && (o.adler = crc32_1(o.adler, l, p, u)), o.next_in += p, o.total_in += p, p) }, longest_match = (o, l) => { let u = o.max_chain_length, f = o.strstart, p, d, m = o.prev_length, v = o.nice_match; const I = o.strstart > o.w_size - MIN_LOOKAHEAD ? o.strstart - (o.w_size - MIN_LOOKAHEAD) : 0, F = o.window, B = o.w_mask, W = o.prev, Z = o.strstart + MAX_MATCH; let Q = F[f + m - 1], re = F[f + m]; o.prev_length >= o.good_match && (u >>= 2), v > o.lookahead && (v = o.lookahead); do if (p = l, !(F[p + m] !== re || F[p + m - 1] !== Q || F[p] !== F[f] || F[++p] !== F[f + 1])) { f += 2, p++; do; while (F[++f] === F[++p] && F[++f] === F[++p] && F[++f] === F[++p] && F[++f] === F[++p] && F[++f] === F[++p] && F[++f] === F[++p] && F[++f] === F[++p] && F[++f] === F[++p] && f < Z); if (d = MAX_MATCH - (Z - f), f = Z - MAX_MATCH, d > m) { if (o.match_start = l, m = d, d >= v) break; Q = F[f + m - 1], re = F[f + m] } } while ((l = W[l & B]) > I && --u !== 0); return m <= o.lookahead ? m : o.lookahead }, fill_window = o => { const l = o.w_size; let u, f, p; do { if (f = o.window_size - o.lookahead - o.strstart, o.strstart >= l + (l - MIN_LOOKAHEAD) && (o.window.set(o.window.subarray(l, l + l - f), 0), o.match_start -= l, o.strstart -= l, o.block_start -= l, o.insert > o.strstart && (o.insert = o.strstart), slide_hash(o), f += l), o.strm.avail_in === 0) break; if (u = read_buf(o.strm, o.window, o.strstart + o.lookahead, f), o.lookahead += u, o.lookahead + o.insert >= MIN_MATCH) for (p = o.strstart - o.insert, o.ins_h = o.window[p], o.ins_h = HASH(o, o.ins_h, o.window[p + 1]); o.insert && (o.ins_h = HASH(o, o.ins_h, o.window[p + MIN_MATCH - 1]), o.prev[p & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = p, p++, o.insert--, !(o.lookahead + o.insert < MIN_MATCH));); } while (o.lookahead < MIN_LOOKAHEAD && o.strm.avail_in !== 0) }, deflate_stored = (o, l) => { let u = o.pending_buf_size - 5 > o.w_size ? o.w_size : o.pending_buf_size - 5, f, p, d, m = 0, v = o.strm.avail_in; do { if (f = 65535, d = o.bi_valid + 42 >> 3, o.strm.avail_out < d || (d = o.strm.avail_out - d, p = o.strstart - o.block_start, f > p + o.strm.avail_in && (f = p + o.strm.avail_in), f > d && (f = d), f < u && (f === 0 && l !== Z_FINISH$3 || l === Z_NO_FLUSH$2 || f !== p + o.strm.avail_in))) break; m = l === Z_FINISH$3 && f === p + o.strm.avail_in ? 1 : 0, _tr_stored_block(o, 0, 0, m), o.pending_buf[o.pending - 4] = f, o.pending_buf[o.pending - 3] = f >> 8, o.pending_buf[o.pending - 2] = ~f, o.pending_buf[o.pending - 1] = ~f >> 8, flush_pending(o.strm), p && (p > f && (p = f), o.strm.output.set(o.window.subarray(o.block_start, o.block_start + p), o.strm.next_out), o.strm.next_out += p, o.strm.avail_out -= p, o.strm.total_out += p, o.block_start += p, f -= p), f && (read_buf(o.strm, o.strm.output, o.strm.next_out, f), o.strm.next_out += f, o.strm.avail_out -= f, o.strm.total_out += f) } while (m === 0); return v -= o.strm.avail_in, v && (v >= o.w_size ? (o.matches = 2, o.window.set(o.strm.input.subarray(o.strm.next_in - o.w_size, o.strm.next_in), 0), o.strstart = o.w_size, o.insert = o.strstart) : (o.window_size - o.strstart <= v && (o.strstart -= o.w_size, o.window.set(o.window.subarray(o.w_size, o.w_size + o.strstart), 0), o.matches < 2 && o.matches++, o.insert > o.strstart && (o.insert = o.strstart)), o.window.set(o.strm.input.subarray(o.strm.next_in - v, o.strm.next_in), o.strstart), o.strstart += v, o.insert += v > o.w_size - o.insert ? o.w_size - o.insert : v), o.block_start = o.strstart), o.high_water < o.strstart && (o.high_water = o.strstart), m ? BS_FINISH_DONE : l !== Z_NO_FLUSH$2 && l !== Z_FINISH$3 && o.strm.avail_in === 0 && o.strstart === o.block_start ? BS_BLOCK_DONE : (d = o.window_size - o.strstart, o.strm.avail_in > d && o.block_start >= o.w_size && (o.block_start -= o.w_size, o.strstart -= o.w_size, o.window.set(o.window.subarray(o.w_size, o.w_size + o.strstart), 0), o.matches < 2 && o.matches++, d += o.w_size, o.insert > o.strstart && (o.insert = o.strstart)), d > o.strm.avail_in && (d = o.strm.avail_in), d && (read_buf(o.strm, o.window, o.strstart, d), o.strstart += d, o.insert += d > o.w_size - o.insert ? o.w_size - o.insert : d), o.high_water < o.strstart && (o.high_water = o.strstart), d = o.bi_valid + 42 >> 3, d = o.pending_buf_size - d > 65535 ? 65535 : o.pending_buf_size - d, u = d > o.w_size ? o.w_size : d, p = o.strstart - o.block_start, (p >= u || (p || l === Z_FINISH$3) && l !== Z_NO_FLUSH$2 && o.strm.avail_in === 0 && p <= d) && (f = p > d ? d : p, m = l === Z_FINISH$3 && o.strm.avail_in === 0 && f === p ? 1 : 0, _tr_stored_block(o, o.block_start, f, m), o.block_start += f, flush_pending(o.strm)), m ? BS_FINISH_STARTED : BS_NEED_MORE) }, deflate_fast = (o, l) => { let u, f; for (; ;) { if (o.lookahead < MIN_LOOKAHEAD) { if (fill_window(o), o.lookahead < MIN_LOOKAHEAD && l === Z_NO_FLUSH$2) return BS_NEED_MORE; if (o.lookahead === 0) break } if (u = 0, o.lookahead >= MIN_MATCH && (o.ins_h = HASH(o, o.ins_h, o.window[o.strstart + MIN_MATCH - 1]), u = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), u !== 0 && o.strstart - u <= o.w_size - MIN_LOOKAHEAD && (o.match_length = longest_match(o, u)), o.match_length >= MIN_MATCH) if (f = _tr_tally(o, o.strstart - o.match_start, o.match_length - MIN_MATCH), o.lookahead -= o.match_length, o.match_length <= o.max_lazy_match && o.lookahead >= MIN_MATCH) { o.match_length--; do o.strstart++, o.ins_h = HASH(o, o.ins_h, o.window[o.strstart + MIN_MATCH - 1]), u = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart; while (--o.match_length !== 0); o.strstart++ } else o.strstart += o.match_length, o.match_length = 0, o.ins_h = o.window[o.strstart], o.ins_h = HASH(o, o.ins_h, o.window[o.strstart + 1]); else f = _tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++; if (f && (flush_block_only(o, !1), o.strm.avail_out === 0)) return BS_NEED_MORE } return o.insert = o.strstart < MIN_MATCH - 1 ? o.strstart : MIN_MATCH - 1, l === Z_FINISH$3 ? (flush_block_only(o, !0), o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : o.sym_next && (flush_block_only(o, !1), o.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE }, deflate_slow = (o, l) => { let u, f, p; for (; ;) { if (o.lookahead < MIN_LOOKAHEAD) { if (fill_window(o), o.lookahead < MIN_LOOKAHEAD && l === Z_NO_FLUSH$2) return BS_NEED_MORE; if (o.lookahead === 0) break } if (u = 0, o.lookahead >= MIN_MATCH && (o.ins_h = HASH(o, o.ins_h, o.window[o.strstart + MIN_MATCH - 1]), u = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), o.prev_length = o.match_length, o.prev_match = o.match_start, o.match_length = MIN_MATCH - 1, u !== 0 && o.prev_length < o.max_lazy_match && o.strstart - u <= o.w_size - MIN_LOOKAHEAD && (o.match_length = longest_match(o, u), o.match_length <= 5 && (o.strategy === Z_FILTERED || o.match_length === MIN_MATCH && o.strstart - o.match_start > 4096) && (o.match_length = MIN_MATCH - 1)), o.prev_length >= MIN_MATCH && o.match_length <= o.prev_length) { p = o.strstart + o.lookahead - MIN_MATCH, f = _tr_tally(o, o.strstart - 1 - o.prev_match, o.prev_length - MIN_MATCH), o.lookahead -= o.prev_length - 1, o.prev_length -= 2; do ++o.strstart <= p && (o.ins_h = HASH(o, o.ins_h, o.window[o.strstart + MIN_MATCH - 1]), u = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart); while (--o.prev_length !== 0); if (o.match_available = 0, o.match_length = MIN_MATCH - 1, o.strstart++, f && (flush_block_only(o, !1), o.strm.avail_out === 0)) return BS_NEED_MORE } else if (o.match_available) { if (f = _tr_tally(o, 0, o.window[o.strstart - 1]), f && flush_block_only(o, !1), o.strstart++, o.lookahead--, o.strm.avail_out === 0) return BS_NEED_MORE } else o.match_available = 1, o.strstart++, o.lookahead-- } return o.match_available && (f = _tr_tally(o, 0, o.window[o.strstart - 1]), o.match_available = 0), o.insert = o.strstart < MIN_MATCH - 1 ? o.strstart : MIN_MATCH - 1, l === Z_FINISH$3 ? (flush_block_only(o, !0), o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : o.sym_next && (flush_block_only(o, !1), o.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE }, deflate_rle = (o, l) => { let u, f, p, d; const m = o.window; for (; ;) { if (o.lookahead <= MAX_MATCH) { if (fill_window(o), o.lookahead <= MAX_MATCH && l === Z_NO_FLUSH$2) return BS_NEED_MORE; if (o.lookahead === 0) break } if (o.match_length = 0, o.lookahead >= MIN_MATCH && o.strstart > 0 && (p = o.strstart - 1, f = m[p], f === m[++p] && f === m[++p] && f === m[++p])) { d = o.strstart + MAX_MATCH; do; while (f === m[++p] && f === m[++p] && f === m[++p] && f === m[++p] && f === m[++p] && f === m[++p] && f === m[++p] && f === m[++p] && p < d); o.match_length = MAX_MATCH - (d - p), o.match_length > o.lookahead && (o.match_length = o.lookahead) } if (o.match_length >= MIN_MATCH ? (u = _tr_tally(o, 1, o.match_length - MIN_MATCH), o.lookahead -= o.match_length, o.strstart += o.match_length, o.match_length = 0) : (u = _tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++), u && (flush_block_only(o, !1), o.strm.avail_out === 0)) return BS_NEED_MORE } return o.insert = 0, l === Z_FINISH$3 ? (flush_block_only(o, !0), o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : o.sym_next && (flush_block_only(o, !1), o.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE }, deflate_huff = (o, l) => { let u; for (; ;) { if (o.lookahead === 0 && (fill_window(o), o.lookahead === 0)) { if (l === Z_NO_FLUSH$2) return BS_NEED_MORE; break } if (o.match_length = 0, u = _tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++, u && (flush_block_only(o, !1), o.strm.avail_out === 0)) return BS_NEED_MORE } return o.insert = 0, l === Z_FINISH$3 ? (flush_block_only(o, !0), o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : o.sym_next && (flush_block_only(o, !1), o.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE }; function Config(o, l, u, f, p) { this.good_length = o, this.max_lazy = l, this.nice_length = u, this.max_chain = f, this.func = p } const configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)], lm_init = o => { o.window_size = 2 * o.w_size, zero(o.head), o.max_lazy_match = configuration_table[o.level].max_lazy, o.good_match = configuration_table[o.level].good_length, o.nice_match = configuration_table[o.level].nice_length, o.max_chain_length = configuration_table[o.level].max_chain, o.strstart = 0, o.block_start = 0, o.lookahead = 0, o.insert = 0, o.match_length = o.prev_length = MIN_MATCH - 1, o.match_available = 0, o.ins_h = 0 }; function DeflateState() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2), this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2), this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MAX_BITS + 1), this.heap = new Uint16Array(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * L_CODES + 1), zero(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } const deflateStateCheck = o => { if (!o) return 1; const l = o.state; return !l || l.strm !== o || l.status !== INIT_STATE && l.status !== GZIP_STATE && l.status !== EXTRA_STATE && l.status !== NAME_STATE && l.status !== COMMENT_STATE && l.status !== HCRC_STATE && l.status !== BUSY_STATE && l.status !== FINISH_STATE ? 1 : 0 }, deflateResetKeep = o => { if (deflateStateCheck(o)) return err(o, Z_STREAM_ERROR$2); o.total_in = o.total_out = 0, o.data_type = Z_UNKNOWN; const l = o.state; return l.pending = 0, l.pending_out = 0, l.wrap < 0 && (l.wrap = -l.wrap), l.status = l.wrap === 2 ? GZIP_STATE : l.wrap ? INIT_STATE : BUSY_STATE, o.adler = l.wrap === 2 ? 0 : 1, l.last_flush = -2, _tr_init(l), Z_OK$3 }, deflateReset = o => { const l = deflateResetKeep(o); return l === Z_OK$3 && lm_init(o.state), l }, deflateSetHeader = (o, l) => deflateStateCheck(o) || o.state.wrap !== 2 ? Z_STREAM_ERROR$2 : (o.state.gzhead = l, Z_OK$3), deflateInit2 = (o, l, u, f, p, d) => { if (!o) return Z_STREAM_ERROR$2; let m = 1; if (l === Z_DEFAULT_COMPRESSION$1 && (l = 6), f < 0 ? (m = 0, f = -f) : f > 15 && (m = 2, f -= 16), p < 1 || p > MAX_MEM_LEVEL || u !== Z_DEFLATED$2 || f < 8 || f > 15 || l < 0 || l > 9 || d < 0 || d > Z_FIXED || f === 8 && m !== 1) return err(o, Z_STREAM_ERROR$2); f === 8 && (f = 9); const v = new DeflateState; return o.state = v, v.strm = o, v.status = INIT_STATE, v.wrap = m, v.gzhead = null, v.w_bits = f, v.w_size = 1 << v.w_bits, v.w_mask = v.w_size - 1, v.hash_bits = p + 7, v.hash_size = 1 << v.hash_bits, v.hash_mask = v.hash_size - 1, v.hash_shift = ~~((v.hash_bits + MIN_MATCH - 1) / MIN_MATCH), v.window = new Uint8Array(v.w_size * 2), v.head = new Uint16Array(v.hash_size), v.prev = new Uint16Array(v.w_size), v.lit_bufsize = 1 << p + 6, v.pending_buf_size = v.lit_bufsize * 4, v.pending_buf = new Uint8Array(v.pending_buf_size), v.sym_buf = v.lit_bufsize, v.sym_end = (v.lit_bufsize - 1) * 3, v.level = l, v.strategy = d, v.method = u, deflateReset(o) }, deflateInit = (o, l) => deflateInit2(o, l, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1), deflate$2 = (o, l) => { if (deflateStateCheck(o) || l > Z_BLOCK$1 || l < 0) return o ? err(o, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2; const u = o.state; if (!o.output || o.avail_in !== 0 && !o.input || u.status === FINISH_STATE && l !== Z_FINISH$3) return err(o, o.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2); const f = u.last_flush; if (u.last_flush = l, u.pending !== 0) { if (flush_pending(o), o.avail_out === 0) return u.last_flush = -1, Z_OK$3 } else if (o.avail_in === 0 && rank(l) <= rank(f) && l !== Z_FINISH$3) return err(o, Z_BUF_ERROR$1); if (u.status === FINISH_STATE && o.avail_in !== 0) return err(o, Z_BUF_ERROR$1); if (u.status === INIT_STATE && u.wrap === 0 && (u.status = BUSY_STATE), u.status === INIT_STATE) { let p = Z_DEFLATED$2 + (u.w_bits - 8 << 4) << 8, d = -1; if (u.strategy >= Z_HUFFMAN_ONLY || u.level < 2 ? d = 0 : u.level < 6 ? d = 1 : u.level === 6 ? d = 2 : d = 3, p |= d << 6, u.strstart !== 0 && (p |= PRESET_DICT), p += 31 - p % 31, putShortMSB(u, p), u.strstart !== 0 && (putShortMSB(u, o.adler >>> 16), putShortMSB(u, o.adler & 65535)), o.adler = 1, u.status = BUSY_STATE, flush_pending(o), u.pending !== 0) return u.last_flush = -1, Z_OK$3 } if (u.status === GZIP_STATE) { if (o.adler = 0, put_byte(u, 31), put_byte(u, 139), put_byte(u, 8), u.gzhead) put_byte(u, (u.gzhead.text ? 1 : 0) + (u.gzhead.hcrc ? 2 : 0) + (u.gzhead.extra ? 4 : 0) + (u.gzhead.name ? 8 : 0) + (u.gzhead.comment ? 16 : 0)), put_byte(u, u.gzhead.time & 255), put_byte(u, u.gzhead.time >> 8 & 255), put_byte(u, u.gzhead.time >> 16 & 255), put_byte(u, u.gzhead.time >> 24 & 255), put_byte(u, u.level === 9 ? 2 : u.strategy >= Z_HUFFMAN_ONLY || u.level < 2 ? 4 : 0), put_byte(u, u.gzhead.os & 255), u.gzhead.extra && u.gzhead.extra.length && (put_byte(u, u.gzhead.extra.length & 255), put_byte(u, u.gzhead.extra.length >> 8 & 255)), u.gzhead.hcrc && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending, 0)), u.gzindex = 0, u.status = EXTRA_STATE; else if (put_byte(u, 0), put_byte(u, 0), put_byte(u, 0), put_byte(u, 0), put_byte(u, 0), put_byte(u, u.level === 9 ? 2 : u.strategy >= Z_HUFFMAN_ONLY || u.level < 2 ? 4 : 0), put_byte(u, OS_CODE), u.status = BUSY_STATE, flush_pending(o), u.pending !== 0) return u.last_flush = -1, Z_OK$3 } if (u.status === EXTRA_STATE) { if (u.gzhead.extra) { let p = u.pending, d = (u.gzhead.extra.length & 65535) - u.gzindex; for (; u.pending + d > u.pending_buf_size;) { let v = u.pending_buf_size - u.pending; if (u.pending_buf.set(u.gzhead.extra.subarray(u.gzindex, u.gzindex + v), u.pending), u.pending = u.pending_buf_size, u.gzhead.hcrc && u.pending > p && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending - p, p)), u.gzindex += v, flush_pending(o), u.pending !== 0) return u.last_flush = -1, Z_OK$3; p = 0, d -= v } let m = new Uint8Array(u.gzhead.extra); u.pending_buf.set(m.subarray(u.gzindex, u.gzindex + d), u.pending), u.pending += d, u.gzhead.hcrc && u.pending > p && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending - p, p)), u.gzindex = 0 } u.status = NAME_STATE } if (u.status === NAME_STATE) { if (u.gzhead.name) { let p = u.pending, d; do { if (u.pending === u.pending_buf_size) { if (u.gzhead.hcrc && u.pending > p && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending - p, p)), flush_pending(o), u.pending !== 0) return u.last_flush = -1, Z_OK$3; p = 0 } u.gzindex < u.gzhead.name.length ? d = u.gzhead.name.charCodeAt(u.gzindex++) & 255 : d = 0, put_byte(u, d) } while (d !== 0); u.gzhead.hcrc && u.pending > p && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending - p, p)), u.gzindex = 0 } u.status = COMMENT_STATE } if (u.status === COMMENT_STATE) { if (u.gzhead.comment) { let p = u.pending, d; do { if (u.pending === u.pending_buf_size) { if (u.gzhead.hcrc && u.pending > p && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending - p, p)), flush_pending(o), u.pending !== 0) return u.last_flush = -1, Z_OK$3; p = 0 } u.gzindex < u.gzhead.comment.length ? d = u.gzhead.comment.charCodeAt(u.gzindex++) & 255 : d = 0, put_byte(u, d) } while (d !== 0); u.gzhead.hcrc && u.pending > p && (o.adler = crc32_1(o.adler, u.pending_buf, u.pending - p, p)) } u.status = HCRC_STATE } if (u.status === HCRC_STATE) { if (u.gzhead.hcrc) { if (u.pending + 2 > u.pending_buf_size && (flush_pending(o), u.pending !== 0)) return u.last_flush = -1, Z_OK$3; put_byte(u, o.adler & 255), put_byte(u, o.adler >> 8 & 255), o.adler = 0 } if (u.status = BUSY_STATE, flush_pending(o), u.pending !== 0) return u.last_flush = -1, Z_OK$3 } if (o.avail_in !== 0 || u.lookahead !== 0 || l !== Z_NO_FLUSH$2 && u.status !== FINISH_STATE) { let p = u.level === 0 ? deflate_stored(u, l) : u.strategy === Z_HUFFMAN_ONLY ? deflate_huff(u, l) : u.strategy === Z_RLE ? deflate_rle(u, l) : configuration_table[u.level].func(u, l); if ((p === BS_FINISH_STARTED || p === BS_FINISH_DONE) && (u.status = FINISH_STATE), p === BS_NEED_MORE || p === BS_FINISH_STARTED) return o.avail_out === 0 && (u.last_flush = -1), Z_OK$3; if (p === BS_BLOCK_DONE && (l === Z_PARTIAL_FLUSH ? _tr_align(u) : l !== Z_BLOCK$1 && (_tr_stored_block(u, 0, 0, !1), l === Z_FULL_FLUSH$1 && (zero(u.head), u.lookahead === 0 && (u.strstart = 0, u.block_start = 0, u.insert = 0))), flush_pending(o), o.avail_out === 0)) return u.last_flush = -1, Z_OK$3 } return l !== Z_FINISH$3 ? Z_OK$3 : u.wrap <= 0 ? Z_STREAM_END$3 : (u.wrap === 2 ? (put_byte(u, o.adler & 255), put_byte(u, o.adler >> 8 & 255), put_byte(u, o.adler >> 16 & 255), put_byte(u, o.adler >> 24 & 255), put_byte(u, o.total_in & 255), put_byte(u, o.total_in >> 8 & 255), put_byte(u, o.total_in >> 16 & 255), put_byte(u, o.total_in >> 24 & 255)) : (putShortMSB(u, o.adler >>> 16), putShortMSB(u, o.adler & 65535)), flush_pending(o), u.wrap > 0 && (u.wrap = -u.wrap), u.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3) }, deflateEnd = o => { if (deflateStateCheck(o)) return Z_STREAM_ERROR$2; const l = o.state.status; return o.state = null, l === BUSY_STATE ? err(o, Z_DATA_ERROR$2) : Z_OK$3 }, deflateSetDictionary = (o, l) => { let u = l.length; if (deflateStateCheck(o)) return Z_STREAM_ERROR$2; const f = o.state, p = f.wrap; if (p === 2 || p === 1 && f.status !== INIT_STATE || f.lookahead) return Z_STREAM_ERROR$2; if (p === 1 && (o.adler = adler32_1(o.adler, l, u, 0)), f.wrap = 0, u >= f.w_size) { p === 0 && (zero(f.head), f.strstart = 0, f.block_start = 0, f.insert = 0); let I = new Uint8Array(f.w_size); I.set(l.subarray(u - f.w_size, u), 0), l = I, u = f.w_size } const d = o.avail_in, m = o.next_in, v = o.input; for (o.avail_in = u, o.next_in = 0, o.input = l, fill_window(f); f.lookahead >= MIN_MATCH;) { let I = f.strstart, F = f.lookahead - (MIN_MATCH - 1); do f.ins_h = HASH(f, f.ins_h, f.window[I + MIN_MATCH - 1]), f.prev[I & f.w_mask] = f.head[f.ins_h], f.head[f.ins_h] = I, I++; while (--F); f.strstart = I, f.lookahead = MIN_MATCH - 1, fill_window(f) } return f.strstart += f.lookahead, f.block_start = f.strstart, f.insert = f.lookahead, f.lookahead = 0, f.match_length = f.prev_length = MIN_MATCH - 1, f.match_available = 0, o.next_in = m, o.input = v, o.avail_in = d, f.wrap = p, Z_OK$3 }; var deflateInit_1 = deflateInit, deflateInit2_1 = deflateInit2, deflateReset_1 = deflateReset, deflateResetKeep_1 = deflateResetKeep, deflateSetHeader_1 = deflateSetHeader, deflate_2$1 = deflate$2, deflateEnd_1 = deflateEnd, deflateSetDictionary_1 = deflateSetDictionary, deflateInfo = "pako deflate (from Nodeca project)", deflate_1$2 = { deflateInit: deflateInit_1, deflateInit2: deflateInit2_1, deflateReset: deflateReset_1, deflateResetKeep: deflateResetKeep_1, deflateSetHeader: deflateSetHeader_1, deflate: deflate_2$1, deflateEnd: deflateEnd_1, deflateSetDictionary: deflateSetDictionary_1, deflateInfo }; const _has = (o, l) => Object.prototype.hasOwnProperty.call(o, l); var assign = function (o) { const l = Array.prototype.slice.call(arguments, 1); for (; l.length;) { const u = l.shift(); if (u) { if (typeof u != "object") throw new TypeError(u + "must be non-object"); for (const f in u) _has(u, f) && (o[f] = u[f]) } } return o }, flattenChunks = o => { let l = 0; for (let f = 0, p = o.length; f < p; f++)l += o[f].length; const u = new Uint8Array(l); for (let f = 0, p = 0, d = o.length; f < d; f++) { let m = o[f]; u.set(m, p), p += m.length } return u }, common$2 = { assign, flattenChunks }; let STR_APPLY_UIA_OK = !0; try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch { STR_APPLY_UIA_OK = !1 } const _utf8len = new Uint8Array(256); for (let o = 0; o < 256; o++)_utf8len[o] = o >= 252 ? 6 : o >= 248 ? 5 : o >= 240 ? 4 : o >= 224 ? 3 : o >= 192 ? 2 : 1; _utf8len[254] = _utf8len[254] = 1; var string2buf = o => { if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(o); let l, u, f, p, d, m = o.length, v = 0; for (p = 0; p < m; p++)u = o.charCodeAt(p), (u & 64512) === 55296 && p + 1 < m && (f = o.charCodeAt(p + 1), (f & 64512) === 56320 && (u = 65536 + (u - 55296 << 10) + (f - 56320), p++)), v += u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4; for (l = new Uint8Array(v), d = 0, p = 0; d < v; p++)u = o.charCodeAt(p), (u & 64512) === 55296 && p + 1 < m && (f = o.charCodeAt(p + 1), (f & 64512) === 56320 && (u = 65536 + (u - 55296 << 10) + (f - 56320), p++)), u < 128 ? l[d++] = u : u < 2048 ? (l[d++] = 192 | u >>> 6, l[d++] = 128 | u & 63) : u < 65536 ? (l[d++] = 224 | u >>> 12, l[d++] = 128 | u >>> 6 & 63, l[d++] = 128 | u & 63) : (l[d++] = 240 | u >>> 18, l[d++] = 128 | u >>> 12 & 63, l[d++] = 128 | u >>> 6 & 63, l[d++] = 128 | u & 63); return l }; const buf2binstring = (o, l) => { if (l < 65534 && o.subarray && STR_APPLY_UIA_OK) return String.fromCharCode.apply(null, o.length === l ? o : o.subarray(0, l)); let u = ""; for (let f = 0; f < l; f++)u += String.fromCharCode(o[f]); return u }; var buf2string = (o, l) => { const u = l || o.length; if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(o.subarray(0, l)); let f, p; const d = new Array(u * 2); for (p = 0, f = 0; f < u;) { let m = o[f++]; if (m < 128) { d[p++] = m; continue } let v = _utf8len[m]; if (v > 4) { d[p++] = 65533, f += v - 1; continue } for (m &= v === 2 ? 31 : v === 3 ? 15 : 7; v > 1 && f < u;)m = m << 6 | o[f++] & 63, v--; if (v > 1) { d[p++] = 65533; continue } m < 65536 ? d[p++] = m : (m -= 65536, d[p++] = 55296 | m >> 10 & 1023, d[p++] = 56320 | m & 1023) } return buf2binstring(d, p) }, utf8border = (o, l) => { l = l || o.length, l > o.length && (l = o.length); let u = l - 1; for (; u >= 0 && (o[u] & 192) === 128;)u--; return u < 0 || u === 0 ? l : u + _utf8len[o[u]] > l ? u : l }, strings$1 = { string2buf, buf2string, utf8border }; function ZStream() { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } var zstream = ZStream; const toString$1 = Object.prototype.toString, { Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2; function Deflate$1(o) { this.options = common$2.assign({ level: Z_DEFAULT_COMPRESSION, method: Z_DEFLATED$1, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Z_DEFAULT_STRATEGY }, o || {}); let l = this.options; l.raw && l.windowBits > 0 ? l.windowBits = -l.windowBits : l.gzip && l.windowBits > 0 && l.windowBits < 16 && (l.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0; let u = deflate_1$2.deflateInit2(this.strm, l.level, l.method, l.windowBits, l.memLevel, l.strategy); if (u !== Z_OK$2) throw new Error(messages[u]); if (l.header && deflate_1$2.deflateSetHeader(this.strm, l.header), l.dictionary) { let f; if (typeof l.dictionary == "string" ? f = strings$1.string2buf(l.dictionary) : toString$1.call(l.dictionary) === "[object ArrayBuffer]" ? f = new Uint8Array(l.dictionary) : f = l.dictionary, u = deflate_1$2.deflateSetDictionary(this.strm, f), u !== Z_OK$2) throw new Error(messages[u]); this._dict_set = !0 } } Deflate$1.prototype.push = function (o, l) { const u = this.strm, f = this.options.chunkSize; let p, d; if (this.ended) return !1; for (l === ~~l ? d = l : d = l === !0 ? Z_FINISH$2 : Z_NO_FLUSH$1, typeof o == "string" ? u.input = strings$1.string2buf(o) : toString$1.call(o) === "[object ArrayBuffer]" ? u.input = new Uint8Array(o) : u.input = o, u.next_in = 0, u.avail_in = u.input.length; ;) { if (u.avail_out === 0 && (u.output = new Uint8Array(f), u.next_out = 0, u.avail_out = f), (d === Z_SYNC_FLUSH || d === Z_FULL_FLUSH) && u.avail_out <= 6) { this.onData(u.output.subarray(0, u.next_out)), u.avail_out = 0; continue } if (p = deflate_1$2.deflate(u, d), p === Z_STREAM_END$2) return u.next_out > 0 && this.onData(u.output.subarray(0, u.next_out)), p = deflate_1$2.deflateEnd(this.strm), this.onEnd(p), this.ended = !0, p === Z_OK$2; if (u.avail_out === 0) { this.onData(u.output); continue } if (d > 0 && u.next_out > 0) { this.onData(u.output.subarray(0, u.next_out)), u.avail_out = 0; continue } if (u.avail_in === 0) break } return !0 }; Deflate$1.prototype.onData = function (o) { this.chunks.push(o) }; Deflate$1.prototype.onEnd = function (o) { o === Z_OK$2 && (this.result = common$2.flattenChunks(this.chunks)), this.chunks = [], this.err = o, this.msg = this.strm.msg }; function deflate$1(o, l) { const u = new Deflate$1(l); if (u.push(o, !0), u.err) throw u.msg || messages[u.err]; return u.result } function deflateRaw$1(o, l) { return l = l || {}, l.raw = !0, deflate$1(o, l) } function gzip$1(o, l) { return l = l || {}, l.gzip = !0, deflate$1(o, l) } var Deflate_1$1 = Deflate$1, deflate_2 = deflate$1, deflateRaw_1$1 = deflateRaw$1, gzip_1$1 = gzip$1, deflate_1$1 = { Deflate: Deflate_1$1, deflate: deflate_2, deflateRaw: deflateRaw_1$1, gzip: gzip_1$1 }; const BAD$1 = 16209, TYPE$1 = 16191; var inffast = function (l, u) { let f, p, d, m, v, I, F, B, W, Z, Q, re, ne, oe, ae, se, le, ue, he, pe, ve, _e, Se, $e; const ie = l.state; f = l.next_in, Se = l.input, p = f + (l.avail_in - 5), d = l.next_out, $e = l.output, m = d - (u - l.avail_out), v = d + (l.avail_out - 257), I = ie.dmax, F = ie.wsize, B = ie.whave, W = ie.wnext, Z = ie.window, Q = ie.hold, re = ie.bits, ne = ie.lencode, oe = ie.distcode, ae = (1 << ie.lenbits) - 1, se = (1 << ie.distbits) - 1; e: do { re < 15 && (Q += Se[f++] << re, re += 8, Q += Se[f++] << re, re += 8), le = ne[Q & ae]; t: for (; ;) { if (ue = le >>> 24, Q >>>= ue, re -= ue, ue = le >>> 16 & 255, ue === 0) $e[d++] = le & 65535; else if (ue & 16) { he = le & 65535, ue &= 15, ue && (re < ue && (Q += Se[f++] << re, re += 8), he += Q & (1 << ue) - 1, Q >>>= ue, re -= ue), re < 15 && (Q += Se[f++] << re, re += 8, Q += Se[f++] << re, re += 8), le = oe[Q & se]; r: for (; ;) { if (ue = le >>> 24, Q >>>= ue, re -= ue, ue = le >>> 16 & 255, ue & 16) { if (pe = le & 65535, ue &= 15, re < ue && (Q += Se[f++] << re, re += 8, re < ue && (Q += Se[f++] << re, re += 8)), pe += Q & (1 << ue) - 1, pe > I) { l.msg = "invalid distance too far back", ie.mode = BAD$1; break e } if (Q >>>= ue, re -= ue, ue = d - m, pe > ue) { if (ue = pe - ue, ue > B && ie.sane) { l.msg = "invalid distance too far back", ie.mode = BAD$1; break e } if (ve = 0, _e = Z, W === 0) { if (ve += F - ue, ue < he) { he -= ue; do $e[d++] = Z[ve++]; while (--ue); ve = d - pe, _e = $e } } else if (W < ue) { if (ve += F + W - ue, ue -= W, ue < he) { he -= ue; do $e[d++] = Z[ve++]; while (--ue); if (ve = 0, W < he) { ue = W, he -= ue; do $e[d++] = Z[ve++]; while (--ue); ve = d - pe, _e = $e } } } else if (ve += W - ue, ue < he) { he -= ue; do $e[d++] = Z[ve++]; while (--ue); ve = d - pe, _e = $e } for (; he > 2;)$e[d++] = _e[ve++], $e[d++] = _e[ve++], $e[d++] = _e[ve++], he -= 3; he && ($e[d++] = _e[ve++], he > 1 && ($e[d++] = _e[ve++])) } else { ve = d - pe; do $e[d++] = $e[ve++], $e[d++] = $e[ve++], $e[d++] = $e[ve++], he -= 3; while (he > 2); he && ($e[d++] = $e[ve++], he > 1 && ($e[d++] = $e[ve++])) } } else if ((ue & 64) === 0) { le = oe[(le & 65535) + (Q & (1 << ue) - 1)]; continue r } else { l.msg = "invalid distance code", ie.mode = BAD$1; break e } break } } else if ((ue & 64) === 0) { le = ne[(le & 65535) + (Q & (1 << ue) - 1)]; continue t } else if (ue & 32) { ie.mode = TYPE$1; break e } else { l.msg = "invalid literal/length code", ie.mode = BAD$1; break e } break } } while (f < p && d < v); he = re >> 3, f -= he, re -= he << 3, Q &= (1 << re) - 1, l.next_in = f, l.next_out = d, l.avail_in = f < p ? 5 + (p - f) : 5 - (f - p), l.avail_out = d < v ? 257 + (v - d) : 257 - (d - v), ie.hold = Q, ie.bits = re }; const MAXBITS = 15, ENOUGH_LENS$1 = 852, ENOUGH_DISTS$1 = 592, CODES$1 = 0, LENS$1 = 1, DISTS$1 = 2, lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]), inflate_table = (o, l, u, f, p, d, m, v) => { const I = v.bits; let F = 0, B = 0, W = 0, Z = 0, Q = 0, re = 0, ne = 0, oe = 0, ae = 0, se = 0, le, ue, he, pe, ve, _e = null, Se; const $e = new Uint16Array(MAXBITS + 1), ie = new Uint16Array(MAXBITS + 1); let g = null, P, U, K; for (F = 0; F <= MAXBITS; F++)$e[F] = 0; for (B = 0; B < f; B++)$e[l[u + B]]++; for (Q = I, Z = MAXBITS; Z >= 1 && $e[Z] === 0; Z--); if (Q > Z && (Q = Z), Z === 0) return p[d++] = 1 << 24 | 64 << 16 | 0, p[d++] = 1 << 24 | 64 << 16 | 0, v.bits = 1, 0; for (W = 1; W < Z && $e[W] === 0; W++); for (Q < W && (Q = W), oe = 1, F = 1; F <= MAXBITS; F++)if (oe <<= 1, oe -= $e[F], oe < 0) return -1; if (oe > 0 && (o === CODES$1 || Z !== 1)) return -1; for (ie[1] = 0, F = 1; F < MAXBITS; F++)ie[F + 1] = ie[F] + $e[F]; for (B = 0; B < f; B++)l[u + B] !== 0 && (m[ie[l[u + B]]++] = B); if (o === CODES$1 ? (_e = g = m, Se = 20) : o === LENS$1 ? (_e = lbase, g = lext, Se = 257) : (_e = dbase, g = dext, Se = 0), se = 0, B = 0, F = W, ve = d, re = Q, ne = 0, he = -1, ae = 1 << Q, pe = ae - 1, o === LENS$1 && ae > ENOUGH_LENS$1 || o === DISTS$1 && ae > ENOUGH_DISTS$1) return 1; for (; ;) { P = F - ne, m[B] + 1 < Se ? (U = 0, K = m[B]) : m[B] >= Se ? (U = g[m[B] - Se], K = _e[m[B] - Se]) : (U = 96, K = 0), le = 1 << F - ne, ue = 1 << re, W = ue; do ue -= le, p[ve + (se >> ne) + ue] = P << 24 | U << 16 | K | 0; while (ue !== 0); for (le = 1 << F - 1; se & le;)le >>= 1; if (le !== 0 ? (se &= le - 1, se += le) : se = 0, B++, --$e[F] === 0) { if (F === Z) break; F = l[u + m[B]] } if (F > Q && (se & pe) !== he) { for (ne === 0 && (ne = Q), ve += W, re = F - ne, oe = 1 << re; re + ne < Z && (oe -= $e[re + ne], !(oe <= 0));)re++, oe <<= 1; if (ae += 1 << re, o === LENS$1 && ae > ENOUGH_LENS$1 || o === DISTS$1 && ae > ENOUGH_DISTS$1) return 1; he = se & pe, p[he] = Q << 24 | re << 16 | ve - d | 0 } } return se !== 0 && (p[ve + se] = F - ne << 24 | 64 << 16 | 0), v.bits = Q, 0 }; var inftrees = inflate_table; const CODES = 0, LENS = 1, DISTS = 2, { Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2, HEAD = 16180, FLAGS = 16181, TIME = 16182, OS = 16183, EXLEN = 16184, EXTRA = 16185, NAME = 16186, COMMENT = 16187, HCRC = 16188, DICTID = 16189, DICT = 16190, TYPE = 16191, TYPEDO = 16192, STORED = 16193, COPY_ = 16194, COPY = 16195, TABLE = 16196, LENLENS = 16197, CODELENS = 16198, LEN_ = 16199, LEN = 16200, LENEXT = 16201, DIST = 16202, DISTEXT = 16203, MATCH = 16204, LIT = 16205, CHECK = 16206, LENGTH = 16207, DONE = 16208, BAD = 16209, MEM = 16210, SYNC = 16211, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS, zswap32 = o => (o >>> 24 & 255) + (o >>> 8 & 65280) + ((o & 65280) << 8) + ((o & 255) << 24); function InflateState() { this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } const inflateStateCheck = o => { if (!o) return 1; const l = o.state; return !l || l.strm !== o || l.mode < HEAD || l.mode > SYNC ? 1 : 0 }, inflateResetKeep = o => { if (inflateStateCheck(o)) return Z_STREAM_ERROR$1; const l = o.state; return o.total_in = o.total_out = l.total = 0, o.msg = "", l.wrap && (o.adler = l.wrap & 1), l.mode = HEAD, l.last = 0, l.havedict = 0, l.flags = -1, l.dmax = 32768, l.head = null, l.hold = 0, l.bits = 0, l.lencode = l.lendyn = new Int32Array(ENOUGH_LENS), l.distcode = l.distdyn = new Int32Array(ENOUGH_DISTS), l.sane = 1, l.back = -1, Z_OK$1 }, inflateReset = o => { if (inflateStateCheck(o)) return Z_STREAM_ERROR$1; const l = o.state; return l.wsize = 0, l.whave = 0, l.wnext = 0, inflateResetKeep(o) }, inflateReset2 = (o, l) => { let u; if (inflateStateCheck(o)) return Z_STREAM_ERROR$1; const f = o.state; return l < 0 ? (u = 0, l = -l) : (u = (l >> 4) + 5, l < 48 && (l &= 15)), l && (l < 8 || l > 15) ? Z_STREAM_ERROR$1 : (f.window !== null && f.wbits !== l && (f.window = null), f.wrap = u, f.wbits = l, inflateReset(o)) }, inflateInit2 = (o, l) => { if (!o) return Z_STREAM_ERROR$1; const u = new InflateState; o.state = u, u.strm = o, u.window = null, u.mode = HEAD; const f = inflateReset2(o, l); return f !== Z_OK$1 && (o.state = null), f }, inflateInit = o => inflateInit2(o, DEF_WBITS); let virgin = !0, lenfix, distfix; const fixedtables = o => { if (virgin) { lenfix = new Int32Array(512), distfix = new Int32Array(32); let l = 0; for (; l < 144;)o.lens[l++] = 8; for (; l < 256;)o.lens[l++] = 9; for (; l < 280;)o.lens[l++] = 7; for (; l < 288;)o.lens[l++] = 8; for (inftrees(LENS, o.lens, 0, 288, lenfix, 0, o.work, { bits: 9 }), l = 0; l < 32;)o.lens[l++] = 5; inftrees(DISTS, o.lens, 0, 32, distfix, 0, o.work, { bits: 5 }), virgin = !1 } o.lencode = lenfix, o.lenbits = 9, o.distcode = distfix, o.distbits = 5 }, updatewindow = (o, l, u, f) => { let p; const d = o.state; return d.window === null && (d.wsize = 1 << d.wbits, d.wnext = 0, d.whave = 0, d.window = new Uint8Array(d.wsize)), f >= d.wsize ? (d.window.set(l.subarray(u - d.wsize, u), 0), d.wnext = 0, d.whave = d.wsize) : (p = d.wsize - d.wnext, p > f && (p = f), d.window.set(l.subarray(u - f, u - f + p), d.wnext), f -= p, f ? (d.window.set(l.subarray(u - f, u), 0), d.wnext = f, d.whave = d.wsize) : (d.wnext += p, d.wnext === d.wsize && (d.wnext = 0), d.whave < d.wsize && (d.whave += p))), 0 }, inflate$2 = (o, l) => { let u, f, p, d, m, v, I, F, B, W, Z, Q, re, ne, oe = 0, ae, se, le, ue, he, pe, ve, _e; const Se = new Uint8Array(4); let $e, ie; const g = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); if (inflateStateCheck(o) || !o.output || !o.input && o.avail_in !== 0) return Z_STREAM_ERROR$1; u = o.state, u.mode === TYPE && (u.mode = TYPEDO), m = o.next_out, p = o.output, I = o.avail_out, d = o.next_in, f = o.input, v = o.avail_in, F = u.hold, B = u.bits, W = v, Z = I, _e = Z_OK$1; e: for (; ;)switch (u.mode) { case HEAD: if (u.wrap === 0) { u.mode = TYPEDO; break } for (; B < 16;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (u.wrap & 2 && F === 35615) { u.wbits === 0 && (u.wbits = 15), u.check = 0, Se[0] = F & 255, Se[1] = F >>> 8 & 255, u.check = crc32_1(u.check, Se, 2, 0), F = 0, B = 0, u.mode = FLAGS; break } if (u.head && (u.head.done = !1), !(u.wrap & 1) || (((F & 255) << 8) + (F >> 8)) % 31) { o.msg = "incorrect header check", u.mode = BAD; break } if ((F & 15) !== Z_DEFLATED) { o.msg = "unknown compression method", u.mode = BAD; break } if (F >>>= 4, B -= 4, ve = (F & 15) + 8, u.wbits === 0 && (u.wbits = ve), ve > 15 || ve > u.wbits) { o.msg = "invalid window size", u.mode = BAD; break } u.dmax = 1 << u.wbits, u.flags = 0, o.adler = u.check = 1, u.mode = F & 512 ? DICTID : TYPE, F = 0, B = 0; break; case FLAGS: for (; B < 16;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (u.flags = F, (u.flags & 255) !== Z_DEFLATED) { o.msg = "unknown compression method", u.mode = BAD; break } if (u.flags & 57344) { o.msg = "unknown header flags set", u.mode = BAD; break } u.head && (u.head.text = F >> 8 & 1), u.flags & 512 && u.wrap & 4 && (Se[0] = F & 255, Se[1] = F >>> 8 & 255, u.check = crc32_1(u.check, Se, 2, 0)), F = 0, B = 0, u.mode = TIME; case TIME: for (; B < 32;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } u.head && (u.head.time = F), u.flags & 512 && u.wrap & 4 && (Se[0] = F & 255, Se[1] = F >>> 8 & 255, Se[2] = F >>> 16 & 255, Se[3] = F >>> 24 & 255, u.check = crc32_1(u.check, Se, 4, 0)), F = 0, B = 0, u.mode = OS; case OS: for (; B < 16;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } u.head && (u.head.xflags = F & 255, u.head.os = F >> 8), u.flags & 512 && u.wrap & 4 && (Se[0] = F & 255, Se[1] = F >>> 8 & 255, u.check = crc32_1(u.check, Se, 2, 0)), F = 0, B = 0, u.mode = EXLEN; case EXLEN: if (u.flags & 1024) { for (; B < 16;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } u.length = F, u.head && (u.head.extra_len = F), u.flags & 512 && u.wrap & 4 && (Se[0] = F & 255, Se[1] = F >>> 8 & 255, u.check = crc32_1(u.check, Se, 2, 0)), F = 0, B = 0 } else u.head && (u.head.extra = null); u.mode = EXTRA; case EXTRA: if (u.flags & 1024 && (Q = u.length, Q > v && (Q = v), Q && (u.head && (ve = u.head.extra_len - u.length, u.head.extra || (u.head.extra = new Uint8Array(u.head.extra_len)), u.head.extra.set(f.subarray(d, d + Q), ve)), u.flags & 512 && u.wrap & 4 && (u.check = crc32_1(u.check, f, Q, d)), v -= Q, d += Q, u.length -= Q), u.length)) break e; u.length = 0, u.mode = NAME; case NAME: if (u.flags & 2048) { if (v === 0) break e; Q = 0; do ve = f[d + Q++], u.head && ve && u.length < 65536 && (u.head.name += String.fromCharCode(ve)); while (ve && Q < v); if (u.flags & 512 && u.wrap & 4 && (u.check = crc32_1(u.check, f, Q, d)), v -= Q, d += Q, ve) break e } else u.head && (u.head.name = null); u.length = 0, u.mode = COMMENT; case COMMENT: if (u.flags & 4096) { if (v === 0) break e; Q = 0; do ve = f[d + Q++], u.head && ve && u.length < 65536 && (u.head.comment += String.fromCharCode(ve)); while (ve && Q < v); if (u.flags & 512 && u.wrap & 4 && (u.check = crc32_1(u.check, f, Q, d)), v -= Q, d += Q, ve) break e } else u.head && (u.head.comment = null); u.mode = HCRC; case HCRC: if (u.flags & 512) { for (; B < 16;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (u.wrap & 4 && F !== (u.check & 65535)) { o.msg = "header crc mismatch", u.mode = BAD; break } F = 0, B = 0 } u.head && (u.head.hcrc = u.flags >> 9 & 1, u.head.done = !0), o.adler = u.check = 0, u.mode = TYPE; break; case DICTID: for (; B < 32;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } o.adler = u.check = zswap32(F), F = 0, B = 0, u.mode = DICT; case DICT: if (u.havedict === 0) return o.next_out = m, o.avail_out = I, o.next_in = d, o.avail_in = v, u.hold = F, u.bits = B, Z_NEED_DICT$1; o.adler = u.check = 1, u.mode = TYPE; case TYPE: if (l === Z_BLOCK || l === Z_TREES) break e; case TYPEDO: if (u.last) { F >>>= B & 7, B -= B & 7, u.mode = CHECK; break } for (; B < 3;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } switch (u.last = F & 1, F >>>= 1, B -= 1, F & 3) { case 0: u.mode = STORED; break; case 1: if (fixedtables(u), u.mode = LEN_, l === Z_TREES) { F >>>= 2, B -= 2; break e } break; case 2: u.mode = TABLE; break; case 3: o.msg = "invalid block type", u.mode = BAD }F >>>= 2, B -= 2; break; case STORED: for (F >>>= B & 7, B -= B & 7; B < 32;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if ((F & 65535) !== (F >>> 16 ^ 65535)) { o.msg = "invalid stored block lengths", u.mode = BAD; break } if (u.length = F & 65535, F = 0, B = 0, u.mode = COPY_, l === Z_TREES) break e; case COPY_: u.mode = COPY; case COPY: if (Q = u.length, Q) { if (Q > v && (Q = v), Q > I && (Q = I), Q === 0) break e; p.set(f.subarray(d, d + Q), m), v -= Q, d += Q, I -= Q, m += Q, u.length -= Q; break } u.mode = TYPE; break; case TABLE: for (; B < 14;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (u.nlen = (F & 31) + 257, F >>>= 5, B -= 5, u.ndist = (F & 31) + 1, F >>>= 5, B -= 5, u.ncode = (F & 15) + 4, F >>>= 4, B -= 4, u.nlen > 286 || u.ndist > 30) { o.msg = "too many length or distance symbols", u.mode = BAD; break } u.have = 0, u.mode = LENLENS; case LENLENS: for (; u.have < u.ncode;) { for (; B < 3;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } u.lens[g[u.have++]] = F & 7, F >>>= 3, B -= 3 } for (; u.have < 19;)u.lens[g[u.have++]] = 0; if (u.lencode = u.lendyn, u.lenbits = 7, $e = { bits: u.lenbits }, _e = inftrees(CODES, u.lens, 0, 19, u.lencode, 0, u.work, $e), u.lenbits = $e.bits, _e) { o.msg = "invalid code lengths set", u.mode = BAD; break } u.have = 0, u.mode = CODELENS; case CODELENS: for (; u.have < u.nlen + u.ndist;) { for (; oe = u.lencode[F & (1 << u.lenbits) - 1], ae = oe >>> 24, se = oe >>> 16 & 255, le = oe & 65535, !(ae <= B);) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (le < 16) F >>>= ae, B -= ae, u.lens[u.have++] = le; else { if (le === 16) { for (ie = ae + 2; B < ie;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (F >>>= ae, B -= ae, u.have === 0) { o.msg = "invalid bit length repeat", u.mode = BAD; break } ve = u.lens[u.have - 1], Q = 3 + (F & 3), F >>>= 2, B -= 2 } else if (le === 17) { for (ie = ae + 3; B < ie;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } F >>>= ae, B -= ae, ve = 0, Q = 3 + (F & 7), F >>>= 3, B -= 3 } else { for (ie = ae + 7; B < ie;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } F >>>= ae, B -= ae, ve = 0, Q = 11 + (F & 127), F >>>= 7, B -= 7 } if (u.have + Q > u.nlen + u.ndist) { o.msg = "invalid bit length repeat", u.mode = BAD; break } for (; Q--;)u.lens[u.have++] = ve } } if (u.mode === BAD) break; if (u.lens[256] === 0) { o.msg = "invalid code -- missing end-of-block", u.mode = BAD; break } if (u.lenbits = 9, $e = { bits: u.lenbits }, _e = inftrees(LENS, u.lens, 0, u.nlen, u.lencode, 0, u.work, $e), u.lenbits = $e.bits, _e) { o.msg = "invalid literal/lengths set", u.mode = BAD; break } if (u.distbits = 6, u.distcode = u.distdyn, $e = { bits: u.distbits }, _e = inftrees(DISTS, u.lens, u.nlen, u.ndist, u.distcode, 0, u.work, $e), u.distbits = $e.bits, _e) { o.msg = "invalid distances set", u.mode = BAD; break } if (u.mode = LEN_, l === Z_TREES) break e; case LEN_: u.mode = LEN; case LEN: if (v >= 6 && I >= 258) { o.next_out = m, o.avail_out = I, o.next_in = d, o.avail_in = v, u.hold = F, u.bits = B, inffast(o, Z), m = o.next_out, p = o.output, I = o.avail_out, d = o.next_in, f = o.input, v = o.avail_in, F = u.hold, B = u.bits, u.mode === TYPE && (u.back = -1); break } for (u.back = 0; oe = u.lencode[F & (1 << u.lenbits) - 1], ae = oe >>> 24, se = oe >>> 16 & 255, le = oe & 65535, !(ae <= B);) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (se && (se & 240) === 0) { for (ue = ae, he = se, pe = le; oe = u.lencode[pe + ((F & (1 << ue + he) - 1) >> ue)], ae = oe >>> 24, se = oe >>> 16 & 255, le = oe & 65535, !(ue + ae <= B);) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } F >>>= ue, B -= ue, u.back += ue } if (F >>>= ae, B -= ae, u.back += ae, u.length = le, se === 0) { u.mode = LIT; break } if (se & 32) { u.back = -1, u.mode = TYPE; break } if (se & 64) { o.msg = "invalid literal/length code", u.mode = BAD; break } u.extra = se & 15, u.mode = LENEXT; case LENEXT: if (u.extra) { for (ie = u.extra; B < ie;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } u.length += F & (1 << u.extra) - 1, F >>>= u.extra, B -= u.extra, u.back += u.extra } u.was = u.length, u.mode = DIST; case DIST: for (; oe = u.distcode[F & (1 << u.distbits) - 1], ae = oe >>> 24, se = oe >>> 16 & 255, le = oe & 65535, !(ae <= B);) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if ((se & 240) === 0) { for (ue = ae, he = se, pe = le; oe = u.distcode[pe + ((F & (1 << ue + he) - 1) >> ue)], ae = oe >>> 24, se = oe >>> 16 & 255, le = oe & 65535, !(ue + ae <= B);) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } F >>>= ue, B -= ue, u.back += ue } if (F >>>= ae, B -= ae, u.back += ae, se & 64) { o.msg = "invalid distance code", u.mode = BAD; break } u.offset = le, u.extra = se & 15, u.mode = DISTEXT; case DISTEXT: if (u.extra) { for (ie = u.extra; B < ie;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } u.offset += F & (1 << u.extra) - 1, F >>>= u.extra, B -= u.extra, u.back += u.extra } if (u.offset > u.dmax) { o.msg = "invalid distance too far back", u.mode = BAD; break } u.mode = MATCH; case MATCH: if (I === 0) break e; if (Q = Z - I, u.offset > Q) { if (Q = u.offset - Q, Q > u.whave && u.sane) { o.msg = "invalid distance too far back", u.mode = BAD; break } Q > u.wnext ? (Q -= u.wnext, re = u.wsize - Q) : re = u.wnext - Q, Q > u.length && (Q = u.length), ne = u.window } else ne = p, re = m - u.offset, Q = u.length; Q > I && (Q = I), I -= Q, u.length -= Q; do p[m++] = ne[re++]; while (--Q); u.length === 0 && (u.mode = LEN); break; case LIT: if (I === 0) break e; p[m++] = u.length, I--, u.mode = LEN; break; case CHECK: if (u.wrap) { for (; B < 32;) { if (v === 0) break e; v--, F |= f[d++] << B, B += 8 } if (Z -= I, o.total_out += Z, u.total += Z, u.wrap & 4 && Z && (o.adler = u.check = u.flags ? crc32_1(u.check, p, Z, m - Z) : adler32_1(u.check, p, Z, m - Z)), Z = I, u.wrap & 4 && (u.flags ? F : zswap32(F)) !== u.check) { o.msg = "incorrect data check", u.mode = BAD; break } F = 0, B = 0 } u.mode = LENGTH; case LENGTH: if (u.wrap && u.flags) { for (; B < 32;) { if (v === 0) break e; v--, F += f[d++] << B, B += 8 } if (u.wrap & 4 && F !== (u.total & 4294967295)) { o.msg = "incorrect length check", u.mode = BAD; break } F = 0, B = 0 } u.mode = DONE; case DONE: _e = Z_STREAM_END$1; break e; case BAD: _e = Z_DATA_ERROR$1; break e; case MEM: return Z_MEM_ERROR$1; case SYNC: default: return Z_STREAM_ERROR$1 }return o.next_out = m, o.avail_out = I, o.next_in = d, o.avail_in = v, u.hold = F, u.bits = B, (u.wsize || Z !== o.avail_out && u.mode < BAD && (u.mode < CHECK || l !== Z_FINISH$1)) && updatewindow(o, o.output, o.next_out, Z - o.avail_out), W -= o.avail_in, Z -= o.avail_out, o.total_in += W, o.total_out += Z, u.total += Z, u.wrap & 4 && Z && (o.adler = u.check = u.flags ? crc32_1(u.check, p, Z, o.next_out - Z) : adler32_1(u.check, p, Z, o.next_out - Z)), o.data_type = u.bits + (u.last ? 64 : 0) + (u.mode === TYPE ? 128 : 0) + (u.mode === LEN_ || u.mode === COPY_ ? 256 : 0), (W === 0 && Z === 0 || l === Z_FINISH$1) && _e === Z_OK$1 && (_e = Z_BUF_ERROR), _e }, inflateEnd = o => { if (inflateStateCheck(o)) return Z_STREAM_ERROR$1; let l = o.state; return l.window && (l.window = null), o.state = null, Z_OK$1 }, inflateGetHeader = (o, l) => { if (inflateStateCheck(o)) return Z_STREAM_ERROR$1; const u = o.state; return (u.wrap & 2) === 0 ? Z_STREAM_ERROR$1 : (u.head = l, l.done = !1, Z_OK$1) }, inflateSetDictionary = (o, l) => { const u = l.length; let f, p, d; return inflateStateCheck(o) || (f = o.state, f.wrap !== 0 && f.mode !== DICT) ? Z_STREAM_ERROR$1 : f.mode === DICT && (p = 1, p = adler32_1(p, l, u, 0), p !== f.check) ? Z_DATA_ERROR$1 : (d = updatewindow(o, l, u, u), d ? (f.mode = MEM, Z_MEM_ERROR$1) : (f.havedict = 1, Z_OK$1)) }; var inflateReset_1 = inflateReset, inflateReset2_1 = inflateReset2, inflateResetKeep_1 = inflateResetKeep, inflateInit_1 = inflateInit, inflateInit2_1 = inflateInit2, inflate_2$1 = inflate$2, inflateEnd_1 = inflateEnd, inflateGetHeader_1 = inflateGetHeader, inflateSetDictionary_1 = inflateSetDictionary, inflateInfo = "pako inflate (from Nodeca project)", inflate_1$2 = { inflateReset: inflateReset_1, inflateReset2: inflateReset2_1, inflateResetKeep: inflateResetKeep_1, inflateInit: inflateInit_1, inflateInit2: inflateInit2_1, inflate: inflate_2$1, inflateEnd: inflateEnd_1, inflateGetHeader: inflateGetHeader_1, inflateSetDictionary: inflateSetDictionary_1, inflateInfo }; function GZheader() { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } var gzheader = GZheader; const toString = Object.prototype.toString, { Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2; function Inflate$1(o) { this.options = common$2.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, o || {}); const l = this.options; l.raw && l.windowBits >= 0 && l.windowBits < 16 && (l.windowBits = -l.windowBits, l.windowBits === 0 && (l.windowBits = -15)), l.windowBits >= 0 && l.windowBits < 16 && !(o && o.windowBits) && (l.windowBits += 32), l.windowBits > 15 && l.windowBits < 48 && (l.windowBits & 15) === 0 && (l.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream, this.strm.avail_out = 0; let u = inflate_1$2.inflateInit2(this.strm, l.windowBits); if (u !== Z_OK) throw new Error(messages[u]); if (this.header = new gzheader, inflate_1$2.inflateGetHeader(this.strm, this.header), l.dictionary && (typeof l.dictionary == "string" ? l.dictionary = strings$1.string2buf(l.dictionary) : toString.call(l.dictionary) === "[object ArrayBuffer]" && (l.dictionary = new Uint8Array(l.dictionary)), l.raw && (u = inflate_1$2.inflateSetDictionary(this.strm, l.dictionary), u !== Z_OK))) throw new Error(messages[u]) } Inflate$1.prototype.push = function (o, l) { const u = this.strm, f = this.options.chunkSize, p = this.options.dictionary; let d, m, v; if (this.ended) return !1; for (l === ~~l ? m = l : m = l === !0 ? Z_FINISH : Z_NO_FLUSH, toString.call(o) === "[object ArrayBuffer]" ? u.input = new Uint8Array(o) : u.input = o, u.next_in = 0, u.avail_in = u.input.length; ;) { for (u.avail_out === 0 && (u.output = new Uint8Array(f), u.next_out = 0, u.avail_out = f), d = inflate_1$2.inflate(u, m), d === Z_NEED_DICT && p && (d = inflate_1$2.inflateSetDictionary(u, p), d === Z_OK ? d = inflate_1$2.inflate(u, m) : d === Z_DATA_ERROR && (d = Z_NEED_DICT)); u.avail_in > 0 && d === Z_STREAM_END && u.state.wrap > 0 && o[u.next_in] !== 0;)inflate_1$2.inflateReset(u), d = inflate_1$2.inflate(u, m); switch (d) { case Z_STREAM_ERROR: case Z_DATA_ERROR: case Z_NEED_DICT: case Z_MEM_ERROR: return this.onEnd(d), this.ended = !0, !1 }if (v = u.avail_out, u.next_out && (u.avail_out === 0 || d === Z_STREAM_END)) if (this.options.to === "string") { let I = strings$1.utf8border(u.output, u.next_out), F = u.next_out - I, B = strings$1.buf2string(u.output, I); u.next_out = F, u.avail_out = f - F, F && u.output.set(u.output.subarray(I, I + F), 0), this.onData(B) } else this.onData(u.output.length === u.next_out ? u.output : u.output.subarray(0, u.next_out)); if (!(d === Z_OK && v === 0)) { if (d === Z_STREAM_END) return d = inflate_1$2.inflateEnd(this.strm), this.onEnd(d), this.ended = !0, !0; if (u.avail_in === 0) break } } return !0 }; Inflate$1.prototype.onData = function (o) { this.chunks.push(o) }; Inflate$1.prototype.onEnd = function (o) { o === Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common$2.flattenChunks(this.chunks)), this.chunks = [], this.err = o, this.msg = this.strm.msg }; function inflate$1(o, l) { const u = new Inflate$1(l); if (u.push(o), u.err) throw u.msg || messages[u.err]; return u.result } function inflateRaw$1(o, l) { return l = l || {}, l.raw = !0, inflate$1(o, l) } var Inflate_1$1 = Inflate$1, inflate_2 = inflate$1, inflateRaw_1$1 = inflateRaw$1, ungzip$1 = inflate$1, inflate_1$1 = { Inflate: Inflate_1$1, inflate: inflate_2, inflateRaw: inflateRaw_1$1, ungzip: ungzip$1 }; const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1, { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1; var Deflate_1 = Deflate, deflate_1 = deflate, deflateRaw_1 = deflateRaw, gzip_1 = gzip, Inflate_1 = Inflate, inflate_1 = inflate, inflateRaw_1 = inflateRaw, ungzip_1 = ungzip, constants_1 = constants$2, pako = { Deflate: Deflate_1, deflate: deflate_1, deflateRaw: deflateRaw_1, gzip: gzip_1, Inflate: Inflate_1, inflate: inflate_1, inflateRaw: inflateRaw_1, ungzip: ungzip_1, constants: constants_1 }, lib$1 = {}; const require$$0$1 = getAugmentedNamespace(mobx_esm); var lib = {}, localstorage = {}, hasRequiredLocalstorage; function requireLocalstorage() { if (hasRequiredLocalstorage) return localstorage; hasRequiredLocalstorage = 1; var o = localstorage && localstorage.__values || function (f) { var p = typeof Symbol == "function" && f[Symbol.iterator], d = 0; return p ? p.call(f) : { next: function () { return f && d >= f.length && (f = void 0), { value: f && f[d++], done: !f } } } }; Object.defineProperty(localstorage, "__esModule", { value: !0 }); var l = function () { function f(p, d) { var m = this; this._events = {}, p ? this.supported = !0 : (this.supported = !1, p = new Window), this.storage = d || p.localStorage, u(p, function (v) { var I = v.key, F = v.newValue; I && m.feed(I, F) }) } return Object.defineProperty(f.prototype, "length", { get: function () { return this.storage.length }, enumerable: !0, configurable: !0 }), f.prototype.key = function (p) { return this.storage.key(p) }, f.prototype.getItem = function (p) { return this.storage.getItem(p) }, f.prototype.setItem = function (p, d) { this.storage.setItem(p, d), this.emit("change", p, d) }, f.prototype.removeItem = function (p) { this.storage.removeItem(p), this.emit("change", p, null) }, f.prototype.clear = function () { this.storage.clear() }, f.prototype.on = function (p, d) { var m = this._events[p]; m || (this._events[p] = m = new Set), m.add(d) }, f.prototype.off = function (p, d) { var m = this._events[p]; m && m.delete(d) }, f.prototype.feed = function (p, d) { this.emit("change", p, d) }, f.prototype.emit = function (p) { for (var d = [], m = 1; m < arguments.length; m++)d[m - 1] = arguments[m]; var v, I, F = this._events[p]; if (F) try { for (var B = o(F.values()), W = B.next(); !W.done; W = B.next()) { var Z = W.value; Z.apply(null, d) } } catch (Q) { v = { error: Q } } finally { try { W && !W.done && (I = B.return) && I.call(B) } finally { if (v) throw v.error } } }, f }(); localstorage.LocalStorage = l; function u(f, p) { if (f.addEventListener) f.addEventListener("storage", p, !0); else if (f.attachEvent) f.attachEvent("storage", p); else return !1; return !0 } return localstorage.listen = u, localstorage } var hasRequiredLib$1; function requireLib$1() { if (hasRequiredLib$1) return lib; hasRequiredLib$1 = 1, Object.defineProperty(lib, "__esModule", { value: !0 }); var o = requireLocalstorage(), l = typeof window < "u" ? window : typeof commonjsGlobal < "u" ? commonjsGlobal : void 0, u = new o.LocalStorage(l); return lib.default = u, lib } var hasRequiredLib; function requireLib() { if (hasRequiredLib) return lib$1; hasRequiredLib = 1; var o = lib$1 && lib$1.__decorate || function (F, B, W, Z) { var Q = arguments.length, re = Q < 3 ? B : Z === null ? Z = Object.getOwnPropertyDescriptor(B, W) : Z, ne; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") re = Reflect.decorate(F, B, W, Z); else for (var oe = F.length - 1; oe >= 0; oe--)(ne = F[oe]) && (re = (Q < 3 ? ne(re) : Q > 3 ? ne(B, W, re) : ne(B, W)) || re); return Q > 3 && re && Object.defineProperty(B, W, re), re }, l = lib$1 && lib$1.__metadata || function (F, B) { if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(F, B) }, u = lib$1 && lib$1.__generator || function (F, B) { var W = { label: 0, sent: function () { if (re[0] & 1) throw re[1]; return re[1] }, trys: [], ops: [] }, Z, Q, re, ne; return ne = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ne[Symbol.iterator] = function () { return this }), ne; function oe(se) { return function (le) { return ae([se, le]) } } function ae(se) { if (Z) throw new TypeError("Generator is already executing."); for (; W;)try { if (Z = 1, Q && (re = se[0] & 2 ? Q.return : se[0] ? Q.throw || ((re = Q.return) && re.call(Q), 0) : Q.next) && !(re = re.call(Q, se[1])).done) return re; switch (Q = 0, re && (se = [se[0] & 2, re.value]), se[0]) { case 0: case 1: re = se; break; case 4: return W.label++, { value: se[1], done: !1 }; case 5: W.label++, Q = se[1], se = [0]; continue; case 7: se = W.ops.pop(), W.trys.pop(); continue; default: if (re = W.trys, !(re = re.length > 0 && re[re.length - 1]) && (se[0] === 6 || se[0] === 2)) { W = 0; continue } if (se[0] === 3 && (!re || se[1] > re[0] && se[1] < re[3])) { W.label = se[1]; break } if (se[0] === 6 && W.label < re[1]) { W.label = re[1], re = se; break } if (re && W.label < re[2]) { W.label = re[2], W.ops.push(se); break } re[2] && W.ops.pop(), W.trys.pop(); continue }se = B.call(F, W) } catch (le) { se = [6, le], Q = 0 } finally { Z = re = 0 } if (se[0] & 5) throw se[1]; return { value: se[0] ? se[1] : void 0, done: !0 } } }, f = lib$1 && lib$1.__values || function (F) { var B = typeof Symbol == "function" && F[Symbol.iterator], W = 0; return B ? B.call(F) : { next: function () { return F && W >= F.length && (F = void 0), { value: F && F[W++], done: !F } } } }, p = lib$1 && lib$1.__read || function (F, B) { var W = typeof Symbol == "function" && F[Symbol.iterator]; if (!W) return F; var Z = W.call(F), Q, re = [], ne; try { for (; (B === void 0 || B-- > 0) && !(Q = Z.next()).done;)re.push(Q.value) } catch (oe) { ne = { error: oe } } finally { try { Q && !Q.done && (W = Z.return) && W.call(Z) } finally { if (ne) throw ne.error } } return re }; Object.defineProperty(lib$1, "__esModule", { value: !0 }); var d = require$$0$1, m = requireLib$1(), v = function () { function F() { var B = this; this[Symbol.toStringTag] = "Map", this._keyBoxes = new Map, this._valueBoxes = new Map, this._keys = new Set, this._keysAtom = d.createAtom("mobx storage keys"), this._is_all_keys_observed = !1, m.default.on("change", d.action(function (W, Z) { typeof W == "string" ? typeof Z == "string" ? B._set(W, Z) : B._delete(W) : B._clear() })) } return Object.defineProperty(F.prototype, "length", { get: function () { return this.size }, enumerable: !0, configurable: !0 }), Object.defineProperty(F.prototype, "size", { get: function () { return this._keysAtom.reportObserved(), this._syncAllKeys(), this._keys.size }, enumerable: !0, configurable: !0 }), F.prototype.key = function (B) { return m.default.key(B) }, F.prototype.getItem = function (B) { return this.get(B) }, F.prototype.setItem = function (B, W) { this.set(B, W) }, F.prototype.removeItem = function (B) { this.delete(B) }, F.prototype.has = function (B) { return this._get_key_box(B).get() }, F.prototype.get = function (B) { return this._get_value_box(B).get() }, F.prototype.set = function (B, W) { return m.default.setItem(B, JSON.stringify(d.toJS(W))), this }, F.prototype.delete = function (B) { var W = this._is_all_keys_observed ? this._keys.has(B) : typeof m.default.getItem(B) == "string"; return m.default.removeItem(B), W }, F.prototype.clear = function () { m.default.clear() }, F.prototype.keys = function () { return this._keysAtom.reportObserved(), this._syncAllKeys(), this._keys.values() }, F.prototype.values = function () { var B, W, Z, Q, re, ne; return u(this, function (oe) { switch (oe.label) { case 0: oe.trys.push([0, 5, 6, 7]), Z = f(this.keys()), Q = Z.next(), oe.label = 1; case 1: return Q.done ? [3, 4] : (re = Q.value, [4, this._get_value_box(re).get()]); case 2: oe.sent(), oe.label = 3; case 3: return Q = Z.next(), [3, 1]; case 4: return [3, 7]; case 5: return ne = oe.sent(), B = { error: ne }, [3, 7]; case 6: try { Q && !Q.done && (W = Z.return) && W.call(Z) } finally { if (B) throw B.error } return [7]; case 7: return [2] } }) }, F.prototype.entries = function () { var B, W, Z, Q, re, ne; return u(this, function (oe) { switch (oe.label) { case 0: oe.trys.push([0, 5, 6, 7]), Z = f(this.keys()), Q = Z.next(), oe.label = 1; case 1: return Q.done ? [3, 4] : (re = Q.value, [4, [re, this._get_value_box(re).get()]]); case 2: oe.sent(), oe.label = 3; case 3: return Q = Z.next(), [3, 1]; case 4: return [3, 7]; case 5: return ne = oe.sent(), B = { error: ne }, [3, 7]; case 6: try { Q && !Q.done && (W = Z.return) && W.call(Z) } finally { if (B) throw B.error } return [7]; case 7: return [2] } }) }, F.prototype[Symbol.iterator] = function () { return this.entries() }, F.prototype.forEach = function (B, W) { var Z, Q; this._keysAtom.reportChanged(), this._syncAllKeys(); try { for (var re = f(this.entries()), ne = re.next(); !ne.done; ne = re.next()) { var oe = p(ne.value, 2), ae = oe[0], se = oe[1]; B.call(W, se, ae, this) } } catch (le) { Z = { error: le } } finally { try { ne && !ne.done && (Q = re.return) && Q.call(re) } finally { if (Z) throw Z.error } } }, F.prototype._set = function (B, W) { this._keysAtom.reportChanged(), this._keys.add(B); var Z = this._keyBoxes.get(B); Z && Z.set(!0); var Q = this._valueBoxes.get(B); Q && Q.set(I(W)) }, F.prototype._delete = function (B) { this._keysAtom.reportChanged(), this._keys.delete(B); var W = this._keyBoxes.get(B); W && W.set(!1); var Z = this._valueBoxes.get(B); Z && Z.set(null) }, F.prototype._clear = function () { var B, W, Z, Q; this._keysAtom.reportChanged(), this._keys.clear(); try { for (var re = f(this._keyBoxes.values()), ne = re.next(); !ne.done; ne = re.next()) { var oe = ne.value; oe.set(!1) } } catch (le) { B = { error: le } } finally { try { ne && !ne.done && (W = re.return) && W.call(re) } finally { if (B) throw B.error } } try { for (var ae = f(this._valueBoxes.values()), se = ae.next(); !se.done; se = ae.next()) { var oe = se.value; oe.set(null) } } catch (le) { Z = { error: le } } finally { try { se && !se.done && (Q = ae.return) && Q.call(ae) } finally { if (Z) throw Z.error } } }, F.prototype._get_key_box = function (B) { var W = this._keyBoxes, Z = W.get(B); if (!Z) { var Q = this._is_all_keys_observed ? !1 : typeof m.default.getItem(B) == "string"; W.set(B, Z = d.observable.box(Q)) } return Z }, F.prototype._get_value_box = function (B) { var W = this._valueBoxes, Z = W.get(B); if (!Z) { var Q = this._is_all_keys_observed ? null : m.default.getItem(B); W.set(B, Z = d.observable.box(I(Q))) } return Z }, F.prototype._syncAllKeys = function () { if (!this._is_all_keys_observed) { this._is_all_keys_observed = !0; var B = m.default.length, W = this._keyBoxes, Z = this._keys; Z.clear(); for (var Q = 0; Q < B; Q++) { var re = m.default.key(Q); typeof re == "string" && (Z.add(re), !W.has(re) && W.set(re, d.observable.box(!0))) } } }, o([d.action, l("design:type", Function), l("design:paramtypes", [String, Object]), l("design:returntype", void 0)], F.prototype, "set", null), o([d.action, l("design:type", Function), l("design:paramtypes", [String]), l("design:returntype", void 0)], F.prototype, "delete", null), o([d.action, l("design:type", Function), l("design:paramtypes", []), l("design:returntype", void 0)], F.prototype, "clear", null), F }(); lib$1.LocalStorage = v; function I(F) { try { return JSON.parse(F) } catch { } return F } return lib$1.parseValue = I, lib$1.default = new v, lib$1 } var libExports = requireLib(); const mobxLocalStorage = getDefaultExportFromCjs$1(libExports); var NOOP = function () { }; function fail(o) { throw new Error("[mobx-utils] " + o) } function invariant$2(o, l) { l === void 0 && (l = "Illegal state"), o || fail(l) } var deepFields = function (o) { return o && o !== Object.prototype && Object.getOwnPropertyNames(o).concat(deepFields(Object.getPrototypeOf(o)) || []) }, distinctDeepFields = function (o) { var l = deepFields(o), u = l.filter(function (f, p) { return l.indexOf(f) === p }); return u }, getAllMethodsAndProperties = function (o) { return distinctDeepFields(o).filter(function (l) { return l !== "constructor" && !~l.indexOf("__") }) }, PENDING = "pending", FULFILLED = "fulfilled", REJECTED = "rejected"; function caseImpl(o) { switch (this.state) { case PENDING: return o.pending && o.pending(this.value); case REJECTED: return o.rejected && o.rejected(this.value); case FULFILLED: return o.fulfilled ? o.fulfilled(this.value) : this.value } } function fromPromise(o, l) { if (invariant$2(arguments.length <= 2, "fromPromise expects up to two arguments"), invariant$2(typeof o == "function" || typeof o == "object" && o && typeof o.then == "function", "Please pass a promise or function to fromPromise"), o.isPromiseBasedObservable === !0) return o; typeof o == "function" && (o = new Promise(o)); var u = o; o.then(action("observableFromPromise-resolve", function (p) { u.value = p, u.state = FULFILLED }), action("observableFromPromise-reject", function (p) { u.value = p, u.state = REJECTED })), u.isPromiseBasedObservable = !0, u.case = caseImpl; var f = l && (l.state === FULFILLED || l.state === PENDING) ? l.value : void 0; return extendObservable(u, { value: f, state: PENDING }, {}, { deep: !1 }), u } (function (o) { o.reject = action("fromPromise.reject", function (u) { var f = o(Promise.reject(u)); return f.state = REJECTED, f.value = u, f }); function l(u) { u === void 0 && (u = void 0); var f = o(Promise.resolve(u)); return f.state = FULFILLED, f.value = u, f } o.resolve = action("fromPromise.resolve", l) })(fromPromise || (fromPromise = {})); function fromResource(o, l, u) { l === void 0 && (l = NOOP), u === void 0 && (u = void 0); var f = !1, p = !1, d = u, m = function () { f && (f = !1, l()) }, v = createAtom("ResourceBasedObservable", function () { invariant$2(!f && !p), f = !0, o(function (I) { allowStateChanges(!0, function () { d = I, v.reportChanged() }) }) }, m); return { current: function () { invariant$2(!p, "subscribingObservable has already been disposed"); var I = v.reportObserved(); return !I && !f && console.warn("Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started"), d }, dispose: function () { p = !0, m() }, isAlive: function () { return f } } } var __decorate = function (o, l, u, f) { var p = arguments.length, d = p < 3 ? l : f === null ? f = Object.getOwnPropertyDescriptor(l, u) : f, m; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") d = Reflect.decorate(o, l, u, f); else for (var v = o.length - 1; v >= 0; v--)(m = o[v]) && (d = (p < 3 ? m(d) : p > 3 ? m(l, u, d) : m(l, u)) || d); return p > 3 && d && Object.defineProperty(l, u, d), d }; (function () { function o(l, u) { var f = this; Object.defineProperty(this, "current", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "subscription", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), makeObservable(this), runInAction(function () { f.current = u, f.subscription = l.subscribe(f) }) } return Object.defineProperty(o.prototype, "dispose", { enumerable: !1, configurable: !0, writable: !0, value: function () { this.subscription && this.subscription.unsubscribe() } }), Object.defineProperty(o.prototype, "next", { enumerable: !1, configurable: !0, writable: !0, value: function (l) { this.current = l } }), Object.defineProperty(o.prototype, "complete", { enumerable: !1, configurable: !0, writable: !0, value: function () { this.dispose() } }), Object.defineProperty(o.prototype, "error", { enumerable: !1, configurable: !0, writable: !0, value: function (l) { this.current = l, this.dispose() } }), __decorate([observable.ref], o.prototype, "current", void 0), __decorate([action.bound], o.prototype, "next", null), __decorate([action.bound], o.prototype, "complete", null), __decorate([action.bound], o.prototype, "error", null), o })(); var __assign$1 = function () { return __assign$1 = Object.assign || function (o) { for (var l, u = 1, f = arguments.length; u < f; u++) { l = arguments[u]; for (var p in l) Object.prototype.hasOwnProperty.call(l, p) && (o[p] = l[p]) } return o }, __assign$1.apply(this, arguments) }, __decorate$1 = function (o, l, u, f) { var p = arguments.length, d = p < 3 ? l : f === null ? f = Object.getOwnPropertyDescriptor(l, u) : f, m; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") d = Reflect.decorate(o, l, u, f); else for (var v = o.length - 1; v >= 0; v--)(m = o[v]) && (d = (p < 3 ? m(d) : p > 3 ? m(l, u, d) : m(l, u)) || d); return p > 3 && d && Object.defineProperty(l, u, d), d }, RESERVED_NAMES = ["model", "reset", "submit", "isDirty", "isPropertyDirty", "resetProperty"]; (function () { function o(l) { var u = this; Object.defineProperty(this, "model", { enumerable: !0, configurable: !0, writable: !0, value: l }), Object.defineProperty(this, "localValues", { enumerable: !0, configurable: !0, writable: !0, value: observable.map({}) }), Object.defineProperty(this, "localComputedValues", { enumerable: !0, configurable: !0, writable: !0, value: observable.map({}) }), Object.defineProperty(this, "isPropertyDirty", { enumerable: !0, configurable: !0, writable: !0, value: function (p) { return u.localValues.has(p) } }), makeObservable(this), invariant$2(isObservableObject(l), "createViewModel expects an observable object"); var f = getAllMethodsAndProperties(this); getAllMethodsAndProperties(l).forEach(function (p) { var d; if (!f.includes(p) && !(p === $mobx || p === "__mobxDidRunLazyInitializers")) { if (invariant$2(RESERVED_NAMES.indexOf(p) === -1, "The propertyname " + p + " is reserved and cannot be used with viewModels"), isComputedProp(l, p)) { var m = getAdministration(l, p), v = m.derivation.bind(u), I = (d = m.setter_) === null || d === void 0 ? void 0 : d.bind(u); u.localComputedValues.set(p, computed$1(v, { set: I })) } var F = Object.getOwnPropertyDescriptor(l, p), B = F ? { enumerable: F.enumerable } : {}; Object.defineProperty(u, p, __assign$1(__assign$1({}, B), { configurable: !0, get: function () { return isComputedProp(l, p) ? u.localComputedValues.get(p).get() : u.isPropertyDirty(p) ? u.localValues.get(p) : u.model[p] }, set: action(function (W) { isComputedProp(l, p) ? u.localComputedValues.get(p).set(W) : W !== u.model[p] ? u.localValues.set(p, W) : u.localValues.delete(p) }) })) } }) } return Object.defineProperty(o.prototype, "isDirty", { get: function () { return this.localValues.size > 0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "changedValues", { get: function () { return new Map(this.localValues) }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, "submit", { enumerable: !1, configurable: !0, writable: !0, value: function () { var l = this; keys(this.localValues).forEach(function (u) { var f = l.localValues.get(u), p = l.model[u]; isObservableArray(p) ? p.replace(f) : isObservableMap(p) ? (p.clear(), p.merge(f)) : isComputed(f) || (l.model[u] = f) }), this.localValues.clear() } }), Object.defineProperty(o.prototype, "reset", { enumerable: !1, configurable: !0, writable: !0, value: function () { this.localValues.clear() } }), Object.defineProperty(o.prototype, "resetProperty", { enumerable: !1, configurable: !0, writable: !0, value: function (l) { this.localValues.delete(l) } }), __decorate$1([computed$1], o.prototype, "isDirty", null), __decorate$1([computed$1], o.prototype, "changedValues", null), __decorate$1([action.bound], o.prototype, "submit", null), __decorate$1([action.bound], o.prototype, "reset", null), __decorate$1([action.bound], o.prototype, "resetProperty", null), o })(); var tickers = {}; function now$2(o) { return isComputingDerivation() ? (tickers[o] || (tickers[o] = createAnimationFrameTicker()), tickers[o].current()) : Date.now() } function createAnimationFrameTicker() { var o = fromResource(function (l) { l(Date.now()); function u() { window.requestAnimationFrame(function () { l(Date.now()), o.isAlive() && u() }) } u() }, function () { }, Date.now()); return o } var __extends = function () { var o = function (l, u) { return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (f, p) { f.__proto__ = p } || function (f, p) { for (var d in p) Object.prototype.hasOwnProperty.call(p, d) && (f[d] = p[d]) }, o(l, u) }; return function (l, u) { o(l, u); function f() { this.constructor = l } l.prototype = u === null ? Object.create(u) : (f.prototype = u.prototype, new f) } }(); (function (o) { __extends(l, o); function l(u, f, p) { var d = p === void 0 ? {} : p, m = d.name, v = m === void 0 ? "ogm" + (Math.random() * 1e3 | 0) : m, I = d.keyToName, F = I === void 0 ? function (Z) { return "" + Z } : I, B = o.call(this) || this; Object.defineProperty(B, "_base", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(B, "_ogmInfoKey", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(B, "_groupBy", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(B, "_keyToName", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(B, "_disposeBaseObserver", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), B._keyToName = F, B._groupBy = f, B._ogmInfoKey = Symbol("ogmInfo" + v), B._base = u; for (var W = 0; W < u.length; W++)B._addItem(u[W]); return B._disposeBaseObserver = observe(B._base, function (Z) { if (Z.type === "splice") transaction(function () { for (var Q = 0, re = Z.removed; Q < re.length; Q++) { var ne = re[Q]; B._removeItem(ne) } for (var oe = 0, ae = Z.added; oe < ae.length; oe++) { var se = ae[oe]; B._addItem(se) } }); else if (Z.type === "update") transaction(function () { B._removeItem(Z.oldValue), B._addItem(Z.newValue) }); else throw new Error("illegal state") }), B } return Object.defineProperty(l.prototype, "clear", { enumerable: !1, configurable: !0, writable: !0, value: function () { throw new Error("not supported") } }), Object.defineProperty(l.prototype, "delete", { enumerable: !1, configurable: !0, writable: !0, value: function (u) { throw new Error("not supported") } }), Object.defineProperty(l.prototype, "set", { enumerable: !1, configurable: !0, writable: !0, value: function (u, f) { throw new Error("not supported") } }), Object.defineProperty(l.prototype, "dispose", { enumerable: !1, configurable: !0, writable: !0, value: function () { this._disposeBaseObserver(); for (var u = 0; u < this._base.length; u++) { var f = this._base[u], p = f[this._ogmInfoKey]; p.reaction(), delete f[this._ogmInfoKey] } } }), Object.defineProperty(l.prototype, "_getGroupArr", { enumerable: !1, configurable: !0, writable: !0, value: function (u) { var f = o.prototype.get.call(this, u); return f === void 0 && (f = observable([], { name: "GroupArray[" + this._keyToName(u) + "]", deep: !1 }), o.prototype.set.call(this, u, f)), f } }), Object.defineProperty(l.prototype, "_removeFromGroupArr", { enumerable: !1, configurable: !0, writable: !0, value: function (u, f) { var p = o.prototype.get.call(this, u); p.length === 1 ? o.prototype.delete.call(this, u) : (f === p.length - 1 || (p[f] = p[p.length - 1], p[f][this._ogmInfoKey].groupArrIndex = f), p.length--) } }), Object.defineProperty(l.prototype, "_addItem", { enumerable: !1, configurable: !0, writable: !0, value: function (u) { var f = this, p = this._groupBy(u), d = this._getGroupArr(p), m = { groupByValue: p, groupArrIndex: d.length, reaction: reaction(function () { return f._groupBy(u) }, function (v, I) { var F = u[f._ogmInfoKey]; f._removeFromGroupArr(F.groupByValue, F.groupArrIndex); var B = f._getGroupArr(v), W = B.length; B.push(u), F.groupByValue = v, F.groupArrIndex = W }) }; Object.defineProperty(u, this._ogmInfoKey, { configurable: !0, enumerable: !1, value: m }), d.push(u) } }), Object.defineProperty(l.prototype, "_removeItem", { enumerable: !1, configurable: !0, writable: !0, value: function (u) { var f = u[this._ogmInfoKey]; this._removeFromGroupArr(f.groupByValue, f.groupArrIndex), f.reaction(), delete u[this._ogmInfoKey] } }), l })(ObservableMap); var DeepMapEntry = function () { function o(l, u) { Object.defineProperty(this, "base", { enumerable: !0, configurable: !0, writable: !0, value: l }), Object.defineProperty(this, "args", { enumerable: !0, configurable: !0, writable: !0, value: u }), Object.defineProperty(this, "root", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "closest", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "closestIdx", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "isDisposed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }); for (var f = this.closest = this.root = l, p = 0; p < this.args.length - 1 && (f = f.get(u[p]), f); p++)this.closest = f; this.closestIdx = p } return Object.defineProperty(o.prototype, "exists", { enumerable: !1, configurable: !0, writable: !0, value: function () { this.assertNotDisposed(); var l = this.args.length; return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]) } }), Object.defineProperty(o.prototype, "get", { enumerable: !1, configurable: !0, writable: !0, value: function () { if (this.assertNotDisposed(), !this.exists()) throw new Error("Entry doesn't exist"); return this.closest.get(this.args[this.args.length - 1]) } }), Object.defineProperty(o.prototype, "set", { enumerable: !1, configurable: !0, writable: !0, value: function (l) { this.assertNotDisposed(); for (var u = this.args.length, f = this.closest, p = this.closestIdx; p < u - 1; p++) { var d = new Map; f.set(this.args[p], d), f = d } this.closestIdx = u - 1, this.closest = f, f.set(this.args[u - 1], l) } }), Object.defineProperty(o.prototype, "delete", { enumerable: !1, configurable: !0, writable: !0, value: function () { if (this.assertNotDisposed(), !this.exists()) throw new Error("Entry doesn't exist"); var l = this.args.length; this.closest.delete(this.args[l - 1]); for (var u = this.root, f = [u], p = 0; p < l - 1; p++)u = u.get(this.args[p]), f.push(u); for (var p = f.length - 1; p > 0; p--)f[p].size === 0 && f[p - 1].delete(this.args[p - 1]); this.isDisposed = !0 } }), Object.defineProperty(o.prototype, "assertNotDisposed", { enumerable: !1, configurable: !0, writable: !0, value: function () { if (this.isDisposed) throw new Error("Concurrent modification exception") } }), o }(), DeepMap = function () { function o() { Object.defineProperty(this, "store", { enumerable: !0, configurable: !0, writable: !0, value: new Map }), Object.defineProperty(this, "argsLength", { enumerable: !0, configurable: !0, writable: !0, value: -1 }), Object.defineProperty(this, "last", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } return Object.defineProperty(o.prototype, "entry", { enumerable: !1, configurable: !0, writable: !0, value: function (l) { if (this.argsLength === -1) this.argsLength = l.length; else if (this.argsLength !== l.length) throw new Error("DeepMap should be used with functions with a consistent length, expected: " + this.argsLength + ", got: " + l.length); return this.last && (this.last.isDisposed = !0), this.last = new DeepMapEntry(this.store, l) } }), o }(), __assign$2 = function () { return __assign$2 = Object.assign || function (o) { for (var l, u = 1, f = arguments.length; u < f; u++) { l = arguments[u]; for (var p in l) Object.prototype.hasOwnProperty.call(l, p) && (o[p] = l[p]) } return o }, __assign$2.apply(this, arguments) }, __spreadArrays$1 = function () { for (var o = 0, l = 0, u = arguments.length; l < u; l++)o += arguments[l].length; for (var f = Array(o), p = 0, l = 0; l < u; l++)for (var d = arguments[l], m = 0, v = d.length; m < v; m++, p++)f[p] = d[m]; return f }; function computedFn(o, l) { if (l === void 0 && (l = !1), isAction(o)) throw new Error("computedFn shouldn't be used on actions"); var u = !1, f = 0, p = typeof l == "boolean" ? { keepAlive: l } : l, d = new DeepMap; return function () { for (var m = this, v = [], I = 0; I < arguments.length; I++)v[I] = arguments[I]; var F = d.entry(v); if (F.exists()) return F.get().get(); if (!p.keepAlive && !isComputingDerivation()) return !u && getGlobalState().computedRequiresReaction && (console.warn("invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set"), u = !0), o.apply(this, v); var B, W = computed$1(function () { return B = o.apply(m, v) }, __assign$2(__assign$2({}, p), { name: "computedFn(" + (p.name || o.name) + "#" + ++f + ")" })); return F.set(W), p.keepAlive || onBecomeUnobserved(W, function () { d.entry(v).delete(), p.onCleanup && p.onCleanup.apply(p, __spreadArrays$1([B], v)), B = void 0 }), W.get() } } const DEBUG_BUILD$4 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, SDK_VERSION = "8.55.0", GLOBAL_OBJ = globalThis; function getGlobalSingleton(o, l, u) { const f = GLOBAL_OBJ, p = f.__SENTRY__ = f.__SENTRY__ || {}, d = p[SDK_VERSION] = p[SDK_VERSION] || {}; return d[o] || (d[o] = l()) } const DEBUG_BUILD$3 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, PREFIX = "Sentry Logger ", CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert", "trace"], originalConsoleMethods = {}; function consoleSandbox(o) { if (!("console" in GLOBAL_OBJ)) return o(); const l = GLOBAL_OBJ.console, u = {}, f = Object.keys(originalConsoleMethods); f.forEach(p => { const d = originalConsoleMethods[p]; u[p] = l[p], l[p] = d }); try { return o() } finally { f.forEach(p => { l[p] = u[p] }) } } function makeLogger() { let o = !1; const l = { enable: () => { o = !0 }, disable: () => { o = !1 }, isEnabled: () => o }; return DEBUG_BUILD$3 ? CONSOLE_LEVELS.forEach(u => { l[u] = (...f) => { o && consoleSandbox(() => { GLOBAL_OBJ.console[u](`${PREFIX}[${u}]:`, ...f) }) } }) : CONSOLE_LEVELS.forEach(u => { l[u] = () => { } }), l } const logger = getGlobalSingleton("logger", makeLogger), STACKTRACE_FRAME_LIMIT = 50, UNKNOWN_FUNCTION = "?", WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/, STRIP_FRAME_REGEXP = /captureMessage|captureException/; function createStackParser(...o) {
  const l = o.sort((u, f) => u[0] - f[0]).map(u => u[1]); return (u, f = 0, p = 0) => {
    const d = [], m = u.split(`
`); for (let v = f; v < m.length; v++) { const I = m[v]; if (I.length > 1024) continue; const F = WEBPACK_ERROR_REGEXP.test(I) ? I.replace(WEBPACK_ERROR_REGEXP, "$1") : I; if (!F.match(/\S*Error: /)) { for (const B of l) { const W = B(F); if (W) { d.push(W); break } } if (d.length >= STACKTRACE_FRAME_LIMIT + p) break } } return stripSentryFramesAndReverse(d.slice(p))
  }
} function stackParserFromStackParserOptions(o) { return Array.isArray(o) ? createStackParser(...o) : o } function stripSentryFramesAndReverse(o) { if (!o.length) return []; const l = Array.from(o); return /sentryWrapped/.test(getLastStackFrame(l).function || "") && l.pop(), l.reverse(), STRIP_FRAME_REGEXP.test(getLastStackFrame(l).function || "") && (l.pop(), STRIP_FRAME_REGEXP.test(getLastStackFrame(l).function || "") && l.pop()), l.slice(0, STACKTRACE_FRAME_LIMIT).map(u => ({ ...u, filename: u.filename || getLastStackFrame(l).filename, function: u.function || UNKNOWN_FUNCTION })) } function getLastStackFrame(o) { return o[o.length - 1] || {} } const defaultFunctionName = "<anonymous>"; function getFunctionName(o) { try { return !o || typeof o != "function" ? defaultFunctionName : o.name || defaultFunctionName } catch { return defaultFunctionName } } function getFramesFromEvent(o) { const l = o.exception; if (l) { const u = []; try { return l.values.forEach(f => { f.stacktrace.frames && u.push(...f.stacktrace.frames) }), u } catch { return } } } const handlers = {}, instrumented = {}; function addHandler(o, l) { handlers[o] = handlers[o] || [], handlers[o].push(l) } function maybeInstrument(o, l) { if (!instrumented[o]) { instrumented[o] = !0; try { l() } catch (u) { DEBUG_BUILD$3 && logger.error(`Error while instrumenting ${o}`, u) } } } function triggerHandlers(o, l) {
  const u = o && handlers[o]; if (u) for (const f of u) try { f(l) } catch (p) {
    DEBUG_BUILD$3 && logger.error(`Error while triggering instrumentation handler.
Type: ${o}
Name: ${getFunctionName(f)}
Error:`, p)
  }
} let _oldOnErrorHandler = null; function addGlobalErrorInstrumentationHandler(o) { const l = "error"; addHandler(l, o), maybeInstrument(l, instrumentError) } function instrumentError() { _oldOnErrorHandler = GLOBAL_OBJ.onerror, GLOBAL_OBJ.onerror = function (o, l, u, f, p) { return triggerHandlers("error", { column: f, error: p, line: u, msg: o, url: l }), _oldOnErrorHandler ? _oldOnErrorHandler.apply(this, arguments) : !1 }, GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0 } let _oldOnUnhandledRejectionHandler = null; function addGlobalUnhandledRejectionInstrumentationHandler(o) { const l = "unhandledrejection"; addHandler(l, o), maybeInstrument(l, instrumentUnhandledRejection) } function instrumentUnhandledRejection() { _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection, GLOBAL_OBJ.onunhandledrejection = function (o) { return triggerHandlers("unhandledrejection", o), _oldOnUnhandledRejectionHandler ? _oldOnUnhandledRejectionHandler.apply(this, arguments) : !0 }, GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0 } function getMainCarrier() { return getSentryCarrier(GLOBAL_OBJ), GLOBAL_OBJ } function getSentryCarrier(o) { const l = o.__SENTRY__ = o.__SENTRY__ || {}; return l.version = l.version || SDK_VERSION, l[SDK_VERSION] = l[SDK_VERSION] || {} } const objectToString = Object.prototype.toString; function isError(o) { switch (objectToString.call(o)) { case "[object Error]": case "[object Exception]": case "[object DOMException]": case "[object WebAssembly.Exception]": return !0; default: return isInstanceOf(o, Error) } } function isBuiltin(o, l) { return objectToString.call(o) === `[object ${l}]` } function isErrorEvent$1(o) { return isBuiltin(o, "ErrorEvent") } function isDOMError(o) { return isBuiltin(o, "DOMError") } function isDOMException(o) { return isBuiltin(o, "DOMException") } function isString$2(o) { return isBuiltin(o, "String") } function isParameterizedString(o) { return typeof o == "object" && o !== null && "__sentry_template_string__" in o && "__sentry_template_values__" in o } function isPrimitive(o) { return o === null || isParameterizedString(o) || typeof o != "object" && typeof o != "function" } function isPlainObject(o) { return isBuiltin(o, "Object") } function isEvent(o) { return typeof Event < "u" && isInstanceOf(o, Event) } function isElement$1(o) { return typeof Element < "u" && isInstanceOf(o, Element) } function isRegExp(o) { return isBuiltin(o, "RegExp") } function isThenable(o) { return !!(o && o.then && typeof o.then == "function") } function isSyntheticEvent(o) { return isPlainObject(o) && "nativeEvent" in o && "preventDefault" in o && "stopPropagation" in o } function isInstanceOf(o, l) { try { return o instanceof l } catch { return !1 } } function isVueViewModel(o) { return !!(typeof o == "object" && o !== null && (o.__isVue || o._isVue)) } const WINDOW$4 = GLOBAL_OBJ, DEFAULT_MAX_STRING_LENGTH = 80; function htmlTreeAsString(o, l = {}) { if (!o) return "<unknown>"; try { let u = o; const f = 5, p = []; let d = 0, m = 0; const v = " > ", I = v.length; let F; const B = Array.isArray(l) ? l : l.keyAttrs, W = !Array.isArray(l) && l.maxStringLength || DEFAULT_MAX_STRING_LENGTH; for (; u && d++ < f && (F = _htmlElementAsString(u, B), !(F === "html" || d > 1 && m + p.length * I + F.length >= W));)p.push(F), m += F.length, u = u.parentNode; return p.reverse().join(v) } catch { return "<unknown>" } } function _htmlElementAsString(o, l) { const u = o, f = []; if (!u || !u.tagName) return ""; if (WINDOW$4.HTMLElement && u instanceof HTMLElement && u.dataset) { if (u.dataset.sentryComponent) return u.dataset.sentryComponent; if (u.dataset.sentryElement) return u.dataset.sentryElement } f.push(u.tagName.toLowerCase()); const p = l && l.length ? l.filter(m => u.getAttribute(m)).map(m => [m, u.getAttribute(m)]) : null; if (p && p.length) p.forEach(m => { f.push(`[${m[0]}="${m[1]}"]`) }); else { u.id && f.push(`#${u.id}`); const m = u.className; if (m && isString$2(m)) { const v = m.split(/\s+/); for (const I of v) f.push(`.${I}`) } } const d = ["aria-label", "type", "name", "title", "alt"]; for (const m of d) { const v = u.getAttribute(m); v && f.push(`[${m}="${v}"]`) } return f.join("") } function getLocationHref() { try { return WINDOW$4.document.location.href } catch { return "" } } function getComponentName(o) { if (!WINDOW$4.HTMLElement) return null; let l = o; const u = 5; for (let f = 0; f < u; f++) { if (!l) return null; if (l instanceof HTMLElement) { if (l.dataset.sentryComponent) return l.dataset.sentryComponent; if (l.dataset.sentryElement) return l.dataset.sentryElement } l = l.parentNode } return null } function truncate(o, l = 0) { return typeof o != "string" || l === 0 || o.length <= l ? o : `${o.slice(0, l)}...` } function safeJoin(o, l) { if (!Array.isArray(o)) return ""; const u = []; for (let f = 0; f < o.length; f++) { const p = o[f]; try { isVueViewModel(p) ? u.push("[VueViewModel]") : u.push(String(p)) } catch { u.push("[value cannot be serialized]") } } return u.join(l) } function isMatchingPattern(o, l, u = !1) { return isString$2(o) ? isRegExp(l) ? l.test(o) : isString$2(l) ? u ? o === l : o.includes(l) : !1 : !1 } function stringMatchesSomePattern(o, l = [], u = !1) { return l.some(f => isMatchingPattern(o, f, u)) } function fill(o, l, u) { if (!(l in o)) return; const f = o[l], p = u(f); typeof p == "function" && markFunctionWrapped(p, f); try { o[l] = p } catch { DEBUG_BUILD$3 && logger.log(`Failed to replace method "${l}" in object`, o) } } function addNonEnumerableProperty(o, l, u) { try { Object.defineProperty(o, l, { value: u, writable: !0, configurable: !0 }) } catch { DEBUG_BUILD$3 && logger.log(`Failed to add non-enumerable property "${l}" to object`, o) } } function markFunctionWrapped(o, l) { try { const u = l.prototype || {}; o.prototype = l.prototype = u, addNonEnumerableProperty(o, "__sentry_original__", l) } catch { } } function getOriginalFunction(o) { return o.__sentry_original__ } function convertToPlainObject(o) { if (isError(o)) return { message: o.message, name: o.name, stack: o.stack, ...getOwnProperties(o) }; if (isEvent(o)) { const l = { type: o.type, target: serializeEventTarget(o.target), currentTarget: serializeEventTarget(o.currentTarget), ...getOwnProperties(o) }; return typeof CustomEvent < "u" && isInstanceOf(o, CustomEvent) && (l.detail = o.detail), l } else return o } function serializeEventTarget(o) { try { return isElement$1(o) ? htmlTreeAsString(o) : Object.prototype.toString.call(o) } catch { return "<unknown>" } } function getOwnProperties(o) { if (typeof o == "object" && o !== null) { const l = {}; for (const u in o) Object.prototype.hasOwnProperty.call(o, u) && (l[u] = o[u]); return l } else return {} } function extractExceptionKeysForMessage(o, l = 40) { const u = Object.keys(convertToPlainObject(o)); u.sort(); const f = u[0]; if (!f) return "[object has no keys]"; if (f.length >= l) return truncate(f, l); for (let p = u.length; p > 0; p--) { const d = u.slice(0, p).join(", "); if (!(d.length > l)) return p === u.length ? d : truncate(d, l) } return "" } function dropUndefinedKeys(o) { return _dropUndefinedKeys(o, new Map) } function _dropUndefinedKeys(o, l) { if (isPojo(o)) { const u = l.get(o); if (u !== void 0) return u; const f = {}; l.set(o, f); for (const p of Object.getOwnPropertyNames(o)) typeof o[p] < "u" && (f[p] = _dropUndefinedKeys(o[p], l)); return f } if (Array.isArray(o)) { const u = l.get(o); if (u !== void 0) return u; const f = []; return l.set(o, f), o.forEach(p => { f.push(_dropUndefinedKeys(p, l)) }), f } return o } function isPojo(o) { if (!isPlainObject(o)) return !1; try { const l = Object.getPrototypeOf(o).constructor.name; return !l || l === "Object" } catch { return !0 } } const ONE_SECOND_IN_MS = 1e3; function dateTimestampInSeconds() { return Date.now() / ONE_SECOND_IN_MS } function createUnixTimestampInSecondsFunc() { const { performance: o } = GLOBAL_OBJ; if (!o || !o.now) return dateTimestampInSeconds; const l = Date.now() - o.now(), u = o.timeOrigin == null ? l : o.timeOrigin; return () => (u + o.now()) / ONE_SECOND_IN_MS } const timestampInSeconds = createUnixTimestampInSecondsFunc(); (() => { const { performance: o } = GLOBAL_OBJ; if (!o || !o.now) return; const l = 3600 * 1e3, u = o.now(), f = Date.now(), p = o.timeOrigin ? Math.abs(o.timeOrigin + u - f) : l, d = p < l, m = o.timing && o.timing.navigationStart, I = typeof m == "number" ? Math.abs(m + u - f) : l, F = I < l; return d || F ? p <= I ? o.timeOrigin : m : f })(); function uuid4() { const o = GLOBAL_OBJ, l = o.crypto || o.msCrypto; let u = () => Math.random() * 16; try { if (l && l.randomUUID) return l.randomUUID().replace(/-/g, ""); l && l.getRandomValues && (u = () => { const f = new Uint8Array(1); return l.getRandomValues(f), f[0] }) } catch { } return ("10000000100040008000" + 1e11).replace(/[018]/g, f => (f ^ (u() & 15) >> f / 4).toString(16)) } function getFirstException(o) { return o.exception && o.exception.values ? o.exception.values[0] : void 0 } function getEventDescription(o) { const { message: l, event_id: u } = o; if (l) return l; const f = getFirstException(o); return f ? f.type && f.value ? `${f.type}: ${f.value}` : f.type || f.value || u || "<unknown>" : u || "<unknown>" } function addExceptionTypeValue(o, l, u) { const f = o.exception = o.exception || {}, p = f.values = f.values || [], d = p[0] = p[0] || {}; d.value || (d.value = l || ""), d.type || (d.type = "Error") } function addExceptionMechanism(o, l) { const u = getFirstException(o); if (!u) return; const f = { type: "generic", handled: !0 }, p = u.mechanism; if (u.mechanism = { ...f, ...p, ...l }, l && "data" in l) { const d = { ...p && p.data, ...l.data }; u.mechanism.data = d } } function checkOrSetAlreadyCaught(o) { if (isAlreadyCaptured(o)) return !0; try { addNonEnumerableProperty(o, "__sentry_captured__", !0) } catch { } return !1 } function isAlreadyCaptured(o) { try { return o.__sentry_captured__ } catch { } } var States; (function (o) { o[o.PENDING = 0] = "PENDING"; const u = 1; o[o.RESOLVED = u] = "RESOLVED"; const f = 2; o[o.REJECTED = f] = "REJECTED" })(States || (States = {})); function resolvedSyncPromise(o) { return new SyncPromise(l => { l(o) }) } function rejectedSyncPromise(o) { return new SyncPromise((l, u) => { u(o) }) } class SyncPromise { constructor(l) { SyncPromise.prototype.__init.call(this), SyncPromise.prototype.__init2.call(this), SyncPromise.prototype.__init3.call(this), SyncPromise.prototype.__init4.call(this), this._state = States.PENDING, this._handlers = []; try { l(this._resolve, this._reject) } catch (u) { this._reject(u) } } then(l, u) { return new SyncPromise((f, p) => { this._handlers.push([!1, d => { if (!l) f(d); else try { f(l(d)) } catch (m) { p(m) } }, d => { if (!u) p(d); else try { f(u(d)) } catch (m) { p(m) } }]), this._executeHandlers() }) } catch(l) { return this.then(u => u, l) } finally(l) { return new SyncPromise((u, f) => { let p, d; return this.then(m => { d = !1, p = m, l && l() }, m => { d = !0, p = m, l && l() }).then(() => { if (d) { f(p); return } u(p) }) }) } __init() { this._resolve = l => { this._setResult(States.RESOLVED, l) } } __init2() { this._reject = l => { this._setResult(States.REJECTED, l) } } __init3() { this._setResult = (l, u) => { if (this._state === States.PENDING) { if (isThenable(u)) { u.then(this._resolve, this._reject); return } this._state = l, this._value = u, this._executeHandlers() } } } __init4() { this._executeHandlers = () => { if (this._state === States.PENDING) return; const l = this._handlers.slice(); this._handlers = [], l.forEach(u => { u[0] || (this._state === States.RESOLVED && u[1](this._value), this._state === States.REJECTED && u[2](this._value), u[0] = !0) }) } } } function makeSession(o) { const l = timestampInSeconds(), u = { sid: uuid4(), init: !0, timestamp: l, started: l, duration: 0, status: "ok", errors: 0, ignoreDuration: !1, toJSON: () => sessionToJSON(u) }; return o && updateSession(u, o), u } function updateSession(o, l = {}) { if (l.user && (!o.ipAddress && l.user.ip_address && (o.ipAddress = l.user.ip_address), !o.did && !l.did && (o.did = l.user.id || l.user.email || l.user.username)), o.timestamp = l.timestamp || timestampInSeconds(), l.abnormal_mechanism && (o.abnormal_mechanism = l.abnormal_mechanism), l.ignoreDuration && (o.ignoreDuration = l.ignoreDuration), l.sid && (o.sid = l.sid.length === 32 ? l.sid : uuid4()), l.init !== void 0 && (o.init = l.init), !o.did && l.did && (o.did = `${l.did}`), typeof l.started == "number" && (o.started = l.started), o.ignoreDuration) o.duration = void 0; else if (typeof l.duration == "number") o.duration = l.duration; else { const u = o.timestamp - o.started; o.duration = u >= 0 ? u : 0 } l.release && (o.release = l.release), l.environment && (o.environment = l.environment), !o.ipAddress && l.ipAddress && (o.ipAddress = l.ipAddress), !o.userAgent && l.userAgent && (o.userAgent = l.userAgent), typeof l.errors == "number" && (o.errors = l.errors), l.status && (o.status = l.status) } function closeSession(o, l) { let u = {}; o.status === "ok" && (u = { status: "exited" }), updateSession(o, u) } function sessionToJSON(o) { return dropUndefinedKeys({ sid: `${o.sid}`, init: o.init, started: new Date(o.started * 1e3).toISOString(), timestamp: new Date(o.timestamp * 1e3).toISOString(), status: o.status, errors: o.errors, did: typeof o.did == "number" || typeof o.did == "string" ? `${o.did}` : void 0, duration: o.duration, abnormal_mechanism: o.abnormal_mechanism, attrs: { release: o.release, environment: o.environment, ip_address: o.ipAddress, user_agent: o.userAgent } }) } function generateTraceId() { return uuid4() } function generateSpanId() { return uuid4().substring(16) } function merge(o, l, u = 2) { if (!l || typeof l != "object" || u <= 0) return l; if (o && l && Object.keys(l).length === 0) return o; const f = { ...o }; for (const p in l) Object.prototype.hasOwnProperty.call(l, p) && (f[p] = merge(f[p], l[p], u - 1)); return f } const SCOPE_SPAN_FIELD = "_sentrySpan"; function _setSpanForScope(o, l) { l ? addNonEnumerableProperty(o, SCOPE_SPAN_FIELD, l) : delete o[SCOPE_SPAN_FIELD] } function _getSpanForScope(o) { return o[SCOPE_SPAN_FIELD] } const DEFAULT_MAX_BREADCRUMBS = 100; class ScopeClass { constructor() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = { traceId: generateTraceId(), spanId: generateSpanId() } } clone() { const l = new ScopeClass; return l._breadcrumbs = [...this._breadcrumbs], l._tags = { ...this._tags }, l._extra = { ...this._extra }, l._contexts = { ...this._contexts }, this._contexts.flags && (l._contexts.flags = { values: [...this._contexts.flags.values] }), l._user = this._user, l._level = this._level, l._session = this._session, l._transactionName = this._transactionName, l._fingerprint = this._fingerprint, l._eventProcessors = [...this._eventProcessors], l._requestSession = this._requestSession, l._attachments = [...this._attachments], l._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, l._propagationContext = { ...this._propagationContext }, l._client = this._client, l._lastEventId = this._lastEventId, _setSpanForScope(l, _getSpanForScope(this)), l } setClient(l) { this._client = l } setLastEventId(l) { this._lastEventId = l } getClient() { return this._client } lastEventId() { return this._lastEventId } addScopeListener(l) { this._scopeListeners.push(l) } addEventProcessor(l) { return this._eventProcessors.push(l), this } setUser(l) { return this._user = l || { email: void 0, id: void 0, ip_address: void 0, username: void 0 }, this._session && updateSession(this._session, { user: l }), this._notifyScopeListeners(), this } getUser() { return this._user } getRequestSession() { return this._requestSession } setRequestSession(l) { return this._requestSession = l, this } setTags(l) { return this._tags = { ...this._tags, ...l }, this._notifyScopeListeners(), this } setTag(l, u) { return this._tags = { ...this._tags, [l]: u }, this._notifyScopeListeners(), this } setExtras(l) { return this._extra = { ...this._extra, ...l }, this._notifyScopeListeners(), this } setExtra(l, u) { return this._extra = { ...this._extra, [l]: u }, this._notifyScopeListeners(), this } setFingerprint(l) { return this._fingerprint = l, this._notifyScopeListeners(), this } setLevel(l) { return this._level = l, this._notifyScopeListeners(), this } setTransactionName(l) { return this._transactionName = l, this._notifyScopeListeners(), this } setContext(l, u) { return u === null ? delete this._contexts[l] : this._contexts[l] = u, this._notifyScopeListeners(), this } setSession(l) { return l ? this._session = l : delete this._session, this._notifyScopeListeners(), this } getSession() { return this._session } update(l) { if (!l) return this; const u = typeof l == "function" ? l(this) : l, [f, p] = u instanceof Scope ? [u.getScopeData(), u.getRequestSession()] : isPlainObject(u) ? [l, l.requestSession] : [], { tags: d, extra: m, user: v, contexts: I, level: F, fingerprint: B = [], propagationContext: W } = f || {}; return this._tags = { ...this._tags, ...d }, this._extra = { ...this._extra, ...m }, this._contexts = { ...this._contexts, ...I }, v && Object.keys(v).length && (this._user = v), F && (this._level = F), B.length && (this._fingerprint = B), W && (this._propagationContext = W), p && (this._requestSession = p), this } clear() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, _setSpanForScope(this, void 0), this._attachments = [], this.setPropagationContext({ traceId: generateTraceId() }), this._notifyScopeListeners(), this } addBreadcrumb(l, u) { const f = typeof u == "number" ? u : DEFAULT_MAX_BREADCRUMBS; if (f <= 0) return this; const p = { timestamp: dateTimestampInSeconds(), ...l }; return this._breadcrumbs.push(p), this._breadcrumbs.length > f && (this._breadcrumbs = this._breadcrumbs.slice(-f), this._client && this._client.recordDroppedEvent("buffer_overflow", "log_item")), this._notifyScopeListeners(), this } getLastBreadcrumb() { return this._breadcrumbs[this._breadcrumbs.length - 1] } clearBreadcrumbs() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } addAttachment(l) { return this._attachments.push(l), this } clearAttachments() { return this._attachments = [], this } getScopeData() { return { breadcrumbs: this._breadcrumbs, attachments: this._attachments, contexts: this._contexts, tags: this._tags, extra: this._extra, user: this._user, level: this._level, fingerprint: this._fingerprint || [], eventProcessors: this._eventProcessors, propagationContext: this._propagationContext, sdkProcessingMetadata: this._sdkProcessingMetadata, transactionName: this._transactionName, span: _getSpanForScope(this) } } setSDKProcessingMetadata(l) { return this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, l, 2), this } setPropagationContext(l) { return this._propagationContext = { spanId: generateSpanId(), ...l }, this } getPropagationContext() { return this._propagationContext } captureException(l, u) { const f = u && u.event_id ? u.event_id : uuid4(); if (!this._client) return logger.warn("No client configured on scope - will not capture exception!"), f; const p = new Error("Sentry syntheticException"); return this._client.captureException(l, { originalException: l, syntheticException: p, ...u, event_id: f }, this), f } captureMessage(l, u, f) { const p = f && f.event_id ? f.event_id : uuid4(); if (!this._client) return logger.warn("No client configured on scope - will not capture message!"), p; const d = new Error(l); return this._client.captureMessage(l, u, { originalException: l, syntheticException: d, ...f, event_id: p }, this), p } captureEvent(l, u) { const f = u && u.event_id ? u.event_id : uuid4(); return this._client ? (this._client.captureEvent(l, { ...u, event_id: f }, this), f) : (logger.warn("No client configured on scope - will not capture event!"), f) } _notifyScopeListeners() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(l => { l(this) }), this._notifyingListeners = !1) } } const Scope = ScopeClass; function getDefaultCurrentScope() { return getGlobalSingleton("defaultCurrentScope", () => new Scope) } function getDefaultIsolationScope() { return getGlobalSingleton("defaultIsolationScope", () => new Scope) } class AsyncContextStack { constructor(l, u) { let f; l ? f = l : f = new Scope; let p; u ? p = u : p = new Scope, this._stack = [{ scope: f }], this._isolationScope = p } withScope(l) { const u = this._pushScope(); let f; try { f = l(u) } catch (p) { throw this._popScope(), p } return isThenable(f) ? f.then(p => (this._popScope(), p), p => { throw this._popScope(), p }) : (this._popScope(), f) } getClient() { return this.getStackTop().client } getScope() { return this.getStackTop().scope } getIsolationScope() { return this._isolationScope } getStackTop() { return this._stack[this._stack.length - 1] } _pushScope() { const l = this.getScope().clone(); return this._stack.push({ client: this.getClient(), scope: l }), l } _popScope() { return this._stack.length <= 1 ? !1 : !!this._stack.pop() } } function getAsyncContextStack() { const o = getMainCarrier(), l = getSentryCarrier(o); return l.stack = l.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()) } function withScope$1(o) { return getAsyncContextStack().withScope(o) } function withSetScope(o, l) { const u = getAsyncContextStack(); return u.withScope(() => (u.getStackTop().scope = o, l(o))) } function withIsolationScope(o) { return getAsyncContextStack().withScope(() => o(getAsyncContextStack().getIsolationScope())) } function getStackAsyncContextStrategy() { return { withIsolationScope, withScope: withScope$1, withSetScope, withSetIsolationScope: (o, l) => withIsolationScope(l), getCurrentScope: () => getAsyncContextStack().getScope(), getIsolationScope: () => getAsyncContextStack().getIsolationScope() } } function getAsyncContextStrategy(o) { const l = getSentryCarrier(o); return l.acs ? l.acs : getStackAsyncContextStrategy() } function getCurrentScope() { const o = getMainCarrier(); return getAsyncContextStrategy(o).getCurrentScope() } function getIsolationScope() { const o = getMainCarrier(); return getAsyncContextStrategy(o).getIsolationScope() } function getGlobalScope() { return getGlobalSingleton("globalScope", () => new Scope) } function withScope(...o) { const l = getMainCarrier(), u = getAsyncContextStrategy(l); if (o.length === 2) { const [f, p] = o; return f ? u.withSetScope(f, p) : u.withScope(p) } return u.withScope(o[0]) } function getClient() { return getCurrentScope().getClient() } function getTraceContextFromScope(o) { const l = o.getPropagationContext(), { traceId: u, spanId: f, parentSpanId: p } = l; return dropUndefinedKeys({ trace_id: u, span_id: f, parent_span_id: p }) } const METRICS_SPAN_FIELD = "_sentryMetrics"; function getMetricSummaryJsonForSpan(o) { const l = o[METRICS_SPAN_FIELD]; if (!l) return; const u = {}; for (const [, [f, p]] of l) (u[f] || (u[f] = [])).push(dropUndefinedKeys(p)); return u } const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source", SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate", SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op", SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin", SPAN_STATUS_UNSET = 0, SPAN_STATUS_OK = 1, SENTRY_BAGGAGE_KEY_PREFIX = "sentry-", SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/; function baggageHeaderToDynamicSamplingContext(o) { const l = parseBaggageHeader(o); if (!l) return; const u = Object.entries(l).reduce((f, [p, d]) => { if (p.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) { const m = p.slice(SENTRY_BAGGAGE_KEY_PREFIX.length); f[m] = d } return f }, {}); if (Object.keys(u).length > 0) return u } function parseBaggageHeader(o) { if (!(!o || !isString$2(o) && !Array.isArray(o))) return Array.isArray(o) ? o.reduce((l, u) => { const f = baggageHeaderToObject(u); return Object.entries(f).forEach(([p, d]) => { l[p] = d }), l }, {}) : baggageHeaderToObject(o) } function baggageHeaderToObject(o) { return o.split(",").map(l => l.split("=").map(u => decodeURIComponent(u.trim()))).reduce((l, [u, f]) => (u && f && (l[u] = f), l), {}) } const TRACE_FLAG_SAMPLED = 1; let hasShownSpanDropWarning = !1; function spanToTraceContext(o) { const { spanId: l, traceId: u, isRemote: f } = o.spanContext(), p = f ? l : spanToJSON(o).parent_span_id, d = f ? generateSpanId() : l; return dropUndefinedKeys({ parent_span_id: p, span_id: d, trace_id: u }) } function spanTimeInputToSeconds(o) { return typeof o == "number" ? ensureTimestampInSeconds(o) : Array.isArray(o) ? o[0] + o[1] / 1e9 : o instanceof Date ? ensureTimestampInSeconds(o.getTime()) : timestampInSeconds() } function ensureTimestampInSeconds(o) { return o > 9999999999 ? o / 1e3 : o } function spanToJSON(o) { if (spanIsSentrySpan(o)) return o.getSpanJSON(); try { const { spanId: l, traceId: u } = o.spanContext(); if (spanIsOpenTelemetrySdkTraceBaseSpan(o)) { const { attributes: f, startTime: p, name: d, endTime: m, parentSpanId: v, status: I } = o; return dropUndefinedKeys({ span_id: l, trace_id: u, data: f, description: d, parent_span_id: v, start_timestamp: spanTimeInputToSeconds(p), timestamp: spanTimeInputToSeconds(m) || void 0, status: getStatusMessage(I), op: f[SEMANTIC_ATTRIBUTE_SENTRY_OP], origin: f[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN], _metrics_summary: getMetricSummaryJsonForSpan(o) }) } return { span_id: l, trace_id: u } } catch { return {} } } function spanIsOpenTelemetrySdkTraceBaseSpan(o) { const l = o; return !!l.attributes && !!l.startTime && !!l.name && !!l.endTime && !!l.status } function spanIsSentrySpan(o) { return typeof o.getSpanJSON == "function" } function spanIsSampled(o) { const { traceFlags: l } = o.spanContext(); return l === TRACE_FLAG_SAMPLED } function getStatusMessage(o) { if (!(!o || o.code === SPAN_STATUS_UNSET)) return o.code === SPAN_STATUS_OK ? "ok" : o.message || "unknown_error" } const ROOT_SPAN_FIELD = "_sentryRootSpan"; function getRootSpan(o) { return o[ROOT_SPAN_FIELD] || o } function showSpanDropWarning() { hasShownSpanDropWarning || (consoleSandbox(() => { console.warn("[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly.") }), hasShownSpanDropWarning = !0) } function hasTracingEnabled(o) { if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1; const l = getClient(), u = l && l.getOptions(); return !!u && (u.enableTracing || "tracesSampleRate" in u || "tracesSampler" in u) } const DEFAULT_ENVIRONMENT = "production", FROZEN_DSC_FIELD = "_frozenDsc"; function getDynamicSamplingContextFromClient(o, l) { const u = l.getOptions(), { publicKey: f } = l.getDsn() || {}, p = dropUndefinedKeys({ environment: u.environment || DEFAULT_ENVIRONMENT, release: u.release, public_key: f, trace_id: o }); return l.emit("createDsc", p), p } function getDynamicSamplingContextFromScope(o, l) { const u = l.getPropagationContext(); return u.dsc || getDynamicSamplingContextFromClient(u.traceId, o) } function getDynamicSamplingContextFromSpan(o) { const l = getClient(); if (!l) return {}; const u = getRootSpan(o), f = u[FROZEN_DSC_FIELD]; if (f) return f; const p = u.spanContext().traceState, d = p && p.get("sentry.dsc"), m = d && baggageHeaderToDynamicSamplingContext(d); if (m) return m; const v = getDynamicSamplingContextFromClient(o.spanContext().traceId, l), I = spanToJSON(u), F = I.data || {}, B = F[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]; B != null && (v.sample_rate = `${B}`); const W = F[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE], Z = I.description; return W !== "url" && Z && (v.transaction = Z), hasTracingEnabled() && (v.sampled = String(spanIsSampled(u))), l.emit("createDsc", v, u), v } function parseSampleRate(o) { if (typeof o == "boolean") return Number(o); const l = typeof o == "string" ? parseFloat(o) : o; if (typeof l != "number" || isNaN(l) || l < 0 || l > 1) { DEBUG_BUILD$4 && logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(o)} of type ${JSON.stringify(typeof o)}.`); return } return l } const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/; function isValidProtocol(o) { return o === "http" || o === "https" } function dsnToString(o, l = !1) { const { host: u, path: f, pass: p, port: d, projectId: m, protocol: v, publicKey: I } = o; return `${v}://${I}${l && p ? `:${p}` : ""}@${u}${d ? `:${d}` : ""}/${f && `${f}/`}${m}` } function dsnFromString(o) { const l = DSN_REGEX.exec(o); if (!l) { consoleSandbox(() => { console.error(`Invalid Sentry Dsn: ${o}`) }); return } const [u, f, p = "", d = "", m = "", v = ""] = l.slice(1); let I = "", F = v; const B = F.split("/"); if (B.length > 1 && (I = B.slice(0, -1).join("/"), F = B.pop()), F) { const W = F.match(/^\d+/); W && (F = W[0]) } return dsnFromComponents({ host: d, pass: p, path: I, projectId: F, port: m, protocol: u, publicKey: f }) } function dsnFromComponents(o) { return { protocol: o.protocol, publicKey: o.publicKey || "", pass: o.pass || "", host: o.host, port: o.port || "", path: o.path || "", projectId: o.projectId } } function validateDsn(o) { if (!DEBUG_BUILD$3) return !0; const { port: l, projectId: u, protocol: f } = o; return ["protocol", "publicKey", "host", "projectId"].find(m => o[m] ? !1 : (logger.error(`Invalid Sentry Dsn: ${m} missing`), !0)) ? !1 : u.match(/^\d+$/) ? isValidProtocol(f) ? l && isNaN(parseInt(l, 10)) ? (logger.error(`Invalid Sentry Dsn: Invalid port ${l}`), !1) : !0 : (logger.error(`Invalid Sentry Dsn: Invalid protocol ${f}`), !1) : (logger.error(`Invalid Sentry Dsn: Invalid projectId ${u}`), !1) } function makeDsn(o) { const l = typeof o == "string" ? dsnFromString(o) : dsnFromComponents(o); if (!(!l || !validateDsn(l))) return l } function memoBuilder() { const o = typeof WeakSet == "function", l = o ? new WeakSet : []; function u(p) { if (o) return l.has(p) ? !0 : (l.add(p), !1); for (let d = 0; d < l.length; d++)if (l[d] === p) return !0; return l.push(p), !1 } function f(p) { if (o) l.delete(p); else for (let d = 0; d < l.length; d++)if (l[d] === p) { l.splice(d, 1); break } } return [u, f] } function normalize(o, l = 100, u = 1 / 0) { try { return visit("", o, l, u) } catch (f) { return { ERROR: `**non-serializable** (${f})` } } } function normalizeToSize(o, l = 3, u = 100 * 1024) { const f = normalize(o, l); return jsonSize(f) > u ? normalizeToSize(o, l - 1, u) : f } function visit(o, l, u = 1 / 0, f = 1 / 0, p = memoBuilder()) { const [d, m] = p; if (l == null || ["boolean", "string"].includes(typeof l) || typeof l == "number" && Number.isFinite(l)) return l; const v = stringifyValue(o, l); if (!v.startsWith("[object ")) return v; if (l.__sentry_skip_normalization__) return l; const I = typeof l.__sentry_override_normalization_depth__ == "number" ? l.__sentry_override_normalization_depth__ : u; if (I === 0) return v.replace("object ", ""); if (d(l)) return "[Circular ~]"; const F = l; if (F && typeof F.toJSON == "function") try { const Q = F.toJSON(); return visit("", Q, I - 1, f, p) } catch { } const B = Array.isArray(l) ? [] : {}; let W = 0; const Z = convertToPlainObject(l); for (const Q in Z) { if (!Object.prototype.hasOwnProperty.call(Z, Q)) continue; if (W >= f) { B[Q] = "[MaxProperties ~]"; break } const re = Z[Q]; B[Q] = visit(Q, re, I - 1, f, p), W++ } return m(l), B } function stringifyValue(o, l) { try { if (o === "domain" && l && typeof l == "object" && l._events) return "[Domain]"; if (o === "domainEmitter") return "[DomainEmitter]"; if (typeof global$1 < "u" && l === global$1) return "[Global]"; if (typeof window < "u" && l === window) return "[Window]"; if (typeof document < "u" && l === document) return "[Document]"; if (isVueViewModel(l)) return "[VueViewModel]"; if (isSyntheticEvent(l)) return "[SyntheticEvent]"; if (typeof l == "number" && !Number.isFinite(l)) return `[${l}]`; if (typeof l == "function") return `[Function: ${getFunctionName(l)}]`; if (typeof l == "symbol") return `[${String(l)}]`; if (typeof l == "bigint") return `[BigInt: ${String(l)}]`; const u = getConstructorName(l); return /^HTML(\w*)Element$/.test(u) ? `[HTMLElement: ${u}]` : `[object ${u}]` } catch (u) { return `**non-serializable** (${u})` } } function getConstructorName(o) { const l = Object.getPrototypeOf(o); return l ? l.constructor.name : "null prototype" } function utf8Length(o) { return ~-encodeURI(o).split(/%..|./).length } function jsonSize(o) { return utf8Length(JSON.stringify(o)) } function createEnvelope(o, l = []) { return [o, l] } function addItemToEnvelope(o, l) { const [u, f] = o; return [u, [...f, l]] } function forEachEnvelopeItem(o, l) { const u = o[1]; for (const f of u) { const p = f[0].type; if (l(f, p)) return !0 } return !1 } function encodeUTF8(o) { return GLOBAL_OBJ.__SENTRY__ && GLOBAL_OBJ.__SENTRY__.encodePolyfill ? GLOBAL_OBJ.__SENTRY__.encodePolyfill(o) : new TextEncoder().encode(o) } function serializeEnvelope(o) {
  const [l, u] = o; let f = JSON.stringify(l); function p(d) { typeof f == "string" ? f = typeof d == "string" ? f + d : [encodeUTF8(f), d] : f.push(typeof d == "string" ? encodeUTF8(d) : d) } for (const d of u) {
    const [m, v] = d; if (p(`
${JSON.stringify(m)}
`), typeof v == "string" || v instanceof Uint8Array) p(v); else { let I; try { I = JSON.stringify(v) } catch { I = JSON.stringify(normalize(v)) } p(I) }
  } return typeof f == "string" ? f : concatBuffers(f)
} function concatBuffers(o) { const l = o.reduce((p, d) => p + d.length, 0), u = new Uint8Array(l); let f = 0; for (const p of o) u.set(p, f), f += p.length; return u } function createAttachmentEnvelopeItem(o) { const l = typeof o.data == "string" ? encodeUTF8(o.data) : o.data; return [dropUndefinedKeys({ type: "attachment", length: l.length, filename: o.filename, content_type: o.contentType, attachment_type: o.attachmentType }), l] } const ITEM_TYPE_TO_DATA_CATEGORY_MAP = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", profile_chunk: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor", feedback: "feedback", span: "span", statsd: "metric_bucket", raw_security: "security" }; function envelopeItemTypeToDataCategory(o) { return ITEM_TYPE_TO_DATA_CATEGORY_MAP[o] } function getSdkMetadataForEnvelopeHeader(o) { if (!o || !o.sdk) return; const { name: l, version: u } = o.sdk; return { name: l, version: u } } function createEventEnvelopeHeaders(o, l, u, f) { const p = o.sdkProcessingMetadata && o.sdkProcessingMetadata.dynamicSamplingContext; return { event_id: o.event_id, sent_at: new Date().toISOString(), ...l && { sdk: l }, ...!!u && f && { dsn: dsnToString(f) }, ...p && { trace: dropUndefinedKeys({ ...p }) } } } function enhanceEventWithSdkInfo(o, l) { return l && (o.sdk = o.sdk || {}, o.sdk.name = o.sdk.name || l.name, o.sdk.version = o.sdk.version || l.version, o.sdk.integrations = [...o.sdk.integrations || [], ...l.integrations || []], o.sdk.packages = [...o.sdk.packages || [], ...l.packages || []]), o } function createSessionEnvelope(o, l, u, f) { const p = getSdkMetadataForEnvelopeHeader(u), d = { sent_at: new Date().toISOString(), ...p && { sdk: p }, ...!!f && l && { dsn: dsnToString(l) } }, m = "aggregates" in o ? [{ type: "sessions" }, o] : [{ type: "session" }, o.toJSON()]; return createEnvelope(d, [m]) } function createEventEnvelope(o, l, u, f) { const p = getSdkMetadataForEnvelopeHeader(u), d = o.type && o.type !== "replay_event" ? o.type : "event"; enhanceEventWithSdkInfo(o, u && u.sdk); const m = createEventEnvelopeHeaders(o, p, f, l); return delete o.sdkProcessingMetadata, createEnvelope(m, [[{ type: d }, o]]) } function notifyEventProcessors(o, l, u, f = 0) { return new SyncPromise((p, d) => { const m = o[f]; if (l === null || typeof m != "function") p(l); else { const v = m({ ...l }, u); DEBUG_BUILD$4 && m.id && v === null && logger.log(`Event processor "${m.id}" dropped event`), isThenable(v) ? v.then(I => notifyEventProcessors(o, I, u, f + 1).then(p)).then(null, d) : notifyEventProcessors(o, v, u, f + 1).then(p).then(null, d) } }) } let parsedStackResults, lastKeysCount, cachedFilenameDebugIds; function getFilenameToDebugIdMap(o) { const l = GLOBAL_OBJ._sentryDebugIds; if (!l) return {}; const u = Object.keys(l); return cachedFilenameDebugIds && u.length === lastKeysCount || (lastKeysCount = u.length, cachedFilenameDebugIds = u.reduce((f, p) => { parsedStackResults || (parsedStackResults = {}); const d = parsedStackResults[p]; if (d) f[d[0]] = d[1]; else { const m = o(p); for (let v = m.length - 1; v >= 0; v--) { const I = m[v], F = I && I.filename, B = l[p]; if (F && B) { f[F] = B, parsedStackResults[p] = [F, B]; break } } } return f }, {})), cachedFilenameDebugIds } function applyScopeDataToEvent(o, l) { const { fingerprint: u, span: f, breadcrumbs: p, sdkProcessingMetadata: d } = l; applyDataToEvent(o, l), f && applySpanToEvent(o, f), applyFingerprintToEvent(o, u), applyBreadcrumbsToEvent(o, p), applySdkMetadataToEvent(o, d) } function mergeScopeData(o, l) { const { extra: u, tags: f, user: p, contexts: d, level: m, sdkProcessingMetadata: v, breadcrumbs: I, fingerprint: F, eventProcessors: B, attachments: W, propagationContext: Z, transactionName: Q, span: re } = l; mergeAndOverwriteScopeData(o, "extra", u), mergeAndOverwriteScopeData(o, "tags", f), mergeAndOverwriteScopeData(o, "user", p), mergeAndOverwriteScopeData(o, "contexts", d), o.sdkProcessingMetadata = merge(o.sdkProcessingMetadata, v, 2), m && (o.level = m), Q && (o.transactionName = Q), re && (o.span = re), I.length && (o.breadcrumbs = [...o.breadcrumbs, ...I]), F.length && (o.fingerprint = [...o.fingerprint, ...F]), B.length && (o.eventProcessors = [...o.eventProcessors, ...B]), W.length && (o.attachments = [...o.attachments, ...W]), o.propagationContext = { ...o.propagationContext, ...Z } } function mergeAndOverwriteScopeData(o, l, u) { o[l] = merge(o[l], u, 1) } function applyDataToEvent(o, l) { const { extra: u, tags: f, user: p, contexts: d, level: m, transactionName: v } = l, I = dropUndefinedKeys(u); I && Object.keys(I).length && (o.extra = { ...I, ...o.extra }); const F = dropUndefinedKeys(f); F && Object.keys(F).length && (o.tags = { ...F, ...o.tags }); const B = dropUndefinedKeys(p); B && Object.keys(B).length && (o.user = { ...B, ...o.user }); const W = dropUndefinedKeys(d); W && Object.keys(W).length && (o.contexts = { ...W, ...o.contexts }), m && (o.level = m), v && o.type !== "transaction" && (o.transaction = v) } function applyBreadcrumbsToEvent(o, l) { const u = [...o.breadcrumbs || [], ...l]; o.breadcrumbs = u.length ? u : void 0 } function applySdkMetadataToEvent(o, l) { o.sdkProcessingMetadata = { ...o.sdkProcessingMetadata, ...l } } function applySpanToEvent(o, l) { o.contexts = { trace: spanToTraceContext(l), ...o.contexts }, o.sdkProcessingMetadata = { dynamicSamplingContext: getDynamicSamplingContextFromSpan(l), ...o.sdkProcessingMetadata }; const u = getRootSpan(l), f = spanToJSON(u).description; f && !o.transaction && o.type === "transaction" && (o.transaction = f) } function applyFingerprintToEvent(o, l) { o.fingerprint = o.fingerprint ? Array.isArray(o.fingerprint) ? o.fingerprint : [o.fingerprint] : [], l && (o.fingerprint = o.fingerprint.concat(l)), o.fingerprint && !o.fingerprint.length && delete o.fingerprint } function prepareEvent(o, l, u, f, p, d) { const { normalizeDepth: m = 3, normalizeMaxBreadth: v = 1e3 } = o, I = { ...l, event_id: l.event_id || u.event_id || uuid4(), timestamp: l.timestamp || dateTimestampInSeconds() }, F = u.integrations || o.integrations.map(oe => oe.name); applyClientOptions(I, o), applyIntegrationsMetadata(I, F), p && p.emit("applyFrameMetadata", l), l.type === void 0 && applyDebugIds(I, o.stackParser); const B = getFinalScope(f, u.captureContext); u.mechanism && addExceptionMechanism(I, u.mechanism); const W = p ? p.getEventProcessors() : [], Z = getGlobalScope().getScopeData(); if (d) { const oe = d.getScopeData(); mergeScopeData(Z, oe) } if (B) { const oe = B.getScopeData(); mergeScopeData(Z, oe) } const Q = [...u.attachments || [], ...Z.attachments]; Q.length && (u.attachments = Q), applyScopeDataToEvent(I, Z); const re = [...W, ...Z.eventProcessors]; return notifyEventProcessors(re, I, u).then(oe => (oe && applyDebugMeta(oe), typeof m == "number" && m > 0 ? normalizeEvent(oe, m, v) : oe)) } function applyClientOptions(o, l) { const { environment: u, release: f, dist: p, maxValueLength: d = 250 } = l; o.environment = o.environment || u || DEFAULT_ENVIRONMENT, !o.release && f && (o.release = f), !o.dist && p && (o.dist = p), o.message && (o.message = truncate(o.message, d)); const m = o.exception && o.exception.values && o.exception.values[0]; m && m.value && (m.value = truncate(m.value, d)); const v = o.request; v && v.url && (v.url = truncate(v.url, d)) } function applyDebugIds(o, l) { const u = getFilenameToDebugIdMap(l); try { o.exception.values.forEach(f => { f.stacktrace.frames.forEach(p => { u && p.filename && (p.debug_id = u[p.filename]) }) }) } catch { } } function applyDebugMeta(o) { const l = {}; try { o.exception.values.forEach(f => { f.stacktrace.frames.forEach(p => { p.debug_id && (p.abs_path ? l[p.abs_path] = p.debug_id : p.filename && (l[p.filename] = p.debug_id), delete p.debug_id) }) }) } catch { } if (Object.keys(l).length === 0) return; o.debug_meta = o.debug_meta || {}, o.debug_meta.images = o.debug_meta.images || []; const u = o.debug_meta.images; Object.entries(l).forEach(([f, p]) => { u.push({ type: "sourcemap", code_file: f, debug_id: p }) }) } function applyIntegrationsMetadata(o, l) { l.length > 0 && (o.sdk = o.sdk || {}, o.sdk.integrations = [...o.sdk.integrations || [], ...l]) } function normalizeEvent(o, l, u) { if (!o) return null; const f = { ...o, ...o.breadcrumbs && { breadcrumbs: o.breadcrumbs.map(p => ({ ...p, ...p.data && { data: normalize(p.data, l, u) } })) }, ...o.user && { user: normalize(o.user, l, u) }, ...o.contexts && { contexts: normalize(o.contexts, l, u) }, ...o.extra && { extra: normalize(o.extra, l, u) } }; return o.contexts && o.contexts.trace && f.contexts && (f.contexts.trace = o.contexts.trace, o.contexts.trace.data && (f.contexts.trace.data = normalize(o.contexts.trace.data, l, u))), o.spans && (f.spans = o.spans.map(p => ({ ...p, ...p.data && { data: normalize(p.data, l, u) } }))), o.contexts && o.contexts.flags && f.contexts && (f.contexts.flags = normalize(o.contexts.flags, 3, u)), f } function getFinalScope(o, l) { if (!l) return o; const u = o ? o.clone() : new Scope; return u.update(l), u } function parseEventHintOrCaptureContext(o) { if (o) return hintIsScopeOrFunction(o) ? { captureContext: o } : hintIsScopeContext(o) ? { captureContext: o } : o } function hintIsScopeOrFunction(o) { return o instanceof Scope || typeof o == "function" } const captureContextKeys = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"]; function hintIsScopeContext(o) { return Object.keys(o).some(l => captureContextKeys.includes(l)) } function captureException(o, l) { return getCurrentScope().captureException(o, parseEventHintOrCaptureContext(l)) } function captureMessage(o, l) { const u = typeof l == "string" ? l : void 0, f = typeof l != "string" ? { captureContext: l } : void 0; return getCurrentScope().captureMessage(o, u, f) } function captureEvent(o, l) { return getCurrentScope().captureEvent(o, l) } function setContext(o, l) { getIsolationScope().setContext(o, l) } function lastEventId() { return getIsolationScope().lastEventId() } function startSession(o) { const l = getClient(), u = getIsolationScope(), f = getCurrentScope(), { release: p, environment: d = DEFAULT_ENVIRONMENT } = l && l.getOptions() || {}, { userAgent: m } = GLOBAL_OBJ.navigator || {}, v = makeSession({ release: p, environment: d, user: f.getUser() || u.getUser(), ...m && { userAgent: m }, ...o }), I = u.getSession(); return I && I.status === "ok" && updateSession(I, { status: "exited" }), endSession(), u.setSession(v), f.setSession(v), v } function endSession() { const o = getIsolationScope(), l = getCurrentScope(), u = l.getSession() || o.getSession(); u && closeSession(u), _sendSessionUpdate(), o.setSession(), l.setSession() } function _sendSessionUpdate() { const o = getIsolationScope(), l = getCurrentScope(), u = getClient(), f = l.getSession() || o.getSession(); f && u && u.captureSession(f) } function captureSession(o = !1) { if (o) { endSession(); return } _sendSessionUpdate() } const SENTRY_API_VERSION = "7"; function getBaseApiEndpoint(o) { const l = o.protocol ? `${o.protocol}:` : "", u = o.port ? `:${o.port}` : ""; return `${l}//${o.host}${u}${o.path ? `/${o.path}` : ""}/api/` } function _getIngestEndpoint(o) { return `${getBaseApiEndpoint(o)}${o.projectId}/envelope/` } function _encodedAuth(o, l) { const u = { sentry_version: SENTRY_API_VERSION }; return o.publicKey && (u.sentry_key = o.publicKey), l && (u.sentry_client = `${l.name}/${l.version}`), new URLSearchParams(u).toString() } function getEnvelopeEndpointWithUrlEncodedAuth(o, l, u) { return l || `${_getIngestEndpoint(o)}?${_encodedAuth(o, u)}` } function getReportDialogEndpoint(o, l) { const u = makeDsn(o); if (!u) return ""; const f = `${getBaseApiEndpoint(u)}embed/error-page/`; let p = `dsn=${dsnToString(u)}`; for (const d in l) if (d !== "dsn" && d !== "onClose") if (d === "user") { const m = l.user; if (!m) continue; m.name && (p += `&name=${encodeURIComponent(m.name)}`), m.email && (p += `&email=${encodeURIComponent(m.email)}`) } else p += `&${encodeURIComponent(d)}=${encodeURIComponent(l[d])}`; return `${f}?${p}` } const installedIntegrations = []; function filterDuplicates(o) { const l = {}; return o.forEach(u => { const { name: f } = u, p = l[f]; p && !p.isDefaultInstance && u.isDefaultInstance || (l[f] = u) }), Object.values(l) } function getIntegrationsToSetup(o) { const l = o.defaultIntegrations || [], u = o.integrations; l.forEach(m => { m.isDefaultInstance = !0 }); let f; if (Array.isArray(u)) f = [...l, ...u]; else if (typeof u == "function") { const m = u(l); f = Array.isArray(m) ? m : [m] } else f = l; const p = filterDuplicates(f), d = p.findIndex(m => m.name === "Debug"); if (d > -1) { const [m] = p.splice(d, 1); p.push(m) } return p } function setupIntegrations(o, l) { const u = {}; return l.forEach(f => { f && setupIntegration(o, f, u) }), u } function afterSetupIntegrations(o, l) { for (const u of l) u && u.afterAllSetup && u.afterAllSetup(o) } function setupIntegration(o, l, u) { if (u[l.name]) { DEBUG_BUILD$4 && logger.log(`Integration skipped because it was already installed: ${l.name}`); return } if (u[l.name] = l, installedIntegrations.indexOf(l.name) === -1 && typeof l.setupOnce == "function" && (l.setupOnce(), installedIntegrations.push(l.name)), l.setup && typeof l.setup == "function" && l.setup(o), typeof l.preprocessEvent == "function") { const f = l.preprocessEvent.bind(l); o.on("preprocessEvent", (p, d) => f(p, d, o)) } if (typeof l.processEvent == "function") { const f = l.processEvent.bind(l), p = Object.assign((d, m) => f(d, m, o), { id: l.name }); o.addEventProcessor(p) } DEBUG_BUILD$4 && logger.log(`Integration installed: ${l.name}`) } function defineIntegration(o) { return o } function createClientReportEnvelope(o, l, u) { const f = [{ type: "client_report" }, { timestamp: dateTimestampInSeconds(), discarded_events: o }]; return createEnvelope(l ? { dsn: l } : {}, [f]) } class SentryError extends Error { constructor(l, u = "warn") { super(l), this.message = l, this.logLevel = u } } const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured."; class BaseClient {
  constructor(l) { if (this._options = l, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], l.dsn ? this._dsn = makeDsn(l.dsn) : DEBUG_BUILD$4 && logger.warn("No DSN provided, client will not send events."), this._dsn) { const p = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, l.tunnel, l._metadata ? l._metadata.sdk : void 0); this._transport = l.transport({ tunnel: this._options.tunnel, recordDroppedEvent: this.recordDroppedEvent.bind(this), ...l.transportOptions, url: p }) } const f = ["enableTracing", "tracesSampleRate", "tracesSampler"].find(p => p in l && l[p] == null); f && consoleSandbox(() => { console.warn(`[Sentry] Deprecation warning: \`${f}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`) }) } captureException(l, u, f) { const p = uuid4(); if (checkOrSetAlreadyCaught(l)) return DEBUG_BUILD$4 && logger.log(ALREADY_SEEN_ERROR), p; const d = { event_id: p, ...u }; return this._process(this.eventFromException(l, d).then(m => this._captureEvent(m, d, f))), d.event_id } captureMessage(l, u, f, p) { const d = { event_id: uuid4(), ...f }, m = isParameterizedString(l) ? l : String(l), v = isPrimitive(l) ? this.eventFromMessage(m, u, d) : this.eventFromException(l, d); return this._process(v.then(I => this._captureEvent(I, d, p))), d.event_id } captureEvent(l, u, f) { const p = uuid4(); if (u && u.originalException && checkOrSetAlreadyCaught(u.originalException)) return DEBUG_BUILD$4 && logger.log(ALREADY_SEEN_ERROR), p; const d = { event_id: p, ...u }, v = (l.sdkProcessingMetadata || {}).capturedSpanScope; return this._process(this._captureEvent(l, d, v || f)), d.event_id } captureSession(l) { typeof l.release != "string" ? DEBUG_BUILD$4 && logger.warn("Discarded session because of missing or non-string release") : (this.sendSession(l), updateSession(l, { init: !1 })) } getDsn() { return this._dsn } getOptions() { return this._options } getSdkMetadata() { return this._options._metadata } getTransport() { return this._transport } flush(l) { const u = this._transport; return u ? (this.emit("flush"), this._isClientDoneProcessing(l).then(f => u.flush(l).then(p => f && p))) : resolvedSyncPromise(!0) } close(l) { return this.flush(l).then(u => (this.getOptions().enabled = !1, this.emit("close"), u)) } getEventProcessors() { return this._eventProcessors } addEventProcessor(l) { this._eventProcessors.push(l) } init() { (this._isEnabled() || this._options.integrations.some(({ name: l }) => l.startsWith("Spotlight"))) && this._setupIntegrations() } getIntegrationByName(l) { return this._integrations[l] } addIntegration(l) { const u = this._integrations[l.name]; setupIntegration(this, l, this._integrations), u || afterSetupIntegrations(this, [l]) } sendEvent(l, u = {}) { this.emit("beforeSendEvent", l, u); let f = createEventEnvelope(l, this._dsn, this._options._metadata, this._options.tunnel); for (const d of u.attachments || []) f = addItemToEnvelope(f, createAttachmentEnvelopeItem(d)); const p = this.sendEnvelope(f); p && p.then(d => this.emit("afterSendEvent", l, d), null) } sendSession(l) { const u = createSessionEnvelope(l, this._dsn, this._options._metadata, this._options.tunnel); this.sendEnvelope(u) } recordDroppedEvent(l, u, f) { if (this._options.sendClientReports) { const p = typeof f == "number" ? f : 1, d = `${l}:${u}`; DEBUG_BUILD$4 && logger.log(`Recording outcome: "${d}"${p > 1 ? ` (${p} times)` : ""}`), this._outcomes[d] = (this._outcomes[d] || 0) + p } } on(l, u) { const f = this._hooks[l] = this._hooks[l] || []; return f.push(u), () => { const p = f.indexOf(u); p > -1 && f.splice(p, 1) } } emit(l, ...u) { const f = this._hooks[l]; f && f.forEach(p => p(...u)) } sendEnvelope(l) { return this.emit("beforeEnvelope", l), this._isEnabled() && this._transport ? this._transport.send(l).then(null, u => (DEBUG_BUILD$4 && logger.error("Error while sending envelope:", u), u)) : (DEBUG_BUILD$4 && logger.error("Transport disabled"), resolvedSyncPromise({})) } _setupIntegrations() { const { integrations: l } = this._options; this._integrations = setupIntegrations(this, l), afterSetupIntegrations(this, l) } _updateSessionFromEvent(l, u) { let f = u.level === "fatal", p = !1; const d = u.exception && u.exception.values; if (d) { p = !0; for (const I of d) { const F = I.mechanism; if (F && F.handled === !1) { f = !0; break } } } const m = l.status === "ok"; (m && l.errors === 0 || m && f) && (updateSession(l, { ...f && { status: "crashed" }, errors: l.errors || Number(p || f) }), this.captureSession(l)) } _isClientDoneProcessing(l) { return new SyncPromise(u => { let f = 0; const p = 1, d = setInterval(() => { this._numProcessing == 0 ? (clearInterval(d), u(!0)) : (f += p, l && f >= l && (clearInterval(d), u(!1))) }, p) }) } _isEnabled() { return this.getOptions().enabled !== !1 && this._transport !== void 0 } _prepareEvent(l, u, f = getCurrentScope(), p = getIsolationScope()) { const d = this.getOptions(), m = Object.keys(this._integrations); return !u.integrations && m.length > 0 && (u.integrations = m), this.emit("preprocessEvent", l, u), l.type || p.setLastEventId(l.event_id || u.event_id), prepareEvent(d, l, u, f, this, p).then(v => { if (v === null) return v; v.contexts = { trace: getTraceContextFromScope(f), ...v.contexts }; const I = getDynamicSamplingContextFromScope(this, f); return v.sdkProcessingMetadata = { dynamicSamplingContext: I, ...v.sdkProcessingMetadata }, v }) } _captureEvent(l, u = {}, f) { return this._processEvent(l, u, f).then(p => p.event_id, p => { DEBUG_BUILD$4 && (p instanceof SentryError && p.logLevel === "log" ? logger.log(p.message) : logger.warn(p)) }) } _processEvent(l, u, f) {
    const p = this.getOptions(), { sampleRate: d } = p, m = isTransactionEvent(l), v = isErrorEvent(l), I = l.type || "error", F = `before send for type \`${I}\``, B = typeof d > "u" ? void 0 : parseSampleRate(d); if (v && typeof B == "number" && Math.random() > B) return this.recordDroppedEvent("sample_rate", "error", l), rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${d})`, "log")); const W = I === "replay_event" ? "replay" : I, Q = (l.sdkProcessingMetadata || {}).capturedSpanIsolationScope; return this._prepareEvent(l, u, f, Q).then(re => { if (re === null) throw this.recordDroppedEvent("event_processor", W, l), new SentryError("An event processor returned `null`, will not send event.", "log"); if (u.data && u.data.__sentry__ === !0) return re; const oe = processBeforeSend(this, p, re, u); return _validateBeforeSendResult(oe, F) }).then(re => { if (re === null) { if (this.recordDroppedEvent("before_send", W, l), m) { const se = 1 + (l.spans || []).length; this.recordDroppedEvent("before_send", "span", se) } throw new SentryError(`${F} returned \`null\`, will not send event.`, "log") } const ne = f && f.getSession(); if (!m && ne && this._updateSessionFromEvent(ne, re), m) { const ae = re.sdkProcessingMetadata && re.sdkProcessingMetadata.spanCountBeforeProcessing || 0, se = re.spans ? re.spans.length : 0, le = ae - se; le > 0 && this.recordDroppedEvent("before_send", "span", le) } const oe = re.transaction_info; if (m && oe && re.transaction !== l.transaction) { const ae = "custom"; re.transaction_info = { ...oe, source: ae } } return this.sendEvent(re, u), re }).then(null, re => {
      throw re instanceof SentryError ? re : (this.captureException(re, { data: { __sentry__: !0 }, originalException: re }), new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${re}`))
    })
  } _process(l) { this._numProcessing++, l.then(u => (this._numProcessing--, u), u => (this._numProcessing--, u)) } _clearOutcomes() { const l = this._outcomes; return this._outcomes = {}, Object.entries(l).map(([u, f]) => { const [p, d] = u.split(":"); return { reason: p, category: d, quantity: f } }) } _flushOutcomes() { DEBUG_BUILD$4 && logger.log("Flushing outcomes..."); const l = this._clearOutcomes(); if (l.length === 0) { DEBUG_BUILD$4 && logger.log("No outcomes to send"); return } if (!this._dsn) { DEBUG_BUILD$4 && logger.log("No dsn provided, will not send outcomes"); return } DEBUG_BUILD$4 && logger.log("Sending outcomes:", l); const u = createClientReportEnvelope(l, this._options.tunnel && dsnToString(this._dsn)); this.sendEnvelope(u) }
} function _validateBeforeSendResult(o, l) { const u = `${l} must return \`null\` or a valid event.`; if (isThenable(o)) return o.then(f => { if (!isPlainObject(f) && f !== null) throw new SentryError(u); return f }, f => { throw new SentryError(`${l} rejected with ${f}`) }); if (!isPlainObject(o) && o !== null) throw new SentryError(u); return o } function processBeforeSend(o, l, u, f) { const { beforeSend: p, beforeSendTransaction: d, beforeSendSpan: m } = l; if (isErrorEvent(u) && p) return p(u, f); if (isTransactionEvent(u)) { if (u.spans && m) { const v = []; for (const I of u.spans) { const F = m(I); F ? v.push(F) : (showSpanDropWarning(), o.recordDroppedEvent("before_send", "span")) } u.spans = v } if (d) { if (u.spans) { const v = u.spans.length; u.sdkProcessingMetadata = { ...u.sdkProcessingMetadata, spanCountBeforeProcessing: v } } return d(u, f) } } return u } function isErrorEvent(o) { return o.type === void 0 } function isTransactionEvent(o) { return o.type === "transaction" } function initAndBind(o, l) { l.debug === !0 && (DEBUG_BUILD$4 ? logger.enable() : consoleSandbox(() => { console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.") })), getCurrentScope().update(l.initialScope); const f = new o(l); return setCurrentClient(f), f.init(), f } function setCurrentClient(o) { getCurrentScope().setClient(o) } function makePromiseBuffer(o) { const l = []; function u() { return o === void 0 || l.length < o } function f(m) { return l.splice(l.indexOf(m), 1)[0] || Promise.resolve(void 0) } function p(m) { if (!u()) return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached.")); const v = m(); return l.indexOf(v) === -1 && l.push(v), v.then(() => f(v)).then(null, () => f(v).then(null, () => { })), v } function d(m) { return new SyncPromise((v, I) => { let F = l.length; if (!F) return v(!0); const B = setTimeout(() => { m && m > 0 && v(!1) }, m); l.forEach(W => { resolvedSyncPromise(W).then(() => { --F || (clearTimeout(B), v(!0)) }, I) }) }) } return { $: l, add: p, drain: d } } const DEFAULT_RETRY_AFTER = 60 * 1e3; function parseRetryAfterHeader(o, l = Date.now()) { const u = parseInt(`${o}`, 10); if (!isNaN(u)) return u * 1e3; const f = Date.parse(`${o}`); return isNaN(f) ? DEFAULT_RETRY_AFTER : f - l } function disabledUntil(o, l) { return o[l] || o.all || 0 } function isRateLimited(o, l, u = Date.now()) { return disabledUntil(o, l) > u } function updateRateLimits(o, { statusCode: l, headers: u }, f = Date.now()) { const p = { ...o }, d = u && u["x-sentry-rate-limits"], m = u && u["retry-after"]; if (d) for (const v of d.trim().split(",")) { const [I, F, , , B] = v.split(":", 5), W = parseInt(I, 10), Z = (isNaN(W) ? 60 : W) * 1e3; if (!F) p.all = f + Z; else for (const Q of F.split(";")) Q === "metric_bucket" ? (!B || B.split(";").includes("custom")) && (p[Q] = f + Z) : p[Q] = f + Z } else m ? p.all = f + parseRetryAfterHeader(m, f) : l === 429 && (p.all = f + 60 * 1e3); return p } const DEFAULT_TRANSPORT_BUFFER_SIZE = 64; function createTransport(o, l, u = makePromiseBuffer(o.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) { let f = {}; const p = m => u.drain(m); function d(m) { const v = []; if (forEachEnvelopeItem(m, (W, Z) => { const Q = envelopeItemTypeToDataCategory(Z); if (isRateLimited(f, Q)) { const re = getEventForEnvelopeItem(W, Z); o.recordDroppedEvent("ratelimit_backoff", Q, re) } else v.push(W) }), v.length === 0) return resolvedSyncPromise({}); const I = createEnvelope(m[0], v), F = W => { forEachEnvelopeItem(I, (Z, Q) => { const re = getEventForEnvelopeItem(Z, Q); o.recordDroppedEvent(W, envelopeItemTypeToDataCategory(Q), re) }) }, B = () => l({ body: serializeEnvelope(I) }).then(W => (W.statusCode !== void 0 && (W.statusCode < 200 || W.statusCode >= 300) && DEBUG_BUILD$4 && logger.warn(`Sentry responded with status code ${W.statusCode} to sent event.`), f = updateRateLimits(f, W), W), W => { throw F("network_error"), W }); return u.add(B).then(W => W, W => { if (W instanceof SentryError) return DEBUG_BUILD$4 && logger.error("Skipped sending event because buffer is full."), F("queue_overflow"), resolvedSyncPromise({}); throw W }) } return { send: d, flush: p } } function getEventForEnvelopeItem(o, l) { if (!(l !== "event" && l !== "transaction")) return Array.isArray(o) ? o[1] : void 0 } function applySdkMetadata(o, l, u = [l], f = "npm") { const p = o._metadata || {}; p.sdk || (p.sdk = { name: `sentry.javascript.${l}`, packages: u.map(d => ({ name: `${f}:@sentry/${d}`, version: SDK_VERSION })), version: SDK_VERSION }), o._metadata = p } const DEFAULT_BREADCRUMBS = 100; function addBreadcrumb(o, l) { const u = getClient(), f = getIsolationScope(); if (!u) return; const { beforeBreadcrumb: p = null, maxBreadcrumbs: d = DEFAULT_BREADCRUMBS } = u.getOptions(); if (d <= 0) return; const v = { timestamp: dateTimestampInSeconds(), ...o }, I = p ? consoleSandbox(() => p(v, l)) : v; I !== null && (u.emit && u.emit("beforeAddBreadcrumb", I, l), f.addBreadcrumb(I, d)) } let originalFunctionToString; const INTEGRATION_NAME$7 = "FunctionToString", SETUP_CLIENTS = new WeakMap, _functionToStringIntegration = () => ({ name: INTEGRATION_NAME$7, setupOnce() { originalFunctionToString = Function.prototype.toString; try { Function.prototype.toString = function (...o) { const l = getOriginalFunction(this), u = SETUP_CLIENTS.has(getClient()) && l !== void 0 ? l : this; return originalFunctionToString.apply(u, o) } } catch { } }, setup(o) { SETUP_CLIENTS.set(o, !0) } }), functionToStringIntegration = _functionToStringIntegration, DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/], INTEGRATION_NAME$6 = "InboundFilters", _inboundFiltersIntegration = (o = {}) => ({ name: INTEGRATION_NAME$6, processEvent(l, u, f) { const p = f.getOptions(), d = _mergeOptions(o, p); return _shouldDropEvent$1(l, d) ? null : l } }), inboundFiltersIntegration = _inboundFiltersIntegration; function _mergeOptions(o = {}, l = {}) { return { allowUrls: [...o.allowUrls || [], ...l.allowUrls || []], denyUrls: [...o.denyUrls || [], ...l.denyUrls || []], ignoreErrors: [...o.ignoreErrors || [], ...l.ignoreErrors || [], ...o.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS], ignoreTransactions: [...o.ignoreTransactions || [], ...l.ignoreTransactions || []], ignoreInternal: o.ignoreInternal !== void 0 ? o.ignoreInternal : !0 } } function _shouldDropEvent$1(o, l) {
  return l.ignoreInternal && _isSentryError(o) ? (DEBUG_BUILD$4 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(o)}`), !0) : _isIgnoredError(o, l.ignoreErrors) ? (DEBUG_BUILD$4 && logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(o)}`), !0) : _isUselessError(o) ? (DEBUG_BUILD$4 && logger.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(o)}`), !0) : _isIgnoredTransaction(o, l.ignoreTransactions) ? (DEBUG_BUILD$4 && logger.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(o)}`), !0) : _isDeniedUrl(o, l.denyUrls) ? (DEBUG_BUILD$4 && logger.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(o)}.
Url: ${_getEventFilterUrl(o)}`), !0) : _isAllowedUrl(o, l.allowUrls) ? !1 : (DEBUG_BUILD$4 && logger.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(o)}.
Url: ${_getEventFilterUrl(o)}`), !0)
} function _isIgnoredError(o, l) { return o.type || !l || !l.length ? !1 : _getPossibleEventMessages(o).some(u => stringMatchesSomePattern(u, l)) } function _isIgnoredTransaction(o, l) { if (o.type !== "transaction" || !l || !l.length) return !1; const u = o.transaction; return u ? stringMatchesSomePattern(u, l) : !1 } function _isDeniedUrl(o, l) { if (!l || !l.length) return !1; const u = _getEventFilterUrl(o); return u ? stringMatchesSomePattern(u, l) : !1 } function _isAllowedUrl(o, l) { if (!l || !l.length) return !0; const u = _getEventFilterUrl(o); return u ? stringMatchesSomePattern(u, l) : !0 } function _getPossibleEventMessages(o) { const l = []; o.message && l.push(o.message); let u; try { u = o.exception.values[o.exception.values.length - 1] } catch { } return u && u.value && (l.push(u.value), u.type && l.push(`${u.type}: ${u.value}`)), l } function _isSentryError(o) { try { return o.exception.values[0].type === "SentryError" } catch { } return !1 } function _getLastValidUrl(o = []) { for (let l = o.length - 1; l >= 0; l--) { const u = o[l]; if (u && u.filename !== "<anonymous>" && u.filename !== "[native code]") return u.filename || null } return null } function _getEventFilterUrl(o) { try { let l; try { l = o.exception.values[0].stacktrace.frames } catch { } return l ? _getLastValidUrl(l) : null } catch { return DEBUG_BUILD$4 && logger.error(`Cannot extract url for event ${getEventDescription(o)}`), null } } function _isUselessError(o) { return o.type || !o.exception || !o.exception.values || o.exception.values.length === 0 ? !1 : !o.message && !o.exception.values.some(l => l.stacktrace || l.type && l.type !== "Error" || l.value) } function applyAggregateErrorsToEvent(o, l, u = 250, f, p, d, m) { if (!d.exception || !d.exception.values || !m || !isInstanceOf(m.originalException, Error)) return; const v = d.exception.values.length > 0 ? d.exception.values[d.exception.values.length - 1] : void 0; v && (d.exception.values = truncateAggregateExceptions(aggregateExceptionsFromError(o, l, p, m.originalException, f, d.exception.values, v, 0), u)) } function aggregateExceptionsFromError(o, l, u, f, p, d, m, v) { if (d.length >= u + 1) return d; let I = [...d]; if (isInstanceOf(f[p], Error)) { applyExceptionGroupFieldsForParentException(m, v); const F = o(l, f[p]), B = I.length; applyExceptionGroupFieldsForChildException(F, p, B, v), I = aggregateExceptionsFromError(o, l, u, f[p], p, [F, ...I], F, B) } return Array.isArray(f.errors) && f.errors.forEach((F, B) => { if (isInstanceOf(F, Error)) { applyExceptionGroupFieldsForParentException(m, v); const W = o(l, F), Z = I.length; applyExceptionGroupFieldsForChildException(W, `errors[${B}]`, Z, v), I = aggregateExceptionsFromError(o, l, u, F, p, [W, ...I], W, Z) } }), I } function applyExceptionGroupFieldsForParentException(o, l) { o.mechanism = o.mechanism || { type: "generic", handled: !0 }, o.mechanism = { ...o.mechanism, ...o.type === "AggregateError" && { is_exception_group: !0 }, exception_id: l } } function applyExceptionGroupFieldsForChildException(o, l, u, f) { o.mechanism = o.mechanism || { type: "generic", handled: !0 }, o.mechanism = { ...o.mechanism, type: "chained", source: l, exception_id: u, parent_id: f } } function truncateAggregateExceptions(o, l) { return o.map(u => (u.value && (u.value = truncate(u.value, l)), u)) } function parseUrl$1(o) { if (!o) return {}; const l = o.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/); if (!l) return {}; const u = l[6] || "", f = l[8] || ""; return { host: l[4], path: l[5], protocol: l[2], search: u, hash: f, relative: l[5] + u + f } } function addConsoleInstrumentationHandler(o) { const l = "console"; addHandler(l, o), maybeInstrument(l, instrumentConsole) } function instrumentConsole() { "console" in GLOBAL_OBJ && CONSOLE_LEVELS.forEach(function (o) { o in GLOBAL_OBJ.console && fill(GLOBAL_OBJ.console, o, function (l) { return originalConsoleMethods[o] = l, function (...u) { triggerHandlers("console", { args: u, level: o }); const p = originalConsoleMethods[o]; p && p.apply(GLOBAL_OBJ.console, u) } }) }) } function severityLevelFromString(o) { return o === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(o) ? o : "log" } const INTEGRATION_NAME$5 = "CaptureConsole", _captureConsoleIntegration = (o = {}) => { const l = o.levels || CONSOLE_LEVELS, u = !!o.handled; return { name: INTEGRATION_NAME$5, setup(f) { "console" in GLOBAL_OBJ && addConsoleInstrumentationHandler(({ args: p, level: d }) => { getClient() !== f || !l.includes(d) || consoleHandler(p, d, u) }) } } }, captureConsoleIntegration = _captureConsoleIntegration; function consoleHandler(o, l, u) { const f = { level: severityLevelFromString(l), extra: { arguments: o } }; withScope(p => { if (p.addEventProcessor(v => (v.logger = "console", addExceptionMechanism(v, { handled: u, type: "console" }), v)), l === "assert") { if (!o[0]) { const v = `Assertion failed: ${safeJoin(o.slice(1), " ") || "console.assert"}`; p.setExtra("arguments", o.slice(1)), captureMessage(v, f) } return } const d = o.find(v => v instanceof Error); if (d) { captureException(d, f); return } const m = safeJoin(o, " "); captureMessage(m, f) }) } const INTEGRATION_NAME$4 = "Dedupe", _dedupeIntegration = () => { let o; return { name: INTEGRATION_NAME$4, processEvent(l) { if (l.type) return l; try { if (_shouldDropEvent(l, o)) return DEBUG_BUILD$4 && logger.warn("Event dropped due to being a duplicate of previously captured event."), null } catch { } return o = l } } }, dedupeIntegration = _dedupeIntegration; function _shouldDropEvent(o, l) { return l ? !!(_isSameMessageEvent(o, l) || _isSameExceptionEvent(o, l)) : !1 } function _isSameMessageEvent(o, l) { const u = o.message, f = l.message; return !(!u && !f || u && !f || !u && f || u !== f || !_isSameFingerprint(o, l) || !_isSameStacktrace(o, l)) } function _isSameExceptionEvent(o, l) { const u = _getExceptionFromEvent(l), f = _getExceptionFromEvent(o); return !(!u || !f || u.type !== f.type || u.value !== f.value || !_isSameFingerprint(o, l) || !_isSameStacktrace(o, l)) } function _isSameStacktrace(o, l) { let u = getFramesFromEvent(o), f = getFramesFromEvent(l); if (!u && !f) return !0; if (u && !f || !u && f || (u = u, f = f, f.length !== u.length)) return !1; for (let p = 0; p < f.length; p++) { const d = f[p], m = u[p]; if (d.filename !== m.filename || d.lineno !== m.lineno || d.colno !== m.colno || d.function !== m.function) return !1 } return !0 } function _isSameFingerprint(o, l) { let u = o.fingerprint, f = l.fingerprint; if (!u && !f) return !0; if (u && !f || !u && f) return !1; u = u, f = f; try { return u.join("") === f.join("") } catch { return !1 } } function _getExceptionFromEvent(o) { return o.exception && o.exception.values && o.exception.values[0] } function getBreadcrumbLogLevelFromHttpStatusCode(o) { if (o !== void 0) return o >= 400 && o < 500 ? "warning" : o >= 500 ? "error" : void 0 } const WINDOW$3 = GLOBAL_OBJ; function supportsFetch() { if (!("fetch" in WINDOW$3)) return !1; try { return new Headers, new Request("http://www.example.com"), new Response, !0 } catch { return !1 } } function isNativeFunction(o) { return o && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(o.toString()) } function supportsNativeFetch() { if (typeof EdgeRuntime == "string") return !0; if (!supportsFetch()) return !1; if (isNativeFunction(WINDOW$3.fetch)) return !0; let o = !1; const l = WINDOW$3.document; if (l && typeof l.createElement == "function") try { const u = l.createElement("iframe"); u.hidden = !0, l.head.appendChild(u), u.contentWindow && u.contentWindow.fetch && (o = isNativeFunction(u.contentWindow.fetch)), l.head.removeChild(u) } catch (u) { DEBUG_BUILD$3 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", u) } return o } function addFetchInstrumentationHandler(o, l) { const u = "fetch"; addHandler(u, o), maybeInstrument(u, () => instrumentFetch(void 0, l)) } function instrumentFetch(o, l = !1) { l && !supportsNativeFetch() || fill(GLOBAL_OBJ, "fetch", function (u) { return function (...f) { const p = new Error, { method: d, url: m } = parseFetchArgs(f), v = { args: f, fetchData: { method: d, url: m }, startTimestamp: timestampInSeconds() * 1e3, virtualError: p }; return triggerHandlers("fetch", { ...v }), u.apply(GLOBAL_OBJ, f).then(async I => (triggerHandlers("fetch", { ...v, endTimestamp: timestampInSeconds() * 1e3, response: I }), I), I => { throw triggerHandlers("fetch", { ...v, endTimestamp: timestampInSeconds() * 1e3, error: I }), isError(I) && I.stack === void 0 && (I.stack = p.stack, addNonEnumerableProperty(I, "framesToPop", 1)), I }) } }) } function hasProp(o, l) { return !!o && typeof o == "object" && !!o[l] } function getUrlFromResource(o) { return typeof o == "string" ? o : o ? hasProp(o, "url") ? o.url : o.toString ? o.toString() : "" : "" } function parseFetchArgs(o) { if (o.length === 0) return { method: "GET", url: "" }; if (o.length === 2) { const [u, f] = o; return { url: getUrlFromResource(u), method: hasProp(f, "method") ? String(f.method).toUpperCase() : "GET" } } const l = o[0]; return { url: getUrlFromResource(l), method: hasProp(l, "method") ? String(l.method).toUpperCase() : "GET" } } function getDefaultExportFromCjs(o) { return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o } var browser$e = { exports: {} }, process = browser$e.exports = {}, cachedSetTimeout, cachedClearTimeout; function defaultSetTimout() { throw new Error("setTimeout has not been defined") } function defaultClearTimeout() { throw new Error("clearTimeout has not been defined") } (function () { try { typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout } catch { cachedSetTimeout = defaultSetTimout } try { typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout } catch { cachedClearTimeout = defaultClearTimeout } })(); function runTimeout(o) { if (cachedSetTimeout === setTimeout) return setTimeout(o, 0); if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(o, 0); try { return cachedSetTimeout(o, 0) } catch { try { return cachedSetTimeout.call(null, o, 0) } catch { return cachedSetTimeout.call(this, o, 0) } } } function runClearTimeout(o) { if (cachedClearTimeout === clearTimeout) return clearTimeout(o); if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(o); try { return cachedClearTimeout(o) } catch { try { return cachedClearTimeout.call(null, o) } catch { return cachedClearTimeout.call(this, o) } } } var queue = [], draining = !1, currentQueue, queueIndex = -1; function cleanUpNextTick() { !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue()) } function drainQueue() { if (!draining) { var o = runTimeout(cleanUpNextTick); draining = !0; for (var l = queue.length; l;) { for (currentQueue = queue, queue = []; ++queueIndex < l;)currentQueue && currentQueue[queueIndex].run(); queueIndex = -1, l = queue.length } currentQueue = null, draining = !1, runClearTimeout(o) } } process.nextTick = function (o) { var l = new Array(arguments.length - 1); if (arguments.length > 1) for (var u = 1; u < arguments.length; u++)l[u - 1] = arguments[u]; queue.push(new Item(o, l)), queue.length === 1 && !draining && runTimeout(drainQueue) }; function Item(o, l) { this.fun = o, this.array = l } Item.prototype.run = function () { this.fun.apply(null, this.array) }; process.title = "browser"; process.browser = !0; process.env = {}; process.argv = []; process.version = ""; process.versions = {}; function noop$1() { } process.on = noop$1; process.addListener = noop$1; process.once = noop$1; process.off = noop$1; process.removeListener = noop$1; process.removeAllListeners = noop$1; process.emit = noop$1; process.prependListener = noop$1; process.prependOnceListener = noop$1; process.listeners = function (o) { return [] }; process.binding = function (o) { throw new Error("process.binding is not supported") }; process.cwd = function () { return "/" }; process.chdir = function (o) { throw new Error("process.chdir is not supported") }; process.umask = function () { return 0 }; var browserExports = browser$e.exports; const process$1 = getDefaultExportFromCjs(browserExports); function getSDKSource() { return "npm" } const WINDOW$2 = GLOBAL_OBJ; function supportsHistory() { const o = WINDOW$2.chrome, l = o && o.app && o.app.runtime, u = "history" in WINDOW$2 && !!WINDOW$2.history.pushState && !!WINDOW$2.history.replaceState; return !l && u } const WINDOW$1 = GLOBAL_OBJ; let ignoreOnError = 0; function shouldIgnoreOnError() { return ignoreOnError > 0 } function ignoreNextOnError() { ignoreOnError++, setTimeout(() => { ignoreOnError-- }) } function wrap$1(o, l = {}) { function u(p) { return typeof p == "function" } if (!u(o)) return o; try { const p = o.__sentry_wrapped__; if (p) return typeof p == "function" ? p : o; if (getOriginalFunction(o)) return o } catch { return o } const f = function (...p) { try { const d = p.map(m => wrap$1(m, l)); return o.apply(this, d) } catch (d) { throw ignoreNextOnError(), withScope(m => { m.addEventProcessor(v => (l.mechanism && (addExceptionTypeValue(v, void 0), addExceptionMechanism(v, l.mechanism)), v.extra = { ...v.extra, arguments: p }, v)), captureException(d) }), d } }; try { for (const p in o) Object.prototype.hasOwnProperty.call(o, p) && (f[p] = o[p]) } catch { } markFunctionWrapped(f, o), addNonEnumerableProperty(o, "__sentry_wrapped__", f); try { Object.getOwnPropertyDescriptor(f, "name").configurable && Object.defineProperty(f, "name", { get() { return o.name } }) } catch { } return f } const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__; function exceptionFromError(o, l) { const u = parseStackFrames(o, l), f = { type: extractType(l), value: extractMessage(l) }; return u.length && (f.stacktrace = { frames: u }), f.type === void 0 && f.value === "" && (f.value = "Unrecoverable error caught"), f } function eventFromPlainObject(o, l, u, f) { const p = getClient(), d = p && p.getOptions().normalizeDepth, m = getErrorPropertyFromObject(l), v = { __serialized__: normalizeToSize(l, d) }; if (m) return { exception: { values: [exceptionFromError(o, m)] }, extra: v }; const I = { exception: { values: [{ type: isEvent(l) ? l.constructor.name : f ? "UnhandledRejection" : "Error", value: getNonErrorObjectExceptionValue(l, { isUnhandledRejection: f }) }] }, extra: v }; if (u) { const F = parseStackFrames(o, u); F.length && (I.exception.values[0].stacktrace = { frames: F }) } return I } function eventFromError(o, l) { return { exception: { values: [exceptionFromError(o, l)] } } } function parseStackFrames(o, l) { const u = l.stacktrace || l.stack || "", f = getSkipFirstStackStringLines(l), p = getPopFirstTopFrames(l); try { return o(u, f, p) } catch { } return [] } const reactMinifiedRegexp = /Minified React error #\d+;/i; function getSkipFirstStackStringLines(o) { return o && reactMinifiedRegexp.test(o.message) ? 1 : 0 } function getPopFirstTopFrames(o) { return typeof o.framesToPop == "number" ? o.framesToPop : 0 } function isWebAssemblyException(o) { return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? o instanceof WebAssembly.Exception : !1 } function extractType(o) { const l = o && o.name; return !l && isWebAssemblyException(o) ? o.message && Array.isArray(o.message) && o.message.length == 2 ? o.message[0] : "WebAssembly.Exception" : l } function extractMessage(o) { const l = o && o.message; return l ? l.error && typeof l.error.message == "string" ? l.error.message : isWebAssemblyException(o) && Array.isArray(o.message) && o.message.length == 2 ? o.message[1] : l : "No error message" } function eventFromException(o, l, u, f) { const p = u && u.syntheticException || void 0, d = eventFromUnknownInput(o, l, p, f); return addExceptionMechanism(d), d.level = "error", u && u.event_id && (d.event_id = u.event_id), resolvedSyncPromise(d) } function eventFromMessage(o, l, u = "info", f, p) { const d = f && f.syntheticException || void 0, m = eventFromString(o, l, d, p); return m.level = u, f && f.event_id && (m.event_id = f.event_id), resolvedSyncPromise(m) } function eventFromUnknownInput(o, l, u, f, p) { let d; if (isErrorEvent$1(l) && l.error) return eventFromError(o, l.error); if (isDOMError(l) || isDOMException(l)) { const m = l; if ("stack" in l) d = eventFromError(o, l); else { const v = m.name || (isDOMError(m) ? "DOMError" : "DOMException"), I = m.message ? `${v}: ${m.message}` : v; d = eventFromString(o, I, u, f), addExceptionTypeValue(d, I) } return "code" in m && (d.tags = { ...d.tags, "DOMException.code": `${m.code}` }), d } return isError(l) ? eventFromError(o, l) : isPlainObject(l) || isEvent(l) ? (d = eventFromPlainObject(o, l, u, p), addExceptionMechanism(d, { synthetic: !0 }), d) : (d = eventFromString(o, l, u, f), addExceptionTypeValue(d, `${l}`), addExceptionMechanism(d, { synthetic: !0 }), d) } function eventFromString(o, l, u, f) { const p = {}; if (f && u) { const d = parseStackFrames(o, u); d.length && (p.exception = { values: [{ value: l, stacktrace: { frames: d } }] }), addExceptionMechanism(p, { synthetic: !0 }) } if (isParameterizedString(l)) { const { __sentry_template_string__: d, __sentry_template_values__: m } = l; return p.logentry = { message: d, params: m }, p } return p.message = l, p } function getNonErrorObjectExceptionValue(o, { isUnhandledRejection: l }) { const u = extractExceptionKeysForMessage(o), f = l ? "promise rejection" : "exception"; return isErrorEvent$1(o) ? `Event \`ErrorEvent\` captured as ${f} with message \`${o.message}\`` : isEvent(o) ? `Event \`${getObjectClassName(o)}\` (type=${o.type}) captured as ${f}` : `Object captured as ${f} with keys: ${u}` } function getObjectClassName(o) { try { const l = Object.getPrototypeOf(o); return l ? l.constructor.name : void 0 } catch { } } function getErrorPropertyFromObject(o) { for (const l in o) if (Object.prototype.hasOwnProperty.call(o, l)) { const u = o[l]; if (u instanceof Error) return u } } function createUserFeedbackEnvelope(o, { metadata: l, tunnel: u, dsn: f }) { const p = { event_id: o.event_id, sent_at: new Date().toISOString(), ...l && l.sdk && { sdk: { name: l.sdk.name, version: l.sdk.version } }, ...!!u && !!f && { dsn: dsnToString(f) } }, d = createUserFeedbackEnvelopeItem(o); return createEnvelope(p, [d]) } function createUserFeedbackEnvelopeItem(o) { return [{ type: "user_report" }, o] } class BrowserClient extends BaseClient { constructor(l) { const u = { parentSpanIsAlwaysRootSpan: !0, ...l }, f = WINDOW$1.SENTRY_SDK_SOURCE || getSDKSource(); applySdkMetadata(u, "browser", ["browser"], f), super(u), u.sendClientReports && WINDOW$1.document && WINDOW$1.document.addEventListener("visibilitychange", () => { WINDOW$1.document.visibilityState === "hidden" && this._flushOutcomes() }) } eventFromException(l, u) { return eventFromException(this._options.stackParser, l, u, this._options.attachStacktrace) } eventFromMessage(l, u = "info", f) { return eventFromMessage(this._options.stackParser, l, u, f, this._options.attachStacktrace) } captureUserFeedback(l) { if (!this._isEnabled()) { DEBUG_BUILD$2 && logger.warn("SDK not enabled, will not capture user feedback."); return } const u = createUserFeedbackEnvelope(l, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel }); this.sendEnvelope(u) } _prepareEvent(l, u, f) { return l.platform = l.platform || "javascript", super._prepareEvent(l, u, f) } } const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, WINDOW = GLOBAL_OBJ, DEBOUNCE_DURATION = 1e3; let debounceTimerID, lastCapturedEventType, lastCapturedEventTargetId; function addClickKeypressInstrumentationHandler(o) { const l = "dom"; addHandler(l, o), maybeInstrument(l, instrumentDOM) } function instrumentDOM() { if (!WINDOW.document) return; const o = triggerHandlers.bind(null, "dom"), l = makeDOMEventHandler(o, !0); WINDOW.document.addEventListener("click", l, !1), WINDOW.document.addEventListener("keypress", l, !1), ["EventTarget", "Node"].forEach(u => { const p = WINDOW[u], d = p && p.prototype; !d || !d.hasOwnProperty || !d.hasOwnProperty("addEventListener") || (fill(d, "addEventListener", function (m) { return function (v, I, F) { if (v === "click" || v == "keypress") try { const B = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}, W = B[v] = B[v] || { refCount: 0 }; if (!W.handler) { const Z = makeDOMEventHandler(o); W.handler = Z, m.call(this, v, Z, F) } W.refCount++ } catch { } return m.call(this, v, I, F) } }), fill(d, "removeEventListener", function (m) { return function (v, I, F) { if (v === "click" || v == "keypress") try { const B = this.__sentry_instrumentation_handlers__ || {}, W = B[v]; W && (W.refCount--, W.refCount <= 0 && (m.call(this, v, W.handler, F), W.handler = void 0, delete B[v]), Object.keys(B).length === 0 && delete this.__sentry_instrumentation_handlers__) } catch { } return m.call(this, v, I, F) } })) }) } function isSimilarToLastCapturedEvent(o) { if (o.type !== lastCapturedEventType) return !1; try { if (!o.target || o.target._sentryId !== lastCapturedEventTargetId) return !1 } catch { } return !0 } function shouldSkipDOMEvent(o, l) { return o !== "keypress" ? !1 : !l || !l.tagName ? !0 : !(l.tagName === "INPUT" || l.tagName === "TEXTAREA" || l.isContentEditable) } function makeDOMEventHandler(o, l = !1) { return u => { if (!u || u._sentryCaptured) return; const f = getEventTarget(u); if (shouldSkipDOMEvent(u.type, f)) return; addNonEnumerableProperty(u, "_sentryCaptured", !0), f && !f._sentryId && addNonEnumerableProperty(f, "_sentryId", uuid4()); const p = u.type === "keypress" ? "input" : u.type; isSimilarToLastCapturedEvent(u) || (o({ event: u, name: p, global: l }), lastCapturedEventType = u.type, lastCapturedEventTargetId = f ? f._sentryId : void 0), clearTimeout(debounceTimerID), debounceTimerID = WINDOW.setTimeout(() => { lastCapturedEventTargetId = void 0, lastCapturedEventType = void 0 }, DEBOUNCE_DURATION) } } function getEventTarget(o) { try { return o.target } catch { return null } } let lastHref; function addHistoryInstrumentationHandler(o) { const l = "history"; addHandler(l, o), maybeInstrument(l, instrumentHistory) } function instrumentHistory() { if (!supportsHistory()) return; const o = WINDOW.onpopstate; WINDOW.onpopstate = function (...u) { const f = WINDOW.location.href, p = lastHref; if (lastHref = f, triggerHandlers("history", { from: p, to: f }), o) try { return o.apply(this, u) } catch { } }; function l(u) { return function (...f) { const p = f.length > 2 ? f[2] : void 0; if (p) { const d = lastHref, m = String(p); lastHref = m, triggerHandlers("history", { from: d, to: m }) } return u.apply(this, f) } } fill(WINDOW.history, "pushState", l), fill(WINDOW.history, "replaceState", l) } const cachedImplementations = {}; function getNativeImplementation(o) { const l = cachedImplementations[o]; if (l) return l; let u = WINDOW[o]; if (isNativeFunction(u)) return cachedImplementations[o] = u.bind(WINDOW); const f = WINDOW.document; if (f && typeof f.createElement == "function") try { const p = f.createElement("iframe"); p.hidden = !0, f.head.appendChild(p); const d = p.contentWindow; d && d[o] && (u = d[o]), f.head.removeChild(p) } catch (p) { DEBUG_BUILD$1 && logger.warn(`Could not create sandbox iframe for ${o} check, bailing to window.${o}: `, p) } return u && (cachedImplementations[o] = u.bind(WINDOW)) } function clearCachedImplementation(o) { cachedImplementations[o] = void 0 } const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__"; function addXhrInstrumentationHandler(o) { const l = "xhr"; addHandler(l, o), maybeInstrument(l, instrumentXHR) } function instrumentXHR() { if (!WINDOW.XMLHttpRequest) return; const o = XMLHttpRequest.prototype; o.open = new Proxy(o.open, { apply(l, u, f) { const p = new Error, d = timestampInSeconds() * 1e3, m = isString$2(f[0]) ? f[0].toUpperCase() : void 0, v = parseUrl(f[1]); if (!m || !v) return l.apply(u, f); u[SENTRY_XHR_DATA_KEY] = { method: m, url: v, request_headers: {} }, m === "POST" && v.match(/sentry_key/) && (u.__sentry_own_request__ = !0); const I = () => { const F = u[SENTRY_XHR_DATA_KEY]; if (F && u.readyState === 4) { try { F.status_code = u.status } catch { } const B = { endTimestamp: timestampInSeconds() * 1e3, startTimestamp: d, xhr: u, virtualError: p }; triggerHandlers("xhr", B) } }; return "onreadystatechange" in u && typeof u.onreadystatechange == "function" ? u.onreadystatechange = new Proxy(u.onreadystatechange, { apply(F, B, W) { return I(), F.apply(B, W) } }) : u.addEventListener("readystatechange", I), u.setRequestHeader = new Proxy(u.setRequestHeader, { apply(F, B, W) { const [Z, Q] = W, re = B[SENTRY_XHR_DATA_KEY]; return re && isString$2(Z) && isString$2(Q) && (re.request_headers[Z.toLowerCase()] = Q), F.apply(B, W) } }), l.apply(u, f) } }), o.send = new Proxy(o.send, { apply(l, u, f) { const p = u[SENTRY_XHR_DATA_KEY]; if (!p) return l.apply(u, f); f[0] !== void 0 && (p.body = f[0]); const d = { startTimestamp: timestampInSeconds() * 1e3, xhr: u }; return triggerHandlers("xhr", d), l.apply(u, f) } }) } function parseUrl(o) { if (isString$2(o)) return o; try { return o.toString() } catch { } } function makeFetchTransport(o, l = getNativeImplementation("fetch")) { let u = 0, f = 0; function p(d) { const m = d.body.length; u += m, f++; const v = { body: d.body, method: "POST", referrerPolicy: "origin", headers: o.headers, keepalive: u <= 6e4 && f < 15, ...o.fetchOptions }; if (!l) return clearCachedImplementation("fetch"), rejectedSyncPromise("No fetch implementation available"); try { return l(o.url, v).then(I => (u -= m, f--, { statusCode: I.status, headers: { "x-sentry-rate-limits": I.headers.get("X-Sentry-Rate-Limits"), "retry-after": I.headers.get("Retry-After") } })) } catch (I) { return clearCachedImplementation("fetch"), u -= m, f--, rejectedSyncPromise(I) } } return createTransport(o, p) } const CHROME_PRIORITY = 30, GECKO_PRIORITY = 50; function createFrame(o, l, u, f) { const p = { filename: o, function: l === "<anonymous>" ? UNKNOWN_FUNCTION : l, in_app: !0 }; return u !== void 0 && (p.lineno = u), f !== void 0 && (p.colno = f), p } const chromeRegexNoFnName = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i, chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/, chromeStackParserFn = o => { const l = chromeRegexNoFnName.exec(o); if (l) { const [, f, p, d] = l; return createFrame(f, UNKNOWN_FUNCTION, +p, +d) } const u = chromeRegex.exec(o); if (u) { if (u[2] && u[2].indexOf("eval") === 0) { const m = chromeEvalRegex.exec(u[2]); m && (u[2] = m[1], u[3] = m[2], u[4] = m[3]) } const [p, d] = extractSafariExtensionDetails(u[1] || UNKNOWN_FUNCTION, u[2]); return createFrame(d, p, u[3] ? +u[3] : void 0, u[4] ? +u[4] : void 0) } }, chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn], geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, gecko = o => { const l = geckoREgex.exec(o); if (l) { if (l[3] && l[3].indexOf(" > eval") > -1) { const d = geckoEvalRegex.exec(l[3]); d && (l[1] = l[1] || "eval", l[3] = d[1], l[4] = d[2], l[5] = "") } let f = l[3], p = l[1] || UNKNOWN_FUNCTION; return [p, f] = extractSafariExtensionDetails(p, f), createFrame(f, p, l[4] ? +l[4] : void 0, l[5] ? +l[5] : void 0) } }, geckoStackLineParser = [GECKO_PRIORITY, gecko], defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser], defaultStackParser = createStackParser(...defaultStackLineParsers), extractSafariExtensionDetails = (o, l) => { const u = o.indexOf("safari-extension") !== -1, f = o.indexOf("safari-web-extension") !== -1; return u || f ? [o.indexOf("@") !== -1 ? o.split("@")[0] : UNKNOWN_FUNCTION, u ? `safari-extension:${l}` : `safari-web-extension:${l}`] : [o, l] }, MAX_ALLOWED_STRING_LENGTH = 1024, INTEGRATION_NAME$3 = "Breadcrumbs", _breadcrumbsIntegration = (o = {}) => { const l = { console: !0, dom: !0, fetch: !0, history: !0, sentry: !0, xhr: !0, ...o }; return { name: INTEGRATION_NAME$3, setup(u) { l.console && addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(u)), l.dom && addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(u, l.dom)), l.xhr && addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(u)), l.fetch && addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(u)), l.history && addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(u)), l.sentry && u.on("beforeSendEvent", _getSentryBreadcrumbHandler(u)) } } }, breadcrumbsIntegration = _breadcrumbsIntegration; function _getSentryBreadcrumbHandler(o) { return function (u) { getClient() === o && addBreadcrumb({ category: `sentry.${u.type === "transaction" ? "transaction" : "event"}`, event_id: u.event_id, level: u.level, message: getEventDescription(u) }, { event: u }) } } function _getDomBreadcrumbHandler(o, l) { return function (f) { if (getClient() !== o) return; let p, d, m = typeof l == "object" ? l.serializeAttribute : void 0, v = typeof l == "object" && typeof l.maxStringLength == "number" ? l.maxStringLength : void 0; v && v > MAX_ALLOWED_STRING_LENGTH && (DEBUG_BUILD$2 && logger.warn(`\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${v} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`), v = MAX_ALLOWED_STRING_LENGTH), typeof m == "string" && (m = [m]); try { const F = f.event, B = _isEvent(F) ? F.target : F; p = htmlTreeAsString(B, { keyAttrs: m, maxStringLength: v }), d = getComponentName(B) } catch { p = "<unknown>" } if (p.length === 0) return; const I = { category: `ui.${f.name}`, message: p }; d && (I.data = { "ui.component_name": d }), addBreadcrumb(I, { event: f.event, name: f.name, global: f.global }) } } function _getConsoleBreadcrumbHandler(o) { return function (u) { if (getClient() !== o) return; const f = { category: "console", data: { arguments: u.args, logger: "console" }, level: severityLevelFromString(u.level), message: safeJoin(u.args, " ") }; if (u.level === "assert") if (u.args[0] === !1) f.message = `Assertion failed: ${safeJoin(u.args.slice(1), " ") || "console.assert"}`, f.data.arguments = u.args.slice(1); else return; addBreadcrumb(f, { input: u.args, level: u.level }) } } function _getXhrBreadcrumbHandler(o) { return function (u) { if (getClient() !== o) return; const { startTimestamp: f, endTimestamp: p } = u, d = u.xhr[SENTRY_XHR_DATA_KEY]; if (!f || !p || !d) return; const { method: m, url: v, status_code: I, body: F } = d, B = { method: m, url: v, status_code: I }, W = { xhr: u.xhr, input: F, startTimestamp: f, endTimestamp: p }, Z = getBreadcrumbLogLevelFromHttpStatusCode(I); addBreadcrumb({ category: "xhr", data: B, type: "http", level: Z }, W) } } function _getFetchBreadcrumbHandler(o) { return function (u) { if (getClient() !== o) return; const { startTimestamp: f, endTimestamp: p } = u; if (p && !(u.fetchData.url.match(/sentry_key/) && u.fetchData.method === "POST")) if (u.error) { const d = u.fetchData, m = { data: u.error, input: u.args, startTimestamp: f, endTimestamp: p }; addBreadcrumb({ category: "fetch", data: d, level: "error", type: "http" }, m) } else { const d = u.response, m = { ...u.fetchData, status_code: d && d.status }, v = { input: u.args, response: d, startTimestamp: f, endTimestamp: p }, I = getBreadcrumbLogLevelFromHttpStatusCode(m.status_code); addBreadcrumb({ category: "fetch", data: m, type: "http", level: I }, v) } } } function _getHistoryBreadcrumbHandler(o) { return function (u) { if (getClient() !== o) return; let f = u.from, p = u.to; const d = parseUrl$1(WINDOW$1.location.href); let m = f ? parseUrl$1(f) : void 0; const v = parseUrl$1(p); (!m || !m.path) && (m = d), d.protocol === v.protocol && d.host === v.host && (p = v.relative), d.protocol === m.protocol && d.host === m.host && (f = m.relative), addBreadcrumb({ category: "navigation", data: { from: f, to: p } }) } } function _isEvent(o) { return !!o && !!o.target } const DEFAULT_EVENT_TARGET = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"], INTEGRATION_NAME$2 = "BrowserApiErrors", _browserApiErrorsIntegration = (o = {}) => { const l = { XMLHttpRequest: !0, eventTarget: !0, requestAnimationFrame: !0, setInterval: !0, setTimeout: !0, ...o }; return { name: INTEGRATION_NAME$2, setupOnce() { l.setTimeout && fill(WINDOW$1, "setTimeout", _wrapTimeFunction), l.setInterval && fill(WINDOW$1, "setInterval", _wrapTimeFunction), l.requestAnimationFrame && fill(WINDOW$1, "requestAnimationFrame", _wrapRAF), l.XMLHttpRequest && "XMLHttpRequest" in WINDOW$1 && fill(XMLHttpRequest.prototype, "send", _wrapXHR); const u = l.eventTarget; u && (Array.isArray(u) ? u : DEFAULT_EVENT_TARGET).forEach(_wrapEventTarget) } } }, browserApiErrorsIntegration = _browserApiErrorsIntegration; function _wrapTimeFunction(o) { return function (...l) { const u = l[0]; return l[0] = wrap$1(u, { mechanism: { data: { function: getFunctionName(o) }, handled: !1, type: "instrument" } }), o.apply(this, l) } } function _wrapRAF(o) { return function (l) { return o.apply(this, [wrap$1(l, { mechanism: { data: { function: "requestAnimationFrame", handler: getFunctionName(o) }, handled: !1, type: "instrument" } })]) } } function _wrapXHR(o) { return function (...l) { const u = this; return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(p => { p in u && typeof u[p] == "function" && fill(u, p, function (d) { const m = { mechanism: { data: { function: p, handler: getFunctionName(d) }, handled: !1, type: "instrument" } }, v = getOriginalFunction(d); return v && (m.mechanism.data.handler = getFunctionName(v)), wrap$1(d, m) }) }), o.apply(this, l) } } function _wrapEventTarget(o) { const u = WINDOW$1[o], f = u && u.prototype; !f || !f.hasOwnProperty || !f.hasOwnProperty("addEventListener") || (fill(f, "addEventListener", function (p) { return function (d, m, v) { try { isEventListenerObject(m) && (m.handleEvent = wrap$1(m.handleEvent, { mechanism: { data: { function: "handleEvent", handler: getFunctionName(m), target: o }, handled: !1, type: "instrument" } })) } catch { } return p.apply(this, [d, wrap$1(m, { mechanism: { data: { function: "addEventListener", handler: getFunctionName(m), target: o }, handled: !1, type: "instrument" } }), v]) } }), fill(f, "removeEventListener", function (p) { return function (d, m, v) { try { const I = m.__sentry_wrapped__; I && p.call(this, d, I, v) } catch { } return p.call(this, d, m, v) } })) } function isEventListenerObject(o) { return typeof o.handleEvent == "function" } const browserSessionIntegration = () => ({ name: "BrowserSession", setupOnce() { if (typeof WINDOW$1.document > "u") { DEBUG_BUILD$2 && logger.warn("Using the `browserSessionIntegration` in non-browser environments is not supported."); return } startSession({ ignoreDuration: !0 }), captureSession(), addHistoryInstrumentationHandler(({ from: o, to: l }) => { o !== void 0 && o !== l && (startSession({ ignoreDuration: !0 }), captureSession()) }) } }), INTEGRATION_NAME$1 = "GlobalHandlers", _globalHandlersIntegration = (o = {}) => { const l = { onerror: !0, onunhandledrejection: !0, ...o }; return { name: INTEGRATION_NAME$1, setupOnce() { Error.stackTraceLimit = 50 }, setup(u) { l.onerror && (_installGlobalOnErrorHandler(u), globalHandlerLog("onerror")), l.onunhandledrejection && (_installGlobalOnUnhandledRejectionHandler(u), globalHandlerLog("onunhandledrejection")) } } }, globalHandlersIntegration = _globalHandlersIntegration; function _installGlobalOnErrorHandler(o) { addGlobalErrorInstrumentationHandler(l => { const { stackParser: u, attachStacktrace: f } = getOptions(); if (getClient() !== o || shouldIgnoreOnError()) return; const { msg: p, url: d, line: m, column: v, error: I } = l, F = _enhanceEventWithInitialFrame(eventFromUnknownInput(u, I || p, void 0, f, !1), d, m, v); F.level = "error", captureEvent(F, { originalException: I, mechanism: { handled: !1, type: "onerror" } }) }) } function _installGlobalOnUnhandledRejectionHandler(o) { addGlobalUnhandledRejectionInstrumentationHandler(l => { const { stackParser: u, attachStacktrace: f } = getOptions(); if (getClient() !== o || shouldIgnoreOnError()) return; const p = _getUnhandledRejectionError(l), d = isPrimitive(p) ? _eventFromRejectionWithPrimitive(p) : eventFromUnknownInput(u, p, void 0, f, !0); d.level = "error", captureEvent(d, { originalException: p, mechanism: { handled: !1, type: "onunhandledrejection" } }) }) } function _getUnhandledRejectionError(o) { if (isPrimitive(o)) return o; try { if ("reason" in o) return o.reason; if ("detail" in o && "reason" in o.detail) return o.detail.reason } catch { } return o } function _eventFromRejectionWithPrimitive(o) { return { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(o)}` }] } } } function _enhanceEventWithInitialFrame(o, l, u, f) { const p = o.exception = o.exception || {}, d = p.values = p.values || [], m = d[0] = d[0] || {}, v = m.stacktrace = m.stacktrace || {}, I = v.frames = v.frames || [], F = f, B = u, W = isString$2(l) && l.length > 0 ? l : getLocationHref(); return I.length === 0 && I.push({ colno: F, filename: W, function: UNKNOWN_FUNCTION, in_app: !0, lineno: B }), o } function globalHandlerLog(o) { DEBUG_BUILD$2 && logger.log(`Global Handler attached: ${o}`) } function getOptions() { const o = getClient(); return o && o.getOptions() || { stackParser: () => [], attachStacktrace: !1 } } const httpContextIntegration = () => ({ name: "HttpContext", preprocessEvent(o) { if (!WINDOW$1.navigator && !WINDOW$1.location && !WINDOW$1.document) return; const l = o.request && o.request.url || WINDOW$1.location && WINDOW$1.location.href, { referrer: u } = WINDOW$1.document || {}, { userAgent: f } = WINDOW$1.navigator || {}, p = { ...o.request && o.request.headers, ...u && { Referer: u }, ...f && { "User-Agent": f } }, d = { ...o.request, ...l && { url: l }, headers: p }; o.request = d } }), DEFAULT_KEY = "cause", DEFAULT_LIMIT = 5, INTEGRATION_NAME = "LinkedErrors", _linkedErrorsIntegration = (o = {}) => { const l = o.limit || DEFAULT_LIMIT, u = o.key || DEFAULT_KEY; return { name: INTEGRATION_NAME, preprocessEvent(f, p, d) { const m = d.getOptions(); applyAggregateErrorsToEvent(exceptionFromError, m.stackParser, m.maxValueLength, u, l, f, p) } } }, linkedErrorsIntegration = _linkedErrorsIntegration; function getDefaultIntegrations(o) { const l = [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration()]; return o.autoSessionTracking !== !1 && l.push(browserSessionIntegration()), l } function applyDefaultOptions(o = {}) { const l = { defaultIntegrations: getDefaultIntegrations(o), release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : WINDOW$1.SENTRY_RELEASE && WINDOW$1.SENTRY_RELEASE.id ? WINDOW$1.SENTRY_RELEASE.id : void 0, autoSessionTracking: !0, sendClientReports: !0 }; return o.defaultIntegrations == null && delete o.defaultIntegrations, { ...l, ...o } } function shouldShowBrowserExtensionError() { const o = typeof WINDOW$1.window < "u" && WINDOW$1; if (!o) return !1; const l = o.chrome ? "chrome" : "browser", u = o[l], f = u && u.runtime && u.runtime.id, p = WINDOW$1.location && WINDOW$1.location.href || "", d = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"], m = !!f && WINDOW$1 === WINDOW$1.top && d.some(I => p.startsWith(`${I}//`)), v = typeof o.nw < "u"; return !!f && !m && !v } function init$1(o = {}) { const l = applyDefaultOptions(o); if (!l.skipBrowserExtensionCheck && shouldShowBrowserExtensionError()) { consoleSandbox(() => { console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/") }); return } DEBUG_BUILD$2 && (supportsFetch() || logger.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill.")); const u = { ...l, stackParser: stackParserFromStackParserOptions(l.stackParser || defaultStackParser), integrations: getIntegrationsToSetup(l), transport: l.transport || makeFetchTransport }; return initAndBind(BrowserClient, u) } function showReportDialog(o = {}) { if (!WINDOW$1.document) { DEBUG_BUILD$2 && logger.error("Global document not defined in showReportDialog call"); return } const l = getCurrentScope(), u = l.getClient(), f = u && u.getDsn(); if (!f) { DEBUG_BUILD$2 && logger.error("DSN not configured for showReportDialog call"); return } if (l && (o.user = { ...l.getUser(), ...o.user }), !o.eventId) { const v = lastEventId(); v && (o.eventId = v) } const p = WINDOW$1.document.createElement("script"); p.async = !0, p.crossOrigin = "anonymous", p.src = getReportDialogEndpoint(f, o), o.onLoad && (p.onload = o.onLoad); const { onClose: d } = o; if (d) { const v = I => { if (I.data === "__sentry_reportdialog_closed__") try { d() } finally { WINDOW$1.removeEventListener("message", v) } }; WINDOW$1.addEventListener("message", v) } const m = WINDOW$1.document.head || WINDOW$1.document.body; m ? m.appendChild(p) : DEBUG_BUILD$2 && logger.error("Not injecting report dialog. No injection point found in HTML") } function init(o) { const l = { ...o }; return applySdkMetadata(l, "react"), setContext("react", { version: reactExports.version }), init$1(l) } function isAtLeastReact17(o) { const l = o.match(/^([^.]+)/); return l !== null && parseInt(l[0]) >= 17 } function setCause(o, l) { const u = new WeakSet; function f(p, d) { if (!u.has(p)) { if (p.cause) return u.add(p), f(p.cause, d); p.cause = d } } f(o, l) } function captureReactException(o, { componentStack: l }, u) { if (isAtLeastReact17(reactExports.version) && isError(o) && l) { const f = new Error(o.message); f.name = `React ErrorBoundary ${o.name}`, f.stack = l, setCause(o, f) } return captureException(o, { ...u, captureContext: { contexts: { react: { componentStack: l } } } }) } var reactIs = { exports: {} }, reactIs_production_min = {};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactIs_production_min; function requireReactIs_production_min() { if (hasRequiredReactIs_production_min) return reactIs_production_min; hasRequiredReactIs_production_min = 1; var o = typeof Symbol == "function" && Symbol.for, l = o ? Symbol.for("react.element") : 60103, u = o ? Symbol.for("react.portal") : 60106, f = o ? Symbol.for("react.fragment") : 60107, p = o ? Symbol.for("react.strict_mode") : 60108, d = o ? Symbol.for("react.profiler") : 60114, m = o ? Symbol.for("react.provider") : 60109, v = o ? Symbol.for("react.context") : 60110, I = o ? Symbol.for("react.async_mode") : 60111, F = o ? Symbol.for("react.concurrent_mode") : 60111, B = o ? Symbol.for("react.forward_ref") : 60112, W = o ? Symbol.for("react.suspense") : 60113, Z = o ? Symbol.for("react.suspense_list") : 60120, Q = o ? Symbol.for("react.memo") : 60115, re = o ? Symbol.for("react.lazy") : 60116, ne = o ? Symbol.for("react.block") : 60121, oe = o ? Symbol.for("react.fundamental") : 60117, ae = o ? Symbol.for("react.responder") : 60118, se = o ? Symbol.for("react.scope") : 60119; function le(he) { if (typeof he == "object" && he !== null) { var pe = he.$$typeof; switch (pe) { case l: switch (he = he.type, he) { case I: case F: case f: case d: case p: case W: return he; default: switch (he = he && he.$$typeof, he) { case v: case B: case re: case Q: case m: return he; default: return pe } }case u: return pe } } } function ue(he) { return le(he) === F } return reactIs_production_min.AsyncMode = I, reactIs_production_min.ConcurrentMode = F, reactIs_production_min.ContextConsumer = v, reactIs_production_min.ContextProvider = m, reactIs_production_min.Element = l, reactIs_production_min.ForwardRef = B, reactIs_production_min.Fragment = f, reactIs_production_min.Lazy = re, reactIs_production_min.Memo = Q, reactIs_production_min.Portal = u, reactIs_production_min.Profiler = d, reactIs_production_min.StrictMode = p, reactIs_production_min.Suspense = W, reactIs_production_min.isAsyncMode = function (he) { return ue(he) || le(he) === I }, reactIs_production_min.isConcurrentMode = ue, reactIs_production_min.isContextConsumer = function (he) { return le(he) === v }, reactIs_production_min.isContextProvider = function (he) { return le(he) === m }, reactIs_production_min.isElement = function (he) { return typeof he == "object" && he !== null && he.$$typeof === l }, reactIs_production_min.isForwardRef = function (he) { return le(he) === B }, reactIs_production_min.isFragment = function (he) { return le(he) === f }, reactIs_production_min.isLazy = function (he) { return le(he) === re }, reactIs_production_min.isMemo = function (he) { return le(he) === Q }, reactIs_production_min.isPortal = function (he) { return le(he) === u }, reactIs_production_min.isProfiler = function (he) { return le(he) === d }, reactIs_production_min.isStrictMode = function (he) { return le(he) === p }, reactIs_production_min.isSuspense = function (he) { return le(he) === W }, reactIs_production_min.isValidElementType = function (he) { return typeof he == "string" || typeof he == "function" || he === f || he === F || he === d || he === p || he === W || he === Z || typeof he == "object" && he !== null && (he.$$typeof === re || he.$$typeof === Q || he.$$typeof === m || he.$$typeof === v || he.$$typeof === B || he.$$typeof === oe || he.$$typeof === ae || he.$$typeof === se || he.$$typeof === ne) }, reactIs_production_min.typeOf = le, reactIs_production_min } var hasRequiredReactIs; function requireReactIs() { return hasRequiredReactIs || (hasRequiredReactIs = 1, reactIs.exports = requireReactIs_production_min()), reactIs.exports } var hoistNonReactStatics_cjs, hasRequiredHoistNonReactStatics_cjs; function requireHoistNonReactStatics_cjs() { if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs; hasRequiredHoistNonReactStatics_cjs = 1; var o = requireReactIs(), l = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, u = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, f = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, p = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, d = {}; d[o.ForwardRef] = f, d[o.Memo] = p; function m(re) { return o.isMemo(re) ? p : d[re.$$typeof] || l } var v = Object.defineProperty, I = Object.getOwnPropertyNames, F = Object.getOwnPropertySymbols, B = Object.getOwnPropertyDescriptor, W = Object.getPrototypeOf, Z = Object.prototype; function Q(re, ne, oe) { if (typeof ne != "string") { if (Z) { var ae = W(ne); ae && ae !== Z && Q(re, ae, oe) } var se = I(ne); F && (se = se.concat(F(ne))); for (var le = m(re), ue = m(ne), he = 0; he < se.length; ++he) { var pe = se[he]; if (!u[pe] && !(oe && oe[pe]) && !(ue && ue[pe]) && !(le && le[pe])) { var ve = B(ne, pe); try { v(re, pe, ve) } catch { } } } } return re } return hoistNonReactStatics_cjs = Q, hoistNonReactStatics_cjs } var hoistNonReactStatics_cjsExports = requireHoistNonReactStatics_cjs(); const hoistNonReactStatics = getDefaultExportFromCjs$1(hoistNonReactStatics_cjsExports), DEBUG_BUILD = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, INITIAL_STATE = { componentStack: null, error: null, eventId: null }; class ErrorBoundary extends reactExports.Component { constructor(l) { super(l), ErrorBoundary.prototype.__init.call(this), this.state = INITIAL_STATE, this._openFallbackReportDialog = !0; const u = getClient(); u && l.showDialog && (this._openFallbackReportDialog = !1, this._cleanupHook = u.on("afterSendEvent", f => { !f.type && this._lastEventId && f.event_id === this._lastEventId && showReportDialog({ ...l.dialogOptions, eventId: this._lastEventId }) })) } componentDidCatch(l, u) { const { componentStack: f } = u, p = f ?? void 0, { beforeCapture: d, onError: m, showDialog: v, dialogOptions: I } = this.props; withScope(F => { d && d(F, l, p); const B = this.props.handled != null ? this.props.handled : !!this.props.fallback, W = captureReactException(l, u, { mechanism: { handled: B } }); m && m(l, p, W), v && (this._lastEventId = W, this._openFallbackReportDialog && showReportDialog({ ...I, eventId: W })), this.setState({ error: l, componentStack: f, eventId: W }) }) } componentDidMount() { const { onMount: l } = this.props; l && l() } componentWillUnmount() { const { error: l, componentStack: u, eventId: f } = this.state, { onUnmount: p } = this.props; p && p(l, u, f), this._cleanupHook && (this._cleanupHook(), this._cleanupHook = void 0) } __init() { this.resetErrorBoundary = () => { const { onReset: l } = this.props, { error: u, componentStack: f, eventId: p } = this.state; l && l(u, f, p), this.setState(INITIAL_STATE) } } render() { const { fallback: l, children: u } = this.props, f = this.state; if (f.error) { let p; return typeof l == "function" ? p = reactExports.createElement(l, { error: f.error, componentStack: f.componentStack, resetError: this.resetErrorBoundary, eventId: f.eventId }) : p = l, reactExports.isValidElement(p) ? p : (l && DEBUG_BUILD && logger.warn("fallback did not produce a valid ReactElement"), null) } return typeof u == "function" ? u() : u } } var dist$2 = {}, Address = {}, symbol_inspect, hasRequiredSymbol_inspect; function requireSymbol_inspect() { return hasRequiredSymbol_inspect || (hasRequiredSymbol_inspect = 1, symbol_inspect = Symbol.for("nodejs.util.inspect.custom")), symbol_inspect } var crc16 = {}, hasRequiredCrc16; function requireCrc16() { if (hasRequiredCrc16) return crc16; hasRequiredCrc16 = 1, Object.defineProperty(crc16, "__esModule", { value: !0 }), crc16.crc16 = void 0; function o(l) { let f = 0; const p = Buffer.alloc(l.length + 2); p.set(l); for (let d of p) { let m = 128; for (; m > 0;)f <<= 1, d & m && (f += 1), m >>= 1, f > 65535 && (f &= 65535, f ^= 4129) } return Buffer.from([Math.floor(f / 256), f % 256]) } return crc16.crc16 = o, crc16 } var hasRequiredAddress; function requireAddress() { if (hasRequiredAddress) return Address; hasRequiredAddress = 1; var o = Address && Address.__importDefault || function (B) { return B && B.__esModule ? B : { default: B } }, l; Object.defineProperty(Address, "__esModule", { value: !0 }), Address.address = Address.Address = void 0; const u = o(requireSymbol_inspect()), f = requireCrc16(), p = 17, d = 81, m = 128; function v(B) { if (typeof B == "string" && !I.isFriendly(B)) throw new Error("Unknown address type"); const W = Buffer.isBuffer(B) ? B : Buffer.from(B, "base64"); if (W.length !== 36) throw new Error("Unknown address type: byte length is not equal to 36"); const Z = W.subarray(0, 34), Q = W.subarray(34, 36), re = (0, f.crc16)(Z); if (!(re[0] === Q[0] && re[1] === Q[1])) throw new Error("Invalid checksum: " + B); let ne = Z[0], oe = !1, ae = !1; if (ne & m && (oe = !0, ne = ne ^ m), ne !== p && ne !== d) throw "Unknown address tag"; ae = ne === p; let se = null; Z[1] === 255 ? se = -1 : se = Z[1]; const le = Z.subarray(2, 34); return { isTestOnly: oe, isBounceable: ae, workchain: se, hashPart: le } } let I = class oi { static isAddress(W) { return W instanceof oi } static isFriendly(W) { return !(W.length !== 48 || !/[A-Za-z0-9+/_-]+/.test(W)) } static isRaw(W) { if (W.indexOf(":") === -1) return !1; let [Z, Q] = W.split(":"); return !(!Number.isInteger(parseFloat(Z)) || !/[a-f0-9]+/.test(Q.toLowerCase()) || Q.length !== 64) } static normalize(W) { return typeof W == "string" ? oi.parse(W).toString() : W.toString() } static parse(W) { if (oi.isFriendly(W)) return this.parseFriendly(W).address; if (oi.isRaw(W)) return this.parseRaw(W); throw new Error("Unknown address type: " + W) } static parseRaw(W) { let Z = parseInt(W.split(":")[0]), Q = Buffer.from(W.split(":")[1], "hex"); return new oi(Z, Q) } static parseFriendly(W) { if (Buffer.isBuffer(W)) { let Z = v(W); return { isBounceable: Z.isBounceable, isTestOnly: Z.isTestOnly, address: new oi(Z.workchain, Z.hashPart) } } else { let Z = W.replace(/\-/g, "+").replace(/_/g, "/"), Q = v(Z); return { isBounceable: Q.isBounceable, isTestOnly: Q.isTestOnly, address: new oi(Q.workchain, Q.hashPart) } } } constructor(W, Z) { if (this.toRawString = () => this.workChain + ":" + this.hash.toString("hex"), this.toRaw = () => { const Q = Buffer.alloc(36); return Q.set(this.hash), Q.set([this.workChain, this.workChain, this.workChain, this.workChain], 32), Q }, this.toStringBuffer = Q => { let re = Q && Q.testOnly !== void 0 ? Q.testOnly : !1, oe = (Q && Q.bounceable !== void 0 ? Q.bounceable : !0) ? p : d; re && (oe |= m); const ae = Buffer.alloc(34); ae[0] = oe, ae[1] = this.workChain, ae.set(this.hash, 2); const se = Buffer.alloc(36); return se.set(ae), se.set((0, f.crc16)(ae), 34), se }, this.toString = Q => { let re = Q && Q.urlSafe !== void 0 ? Q.urlSafe : !0, ne = this.toStringBuffer(Q); return re ? ne.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : ne.toString("base64") }, this[l] = () => this.toString(), Z.length !== 32) throw new Error("Invalid address hash length: " + Z.length); this.workChain = W, this.hash = Z, Object.freeze(this) } equals(W) { return W.workChain !== this.workChain ? !1 : W.hash.equals(this.hash) } }; Address.Address = I, l = u.default; function F(B) { return I.parse(B) } return Address.address = F, Address } var ExternalAddress = {}, hasRequiredExternalAddress; function requireExternalAddress() { if (hasRequiredExternalAddress) return ExternalAddress; hasRequiredExternalAddress = 1; var o = ExternalAddress && ExternalAddress.__importDefault || function (p) { return p && p.__esModule ? p : { default: p } }, l; Object.defineProperty(ExternalAddress, "__esModule", { value: !0 }), ExternalAddress.ExternalAddress = void 0; const u = o(requireSymbol_inspect()); let f = class xf { static isAddress(d) { return d instanceof xf } constructor(d, m) { this[l] = () => this.toString(), this.value = d, this.bits = m } toString() { return `External<${this.bits}:${this.value}>` } }; return ExternalAddress.ExternalAddress = f, l = u.default, ExternalAddress } var ADNLAddress = {}, base32 = {}, hasRequiredBase32; function requireBase32() { if (hasRequiredBase32) return base32; hasRequiredBase32 = 1, Object.defineProperty(base32, "__esModule", { value: !0 }), base32.base32Decode = base32.base32Encode = void 0; const o = "abcdefghijklmnopqrstuvwxyz234567"; function l(p) { const d = p.byteLength; let m = 0, v = 0, I = ""; for (let F = 0; F < d; F++)for (v = v << 8 | p[F], m += 8; m >= 5;)I += o[v >>> m - 5 & 31], m -= 5; return m > 0 && (I += o[v << 5 - m & 31]), I } base32.base32Encode = l; function u(p, d) { const m = p.indexOf(d); if (m === -1) throw new Error("Invalid character found: " + d); return m } function f(p) { let d; d = p.toLowerCase(); const { length: m } = d; let v = 0, I = 0, F = 0; const B = Buffer.alloc(m * 5 / 8 | 0); for (let W = 0; W < m; W++)I = I << 5 | u(o, d[W]), v += 5, v >= 8 && (B[F++] = I >>> v - 8 & 255, v -= 8); return B } return base32.base32Decode = f, base32 } var hasRequiredADNLAddress; function requireADNLAddress() { if (hasRequiredADNLAddress) return ADNLAddress; hasRequiredADNLAddress = 1; var o = ADNLAddress && ADNLAddress.__importDefault || function (m) { return m && m.__esModule ? m : { default: m } }, l; Object.defineProperty(ADNLAddress, "__esModule", { value: !0 }), ADNLAddress.ADNLAddress = void 0; const u = o(requireSymbol_inspect()), f = requireBase32(), p = requireCrc16(); let d = class tl { static parseFriendly(v) { if (v.length !== 55) throw Error("Invalid address"); v = "f" + v; let I = (0, f.base32Decode)(v); if (I[0] !== 45) throw Error("Invalid address"); let F = I.slice(33); if (!(0, p.crc16)(I.slice(0, 33)).equals(F)) throw Error("Invalid address"); return new tl(I.slice(1, 33)) } static parseRaw(v) { const I = Buffer.from(v, "base64"); return new tl(I) } constructor(v) { if (this.toRaw = () => this.address.toString("hex").toUpperCase(), this.toString = () => { let I = Buffer.concat([Buffer.from([45]), this.address]), F = (0, p.crc16)(I); return I = Buffer.concat([I, F]), (0, f.base32Encode)(I).slice(1) }, this[l] = () => this.toString(), v.length !== 32) throw Error("Invalid address"); this.address = v } equals(v) { return this.address.equals(v.address) } }; return ADNLAddress.ADNLAddress = d, l = u.default, ADNLAddress } var contractAddress = {}, Builder = {}, BitBuilder = {}, BitString = {}, paddedBits = {}, hasRequiredPaddedBits; function requirePaddedBits() { if (hasRequiredPaddedBits) return paddedBits; hasRequiredPaddedBits = 1, Object.defineProperty(paddedBits, "__esModule", { value: !0 }), paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0; const o = requireBitBuilder(), l = requireBitString(); function u(p) { let d = new o.BitBuilder(Math.ceil(p.length / 8) * 8); d.writeBits(p); let m = Math.ceil(p.length / 8) * 8 - p.length; for (let v = 0; v < m; v++)v === 0 ? d.writeBit(1) : d.writeBit(0); return d.buffer() } paddedBits.bitsToPaddedBuffer = u; function f(p) { let d = 0; for (let m = p.length - 1; m >= 0; m--)if (p[m] !== 0) { const v = p[m]; let I = v & -v; (I & 1) == 0 && (I = Math.log2(I) + 1), m > 0 && (d = m << 3), d += 8 - I; break } return new l.BitString(p, 0, d) } return paddedBits.paddedBufferToBits = f, paddedBits } var hasRequiredBitString; function requireBitString() { if (hasRequiredBitString) return BitString; hasRequiredBitString = 1; var o = BitString && BitString.__importDefault || function (d) { return d && d.__esModule ? d : { default: d } }, l; Object.defineProperty(BitString, "__esModule", { value: !0 }), BitString.BitString = void 0; const u = requirePaddedBits(), f = o(requireSymbol_inspect()); let p = class Ss { static isBitString(m) { return m instanceof Ss } constructor(m, v, I) { if (this[l] = () => this.toString(), I < 0) throw new Error(`Length ${I} is out of bounds`); this._length = I, this._data = m, this._offset = v } get length() { return this._length } at(m) { if (m >= this._length) throw new Error(`Index ${m} > ${this._length} is out of bounds`); if (m < 0) throw new Error(`Index ${m} < 0 is out of bounds`); let v = this._offset + m >> 3, I = 7 - (this._offset + m) % 8; return (this._data[v] & 1 << I) !== 0 } substring(m, v) { if (m > this._length) throw new Error(`Offset(${m}) > ${this._length} is out of bounds`); if (m < 0) throw new Error(`Offset(${m}) < 0 is out of bounds`); if (v === 0) return Ss.EMPTY; if (m + v > this._length) throw new Error(`Offset ${m} + Length ${v} > ${this._length} is out of bounds`); return new Ss(this._data, this._offset + m, v) } subbuffer(m, v) { if (m > this._length) throw new Error(`Offset ${m} is out of bounds`); if (m < 0) throw new Error(`Offset ${m} is out of bounds`); if (m + v > this._length) throw new Error(`Offset + Lenght = ${m + v} is out of bounds`); if (v % 8 !== 0 || (this._offset + m) % 8 !== 0) return null; let I = this._offset + m >> 3, F = I + (v >> 3); return this._data.subarray(I, F) } equals(m) { if (this._length !== m._length) return !1; for (let v = 0; v < this._length; v++)if (this.at(v) !== m.at(v)) return !1; return !0 } toString() { const m = (0, u.bitsToPaddedBuffer)(this); if (this._length % 4 === 0) { const v = m.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase(); return this._length % 8 === 0 ? v : v.substring(0, v.length - 1) } else { const v = m.toString("hex").toUpperCase(); return this._length % 8 <= 4 ? v.substring(0, v.length - 1) + "_" : v + "_" } } }; return BitString.BitString = p, l = f.default, p.EMPTY = new p(Buffer.alloc(0), 0, 0), BitString } var hasRequiredBitBuilder; function requireBitBuilder() { if (hasRequiredBitBuilder) return BitBuilder; hasRequiredBitBuilder = 1, Object.defineProperty(BitBuilder, "__esModule", { value: !0 }), BitBuilder.BitBuilder = void 0; const o = requireAddress(), l = requireExternalAddress(), u = requireBitString(); let f = class { constructor(d = 1023) { this._buffer = Buffer.alloc(Math.ceil(d / 8)), this._length = 0 } get length() { return this._length } writeBit(d) { let m = this._length; if (m > this._buffer.length * 8) throw new Error("BitBuilder overflow"); (typeof d == "boolean" && d === !0 || typeof d == "number" && d > 0) && (this._buffer[m / 8 | 0] |= 1 << 7 - m % 8), this._length++ } writeBits(d) { for (let m = 0; m < d.length; m++)this.writeBit(d.at(m)) } writeBuffer(d) { if (this._length % 8 === 0) { if (this._length + d.length * 8 > this._buffer.length * 8) throw new Error("BitBuilder overflow"); d.copy(this._buffer, this._length / 8), this._length += d.length * 8 } else for (let m = 0; m < d.length; m++)this.writeUint(d[m], 8) } writeUint(d, m) { if (m < 0 || !Number.isSafeInteger(m)) throw Error(`invalid bit length. Got ${m}`); const v = BigInt(d); if (m === 0) { if (v !== 0n) throw Error(`value is not zero for ${m} bits. Got ${d}`); return } const I = 1n << BigInt(m); if (v < 0 || v >= I) throw Error(`bitLength is too small for a value ${d}. Got ${m}`); if (this._length + m > this._buffer.length * 8) throw new Error("BitBuilder overflow"); const F = 8 - this._length % 8; if (F > 0) { const B = Math.floor(this._length / 8); if (m < F) { const W = Number(v); this._buffer[B] |= W << F - m, this._length += m } else { const W = Number(v >> BigInt(m - F)); this._buffer[B] |= W, this._length += F } } for (m -= F; m > 0;)m >= 8 ? (this._buffer[this._length / 8] = Number(v >> BigInt(m - 8) & 0xffn), this._length += 8, m -= 8) : (this._buffer[this._length / 8] = Number(v << BigInt(8 - m) & 0xffn), this._length += m, m = 0) } writeInt(d, m) { let v = BigInt(d); if (m < 0 || !Number.isSafeInteger(m)) throw Error(`invalid bit length. Got ${m}`); if (m === 0) { if (d !== 0n) throw Error(`value is not zero for ${m} bits. Got ${d}`); return } if (m === 1) { if (d !== -1n && d !== 0n) throw Error(`value is not zero or -1 for ${m} bits. Got ${d}`); this.writeBit(d === -1n); return } let I = 1n << BigInt(m) - 1n; if (v < -I || v >= I) throw Error(`value is out of range for ${m} bits. Got ${d}`); v < 0 ? (this.writeBit(!0), v = I + v) : this.writeBit(!1), this.writeUint(v, m - 1) } writeVarUint(d, m) { let v = BigInt(d); if (m < 0 || !Number.isSafeInteger(m)) throw Error(`invalid bit length. Got ${m}`); if (v < 0) throw Error(`value is negative. Got ${d}`); if (v === 0n) { this.writeUint(0, m); return } const I = Math.ceil(v.toString(2).length / 8), F = I * 8; this.writeUint(I, m), this.writeUint(v, F) } writeVarInt(d, m) { let v = BigInt(d); if (m < 0 || !Number.isSafeInteger(m)) throw Error(`invalid bit length. Got ${m}`); if (v === 0n) { this.writeUint(0, m); return } let I = v > 0 ? v : -v; const F = 1 + Math.ceil(I.toString(2).length / 8), B = F * 8; this.writeUint(F, m), this.writeInt(v, B) } writeCoins(d) { this.writeVarUint(d, 4) } writeAddress(d) { if (d == null) { this.writeUint(0, 2); return } if (o.Address.isAddress(d)) { this.writeUint(2, 2), this.writeUint(0, 1), this.writeInt(d.workChain, 8), this.writeBuffer(d.hash); return } if (l.ExternalAddress.isAddress(d)) { this.writeUint(1, 2), this.writeUint(d.bits, 9), this.writeUint(d.value, d.bits); return } throw Error(`Invalid address. Got ${d}`) } build() { return new u.BitString(this._buffer, 0, this._length) } buffer() { if (this._length % 8 !== 0) throw new Error("BitBuilder buffer is not byte aligned"); return this._buffer.subarray(0, this._length / 8) } }; return BitBuilder.BitBuilder = f, BitBuilder } var Cell = {}, CellType = {}, hasRequiredCellType; function requireCellType() { if (hasRequiredCellType) return CellType; hasRequiredCellType = 1, Object.defineProperty(CellType, "__esModule", { value: !0 }), CellType.CellType = void 0; var o; return function (l) { l[l.Ordinary = -1] = "Ordinary", l[l.PrunedBranch = 1] = "PrunedBranch", l[l.Library = 2] = "Library", l[l.MerkleProof = 3] = "MerkleProof", l[l.MerkleUpdate = 4] = "MerkleUpdate" }(o || (CellType.CellType = o = {})), CellType } var Slice = {}, Dictionary = {}, generateMerkleProof = {}, readUnaryLength = {}, hasRequiredReadUnaryLength; function requireReadUnaryLength() { if (hasRequiredReadUnaryLength) return readUnaryLength; hasRequiredReadUnaryLength = 1, Object.defineProperty(readUnaryLength, "__esModule", { value: !0 }), readUnaryLength.readUnaryLength = void 0; function o(l) { let u = 0; for (; l.loadBit();)u++; return u } return readUnaryLength.readUnaryLength = o, readUnaryLength } var exoticMerkleProof = {}, BitReader = {}, hasRequiredBitReader; function requireBitReader() { if (hasRequiredBitReader) return BitReader; hasRequiredBitReader = 1, Object.defineProperty(BitReader, "__esModule", { value: !0 }), BitReader.BitReader = void 0; const o = requireAddress(), l = requireExternalAddress(); let u = class Sf { constructor(p, d = 0) { this._checkpoints = [], this._bits = p, this._offset = d } get offset() { return this._offset } get remaining() { return this._bits.length - this._offset } skip(p) { if (p < 0 || this._offset + p > this._bits.length) throw new Error(`Index ${this._offset + p} is out of bounds`); this._offset += p } reset() { this._checkpoints.length > 0 ? this._offset = this._checkpoints.pop() : this._offset = 0 } save() { this._checkpoints.push(this._offset) } loadBit() { let p = this._bits.at(this._offset); return this._offset++, p } preloadBit() { return this._bits.at(this._offset) } loadBits(p) { let d = this._bits.substring(this._offset, p); return this._offset += p, d } preloadBits(p) { return this._bits.substring(this._offset, p) } loadBuffer(p) { let d = this._preloadBuffer(p, this._offset); return this._offset += p * 8, d } preloadBuffer(p) { return this._preloadBuffer(p, this._offset) } loadUint(p) { return this._toSafeInteger(this.loadUintBig(p), "loadUintBig") } loadUintBig(p) { let d = this.preloadUintBig(p); return this._offset += p, d } preloadUint(p) { return this._toSafeInteger(this._preloadUint(p, this._offset), "preloadUintBig") } preloadUintBig(p) { return this._preloadUint(p, this._offset) } loadInt(p) { let d = this._preloadInt(p, this._offset); return this._offset += p, this._toSafeInteger(d, "loadUintBig") } loadIntBig(p) { let d = this._preloadInt(p, this._offset); return this._offset += p, d } preloadInt(p) { return this._toSafeInteger(this._preloadInt(p, this._offset), "preloadIntBig") } preloadIntBig(p) { return this._preloadInt(p, this._offset) } loadVarUint(p) { let d = Number(this.loadUint(p)); return this._toSafeInteger(this.loadUintBig(d * 8), "loadVarUintBig") } loadVarUintBig(p) { let d = Number(this.loadUint(p)); return this.loadUintBig(d * 8) } preloadVarUint(p) { let d = Number(this._preloadUint(p, this._offset)); return this._toSafeInteger(this._preloadUint(d * 8, this._offset + p), "preloadVarUintBig") } preloadVarUintBig(p) { let d = Number(this._preloadUint(p, this._offset)); return this._preloadUint(d * 8, this._offset + p) } loadVarInt(p) { let d = Number(this.loadUint(p)); return this._toSafeInteger(this.loadIntBig(d * 8), "loadVarIntBig") } loadVarIntBig(p) { let d = Number(this.loadUint(p)); return this.loadIntBig(d * 8) } preloadVarInt(p) { let d = Number(this._preloadUint(p, this._offset)); return this._toSafeInteger(this._preloadInt(d * 8, this._offset + p), "preloadVarIntBig") } preloadVarIntBig(p) { let d = Number(this._preloadUint(p, this._offset)); return this._preloadInt(d * 8, this._offset + p) } loadCoins() { return this.loadVarUintBig(4) } preloadCoins() { return this.preloadVarUintBig(4) } loadAddress() { let p = Number(this._preloadUint(2, this._offset)); if (p === 2) return this._loadInternalAddress(); throw new Error("Invalid address: " + p) } loadMaybeAddress() { let p = Number(this._preloadUint(2, this._offset)); if (p === 0) return this._offset += 2, null; if (p === 2) return this._loadInternalAddress(); throw new Error("Invalid address") } loadExternalAddress() { if (Number(this._preloadUint(2, this._offset)) === 1) return this._loadExternalAddress(); throw new Error("Invalid address") } loadMaybeExternalAddress() { let p = Number(this._preloadUint(2, this._offset)); if (p === 0) return this._offset += 2, null; if (p === 1) return this._loadExternalAddress(); throw new Error("Invalid address") } loadAddressAny() { let p = Number(this._preloadUint(2, this._offset)); if (p === 0) return this._offset += 2, null; if (p === 2) return this._loadInternalAddress(); if (p === 1) return this._loadExternalAddress(); throw Error(p === 3 ? "Unsupported" : "Unreachable") } loadPaddedBits(p) { if (p % 8 !== 0) throw new Error("Invalid number of bits"); let d = p; for (; ;)if (this._bits.at(this._offset + d - 1)) { d--; break } else d--; let m = this._bits.substring(this._offset, d); return this._offset += p, m } clone() { return new Sf(this._bits, this._offset) } _preloadInt(p, d) { if (p == 0) return 0n; let m = this._bits.at(d), v = 0n; for (let I = 0; I < p - 1; I++)this._bits.at(d + 1 + I) && (v += 1n << BigInt(p - I - 1 - 1)); return m && (v = v - (1n << BigInt(p - 1))), v } _preloadUint(p, d) { if (p == 0) return 0n; let m = 0n; for (let v = 0; v < p; v++)this._bits.at(d + v) && (m += 1n << BigInt(p - v - 1)); return m } _preloadBuffer(p, d) { let m = this._bits.subbuffer(d, p * 8); if (m) return m; let v = Buffer.alloc(p); for (let I = 0; I < p; I++)v[I] = Number(this._preloadUint(8, d + I * 8)); return v } _loadInternalAddress() { if (Number(this._preloadUint(2, this._offset)) !== 2 || this._preloadUint(1, this._offset + 2) !== 0n) throw Error("Invalid address"); let d = Number(this._preloadInt(8, this._offset + 3)), m = this._preloadBuffer(32, this._offset + 11); return this._offset += 267, new o.Address(d, m) } _loadExternalAddress() { if (Number(this._preloadUint(2, this._offset)) !== 1) throw Error("Invalid address"); let d = Number(this._preloadUint(9, this._offset + 2)), m = this._preloadUint(d, this._offset + 11); return this._offset += 11 + d, new l.ExternalAddress(m, d) } _toSafeInteger(p, d) { if (BigInt(Number.MAX_SAFE_INTEGER) < p || p < BigInt(Number.MIN_SAFE_INTEGER)) throw new TypeError(`${p} is out of safe integer range. Use ${d} instead`); return Number(p) } }; return BitReader.BitReader = u, BitReader } var hasRequiredExoticMerkleProof; function requireExoticMerkleProof() { if (hasRequiredExoticMerkleProof) return exoticMerkleProof; hasRequiredExoticMerkleProof = 1, Object.defineProperty(exoticMerkleProof, "__esModule", { value: !0 }), exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0; const o = requireBitReader(), l = requireBuilder$1(); function u(p, d) { const m = new o.BitReader(p); if (p.length !== 280) throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${p.length}"`); if (d.length !== 1) throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${d.length}"`); let I = m.loadUint(8); if (I !== 3) throw new Error(`Merkle Proof cell must have type 3, got "${I}"`); const F = m.loadBuffer(32), B = m.loadUint(16), W = d[0].hash(0), Z = d[0].depth(0); if (B !== Z) throw new Error(`Merkle Proof cell ref depth must be exactly "${B}", got "${Z}"`); if (!F.equals(W)) throw new Error(`Merkle Proof cell ref hash must be exactly "${F.toString("hex")}", got "${W.toString("hex")}"`); return { proofDepth: B, proofHash: F } } exoticMerkleProof.exoticMerkleProof = u; function f(p) { return (0, l.beginCell)().storeUint(3, 8).storeBuffer(p.hash(0)).storeUint(p.depth(0), 16).storeRef(p).endCell({ exotic: !0 }) } return exoticMerkleProof.convertToMerkleProof = f, exoticMerkleProof } var hasRequiredGenerateMerkleProof; function requireGenerateMerkleProof() { if (hasRequiredGenerateMerkleProof) return generateMerkleProof; hasRequiredGenerateMerkleProof = 1, Object.defineProperty(generateMerkleProof, "__esModule", { value: !0 }), generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0; const o = requireBuilder$1(), l = requireReadUnaryLength(), u = requireExoticMerkleProof(); function f(v) { return (0, o.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(v.hash(0)).storeUint(v.depth(0), 16).endCell({ exotic: !0 }) } function p(v, I, F, B) { const W = I.asCell(); if (B.length == 0) return f(W); let Z = I.loadBit() ? 1 : 0, Q = 0, re = v; if (Z === 0) { Q = (0, l.readUnaryLength)(I); for (let ne = 0; ne < Q; ne++)re += I.loadBit() ? "1" : "0" } else if ((I.loadBit() ? 1 : 0) === 0) { Q = I.loadUint(Math.ceil(Math.log2(F + 1))); for (let oe = 0; oe < Q; oe++)re += I.loadBit() ? "1" : "0" } else { let oe = I.loadBit() ? "1" : "0"; Q = I.loadUint(Math.ceil(Math.log2(F + 1))); for (let ae = 0; ae < Q; ae++)re += oe } if (F - Q === 0) return W; { let ne = W.beginParse(), oe = ne.loadRef(), ae = ne.loadRef(); if (!oe.isExotic) { const se = B.filter(le => re + "0" === le.slice(0, re.length + 1)); oe = p(re + "0", oe.beginParse(), F - Q - 1, se) } if (!ae.isExotic) { const se = B.filter(le => re + "1" === le.slice(0, re.length + 1)); ae = p(re + "1", ae.beginParse(), F - Q - 1, se) } return (0, o.beginCell)().storeSlice(ne).storeRef(oe).storeRef(ae).endCell() } } function d(v, I, F) { I.forEach(W => { if (!v.has(W)) throw new Error(`Trying to generate merkle proof for a missing key "${W}"`) }); const B = (0, o.beginCell)().storeDictDirect(v).asSlice(); return p("", B, F.bits, I.map(W => F.serialize(W).toString(2).padStart(F.bits, "0"))) } generateMerkleProof.generateMerkleProofDirect = d; function m(v, I, F) { return (0, u.convertToMerkleProof)(d(v, I, F)) } return generateMerkleProof.generateMerkleProof = m, generateMerkleProof } var generateMerkleUpdate = {}, hasRequiredGenerateMerkleUpdate; function requireGenerateMerkleUpdate() { if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate; hasRequiredGenerateMerkleUpdate = 1, Object.defineProperty(generateMerkleUpdate, "__esModule", { value: !0 }), generateMerkleUpdate.generateMerkleUpdate = void 0; const o = requireBuilder$1(), l = requireGenerateMerkleProof(); function u(p, d) { return (0, o.beginCell)().storeUint(4, 8).storeBuffer(p.hash(0)).storeBuffer(d.hash(0)).storeUint(p.depth(0), 16).storeUint(d.depth(0), 16).storeRef(p).storeRef(d).endCell({ exotic: !0 }) } function f(p, d, m, v) { const I = (0, l.generateMerkleProof)(p, [d], m).refs[0]; p.set(d, v); const F = (0, l.generateMerkleProof)(p, [d], m).refs[0]; return u(I, F) } return generateMerkleUpdate.generateMerkleUpdate = f, generateMerkleUpdate } var parseDict = {}, hasRequiredParseDict; function requireParseDict() { if (hasRequiredParseDict) return parseDict; hasRequiredParseDict = 1, Object.defineProperty(parseDict, "__esModule", { value: !0 }), parseDict.parseDict = void 0; function o(f) { let p = 0; for (; f.loadBit();)p++; return p } function l(f, p, d, m, v) { let I = p.loadBit() ? 1 : 0, F = 0, B = f; if (I === 0) { F = o(p); for (let W = 0; W < F; W++)B += p.loadBit() ? "1" : "0" } else if ((p.loadBit() ? 1 : 0) === 0) { F = p.loadUint(Math.ceil(Math.log2(d + 1))); for (let Z = 0; Z < F; Z++)B += p.loadBit() ? "1" : "0" } else { let Z = p.loadBit() ? "1" : "0"; F = p.loadUint(Math.ceil(Math.log2(d + 1))); for (let Q = 0; Q < F; Q++)B += Z } if (d - F === 0) m.set(BigInt("0b" + B), v(p)); else { let W = p.loadRef(), Z = p.loadRef(); W.isExotic || l(B + "0", W.beginParse(), d - F - 1, m, v), Z.isExotic || l(B + "1", Z.beginParse(), d - F - 1, m, v) } } function u(f, p, d) { let m = new Map; return f && l("", f, p, m, d), m } return parseDict.parseDict = u, parseDict } var serializeDict = {}, findCommonPrefix = {}, hasRequiredFindCommonPrefix; function requireFindCommonPrefix() { if (hasRequiredFindCommonPrefix) return findCommonPrefix; hasRequiredFindCommonPrefix = 1, Object.defineProperty(findCommonPrefix, "__esModule", { value: !0 }), findCommonPrefix.findCommonPrefix = void 0; function o(l, u = 0) { if (l.length === 0) return ""; let f = l[0].slice(u); for (let p = 1; p < l.length; p++) { const d = l[p]; for (; d.indexOf(f, u) !== u;)if (f = f.substring(0, f.length - 1), f === "") return f } return f } return findCommonPrefix.findCommonPrefix = o, findCommonPrefix } var hasRequiredSerializeDict; function requireSerializeDict() { if (hasRequiredSerializeDict) return serializeDict; hasRequiredSerializeDict = 1, Object.defineProperty(serializeDict, "__esModule", { value: !0 }), serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0; const o = requireBuilder$1(), l = requireFindCommonPrefix(); function u(le, ue) { for (; le.length < ue;)le = "0" + le; return le } function f(le, ue) { if (le.size === 0) throw Error("Internal inconsistency"); let he = new Map, pe = new Map; for (let [ve, _e] of le.entries()) ve[ue] === "0" ? he.set(ve, _e) : pe.set(ve, _e); if (he.size === 0) throw Error("Internal inconsistency. Left emtpy."); if (pe.size === 0) throw Error("Internal inconsistency. Right emtpy."); return { left: he, right: pe } } function p(le, ue) { if (le.size === 0) throw Error("Internal inconsistency"); if (le.size === 1) return { type: "leaf", value: Array.from(le.values())[0] }; let { left: he, right: pe } = f(le, ue); return { type: "fork", left: d(he, ue + 1), right: d(pe, ue + 1) } } function d(le, ue = 0) { if (le.size === 0) throw Error("Internal inconsistency"); const he = (0, l.findCommonPrefix)(Array.from(le.keys()), ue); return { label: he, node: p(le, he.length + ue) } } function m(le, ue) { let he = new Map; for (let pe of Array.from(le.keys())) { const ve = u(pe.toString(2), ue); he.set(ve, le.get(pe)) } return d(he) } serializeDict.buildTree = m; function v(le, ue) { ue.storeBit(0); for (let he = 0; he < le.length; he++)ue.storeBit(1); return ue.storeBit(0), le.length > 0 && ue.storeUint(BigInt("0b" + le), le.length), ue } serializeDict.writeLabelShort = v; function I(le) { return 1 + le.length + 1 + le.length } function F(le, ue, he) { he.storeBit(1), he.storeBit(0); let pe = Math.ceil(Math.log2(ue + 1)); return he.storeUint(le.length, pe), le.length > 0 && he.storeUint(BigInt("0b" + le), le.length), he } serializeDict.writeLabelLong = F; function B(le, ue) { return 2 + Math.ceil(Math.log2(ue + 1)) + le.length } function W(le, ue, he, pe) { pe.storeBit(1), pe.storeBit(1), pe.storeBit(le); let ve = Math.ceil(Math.log2(he + 1)); pe.storeUint(ue, ve) } serializeDict.writeLabelSame = W; function Z(le) { return 3 + Math.ceil(Math.log2(le + 1)) } function Q(le) { if (le.length === 0 || le.length === 1) return !0; for (let ue = 1; ue < le.length; ue++)if (le[ue] !== le[0]) return !1; return !0 } function re(le, ue) { let he = "short", pe = I(le), ve = B(le, ue); if (ve < pe && (pe = ve, he = "long"), Q(le)) { let _e = Z(ue); _e < pe && (pe = _e, he = "same") } return he } serializeDict.detectLabelType = re; function ne(le, ue, he) { let pe = re(le, ue); pe === "short" ? v(le, he) : pe === "long" ? F(le, ue, he) : pe === "same" && W(le[0] === "1", le.length, ue, he) } function oe(le, ue, he, pe) { if (le.type === "leaf" && he(le.value, pe), le.type === "fork") { const ve = (0, o.beginCell)(), _e = (0, o.beginCell)(); ae(le.left, ue - 1, he, ve), ae(le.right, ue - 1, he, _e), pe.storeRef(ve), pe.storeRef(_e) } } function ae(le, ue, he, pe) { ne(le.label, ue, pe), oe(le.node, ue - le.label.length, he, pe) } function se(le, ue, he, pe) { const ve = m(le, ue); ae(ve, ue, he, pe) } return serializeDict.serializeDict = se, serializeDict } var internalKeySerializer = {}, hasRequiredInternalKeySerializer; function requireInternalKeySerializer() { if (hasRequiredInternalKeySerializer) return internalKeySerializer; hasRequiredInternalKeySerializer = 1, Object.defineProperty(internalKeySerializer, "__esModule", { value: !0 }), internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0; const o = requireAddress(), l = requireBitString(), u = requirePaddedBits(); function f(d) { if (typeof d == "number") { if (!Number.isSafeInteger(d)) throw Error("Invalid key type: not a safe integer: " + d); return "n:" + d.toString(10) } else { if (typeof d == "bigint") return "b:" + d.toString(10); if (o.Address.isAddress(d)) return "a:" + d.toString(); if (Buffer.isBuffer(d)) return "f:" + d.toString("hex"); if (l.BitString.isBitString(d)) return "B:" + d.toString(); throw Error("Invalid key type") } } internalKeySerializer.serializeInternalKey = f; function p(d) { let m = d.slice(0, 2), v = d.slice(2); if (m === "n:") return parseInt(v, 10); if (m === "b:") return BigInt(v); if (m === "a:") return o.Address.parse(v); if (m === "f:") return Buffer.from(v, "hex"); if (m === "B:") { const I = v.slice(-1) == "_"; if (I || v.length % 2 != 0) { let B = I ? v.length - 1 : v.length; const W = v.substr(0, B) + "0"; return !I && (B & 1) !== 0 ? new l.BitString(Buffer.from(W, "hex"), 0, B << 2) : (0, u.paddedBufferToBits)(Buffer.from(W, "hex")) } else return new l.BitString(Buffer.from(v, "hex"), 0, v.length << 2) } throw Error("Invalid key type: " + m) } return internalKeySerializer.deserializeInternalKey = p, internalKeySerializer } var hasRequiredDictionary; function requireDictionary() { if (hasRequiredDictionary) return Dictionary; hasRequiredDictionary = 1, Object.defineProperty(Dictionary, "__esModule", { value: !0 }), Dictionary.Dictionary = void 0; const o = requireAddress(), l = requireBuilder$1(), u = requireCell(), f = requireBitString(), p = requireGenerateMerkleProof(), d = requireGenerateMerkleUpdate(), m = requireParseDict(), v = requireSerializeDict(), I = requireInternalKeySerializer(); let F = class li { static empty(U, K) { return U && K ? new li(new Map, U, K) : new li(new Map, null, null) } static load(U, K, Y) { let te; if (Y instanceof u.Cell) { if (Y.isExotic) return li.empty(U, K); te = Y.beginParse() } else te = Y; let ee = te.loadMaybeRef(); return ee && !ee.isExotic ? li.loadDirect(U, K, ee.beginParse()) : li.empty(U, K) } static loadDirect(U, K, Y) { if (!Y) return li.empty(U, K); let te; Y instanceof u.Cell ? te = Y.beginParse() : te = Y; let ee = (0, m.parseDict)(te, U.bits, K.parse), G = new Map; for (let [y, X] of ee) G.set((0, I.serializeInternalKey)(U.parse(y)), X); return new li(G, U, K) } constructor(U, K, Y) { this._key = K, this._value = Y, this._map = U } get size() { return this._map.size } get(U) { return this._map.get((0, I.serializeInternalKey)(U)) } has(U) { return this._map.has((0, I.serializeInternalKey)(U)) } set(U, K) { return this._map.set((0, I.serializeInternalKey)(U), K), this } delete(U) { const K = (0, I.serializeInternalKey)(U); return this._map.delete(K) } clear() { this._map.clear() } *[Symbol.iterator]() { for (const [U, K] of this._map) yield [(0, I.deserializeInternalKey)(U), K] } keys() { return Array.from(this._map.keys()).map(U => (0, I.deserializeInternalKey)(U)) } values() { return Array.from(this._map.values()) } store(U, K, Y) { if (this._map.size === 0) U.storeBit(0); else { let te = this._key; K != null && (te = K); let ee = this._value; if (Y != null && (ee = Y), !te) throw Error("Key serializer is not defined"); if (!ee) throw Error("Value serializer is not defined"); let G = new Map; for (const [X, ce] of this._map) G.set(te.serialize((0, I.deserializeInternalKey)(X)), ce); U.storeBit(1); let y = (0, l.beginCell)(); (0, v.serializeDict)(G, te.bits, ee.serialize, y), U.storeRef(y.endCell()) } } storeDirect(U, K, Y) { if (this._map.size === 0) throw Error("Cannot store empty dictionary directly"); let te = this._key; K != null && (te = K); let ee = this._value; if (Y != null && (ee = Y), !te) throw Error("Key serializer is not defined"); if (!ee) throw Error("Value serializer is not defined"); let G = new Map; for (const [y, X] of this._map) G.set(te.serialize((0, I.deserializeInternalKey)(y)), X); (0, v.serializeDict)(G, te.bits, ee.serialize, U) } generateMerkleProof(U) { return (0, p.generateMerkleProof)(this, U, this._key) } generateMerkleProofDirect(U) { return (0, p.generateMerkleProofDirect)(this, U, this._key) } generateMerkleUpdate(U, K) { return (0, d.generateMerkleUpdate)(this, U, this._key, K) } }; Dictionary.Dictionary = F, F.Keys = { Address: () => B(), BigInt: P => W(P), Int: P => Z(P), BigUint: P => Q(P), Uint: P => re(P), Buffer: P => ne(P), BitString: P => oe(P) }, F.Values = { BigInt: P => se(P), Int: P => ae(P), BigVarInt: P => le(P), BigUint: P => pe(P), Uint: P => he(P), BigVarUint: P => ue(P), Bool: () => ve(), Address: () => _e(), Cell: () => Se(), Buffer: P => ie(P), BitString: P => g(P), Dictionary: (P, U) => $e(P, U) }; function B() { return { bits: 267, serialize: P => { if (!o.Address.isAddress(P)) throw Error("Key is not an address"); return (0, l.beginCell)().storeAddress(P).endCell().beginParse().preloadUintBig(267) }, parse: P => (0, l.beginCell)().storeUint(P, 267).endCell().beginParse().loadAddress() } } function W(P) { return { bits: P, serialize: U => { if (typeof U != "bigint") throw Error("Key is not a bigint"); return (0, l.beginCell)().storeInt(U, P).endCell().beginParse().loadUintBig(P) }, parse: U => (0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadIntBig(P) } } function Z(P) { return { bits: P, serialize: U => { if (typeof U != "number") throw Error("Key is not a number"); if (!Number.isSafeInteger(U)) throw Error("Key is not a safe integer: " + U); return (0, l.beginCell)().storeInt(U, P).endCell().beginParse().loadUintBig(P) }, parse: U => (0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadInt(P) } } function Q(P) { return { bits: P, serialize: U => { if (typeof U != "bigint") throw Error("Key is not a bigint"); if (U < 0) throw Error("Key is negative: " + U); return (0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadUintBig(P) }, parse: U => (0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadUintBig(P) } } function re(P) { return { bits: P, serialize: U => { if (typeof U != "number") throw Error("Key is not a number"); if (!Number.isSafeInteger(U)) throw Error("Key is not a safe integer: " + U); if (U < 0) throw Error("Key is negative: " + U); return (0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadUintBig(P) }, parse: U => Number((0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadUint(P)) } } function ne(P) { return { bits: P * 8, serialize: U => { if (!Buffer.isBuffer(U)) throw Error("Key is not a buffer"); return (0, l.beginCell)().storeBuffer(U).endCell().beginParse().loadUintBig(P * 8) }, parse: U => (0, l.beginCell)().storeUint(U, P * 8).endCell().beginParse().loadBuffer(P) } } function oe(P) { return { bits: P, serialize: U => { if (!f.BitString.isBitString(U)) throw Error("Key is not a BitString"); return (0, l.beginCell)().storeBits(U).endCell().beginParse().loadUintBig(P) }, parse: U => (0, l.beginCell)().storeUint(U, P).endCell().beginParse().loadBits(P) } } function ae(P) { return { serialize: (U, K) => { K.storeInt(U, P) }, parse: U => U.loadInt(P) } } function se(P) { return { serialize: (U, K) => { K.storeInt(U, P) }, parse: U => U.loadIntBig(P) } } function le(P) { return { serialize: (U, K) => { K.storeVarInt(U, P) }, parse: U => U.loadVarIntBig(P) } } function ue(P) { return { serialize: (U, K) => { K.storeVarUint(U, P) }, parse: U => U.loadVarUintBig(P) } } function he(P) { return { serialize: (U, K) => { K.storeUint(U, P) }, parse: U => U.loadUint(P) } } function pe(P) { return { serialize: (U, K) => { K.storeUint(U, P) }, parse: U => U.loadUintBig(P) } } function ve() { return { serialize: (P, U) => { U.storeBit(P) }, parse: P => P.loadBit() } } function _e() { return { serialize: (P, U) => { U.storeAddress(P) }, parse: P => P.loadAddress() } } function Se() { return { serialize: (P, U) => { U.storeRef(P) }, parse: P => P.loadRef() } } function $e(P, U) { return { serialize: (K, Y) => { K.store(Y) }, parse: K => F.load(P, U, K) } } function ie(P) { return { serialize: (U, K) => { if (U.length !== P) throw Error("Invalid buffer size"); K.storeBuffer(U) }, parse: U => U.loadBuffer(P) } } function g(P) { return { serialize: (U, K) => { if (U.length !== P) throw Error("Invalid BitString size"); K.storeBits(U) }, parse: U => U.loadBits(P) } } return Dictionary } var strings = {}, hasRequiredStrings; function requireStrings() { if (hasRequiredStrings) return strings; hasRequiredStrings = 1, Object.defineProperty(strings, "__esModule", { value: !0 }), strings.writeString = strings.stringToCell = strings.readString = void 0; const o = requireBuilder$1(); function l(m) { if (m.remainingBits % 8 !== 0) throw new Error(`Invalid string length: ${m.remainingBits}`); if (m.remainingRefs !== 0 && m.remainingRefs !== 1) throw new Error(`invalid number of refs: ${m.remainingRefs}`); let v; return m.remainingBits === 0 ? v = Buffer.alloc(0) : v = m.loadBuffer(m.remainingBits / 8), m.remainingRefs === 1 && (v = Buffer.concat([v, l(m.loadRef().beginParse())])), v } function u(m) { return l(m).toString() } strings.readString = u; function f(m, v) { if (m.length > 0) { let I = Math.floor(v.availableBits / 8); if (m.length > I) { let F = m.subarray(0, I), B = m.subarray(I); v = v.storeBuffer(F); let W = (0, o.beginCell)(); f(B, W), v = v.storeRef(W.endCell()) } else v = v.storeBuffer(m) } } function p(m) { let v = (0, o.beginCell)(); return f(Buffer.from(m), v), v.endCell() } strings.stringToCell = p; function d(m, v) { f(Buffer.from(m), v) } return strings.writeString = d, strings } var hasRequiredSlice; function requireSlice() { if (hasRequiredSlice) return Slice; hasRequiredSlice = 1; var o = Slice && Slice.__importDefault || function (v) { return v && v.__esModule ? v : { default: v } }, l; Object.defineProperty(Slice, "__esModule", { value: !0 }), Slice.Slice = void 0; const u = o(requireSymbol_inspect()), f = requireDictionary(), p = requireBuilder$1(), d = requireStrings(); let m = class rl { constructor(I, F) { this[l] = () => this.toString(), this._reader = I.clone(), this._refs = [...F], this._refsOffset = 0 } get remainingBits() { return this._reader.remaining } get offsetBits() { return this._reader.offset } get remainingRefs() { return this._refs.length - this._refsOffset } get offsetRefs() { return this._refsOffset } skip(I) { return this._reader.skip(I), this } loadBit() { return this._reader.loadBit() } preloadBit() { return this._reader.preloadBit() } loadBoolean() { return this.loadBit() } loadMaybeBoolean() { return this.loadBit() ? this.loadBoolean() : null } loadBits(I) { return this._reader.loadBits(I) } preloadBits(I) { return this._reader.preloadBits(I) } loadUint(I) { return this._reader.loadUint(I) } loadUintBig(I) { return this._reader.loadUintBig(I) } preloadUint(I) { return this._reader.preloadUint(I) } preloadUintBig(I) { return this._reader.preloadUintBig(I) } loadMaybeUint(I) { return this.loadBit() ? this.loadUint(I) : null } loadMaybeUintBig(I) { return this.loadBit() ? this.loadUintBig(I) : null } loadInt(I) { return this._reader.loadInt(I) } loadIntBig(I) { return this._reader.loadIntBig(I) } preloadInt(I) { return this._reader.preloadInt(I) } preloadIntBig(I) { return this._reader.preloadIntBig(I) } loadMaybeInt(I) { return this.loadBit() ? this.loadInt(I) : null } loadMaybeIntBig(I) { return this.loadBit() ? this.loadIntBig(I) : null } loadVarUint(I) { return this._reader.loadVarUint(I) } loadVarUintBig(I) { return this._reader.loadVarUintBig(I) } preloadVarUint(I) { return this._reader.preloadVarUint(I) } preloadVarUintBig(I) { return this._reader.preloadVarUintBig(I) } loadVarInt(I) { return this._reader.loadVarInt(I) } loadVarIntBig(I) { return this._reader.loadVarIntBig(I) } preloadVarInt(I) { return this._reader.preloadVarInt(I) } preloadVarIntBig(I) { return this._reader.preloadVarIntBig(I) } loadCoins() { return this._reader.loadCoins() } preloadCoins() { return this._reader.preloadCoins() } loadMaybeCoins() { return this._reader.loadBit() ? this._reader.loadCoins() : null } loadAddress() { return this._reader.loadAddress() } loadMaybeAddress() { return this._reader.loadMaybeAddress() } loadExternalAddress() { return this._reader.loadExternalAddress() } loadMaybeExternalAddress() { return this._reader.loadMaybeExternalAddress() } loadAddressAny() { return this._reader.loadAddressAny() } loadRef() { if (this._refsOffset >= this._refs.length) throw new Error("No more references"); return this._refs[this._refsOffset++] } preloadRef() { if (this._refsOffset >= this._refs.length) throw new Error("No more references"); return this._refs[this._refsOffset] } loadMaybeRef() { return this.loadBit() ? this.loadRef() : null } preloadMaybeRef() { return this.preloadBit() ? this.preloadRef() : null } loadBuffer(I) { return this._reader.loadBuffer(I) } preloadBuffer(I) { return this._reader.preloadBuffer(I) } loadStringTail() { return (0, d.readString)(this) } loadMaybeStringTail() { return this.loadBit() ? (0, d.readString)(this) : null } loadStringRefTail() { return (0, d.readString)(this.loadRef().beginParse()) } loadMaybeStringRefTail() { const I = this.loadMaybeRef(); return I ? (0, d.readString)(I.beginParse()) : null } loadDict(I, F) { return f.Dictionary.load(I, F, this) } loadDictDirect(I, F) { return f.Dictionary.loadDirect(I, F, this) } endParse() { if (this.remainingBits > 0 || this.remainingRefs > 0) throw new Error("Slice is not empty") } asCell() { return (0, p.beginCell)().storeSlice(this).endCell() } asBuilder() { return (0, p.beginCell)().storeSlice(this) } clone(I = !1) { if (I) { let F = this._reader.clone(); return F.reset(), new rl(F, this._refs) } else { let F = new rl(this._reader, this._refs); return F._refsOffset = this._refsOffset, F } } toString() { return this.asCell().toString() } }; return Slice.Slice = m, l = u.default, Slice } var resolveExotic = {}, exoticLibrary = {}, hasRequiredExoticLibrary; function requireExoticLibrary() { if (hasRequiredExoticLibrary) return exoticLibrary; hasRequiredExoticLibrary = 1, Object.defineProperty(exoticLibrary, "__esModule", { value: !0 }), exoticLibrary.exoticLibrary = void 0; const o = requireBitReader(); function l(u, f) { const p = new o.BitReader(u); if (u.length !== 264) throw new Error(`Library cell must have exactly (8 + 256) bits, got "${u.length}"`); let m = p.loadUint(8); if (m !== 2) throw new Error(`Library cell must have type 2, got "${m}"`); return {} } return exoticLibrary.exoticLibrary = l, exoticLibrary } var exoticMerkleUpdate = {}, hasRequiredExoticMerkleUpdate; function requireExoticMerkleUpdate() { if (hasRequiredExoticMerkleUpdate) return exoticMerkleUpdate; hasRequiredExoticMerkleUpdate = 1, Object.defineProperty(exoticMerkleUpdate, "__esModule", { value: !0 }), exoticMerkleUpdate.exoticMerkleUpdate = void 0; const o = requireBitReader(); function l(u, f) { const p = new o.BitReader(u), d = 8 + 2 * 272; if (u.length !== d) throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${u.length}"`); if (f.length !== 2) throw new Error(`Merkle Update cell must have exactly 2 refs, got "${f.length}"`); let m = p.loadUint(8); if (m !== 4) throw new Error(`Merkle Update cell type must be exactly 4, got "${m}"`); const v = p.loadBuffer(32), I = p.loadBuffer(32), F = p.loadUint(16), B = p.loadUint(16); if (F !== f[0].depth(0)) throw new Error(`Merkle Update cell ref depth must be exactly "${F}", got "${f[0].depth(0)}"`); if (!v.equals(f[0].hash(0))) throw new Error(`Merkle Update cell ref hash must be exactly "${v.toString("hex")}", got "${f[0].hash(0).toString("hex")}"`); if (B !== f[1].depth(0)) throw new Error(`Merkle Update cell ref depth must be exactly "${B}", got "${f[1].depth(0)}"`); if (!I.equals(f[1].hash(0))) throw new Error(`Merkle Update cell ref hash must be exactly "${I.toString("hex")}", got "${f[1].hash(0).toString("hex")}"`); return { proofDepth1: F, proofDepth2: B, proofHash1: v, proofHash2: I } } return exoticMerkleUpdate.exoticMerkleUpdate = l, exoticMerkleUpdate } var exoticPruned = {}, LevelMask = {}, hasRequiredLevelMask; function requireLevelMask() { if (hasRequiredLevelMask) return LevelMask; hasRequiredLevelMask = 1, Object.defineProperty(LevelMask, "__esModule", { value: !0 }), LevelMask.LevelMask = void 0; let o = class Ef { constructor(f = 0) { this._mask = 0, this._mask = f, this._hashIndex = l(this._mask), this._hashCount = this._hashIndex + 1 } get value() { return this._mask } get level() { return 32 - Math.clz32(this._mask) } get hashIndex() { return this._hashIndex } get hashCount() { return this._hashCount } apply(f) { return new Ef(this._mask & (1 << f) - 1) } isSignificant(f) { return f === 0 || (this._mask >> f - 1) % 2 !== 0 } }; LevelMask.LevelMask = o; function l(u) { return u = u - (u >> 1 & 1431655765), u = (u & 858993459) + (u >> 2 & 858993459), (u + (u >> 4) & 252645135) * 16843009 >> 24 } return LevelMask } var hasRequiredExoticPruned; function requireExoticPruned() { if (hasRequiredExoticPruned) return exoticPruned; hasRequiredExoticPruned = 1, Object.defineProperty(exoticPruned, "__esModule", { value: !0 }), exoticPruned.exoticPruned = void 0; const o = requireBitReader(), l = requireLevelMask(); function u(f, p) { let d = new o.BitReader(f), m = d.loadUint(8); if (m !== 1) throw new Error(`Pruned branch cell must have type 1, got "${m}"`); if (p.length !== 0) throw new Error(`Pruned Branch cell can't has refs, got "${p.length}"`); let v; if (f.length === 280) v = new l.LevelMask(1); else { if (v = new l.LevelMask(d.loadUint(8)), v.level < 1 || v.level > 3) throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${v.level}/${v.value}"`); const W = 16 + v.apply(v.level - 1).hashCount * 272; if (f.length !== W) throw new Error(`Pruned branch cell must have exactly ${W} bits, got "${f.length}"`) } let I = [], F = [], B = []; for (let W = 0; W < v.level; W++)F.push(d.loadBuffer(32)); for (let W = 0; W < v.level; W++)B.push(d.loadUint(16)); for (let W = 0; W < v.level; W++)I.push({ depth: B[W], hash: F[W] }); return { mask: v.value, pruned: I } } return exoticPruned.exoticPruned = u, exoticPruned } var hasRequiredResolveExotic; function requireResolveExotic() { if (hasRequiredResolveExotic) return resolveExotic; hasRequiredResolveExotic = 1, Object.defineProperty(resolveExotic, "__esModule", { value: !0 }), resolveExotic.resolveExotic = void 0; const o = requireBitReader(), l = requireCellType(), u = requireExoticLibrary(), f = requireExoticMerkleProof(), p = requireExoticMerkleUpdate(), d = requireExoticPruned(), m = requireLevelMask(); function v(Z, Q) { let re = (0, d.exoticPruned)(Z, Q), ne = [], oe = [], ae = new m.LevelMask(re.mask); for (let se = 0; se < re.pruned.length; se++)ne.push(re.pruned[se].depth), oe.push(re.pruned[se].hash); return { type: l.CellType.PrunedBranch, depths: ne, hashes: oe, mask: ae } } function I(Z, Q) { (0, u.exoticLibrary)(Z, Q); let re = [], ne = [], oe = new m.LevelMask; return { type: l.CellType.Library, depths: re, hashes: ne, mask: oe } } function F(Z, Q) { (0, f.exoticMerkleProof)(Z, Q); let re = [], ne = [], oe = new m.LevelMask(Q[0].level() >> 1); return { type: l.CellType.MerkleProof, depths: re, hashes: ne, mask: oe } } function B(Z, Q) { (0, p.exoticMerkleUpdate)(Z, Q); let re = [], ne = [], oe = new m.LevelMask((Q[0].level() | Q[1].level()) >> 1); return { type: l.CellType.MerkleUpdate, depths: re, hashes: ne, mask: oe } } function W(Z, Q) { let ne = new o.BitReader(Z).preloadUint(8); if (ne === 1) return v(Z, Q); if (ne === 2) return I(Z, Q); if (ne === 3) return F(Z, Q); if (ne === 4) return B(Z, Q); throw Error("Invalid exotic cell type: " + ne) } return resolveExotic.resolveExotic = W, resolveExotic } var wonderCalculator = {}, descriptor = {}, hasRequiredDescriptor; function requireDescriptor() { if (hasRequiredDescriptor) return descriptor; hasRequiredDescriptor = 1, Object.defineProperty(descriptor, "__esModule", { value: !0 }), descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0; const o = requireCellType(), l = requirePaddedBits(); function u(d, m, v) { return d.length + (v !== o.CellType.Ordinary ? 1 : 0) * 8 + m * 32 } descriptor.getRefsDescriptor = u; function f(d) { let m = d.length; return Math.ceil(m / 8) + Math.floor(m / 8) } descriptor.getBitsDescriptor = f; function p(d, m, v, I, F, B) { const W = Math.ceil(m.length / 8), Z = Buffer.alloc(2 + W + 34 * v.length); let Q = 0; Z[Q++] = u(v, F, B), Z[Q++] = f(d), (0, l.bitsToPaddedBuffer)(m).copy(Z, Q), Q += W; for (const re of v) { let ne; B == o.CellType.MerkleProof || B == o.CellType.MerkleUpdate ? ne = re.depth(I + 1) : ne = re.depth(I), Z[Q++] = Math.floor(ne / 256), Z[Q++] = ne % 256 } for (const re of v) { let ne; B == o.CellType.MerkleProof || B == o.CellType.MerkleUpdate ? ne = re.hash(I + 1) : ne = re.hash(I), ne.copy(Z, Q), Q += 32 } return Z } return descriptor.getRepr = p, descriptor } var dist$1 = {}, sha256$3 = {}, sha$3 = { exports: {} }, sha$2 = sha$3.exports, hasRequiredSha$2; function requireSha$2() { return hasRequiredSha$2 || (hasRequiredSha$2 = 1, function (o, l) { (function (u, f) { o.exports = f() })(sha$2, function () { var u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function f(We, Ge, ze, Ze) { var ut, ye, ge, Ee = Ge || [0], Oe = (ze = ze || 0) >>> 3, je = Ze === -1 ? 3 : 0; for (ut = 0; ut < We.length; ut += 1)ye = (ge = ut + Oe) >>> 2, Ee.length <= ye && Ee.push(0), Ee[ye] |= We[ut] << 8 * (je + Ze * (ge % 4)); return { value: Ee, binLen: 8 * We.length + ze } } function p(We, Ge, ze) { switch (Ge) { case "UTF8": case "UTF16BE": case "UTF16LE": break; default: throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE") }switch (We) { case "HEX": return function (Ze, ut, ye) { return function (ge, Ee, Oe, je) { var nt, Xe, it, Tt; if (ge.length % 2 != 0) throw new Error("String of HEX type must be in byte increments"); var tt = Ee || [0], yt = (Oe = Oe || 0) >>> 3, kt = je === -1 ? 3 : 0; for (nt = 0; nt < ge.length; nt += 2) { if (Xe = parseInt(ge.substr(nt, 2), 16), isNaN(Xe)) throw new Error("String of HEX type contains invalid characters"); for (it = (Tt = (nt >>> 1) + yt) >>> 2; tt.length <= it;)tt.push(0); tt[it] |= Xe << 8 * (kt + je * (Tt % 4)) } return { value: tt, binLen: 4 * ge.length + Oe } }(Ze, ut, ye, ze) }; case "TEXT": return function (Ze, ut, ye) { return function (ge, Ee, Oe, je, nt) { var Xe, it, Tt, tt, yt, kt, wt, Mt, tr = 0, St = Oe || [0], gt = (je = je || 0) >>> 3; if (Ee === "UTF8") for (wt = nt === -1 ? 3 : 0, Tt = 0; Tt < ge.length; Tt += 1)for (it = [], 128 > (Xe = ge.charCodeAt(Tt)) ? it.push(Xe) : 2048 > Xe ? (it.push(192 | Xe >>> 6), it.push(128 | 63 & Xe)) : 55296 > Xe || 57344 <= Xe ? it.push(224 | Xe >>> 12, 128 | Xe >>> 6 & 63, 128 | 63 & Xe) : (Tt += 1, Xe = 65536 + ((1023 & Xe) << 10 | 1023 & ge.charCodeAt(Tt)), it.push(240 | Xe >>> 18, 128 | Xe >>> 12 & 63, 128 | Xe >>> 6 & 63, 128 | 63 & Xe)), tt = 0; tt < it.length; tt += 1) { for (yt = (kt = tr + gt) >>> 2; St.length <= yt;)St.push(0); St[yt] |= it[tt] << 8 * (wt + nt * (kt % 4)), tr += 1 } else for (wt = nt === -1 ? 2 : 0, Mt = Ee === "UTF16LE" && nt !== 1 || Ee !== "UTF16LE" && nt === 1, Tt = 0; Tt < ge.length; Tt += 1) { for (Xe = ge.charCodeAt(Tt), Mt === !0 && (Xe = (tt = 255 & Xe) << 8 | Xe >>> 8), yt = (kt = tr + gt) >>> 2; St.length <= yt;)St.push(0); St[yt] |= Xe << 8 * (wt + nt * (kt % 4)), tr += 2 } return { value: St, binLen: 8 * tr + je } }(Ze, Ge, ut, ye, ze) }; case "B64": return function (Ze, ut, ye) { return function (ge, Ee, Oe, je) { var nt, Xe, it, Tt, tt, yt, kt = 0, wt = Ee || [0], Mt = (Oe = Oe || 0) >>> 3, tr = je === -1 ? 3 : 0, St = ge.indexOf("="); if (ge.search(/^[a-zA-Z0-9=+/]+$/) === -1) throw new Error("Invalid character in base-64 string"); if (ge = ge.replace(/=/g, ""), St !== -1 && St < ge.length) throw new Error("Invalid '=' found in base-64 string"); for (nt = 0; nt < ge.length; nt += 4) { for (Tt = ge.substr(nt, 4), it = 0, Xe = 0; Xe < Tt.length; Xe += 1)it |= u.indexOf(Tt.charAt(Xe)) << 18 - 6 * Xe; for (Xe = 0; Xe < Tt.length - 1; Xe += 1) { for (tt = (yt = kt + Mt) >>> 2; wt.length <= tt;)wt.push(0); wt[tt] |= (it >>> 16 - 8 * Xe & 255) << 8 * (tr + je * (yt % 4)), kt += 1 } } return { value: wt, binLen: 8 * kt + Oe } }(Ze, ut, ye, ze) }; case "BYTES": return function (Ze, ut, ye) { return function (ge, Ee, Oe, je) { var nt, Xe, it, Tt, tt = Ee || [0], yt = (Oe = Oe || 0) >>> 3, kt = je === -1 ? 3 : 0; for (Xe = 0; Xe < ge.length; Xe += 1)nt = ge.charCodeAt(Xe), it = (Tt = Xe + yt) >>> 2, tt.length <= it && tt.push(0), tt[it] |= nt << 8 * (kt + je * (Tt % 4)); return { value: tt, binLen: 8 * ge.length + Oe } }(Ze, ut, ye, ze) }; case "ARRAYBUFFER": try { new ArrayBuffer(0) } catch { throw new Error("ARRAYBUFFER not supported by this environment") } return function (Ze, ut, ye) { return function (ge, Ee, Oe, je) { return f(new Uint8Array(ge), Ee, Oe, je) }(Ze, ut, ye, ze) }; case "UINT8ARRAY": try { new Uint8Array(0) } catch { throw new Error("UINT8ARRAY not supported by this environment") } return function (Ze, ut, ye) { return f(Ze, ut, ye, ze) }; default: throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY") } } function d(We, Ge, ze, Ze) { switch (We) { case "HEX": return function (ut) { return function (ye, ge, Ee, Oe) { var je, nt, Xe = "", it = ge / 8, Tt = Ee === -1 ? 3 : 0; for (je = 0; je < it; je += 1)nt = ye[je >>> 2] >>> 8 * (Tt + Ee * (je % 4)), Xe += "0123456789abcdef".charAt(nt >>> 4 & 15) + "0123456789abcdef".charAt(15 & nt); return Oe.outputUpper ? Xe.toUpperCase() : Xe }(ut, Ge, ze, Ze) }; case "B64": return function (ut) { return function (ye, ge, Ee, Oe) { var je, nt, Xe, it, Tt, tt = "", yt = ge / 8, kt = Ee === -1 ? 3 : 0; for (je = 0; je < yt; je += 3)for (it = je + 1 < yt ? ye[je + 1 >>> 2] : 0, Tt = je + 2 < yt ? ye[je + 2 >>> 2] : 0, Xe = (ye[je >>> 2] >>> 8 * (kt + Ee * (je % 4)) & 255) << 16 | (it >>> 8 * (kt + Ee * ((je + 1) % 4)) & 255) << 8 | Tt >>> 8 * (kt + Ee * ((je + 2) % 4)) & 255, nt = 0; nt < 4; nt += 1)tt += 8 * je + 6 * nt <= ge ? u.charAt(Xe >>> 6 * (3 - nt) & 63) : Oe.b64Pad; return tt }(ut, Ge, ze, Ze) }; case "BYTES": return function (ut) { return function (ye, ge, Ee) { var Oe, je, nt = "", Xe = ge / 8, it = Ee === -1 ? 3 : 0; for (Oe = 0; Oe < Xe; Oe += 1)je = ye[Oe >>> 2] >>> 8 * (it + Ee * (Oe % 4)) & 255, nt += String.fromCharCode(je); return nt }(ut, Ge, ze) }; case "ARRAYBUFFER": try { new ArrayBuffer(0) } catch { throw new Error("ARRAYBUFFER not supported by this environment") } return function (ut) { return function (ye, ge, Ee) { var Oe, je = ge / 8, nt = new ArrayBuffer(je), Xe = new Uint8Array(nt), it = Ee === -1 ? 3 : 0; for (Oe = 0; Oe < je; Oe += 1)Xe[Oe] = ye[Oe >>> 2] >>> 8 * (it + Ee * (Oe % 4)) & 255; return nt }(ut, Ge, ze) }; case "UINT8ARRAY": try { new Uint8Array(0) } catch { throw new Error("UINT8ARRAY not supported by this environment") } return function (ut) { return function (ye, ge, Ee) { var Oe, je = ge / 8, nt = Ee === -1 ? 3 : 0, Xe = new Uint8Array(je); for (Oe = 0; Oe < je; Oe += 1)Xe[Oe] = ye[Oe >>> 2] >>> 8 * (nt + Ee * (Oe % 4)) & 255; return Xe }(ut, Ge, ze) }; default: throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY") } } var m = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], v = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], I = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], F = "Chosen SHA variant is not supported"; function B(We, Ge) { var ze, Ze, ut = We.binLen >>> 3, ye = Ge.binLen >>> 3, ge = ut << 3, Ee = 4 - ut << 3; if (ut % 4 != 0) { for (ze = 0; ze < ye; ze += 4)Ze = ut + ze >>> 2, We.value[Ze] |= Ge.value[ze >>> 2] << ge, We.value.push(0), We.value[Ze + 1] |= Ge.value[ze >>> 2] >>> Ee; return (We.value.length << 2) - 4 >= ye + ut && We.value.pop(), { value: We.value, binLen: We.binLen + Ge.binLen } } return { value: We.value.concat(Ge.value), binLen: We.binLen + Ge.binLen } } function W(We) { var Ge = { outputUpper: !1, b64Pad: "=", outputLen: -1 }, ze = We || {}, Ze = "Output length must be a multiple of 8"; if (Ge.outputUpper = ze.outputUpper || !1, ze.b64Pad && (Ge.b64Pad = ze.b64Pad), ze.outputLen) { if (ze.outputLen % 8 != 0) throw new Error(Ze); Ge.outputLen = ze.outputLen } else if (ze.shakeLen) { if (ze.shakeLen % 8 != 0) throw new Error(Ze); Ge.outputLen = ze.shakeLen } if (typeof Ge.outputUpper != "boolean") throw new Error("Invalid outputUpper formatting option"); if (typeof Ge.b64Pad != "string") throw new Error("Invalid b64Pad formatting option"); return Ge } function Z(We, Ge, ze, Ze) { var ut = We + " must include a value and format"; if (!Ge) { if (!Ze) throw new Error(ut); return Ze } if (Ge.value === void 0 || !Ge.format) throw new Error(ut); return p(Ge.format, Ge.encoding || "UTF8", ze)(Ge.value) } var Q = function () { function We(Ge, ze, Ze) { var ut = Ze || {}; if (this.t = ze, this.i = ut.encoding || "UTF8", this.numRounds = ut.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1"); this.o = Ge, this.u = [], this.s = 0, this.h = !1, this.v = 0, this.A = !1, this.l = [], this.H = [] } return We.prototype.update = function (Ge) { var ze, Ze = 0, ut = this.S >>> 5, ye = this.p(Ge, this.u, this.s), ge = ye.binLen, Ee = ye.value, Oe = ge >>> 5; for (ze = 0; ze < Oe; ze += ut)Ze + this.S <= ge && (this.m = this.R(Ee.slice(ze, ze + ut), this.m), Ze += this.S); this.v += Ze, this.u = Ee.slice(Ze >>> 5), this.s = ge % this.S, this.h = !0 }, We.prototype.getHash = function (Ge, ze) { var Ze, ut, ye = this.U, ge = W(ze); if (this.T) { if (ge.outputLen === -1) throw new Error("Output length must be specified in options"); ye = ge.outputLen } var Ee = d(Ge, ye, this.C, ge); if (this.A && this.F) return Ee(this.F(ge)); for (ut = this.K(this.u.slice(), this.s, this.v, this.B(this.m), ye), Ze = 1; Ze < this.numRounds; Ze += 1)this.T && ye % 32 != 0 && (ut[ut.length - 1] &= 16777215 >>> 24 - ye % 32), ut = this.K(ut, ye, 0, this.L(this.o), ye); return Ee(ut) }, We.prototype.setHMACKey = function (Ge, ze, Ze) { if (!this.g) throw new Error("Variant does not support HMAC"); if (this.h) throw new Error("Cannot set MAC key after calling update"); var ut = p(ze, (Ze || {}).encoding || "UTF8", this.C); this.k(ut(Ge)) }, We.prototype.k = function (Ge) { var ze, Ze = this.S >>> 3, ut = Ze / 4 - 1; if (this.numRounds !== 1) throw new Error("Cannot set numRounds with MAC"); if (this.A) throw new Error("MAC key already set"); for (Ze < Ge.binLen / 8 && (Ge.value = this.K(Ge.value, Ge.binLen, 0, this.L(this.o), this.U)); Ge.value.length <= ut;)Ge.value.push(0); for (ze = 0; ze <= ut; ze += 1)this.l[ze] = 909522486 ^ Ge.value[ze], this.H[ze] = 1549556828 ^ Ge.value[ze]; this.m = this.R(this.l, this.m), this.v = this.S, this.A = !0 }, We.prototype.getHMAC = function (Ge, ze) { var Ze = W(ze); return d(Ge, this.U, this.C, Ze)(this.Y()) }, We.prototype.Y = function () { var Ge; if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key"); var ze = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U); return Ge = this.R(this.H, this.L(this.o)), Ge = this.K(ze, this.U, this.S, Ge, this.U) }, We }(), re = function (We, Ge) { return (re = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (ze, Ze) { ze.__proto__ = Ze } || function (ze, Ze) { for (var ut in Ze) Object.prototype.hasOwnProperty.call(Ze, ut) && (ze[ut] = Ze[ut]) })(We, Ge) }; function ne(We, Ge) { function ze() { this.constructor = We } re(We, Ge), We.prototype = Ge === null ? Object.create(Ge) : (ze.prototype = Ge.prototype, new ze) } function oe(We, Ge) { return We << Ge | We >>> 32 - Ge } function ae(We, Ge) { return We >>> Ge | We << 32 - Ge } function se(We, Ge) { return We >>> Ge } function le(We, Ge, ze) { return We ^ Ge ^ ze } function ue(We, Ge, ze) { return We & Ge ^ ~We & ze } function he(We, Ge, ze) { return We & Ge ^ We & ze ^ Ge & ze } function pe(We) { return ae(We, 2) ^ ae(We, 13) ^ ae(We, 22) } function ve(We, Ge) { var ze = (65535 & We) + (65535 & Ge); return (65535 & (We >>> 16) + (Ge >>> 16) + (ze >>> 16)) << 16 | 65535 & ze } function _e(We, Ge, ze, Ze) { var ut = (65535 & We) + (65535 & Ge) + (65535 & ze) + (65535 & Ze); return (65535 & (We >>> 16) + (Ge >>> 16) + (ze >>> 16) + (Ze >>> 16) + (ut >>> 16)) << 16 | 65535 & ut } function Se(We, Ge, ze, Ze, ut) { var ye = (65535 & We) + (65535 & Ge) + (65535 & ze) + (65535 & Ze) + (65535 & ut); return (65535 & (We >>> 16) + (Ge >>> 16) + (ze >>> 16) + (Ze >>> 16) + (ut >>> 16) + (ye >>> 16)) << 16 | 65535 & ye } function $e(We) { return ae(We, 7) ^ ae(We, 18) ^ se(We, 3) } function ie(We) { return ae(We, 6) ^ ae(We, 11) ^ ae(We, 25) } function g(We) { return [1732584193, 4023233417, 2562383102, 271733878, 3285377520] } function P(We, Ge) { var ze, Ze, ut, ye, ge, Ee, Oe, je = []; for (ze = Ge[0], Ze = Ge[1], ut = Ge[2], ye = Ge[3], ge = Ge[4], Oe = 0; Oe < 80; Oe += 1)je[Oe] = Oe < 16 ? We[Oe] : oe(je[Oe - 3] ^ je[Oe - 8] ^ je[Oe - 14] ^ je[Oe - 16], 1), Ee = Oe < 20 ? Se(oe(ze, 5), ue(Ze, ut, ye), ge, 1518500249, je[Oe]) : Oe < 40 ? Se(oe(ze, 5), le(Ze, ut, ye), ge, 1859775393, je[Oe]) : Oe < 60 ? Se(oe(ze, 5), he(Ze, ut, ye), ge, 2400959708, je[Oe]) : Se(oe(ze, 5), le(Ze, ut, ye), ge, 3395469782, je[Oe]), ge = ye, ye = ut, ut = oe(Ze, 30), Ze = ze, ze = Ee; return Ge[0] = ve(ze, Ge[0]), Ge[1] = ve(Ze, Ge[1]), Ge[2] = ve(ut, Ge[2]), Ge[3] = ve(ye, Ge[3]), Ge[4] = ve(ge, Ge[4]), Ge } function U(We, Ge, ze, Ze) { for (var ut, ye = 15 + (Ge + 65 >>> 9 << 4), ge = Ge + ze; We.length <= ye;)We.push(0); for (We[Ge >>> 5] |= 128 << 24 - Ge % 32, We[ye] = 4294967295 & ge, We[ye - 1] = ge / 4294967296 | 0, ut = 0; ut < We.length; ut += 16)Ze = P(We.slice(ut, ut + 16), Ze); return Ze } var K = function (We) { function Ge(ze, Ze, ut) { var ye = this; if (ze !== "SHA-1") throw new Error(F); var ge = ut || {}; return (ye = We.call(this, ze, Ze, ut) || this).g = !0, ye.F = ye.Y, ye.C = -1, ye.p = p(ye.t, ye.i, ye.C), ye.R = P, ye.B = function (Ee) { return Ee.slice() }, ye.L = g, ye.K = U, ye.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], ye.S = 512, ye.U = 160, ye.T = !1, ge.hmacKey && ye.k(Z("hmacKey", ge.hmacKey, ye.C)), ye } return ne(Ge, We), Ge }(Q); function Y(We) { return We == "SHA-224" ? v.slice() : I.slice() } function te(We, Ge) { var ze, Ze, ut, ye, ge, Ee, Oe, je, nt, Xe, it, Tt, tt = []; for (ze = Ge[0], Ze = Ge[1], ut = Ge[2], ye = Ge[3], ge = Ge[4], Ee = Ge[5], Oe = Ge[6], je = Ge[7], it = 0; it < 64; it += 1)tt[it] = it < 16 ? We[it] : _e(ae(Tt = tt[it - 2], 17) ^ ae(Tt, 19) ^ se(Tt, 10), tt[it - 7], $e(tt[it - 15]), tt[it - 16]), nt = Se(je, ie(ge), ue(ge, Ee, Oe), m[it], tt[it]), Xe = ve(pe(ze), he(ze, Ze, ut)), je = Oe, Oe = Ee, Ee = ge, ge = ve(ye, nt), ye = ut, ut = Ze, Ze = ze, ze = ve(nt, Xe); return Ge[0] = ve(ze, Ge[0]), Ge[1] = ve(Ze, Ge[1]), Ge[2] = ve(ut, Ge[2]), Ge[3] = ve(ye, Ge[3]), Ge[4] = ve(ge, Ge[4]), Ge[5] = ve(Ee, Ge[5]), Ge[6] = ve(Oe, Ge[6]), Ge[7] = ve(je, Ge[7]), Ge } var ee = function (We) { function Ge(ze, Ze, ut) { var ye = this; if (ze !== "SHA-224" && ze !== "SHA-256") throw new Error(F); var ge = ut || {}; return (ye = We.call(this, ze, Ze, ut) || this).F = ye.Y, ye.g = !0, ye.C = -1, ye.p = p(ye.t, ye.i, ye.C), ye.R = te, ye.B = function (Ee) { return Ee.slice() }, ye.L = Y, ye.K = function (Ee, Oe, je, nt) { return function (Xe, it, Tt, tt, yt) { for (var kt, wt = 15 + (it + 65 >>> 9 << 4), Mt = it + Tt; Xe.length <= wt;)Xe.push(0); for (Xe[it >>> 5] |= 128 << 24 - it % 32, Xe[wt] = 4294967295 & Mt, Xe[wt - 1] = Mt / 4294967296 | 0, kt = 0; kt < Xe.length; kt += 16)tt = te(Xe.slice(kt, kt + 16), tt); return yt === "SHA-224" ? [tt[0], tt[1], tt[2], tt[3], tt[4], tt[5], tt[6]] : tt }(Ee, Oe, je, nt, ze) }, ye.m = Y(ze), ye.S = 512, ye.U = ze === "SHA-224" ? 224 : 256, ye.T = !1, ge.hmacKey && ye.k(Z("hmacKey", ge.hmacKey, ye.C)), ye } return ne(Ge, We), Ge }(Q), G = function (We, Ge) { this.N = We, this.I = Ge }; function y(We, Ge) { var ze; return Ge > 32 ? (ze = 64 - Ge, new G(We.I << Ge | We.N >>> ze, We.N << Ge | We.I >>> ze)) : Ge !== 0 ? (ze = 32 - Ge, new G(We.N << Ge | We.I >>> ze, We.I << Ge | We.N >>> ze)) : We } function X(We, Ge) { var ze; return Ge < 32 ? (ze = 32 - Ge, new G(We.N >>> Ge | We.I << ze, We.I >>> Ge | We.N << ze)) : (ze = 64 - Ge, new G(We.I >>> Ge | We.N << ze, We.N >>> Ge | We.I << ze)) } function ce(We, Ge) { return new G(We.N >>> Ge, We.I >>> Ge | We.N << 32 - Ge) } function me(We, Ge, ze) { return new G(We.N & Ge.N ^ ~We.N & ze.N, We.I & Ge.I ^ ~We.I & ze.I) } function Ae(We, Ge, ze) { return new G(We.N & Ge.N ^ We.N & ze.N ^ Ge.N & ze.N, We.I & Ge.I ^ We.I & ze.I ^ Ge.I & ze.I) } function Ie(We) { var Ge = X(We, 28), ze = X(We, 34), Ze = X(We, 39); return new G(Ge.N ^ ze.N ^ Ze.N, Ge.I ^ ze.I ^ Ze.I) } function Be(We, Ge) { var ze, Ze; ze = (65535 & We.I) + (65535 & Ge.I); var ut = (65535 & (Ze = (We.I >>> 16) + (Ge.I >>> 16) + (ze >>> 16))) << 16 | 65535 & ze; return ze = (65535 & We.N) + (65535 & Ge.N) + (Ze >>> 16), Ze = (We.N >>> 16) + (Ge.N >>> 16) + (ze >>> 16), new G((65535 & Ze) << 16 | 65535 & ze, ut) } function Me(We, Ge, ze, Ze) { var ut, ye; ut = (65535 & We.I) + (65535 & Ge.I) + (65535 & ze.I) + (65535 & Ze.I); var ge = (65535 & (ye = (We.I >>> 16) + (Ge.I >>> 16) + (ze.I >>> 16) + (Ze.I >>> 16) + (ut >>> 16))) << 16 | 65535 & ut; return ut = (65535 & We.N) + (65535 & Ge.N) + (65535 & ze.N) + (65535 & Ze.N) + (ye >>> 16), ye = (We.N >>> 16) + (Ge.N >>> 16) + (ze.N >>> 16) + (Ze.N >>> 16) + (ut >>> 16), new G((65535 & ye) << 16 | 65535 & ut, ge) } function De(We, Ge, ze, Ze, ut) { var ye, ge; ye = (65535 & We.I) + (65535 & Ge.I) + (65535 & ze.I) + (65535 & Ze.I) + (65535 & ut.I); var Ee = (65535 & (ge = (We.I >>> 16) + (Ge.I >>> 16) + (ze.I >>> 16) + (Ze.I >>> 16) + (ut.I >>> 16) + (ye >>> 16))) << 16 | 65535 & ye; return ye = (65535 & We.N) + (65535 & Ge.N) + (65535 & ze.N) + (65535 & Ze.N) + (65535 & ut.N) + (ge >>> 16), ge = (We.N >>> 16) + (Ge.N >>> 16) + (ze.N >>> 16) + (Ze.N >>> 16) + (ut.N >>> 16) + (ye >>> 16), new G((65535 & ge) << 16 | 65535 & ye, Ee) } function Ue(We, Ge) { return new G(We.N ^ Ge.N, We.I ^ Ge.I) } function Ke(We) { var Ge = X(We, 1), ze = X(We, 8), Ze = ce(We, 7); return new G(Ge.N ^ ze.N ^ Ze.N, Ge.I ^ ze.I ^ Ze.I) } function Ve(We) { var Ge = X(We, 14), ze = X(We, 18), Ze = X(We, 41); return new G(Ge.N ^ ze.N ^ Ze.N, Ge.I ^ ze.I ^ Ze.I) } var ke = [new G(m[0], 3609767458), new G(m[1], 602891725), new G(m[2], 3964484399), new G(m[3], 2173295548), new G(m[4], 4081628472), new G(m[5], 3053834265), new G(m[6], 2937671579), new G(m[7], 3664609560), new G(m[8], 2734883394), new G(m[9], 1164996542), new G(m[10], 1323610764), new G(m[11], 3590304994), new G(m[12], 4068182383), new G(m[13], 991336113), new G(m[14], 633803317), new G(m[15], 3479774868), new G(m[16], 2666613458), new G(m[17], 944711139), new G(m[18], 2341262773), new G(m[19], 2007800933), new G(m[20], 1495990901), new G(m[21], 1856431235), new G(m[22], 3175218132), new G(m[23], 2198950837), new G(m[24], 3999719339), new G(m[25], 766784016), new G(m[26], 2566594879), new G(m[27], 3203337956), new G(m[28], 1034457026), new G(m[29], 2466948901), new G(m[30], 3758326383), new G(m[31], 168717936), new G(m[32], 1188179964), new G(m[33], 1546045734), new G(m[34], 1522805485), new G(m[35], 2643833823), new G(m[36], 2343527390), new G(m[37], 1014477480), new G(m[38], 1206759142), new G(m[39], 344077627), new G(m[40], 1290863460), new G(m[41], 3158454273), new G(m[42], 3505952657), new G(m[43], 106217008), new G(m[44], 3606008344), new G(m[45], 1432725776), new G(m[46], 1467031594), new G(m[47], 851169720), new G(m[48], 3100823752), new G(m[49], 1363258195), new G(m[50], 3750685593), new G(m[51], 3785050280), new G(m[52], 3318307427), new G(m[53], 3812723403), new G(m[54], 2003034995), new G(m[55], 3602036899), new G(m[56], 1575990012), new G(m[57], 1125592928), new G(m[58], 2716904306), new G(m[59], 442776044), new G(m[60], 593698344), new G(m[61], 3733110249), new G(m[62], 2999351573), new G(m[63], 3815920427), new G(3391569614, 3928383900), new G(3515267271, 566280711), new G(3940187606, 3454069534), new G(4118630271, 4000239992), new G(116418474, 1914138554), new G(174292421, 2731055270), new G(289380356, 3203993006), new G(460393269, 320620315), new G(685471733, 587496836), new G(852142971, 1086792851), new G(1017036298, 365543100), new G(1126000580, 2618297676), new G(1288033470, 3409855158), new G(1501505948, 4234509866), new G(1607167915, 987167468), new G(1816402316, 1246189591)]; function Je(We) { return We === "SHA-384" ? [new G(3418070365, v[0]), new G(1654270250, v[1]), new G(2438529370, v[2]), new G(355462360, v[3]), new G(1731405415, v[4]), new G(41048885895, v[5]), new G(3675008525, v[6]), new G(1203062813, v[7])] : [new G(I[0], 4089235720), new G(I[1], 2227873595), new G(I[2], 4271175723), new G(I[3], 1595750129), new G(I[4], 2917565137), new G(I[5], 725511199), new G(I[6], 4215389547), new G(I[7], 327033209)] } function dt(We, Ge) { var ze, Ze, ut, ye, ge, Ee, Oe, je, nt, Xe, it, Tt, tt, yt, kt, wt, Mt = []; for (ze = Ge[0], Ze = Ge[1], ut = Ge[2], ye = Ge[3], ge = Ge[4], Ee = Ge[5], Oe = Ge[6], je = Ge[7], it = 0; it < 80; it += 1)it < 16 ? (Tt = 2 * it, Mt[it] = new G(We[Tt], We[Tt + 1])) : Mt[it] = Me((tt = Mt[it - 2], yt = void 0, kt = void 0, wt = void 0, yt = X(tt, 19), kt = X(tt, 61), wt = ce(tt, 6), new G(yt.N ^ kt.N ^ wt.N, yt.I ^ kt.I ^ wt.I)), Mt[it - 7], Ke(Mt[it - 15]), Mt[it - 16]), nt = De(je, Ve(ge), me(ge, Ee, Oe), ke[it], Mt[it]), Xe = Be(Ie(ze), Ae(ze, Ze, ut)), je = Oe, Oe = Ee, Ee = ge, ge = Be(ye, nt), ye = ut, ut = Ze, Ze = ze, ze = Be(nt, Xe); return Ge[0] = Be(ze, Ge[0]), Ge[1] = Be(Ze, Ge[1]), Ge[2] = Be(ut, Ge[2]), Ge[3] = Be(ye, Ge[3]), Ge[4] = Be(ge, Ge[4]), Ge[5] = Be(Ee, Ge[5]), Ge[6] = Be(Oe, Ge[6]), Ge[7] = Be(je, Ge[7]), Ge } var lt = function (We) { function Ge(ze, Ze, ut) { var ye = this; if (ze !== "SHA-384" && ze !== "SHA-512") throw new Error(F); var ge = ut || {}; return (ye = We.call(this, ze, Ze, ut) || this).F = ye.Y, ye.g = !0, ye.C = -1, ye.p = p(ye.t, ye.i, ye.C), ye.R = dt, ye.B = function (Ee) { return Ee.slice() }, ye.L = Je, ye.K = function (Ee, Oe, je, nt) { return function (Xe, it, Tt, tt, yt) { for (var kt, wt = 31 + (it + 129 >>> 10 << 5), Mt = it + Tt; Xe.length <= wt;)Xe.push(0); for (Xe[it >>> 5] |= 128 << 24 - it % 32, Xe[wt] = 4294967295 & Mt, Xe[wt - 1] = Mt / 4294967296 | 0, kt = 0; kt < Xe.length; kt += 32)tt = dt(Xe.slice(kt, kt + 32), tt); return yt === "SHA-384" ? [(tt = tt)[0].N, tt[0].I, tt[1].N, tt[1].I, tt[2].N, tt[2].I, tt[3].N, tt[3].I, tt[4].N, tt[4].I, tt[5].N, tt[5].I] : [tt[0].N, tt[0].I, tt[1].N, tt[1].I, tt[2].N, tt[2].I, tt[3].N, tt[3].I, tt[4].N, tt[4].I, tt[5].N, tt[5].I, tt[6].N, tt[6].I, tt[7].N, tt[7].I] }(Ee, Oe, je, nt, ze) }, ye.m = Je(ze), ye.S = 1024, ye.U = ze === "SHA-384" ? 384 : 512, ye.T = !1, ge.hmacKey && ye.k(Z("hmacKey", ge.hmacKey, ye.C)), ye } return ne(Ge, We), Ge }(Q), ht = [new G(0, 1), new G(0, 32898), new G(2147483648, 32906), new G(2147483648, 2147516416), new G(0, 32907), new G(0, 2147483649), new G(2147483648, 2147516545), new G(2147483648, 32777), new G(0, 138), new G(0, 136), new G(0, 2147516425), new G(0, 2147483658), new G(0, 2147516555), new G(2147483648, 139), new G(2147483648, 32905), new G(2147483648, 32771), new G(2147483648, 32770), new G(2147483648, 128), new G(0, 32778), new G(2147483648, 2147483658), new G(2147483648, 2147516545), new G(2147483648, 32896), new G(0, 2147483649), new G(2147483648, 2147516424)], Bt = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]]; function mt(We) { var Ge, ze = []; for (Ge = 0; Ge < 5; Ge += 1)ze[Ge] = [new G(0, 0), new G(0, 0), new G(0, 0), new G(0, 0), new G(0, 0)]; return ze } function et(We) { var Ge, ze = []; for (Ge = 0; Ge < 5; Ge += 1)ze[Ge] = We[Ge].slice(); return ze } function Gt(We, Ge) { var ze, Ze, ut, ye, ge, Ee, Oe, je, nt, Xe = [], it = []; if (We !== null) for (Ze = 0; Ze < We.length; Ze += 2)Ge[(Ze >>> 1) % 5][(Ze >>> 1) / 5 | 0] = Ue(Ge[(Ze >>> 1) % 5][(Ze >>> 1) / 5 | 0], new G(We[Ze + 1], We[Ze])); for (ze = 0; ze < 24; ze += 1) { for (ye = mt(), Ze = 0; Ze < 5; Ze += 1)Xe[Ze] = (ge = Ge[Ze][0], Ee = Ge[Ze][1], Oe = Ge[Ze][2], je = Ge[Ze][3], nt = Ge[Ze][4], new G(ge.N ^ Ee.N ^ Oe.N ^ je.N ^ nt.N, ge.I ^ Ee.I ^ Oe.I ^ je.I ^ nt.I)); for (Ze = 0; Ze < 5; Ze += 1)it[Ze] = Ue(Xe[(Ze + 4) % 5], y(Xe[(Ze + 1) % 5], 1)); for (Ze = 0; Ze < 5; Ze += 1)for (ut = 0; ut < 5; ut += 1)Ge[Ze][ut] = Ue(Ge[Ze][ut], it[Ze]); for (Ze = 0; Ze < 5; Ze += 1)for (ut = 0; ut < 5; ut += 1)ye[ut][(2 * Ze + 3 * ut) % 5] = y(Ge[Ze][ut], Bt[Ze][ut]); for (Ze = 0; Ze < 5; Ze += 1)for (ut = 0; ut < 5; ut += 1)Ge[Ze][ut] = Ue(ye[Ze][ut], new G(~ye[(Ze + 1) % 5][ut].N & ye[(Ze + 2) % 5][ut].N, ~ye[(Ze + 1) % 5][ut].I & ye[(Ze + 2) % 5][ut].I)); Ge[0][0] = Ue(Ge[0][0], ht[ze]) } return Ge } function pt(We) { var Ge, ze, Ze = 0, ut = [0, 0], ye = [4294967295 & We, We / 4294967296 & 2097151]; for (Ge = 6; Ge >= 0; Ge--)(ze = ye[Ge >> 2] >>> 8 * Ge & 255) === 0 && Ze === 0 || (ut[Ze + 1 >> 2] |= ze << 8 * (Ze + 1), Ze += 1); return Ze = Ze !== 0 ? Ze : 1, ut[0] |= Ze, { value: Ze + 1 > 4 ? ut : [ut[0]], binLen: 8 + 8 * Ze } } function _t(We) { return B(pt(We.binLen), We) } function zt(We, Ge) { var ze, Ze = pt(Ge), ut = Ge >>> 2, ye = (ut - (Ze = B(Ze, We)).value.length % ut) % ut; for (ze = 0; ze < ye; ze++)Ze.value.push(0); return Ze.value } var bt = function (We) { function Ge(ze, Ze, ut) { var ye = this, ge = 6, Ee = 0, Oe = ut || {}; if ((ye = We.call(this, ze, Ze, ut) || this).numRounds !== 1) { if (Oe.kmacKey || Oe.hmacKey) throw new Error("Cannot set numRounds with MAC"); if (ye.o === "CSHAKE128" || ye.o === "CSHAKE256") throw new Error("Cannot set numRounds for CSHAKE variants") } switch (ye.C = 1, ye.p = p(ye.t, ye.i, ye.C), ye.R = Gt, ye.B = et, ye.L = mt, ye.m = mt(), ye.T = !1, ze) { case "SHA3-224": ye.S = Ee = 1152, ye.U = 224, ye.g = !0, ye.F = ye.Y; break; case "SHA3-256": ye.S = Ee = 1088, ye.U = 256, ye.g = !0, ye.F = ye.Y; break; case "SHA3-384": ye.S = Ee = 832, ye.U = 384, ye.g = !0, ye.F = ye.Y; break; case "SHA3-512": ye.S = Ee = 576, ye.U = 512, ye.g = !0, ye.F = ye.Y; break; case "SHAKE128": ge = 31, ye.S = Ee = 1344, ye.U = -1, ye.T = !0, ye.g = !1, ye.F = null; break; case "SHAKE256": ge = 31, ye.S = Ee = 1088, ye.U = -1, ye.T = !0, ye.g = !1, ye.F = null; break; case "KMAC128": ge = 4, ye.S = Ee = 1344, ye.M(ut), ye.U = -1, ye.T = !0, ye.g = !1, ye.F = ye.X; break; case "KMAC256": ge = 4, ye.S = Ee = 1088, ye.M(ut), ye.U = -1, ye.T = !0, ye.g = !1, ye.F = ye.X; break; case "CSHAKE128": ye.S = Ee = 1344, ge = ye.O(ut), ye.U = -1, ye.T = !0, ye.g = !1, ye.F = null; break; case "CSHAKE256": ye.S = Ee = 1088, ge = ye.O(ut), ye.U = -1, ye.T = !0, ye.g = !1, ye.F = null; break; default: throw new Error(F) }return ye.K = function (je, nt, Xe, it, Tt) { return function (tt, yt, kt, wt, Mt, tr, St) { var gt, rr, Le = 0, xe = [], Ce = Mt >>> 5, Ne = yt >>> 5; for (gt = 0; gt < Ne && yt >= Mt; gt += Ce)wt = Gt(tt.slice(gt, gt + Ce), wt), yt -= Mt; for (tt = tt.slice(gt), yt %= Mt; tt.length < Ce;)tt.push(0); for (tt[(gt = yt >>> 3) >> 2] ^= tr << gt % 4 * 8, tt[Ce - 1] ^= 2147483648, wt = Gt(tt, wt); 32 * xe.length < St && (rr = wt[Le % 5][Le / 5 | 0], xe.push(rr.I), !(32 * xe.length >= St));)xe.push(rr.N), 64 * (Le += 1) % Mt == 0 && (Gt(null, wt), Le = 0); return xe }(je, nt, 0, it, Ee, ge, Tt) }, Oe.hmacKey && ye.k(Z("hmacKey", Oe.hmacKey, ye.C)), ye } return ne(Ge, We), Ge.prototype.O = function (ze, Ze) { var ut = function (Oe) { var je = Oe || {}; return { funcName: Z("funcName", je.funcName, 1, { value: [], binLen: 0 }), customization: Z("Customization", je.customization, 1, { value: [], binLen: 0 }) } }(ze || {}); Ze && (ut.funcName = Ze); var ye = B(_t(ut.funcName), _t(ut.customization)); if (ut.customization.binLen !== 0 || ut.funcName.binLen !== 0) { for (var ge = zt(ye, this.S >>> 3), Ee = 0; Ee < ge.length; Ee += this.S >>> 5)this.m = this.R(ge.slice(Ee, Ee + (this.S >>> 5)), this.m), this.v += this.S; return 4 } return 31 }, Ge.prototype.M = function (ze) { var Ze = function (ge) { var Ee = ge || {}; return { kmacKey: Z("kmacKey", Ee.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: Z("Customization", Ee.customization, 1, { value: [], binLen: 0 }) } }(ze || {}); this.O(ze, Ze.funcName); for (var ut = zt(_t(Ze.kmacKey), this.S >>> 3), ye = 0; ye < ut.length; ye += this.S >>> 5)this.m = this.R(ut.slice(ye, ye + (this.S >>> 5)), this.m), this.v += this.S; this.A = !0 }, Ge.prototype.X = function (ze) { var Ze = B({ value: this.u.slice(), binLen: this.s }, function (ut) { var ye, ge, Ee = 0, Oe = [0, 0], je = [4294967295 & ut, ut / 4294967296 & 2097151]; for (ye = 6; ye >= 0; ye--)(ge = je[ye >> 2] >>> 8 * ye & 255) == 0 && Ee === 0 || (Oe[Ee >> 2] |= ge << 8 * Ee, Ee += 1); return Oe[(Ee = Ee !== 0 ? Ee : 1) >> 2] |= Ee << 8 * Ee, { value: Ee + 1 > 4 ? Oe : [Oe[0]], binLen: 8 + 8 * Ee } }(ze.outputLen)); return this.K(Ze.value, Ze.binLen, this.v, this.B(this.m), ze.outputLen) }, Ge }(Q); return function () { function We(Ge, ze, Ze) { if (Ge == "SHA-1") this.j = new K(Ge, ze, Ze); else if (Ge == "SHA-224" || Ge == "SHA-256") this.j = new ee(Ge, ze, Ze); else if (Ge == "SHA-384" || Ge == "SHA-512") this.j = new lt(Ge, ze, Ze); else { if (Ge != "SHA3-224" && Ge != "SHA3-256" && Ge != "SHA3-384" && Ge != "SHA3-512" && Ge != "SHAKE128" && Ge != "SHAKE256" && Ge != "CSHAKE128" && Ge != "CSHAKE256" && Ge != "KMAC128" && Ge != "KMAC256") throw new Error(F); this.j = new bt(Ge, ze, Ze) } } return We.prototype.update = function (Ge) { this.j.update(Ge) }, We.prototype.getHash = function (Ge, ze) { return this.j.getHash(Ge, ze) }, We.prototype.setHMACKey = function (Ge, ze, Ze) { this.j.setHMACKey(Ge, ze, Ze) }, We.prototype.getHMAC = function (Ge, ze) { return this.j.getHMAC(Ge, ze) }, We }() }) }(sha$3)), sha$3.exports } var browser$d = {}, getSecureRandom$1 = {}, hasRequiredGetSecureRandom$1; function requireGetSecureRandom$1() { if (hasRequiredGetSecureRandom$1) return getSecureRandom$1; hasRequiredGetSecureRandom$1 = 1, Object.defineProperty(getSecureRandom$1, "__esModule", { value: !0 }), getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0; function o(u) { return Buffer.from(window.crypto.getRandomValues(new Uint8Array(u))) } getSecureRandom$1.getSecureRandomBytes = o; function l(u) { return window.crypto.getRandomValues(new Uint16Array(u)) } return getSecureRandom$1.getSecureRandomWords = l, getSecureRandom$1 } var hmac_sha512$1 = {}, hasRequiredHmac_sha512$1; function requireHmac_sha512$1() { if (hasRequiredHmac_sha512$1) return hmac_sha512$1; hasRequiredHmac_sha512$1 = 1, Object.defineProperty(hmac_sha512$1, "__esModule", { value: !0 }), hmac_sha512$1.hmac_sha512 = void 0; async function o(l, u) { let f = typeof l == "string" ? Buffer.from(l, "utf-8") : l, p = typeof u == "string" ? Buffer.from(u, "utf-8") : u; const d = { name: "HMAC", hash: "SHA-512" }, m = await window.crypto.subtle.importKey("raw", f, d, !1, ["sign"]); return Buffer.from(await crypto.subtle.sign(d, m, p)) } return hmac_sha512$1.hmac_sha512 = o, hmac_sha512$1 } var pbkdf2_sha512$1 = {}, hasRequiredPbkdf2_sha512$1; function requirePbkdf2_sha512$1() { if (hasRequiredPbkdf2_sha512$1) return pbkdf2_sha512$1; hasRequiredPbkdf2_sha512$1 = 1, Object.defineProperty(pbkdf2_sha512$1, "__esModule", { value: !0 }), pbkdf2_sha512$1.pbkdf2_sha512 = void 0; async function o(l, u, f, p) { const d = typeof l == "string" ? Buffer.from(l, "utf-8") : l, m = typeof u == "string" ? Buffer.from(u, "utf-8") : u, v = await window.crypto.subtle.importKey("raw", d, { name: "PBKDF2" }, !1, ["deriveBits"]), I = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: m, iterations: f }, v, p * 8); return Buffer.from(I) } return pbkdf2_sha512$1.pbkdf2_sha512 = o, pbkdf2_sha512$1 } var sha256$2 = {}, hasRequiredSha256$2; function requireSha256$2() { if (hasRequiredSha256$2) return sha256$2; hasRequiredSha256$2 = 1, Object.defineProperty(sha256$2, "__esModule", { value: !0 }), sha256$2.sha256 = void 0; async function o(l) { return typeof l == "string" ? Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(l, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-256", l)) } return sha256$2.sha256 = o, sha256$2 } var sha512$3 = {}, hasRequiredSha512$2; function requireSha512$2() { if (hasRequiredSha512$2) return sha512$3; hasRequiredSha512$2 = 1, Object.defineProperty(sha512$3, "__esModule", { value: !0 }), sha512$3.sha512 = void 0; async function o(l) { return typeof l == "string" ? Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(l, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-512", l)) } return sha512$3.sha512 = o, sha512$3 } var hasRequiredBrowser$c; function requireBrowser$c() { return hasRequiredBrowser$c || (hasRequiredBrowser$c = 1, function (o) { Object.defineProperty(o, "__esModule", { value: !0 }), o.sha512 = o.sha256 = o.pbkdf2_sha512 = o.hmac_sha512 = o.getSecureRandomWords = o.getSecureRandomBytes = void 0; var l = requireGetSecureRandom$1(); Object.defineProperty(o, "getSecureRandomBytes", { enumerable: !0, get: function () { return l.getSecureRandomBytes } }), Object.defineProperty(o, "getSecureRandomWords", { enumerable: !0, get: function () { return l.getSecureRandomWords } }); var u = requireHmac_sha512$1(); Object.defineProperty(o, "hmac_sha512", { enumerable: !0, get: function () { return u.hmac_sha512 } }); var f = requirePbkdf2_sha512$1(); Object.defineProperty(o, "pbkdf2_sha512", { enumerable: !0, get: function () { return f.pbkdf2_sha512 } }); var p = requireSha256$2(); Object.defineProperty(o, "sha256", { enumerable: !0, get: function () { return p.sha256 } }); var d = requireSha512$2(); Object.defineProperty(o, "sha512", { enumerable: !0, get: function () { return d.sha512 } }) }(browser$d)), browser$d } var hasRequiredSha256$1; function requireSha256$1() { if (hasRequiredSha256$1) return sha256$3; hasRequiredSha256$1 = 1; var o = sha256$3 && sha256$3.__importDefault || function (m) { return m && m.__esModule ? m : { default: m } }; Object.defineProperty(sha256$3, "__esModule", { value: !0 }), sha256$3.sha256 = sha256$3.sha256_fallback = sha256$3.sha256_sync = void 0; const l = o(requireSha$2()), u = requireBrowser$c(); function f(m) { let v; typeof m == "string" ? v = Buffer.from(m, "utf-8").toString("hex") : v = m.toString("hex"); let I = new l.default("SHA-256", "HEX"); I.update(v); let F = I.getHash("HEX"); return Buffer.from(F, "hex") } sha256$3.sha256_sync = f; async function p(m) { return f(m) } sha256$3.sha256_fallback = p; function d(m) { return (0, u.sha256)(m) } return sha256$3.sha256 = d, sha256$3 } var sha512$2 = {}, hasRequiredSha512$1; function requireSha512$1() { if (hasRequiredSha512$1) return sha512$2; hasRequiredSha512$1 = 1; var o = sha512$2 && sha512$2.__importDefault || function (m) { return m && m.__esModule ? m : { default: m } }; Object.defineProperty(sha512$2, "__esModule", { value: !0 }), sha512$2.sha512 = sha512$2.sha512_fallback = sha512$2.sha512_sync = void 0; const l = o(requireSha$2()), u = requireBrowser$c(); function f(m) { let v; typeof m == "string" ? v = Buffer.from(m, "utf-8").toString("hex") : v = m.toString("hex"); let I = new l.default("SHA-512", "HEX"); I.update(v); let F = I.getHash("HEX"); return Buffer.from(F, "hex") } sha512$2.sha512_sync = f; async function p(m) { return f(m) } sha512$2.sha512_fallback = p; async function d(m) { return (0, u.sha512)(m) } return sha512$2.sha512 = d, sha512$2 } var pbkdf2_sha512 = {}, hasRequiredPbkdf2_sha512; function requirePbkdf2_sha512() { if (hasRequiredPbkdf2_sha512) return pbkdf2_sha512; hasRequiredPbkdf2_sha512 = 1, Object.defineProperty(pbkdf2_sha512, "__esModule", { value: !0 }), pbkdf2_sha512.pbkdf2_sha512 = void 0; const o = requireBrowser$c(); function l(u, f, p, d) { return (0, o.pbkdf2_sha512)(u, f, p, d) } return pbkdf2_sha512.pbkdf2_sha512 = l, pbkdf2_sha512 } var hmac_sha512 = {}, hasRequiredHmac_sha512; function requireHmac_sha512() { if (hasRequiredHmac_sha512) return hmac_sha512; hasRequiredHmac_sha512 = 1; var o = hmac_sha512 && hmac_sha512.__importDefault || function (d) { return d && d.__esModule ? d : { default: d } }; Object.defineProperty(hmac_sha512, "__esModule", { value: !0 }), hmac_sha512.hmac_sha512 = hmac_sha512.hmac_sha512_fallback = void 0; const l = o(requireSha$2()), u = requireBrowser$c(); async function f(d, m) { let v = typeof d == "string" ? Buffer.from(d, "utf-8") : d, I = typeof m == "string" ? Buffer.from(m, "utf-8") : m; const F = new l.default("SHA-512", "HEX", { hmacKey: { value: v.toString("hex"), format: "HEX" } }); F.update(I.toString("hex")); const B = F.getHash("HEX"); return Buffer.from(B, "hex") } hmac_sha512.hmac_sha512_fallback = f; function p(d, m) { return (0, u.hmac_sha512)(d, m) } return hmac_sha512.hmac_sha512 = p, hmac_sha512 } var getSecureRandom = {}, hasRequiredGetSecureRandom; function requireGetSecureRandom() { if (hasRequiredGetSecureRandom) return getSecureRandom; hasRequiredGetSecureRandom = 1, Object.defineProperty(getSecureRandom, "__esModule", { value: !0 }), getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0; const o = requireBrowser$c(); async function l(p) { return (0, o.getSecureRandomBytes)(p) } getSecureRandom.getSecureRandomBytes = l; async function u(p) { return u() } getSecureRandom.getSecureRandomWords = u; async function f(p, d) { let m = d - p; var v = Math.ceil(Math.log2(m)); if (v > 53) throw new Error("Range is too large"); for (var I = Math.ceil(v / 8), F = Math.pow(2, v) - 1; ;) { let W = await l(v), Z = (I - 1) * 8, Q = 0; for (var B = 0; B < I; B++)Q += W[B] * Math.pow(2, Z), Z -= 8; if (Q = Q & F, !(Q >= m)) return p + Q } } return getSecureRandom.getSecureRandomNumber = f, getSecureRandom } var newSecureWords = {}, wordlist$1 = {}, hasRequiredWordlist$1; function requireWordlist$1() { return hasRequiredWordlist$1 || (hasRequiredWordlist$1 = 1, Object.defineProperty(wordlist$1, "__esModule", { value: !0 }), wordlist$1.wordlist = void 0, wordlist$1.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"]), wordlist$1 } var hasRequiredNewSecureWords; function requireNewSecureWords() { if (hasRequiredNewSecureWords) return newSecureWords; hasRequiredNewSecureWords = 1, Object.defineProperty(newSecureWords, "__esModule", { value: !0 }), newSecureWords.newSecureWords = void 0; const o = requireGetSecureRandom(), l = requireWordlist$1(); async function u(f = 6) { let p = []; for (let d = 0; d < f; d++)p.push(l.wordlist[await (0, o.getSecureRandomNumber)(0, l.wordlist.length)]); return p } return newSecureWords.newSecureWords = u, newSecureWords } var newSecurePassphrase = {}, hasRequiredNewSecurePassphrase; function requireNewSecurePassphrase() { if (hasRequiredNewSecurePassphrase) return newSecurePassphrase; hasRequiredNewSecurePassphrase = 1, Object.defineProperty(newSecurePassphrase, "__esModule", { value: !0 }), newSecurePassphrase.newSecurePassphrase = void 0; const o = requireDist$1(); async function l(u = 6) { return (await (0, o.newSecureWords)(u)).join("-") } return newSecurePassphrase.newSecurePassphrase = l, newSecurePassphrase } var mnemonic = {}; function commonjsRequire(o) { throw new Error('Could not dynamically require "' + o + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var naclFast = { exports: {} }, cryptoBrowserify = {}, browser$c = { exports: {} }, safeBuffer$1 = { exports: {} }, dist = {}, hasRequiredDist$2; function requireDist$2() {
  return hasRequiredDist$2 || (hasRequiredDist$2 = 1, function (o) {
    Object.defineProperties(o, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } }); var l = {}, u = {}; u.byteLength = B, u.toByteArray = Z, u.fromByteArray = ne; for (var f = [], p = [], d = typeof Uint8Array < "u" ? Uint8Array : Array, m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", v = 0, I = m.length; v < I; ++v)f[v] = m[v], p[m.charCodeAt(v)] = v; p[45] = 62, p[95] = 63; function F(se) { var le = se.length; if (le % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var ue = se.indexOf("="); ue === -1 && (ue = le); var he = ue === le ? 0 : 4 - ue % 4; return [ue, he] } function B(se) { var le = F(se), ue = le[0], he = le[1]; return (ue + he) * 3 / 4 - he } function W(se, le, ue) { return (le + ue) * 3 / 4 - ue } function Z(se) { var le, ue = F(se), he = ue[0], pe = ue[1], ve = new d(W(se, he, pe)), _e = 0, Se = pe > 0 ? he - 4 : he, $e; for ($e = 0; $e < Se; $e += 4)le = p[se.charCodeAt($e)] << 18 | p[se.charCodeAt($e + 1)] << 12 | p[se.charCodeAt($e + 2)] << 6 | p[se.charCodeAt($e + 3)], ve[_e++] = le >> 16 & 255, ve[_e++] = le >> 8 & 255, ve[_e++] = le & 255; return pe === 2 && (le = p[se.charCodeAt($e)] << 2 | p[se.charCodeAt($e + 1)] >> 4, ve[_e++] = le & 255), pe === 1 && (le = p[se.charCodeAt($e)] << 10 | p[se.charCodeAt($e + 1)] << 4 | p[se.charCodeAt($e + 2)] >> 2, ve[_e++] = le >> 8 & 255, ve[_e++] = le & 255), ve } function Q(se) { return f[se >> 18 & 63] + f[se >> 12 & 63] + f[se >> 6 & 63] + f[se & 63] } function re(se, le, ue) { for (var he, pe = [], ve = le; ve < ue; ve += 3)he = (se[ve] << 16 & 16711680) + (se[ve + 1] << 8 & 65280) + (se[ve + 2] & 255), pe.push(Q(he)); return pe.join("") } function ne(se) { for (var le, ue = se.length, he = ue % 3, pe = [], ve = 16383, _e = 0, Se = ue - he; _e < Se; _e += ve)pe.push(re(se, _e, _e + ve > Se ? Se : _e + ve)); return he === 1 ? (le = se[ue - 1], pe.push(f[le >> 2] + f[le << 4 & 63] + "==")) : he === 2 && (le = (se[ue - 2] << 8) + se[ue - 1], pe.push(f[le >> 10] + f[le >> 4 & 63] + f[le << 2 & 63] + "=")), pe.join("") } var oe = {};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */oe.read = function (se, le, ue, he, pe) { var ve, _e, Se = pe * 8 - he - 1, $e = (1 << Se) - 1, ie = $e >> 1, g = -7, P = ue ? pe - 1 : 0, U = ue ? -1 : 1, K = se[le + P]; for (P += U, ve = K & (1 << -g) - 1, K >>= -g, g += Se; g > 0; ve = ve * 256 + se[le + P], P += U, g -= 8); for (_e = ve & (1 << -g) - 1, ve >>= -g, g += he; g > 0; _e = _e * 256 + se[le + P], P += U, g -= 8); if (ve === 0) ve = 1 - ie; else { if (ve === $e) return _e ? NaN : (K ? -1 : 1) * (1 / 0); _e = _e + Math.pow(2, he), ve = ve - ie } return (K ? -1 : 1) * _e * Math.pow(2, ve - he) }, oe.write = function (se, le, ue, he, pe, ve) { var _e, Se, $e, ie = ve * 8 - pe - 1, g = (1 << ie) - 1, P = g >> 1, U = pe === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, K = he ? 0 : ve - 1, Y = he ? 1 : -1, te = le < 0 || le === 0 && 1 / le < 0 ? 1 : 0; for (le = Math.abs(le), isNaN(le) || le === 1 / 0 ? (Se = isNaN(le) ? 1 : 0, _e = g) : (_e = Math.floor(Math.log(le) / Math.LN2), le * ($e = Math.pow(2, -_e)) < 1 && (_e--, $e *= 2), _e + P >= 1 ? le += U / $e : le += U * Math.pow(2, 1 - P), le * $e >= 2 && (_e++, $e /= 2), _e + P >= g ? (Se = 0, _e = g) : _e + P >= 1 ? (Se = (le * $e - 1) * Math.pow(2, pe), _e = _e + P) : (Se = le * Math.pow(2, P - 1) * Math.pow(2, pe), _e = 0)); pe >= 8; se[ue + K] = Se & 255, K += Y, Se /= 256, pe -= 8); for (_e = _e << pe | Se, ie += pe; ie > 0; se[ue + K] = _e & 255, K += Y, _e /= 256, ie -= 8); se[ue + K - Y] |= te * 128 };/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function (se) { const le = u, ue = oe, he = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null; se.Buffer = g, se.SlowBuffer = me, se.INSPECT_MAX_BYTES = 50; const pe = 2147483647; se.kMaxLength = pe; const { Uint8Array: ve, ArrayBuffer: _e, SharedArrayBuffer: Se } = globalThis; g.TYPED_ARRAY_SUPPORT = $e(), !g.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."); function $e() { try { const Le = new ve(1), xe = { foo: function () { return 42 } }; return Object.setPrototypeOf(xe, ve.prototype), Object.setPrototypeOf(Le, xe), Le.foo() === 42 } catch { return !1 } } Object.defineProperty(g.prototype, "parent", { enumerable: !0, get: function () { if (g.isBuffer(this)) return this.buffer } }), Object.defineProperty(g.prototype, "offset", { enumerable: !0, get: function () { if (g.isBuffer(this)) return this.byteOffset } }); function ie(Le) { if (Le > pe) throw new RangeError('The value "' + Le + '" is invalid for option "size"'); const xe = new ve(Le); return Object.setPrototypeOf(xe, g.prototype), xe } function g(Le, xe, Ce) { if (typeof Le == "number") { if (typeof xe == "string") throw new TypeError('The "string" argument must be of type string. Received type number'); return Y(Le) } return P(Le, xe, Ce) } g.poolSize = 8192; function P(Le, xe, Ce) { if (typeof Le == "string") return te(Le, xe); if (_e.isView(Le)) return G(Le); if (Le == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Le); if (Mt(Le, _e) || Le && Mt(Le.buffer, _e) || typeof Se < "u" && (Mt(Le, Se) || Le && Mt(Le.buffer, Se))) return y(Le, xe, Ce); if (typeof Le == "number") throw new TypeError('The "value" argument must not be of type number. Received type number'); const Ne = Le.valueOf && Le.valueOf(); if (Ne != null && Ne !== Le) return g.from(Ne, xe, Ce); const Ye = X(Le); if (Ye) return Ye; if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Le[Symbol.toPrimitive] == "function") return g.from(Le[Symbol.toPrimitive]("string"), xe, Ce); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Le) } g.from = function (Le, xe, Ce) { return P(Le, xe, Ce) }, Object.setPrototypeOf(g.prototype, ve.prototype), Object.setPrototypeOf(g, ve); function U(Le) { if (typeof Le != "number") throw new TypeError('"size" argument must be of type number'); if (Le < 0) throw new RangeError('The value "' + Le + '" is invalid for option "size"') } function K(Le, xe, Ce) { return U(Le), Le <= 0 ? ie(Le) : xe !== void 0 ? typeof Ce == "string" ? ie(Le).fill(xe, Ce) : ie(Le).fill(xe) : ie(Le) } g.alloc = function (Le, xe, Ce) { return K(Le, xe, Ce) }; function Y(Le) { return U(Le), ie(Le < 0 ? 0 : ce(Le) | 0) } g.allocUnsafe = function (Le) { return Y(Le) }, g.allocUnsafeSlow = function (Le) { return Y(Le) }; function te(Le, xe) { if ((typeof xe != "string" || xe === "") && (xe = "utf8"), !g.isEncoding(xe)) throw new TypeError("Unknown encoding: " + xe); const Ce = Ae(Le, xe) | 0; let Ne = ie(Ce); const Ye = Ne.write(Le, xe); return Ye !== Ce && (Ne = Ne.slice(0, Ye)), Ne } function ee(Le) { const xe = Le.length < 0 ? 0 : ce(Le.length) | 0, Ce = ie(xe); for (let Ne = 0; Ne < xe; Ne += 1)Ce[Ne] = Le[Ne] & 255; return Ce } function G(Le) { if (Mt(Le, ve)) { const xe = new ve(Le); return y(xe.buffer, xe.byteOffset, xe.byteLength) } return ee(Le) } function y(Le, xe, Ce) { if (xe < 0 || Le.byteLength < xe) throw new RangeError('"offset" is outside of buffer bounds'); if (Le.byteLength < xe + (Ce || 0)) throw new RangeError('"length" is outside of buffer bounds'); let Ne; return xe === void 0 && Ce === void 0 ? Ne = new ve(Le) : Ce === void 0 ? Ne = new ve(Le, xe) : Ne = new ve(Le, xe, Ce), Object.setPrototypeOf(Ne, g.prototype), Ne } function X(Le) { if (g.isBuffer(Le)) { const xe = ce(Le.length) | 0, Ce = ie(xe); return Ce.length === 0 || Le.copy(Ce, 0, 0, xe), Ce } if (Le.length !== void 0) return typeof Le.length != "number" || tr(Le.length) ? ie(0) : ee(Le); if (Le.type === "Buffer" && Array.isArray(Le.data)) return ee(Le.data) } function ce(Le) { if (Le >= pe) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + pe.toString(16) + " bytes"); return Le | 0 } function me(Le) { return +Le != Le && (Le = 0), g.alloc(+Le) } g.isBuffer = function (xe) { return xe != null && xe._isBuffer === !0 && xe !== g.prototype }, g.compare = function (xe, Ce) { if (Mt(xe, ve) && (xe = g.from(xe, xe.offset, xe.byteLength)), Mt(Ce, ve) && (Ce = g.from(Ce, Ce.offset, Ce.byteLength)), !g.isBuffer(xe) || !g.isBuffer(Ce)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (xe === Ce) return 0; let Ne = xe.length, Ye = Ce.length; for (let Re = 0, Pe = Math.min(Ne, Ye); Re < Pe; ++Re)if (xe[Re] !== Ce[Re]) { Ne = xe[Re], Ye = Ce[Re]; break } return Ne < Ye ? -1 : Ye < Ne ? 1 : 0 }, g.isEncoding = function (xe) { switch (String(xe).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, g.concat = function (xe, Ce) { if (!Array.isArray(xe)) throw new TypeError('"list" argument must be an Array of Buffers'); if (xe.length === 0) return g.alloc(0); let Ne; if (Ce === void 0) for (Ce = 0, Ne = 0; Ne < xe.length; ++Ne)Ce += xe[Ne].length; const Ye = g.allocUnsafe(Ce); let Re = 0; for (Ne = 0; Ne < xe.length; ++Ne) { let Pe = xe[Ne]; if (Mt(Pe, ve)) Re + Pe.length > Ye.length ? (g.isBuffer(Pe) || (Pe = g.from(Pe)), Pe.copy(Ye, Re)) : ve.prototype.set.call(Ye, Pe, Re); else if (g.isBuffer(Pe)) Pe.copy(Ye, Re); else throw new TypeError('"list" argument must be an Array of Buffers'); Re += Pe.length } return Ye }; function Ae(Le, xe) { if (g.isBuffer(Le)) return Le.length; if (_e.isView(Le) || Mt(Le, _e)) return Le.byteLength; if (typeof Le != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Le); const Ce = Le.length, Ne = arguments.length > 2 && arguments[2] === !0; if (!Ne && Ce === 0) return 0; let Ye = !1; for (; ;)switch (xe) { case "ascii": case "latin1": case "binary": return Ce; case "utf8": case "utf-8": return Tt(Le).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return Ce * 2; case "hex": return Ce >>> 1; case "base64": return kt(Le).length; default: if (Ye) return Ne ? -1 : Tt(Le).length; xe = ("" + xe).toLowerCase(), Ye = !0 } } g.byteLength = Ae; function Ie(Le, xe, Ce) { let Ne = !1; if ((xe === void 0 || xe < 0) && (xe = 0), xe > this.length || ((Ce === void 0 || Ce > this.length) && (Ce = this.length), Ce <= 0) || (Ce >>>= 0, xe >>>= 0, Ce <= xe)) return ""; for (Le || (Le = "utf8"); ;)switch (Le) { case "hex": return Gt(this, xe, Ce); case "utf8": case "utf-8": return lt(this, xe, Ce); case "ascii": return mt(this, xe, Ce); case "latin1": case "binary": return et(this, xe, Ce); case "base64": return dt(this, xe, Ce); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return pt(this, xe, Ce); default: if (Ne) throw new TypeError("Unknown encoding: " + Le); Le = (Le + "").toLowerCase(), Ne = !0 } } g.prototype._isBuffer = !0; function Be(Le, xe, Ce) { const Ne = Le[xe]; Le[xe] = Le[Ce], Le[Ce] = Ne } g.prototype.swap16 = function () { const xe = this.length; if (xe % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let Ce = 0; Ce < xe; Ce += 2)Be(this, Ce, Ce + 1); return this }, g.prototype.swap32 = function () { const xe = this.length; if (xe % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let Ce = 0; Ce < xe; Ce += 4)Be(this, Ce, Ce + 3), Be(this, Ce + 1, Ce + 2); return this }, g.prototype.swap64 = function () { const xe = this.length; if (xe % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let Ce = 0; Ce < xe; Ce += 8)Be(this, Ce, Ce + 7), Be(this, Ce + 1, Ce + 6), Be(this, Ce + 2, Ce + 5), Be(this, Ce + 3, Ce + 4); return this }, g.prototype.toString = function () { const xe = this.length; return xe === 0 ? "" : arguments.length === 0 ? lt(this, 0, xe) : Ie.apply(this, arguments) }, g.prototype.toLocaleString = g.prototype.toString, g.prototype.equals = function (xe) { if (!g.isBuffer(xe)) throw new TypeError("Argument must be a Buffer"); return this === xe ? !0 : g.compare(this, xe) === 0 }, g.prototype.inspect = function () { let xe = ""; const Ce = se.INSPECT_MAX_BYTES; return xe = this.toString("hex", 0, Ce).replace(/(.{2})/g, "$1 ").trim(), this.length > Ce && (xe += " ... "), "<Buffer " + xe + ">" }, he && (g.prototype[he] = g.prototype.inspect), g.prototype.compare = function (xe, Ce, Ne, Ye, Re) { if (Mt(xe, ve) && (xe = g.from(xe, xe.offset, xe.byteLength)), !g.isBuffer(xe)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof xe); if (Ce === void 0 && (Ce = 0), Ne === void 0 && (Ne = xe ? xe.length : 0), Ye === void 0 && (Ye = 0), Re === void 0 && (Re = this.length), Ce < 0 || Ne > xe.length || Ye < 0 || Re > this.length) throw new RangeError("out of range index"); if (Ye >= Re && Ce >= Ne) return 0; if (Ye >= Re) return -1; if (Ce >= Ne) return 1; if (Ce >>>= 0, Ne >>>= 0, Ye >>>= 0, Re >>>= 0, this === xe) return 0; let Pe = Re - Ye, qe = Ne - Ce; const be = Math.min(Pe, qe), Fe = this.slice(Ye, Re), Qe = xe.slice(Ce, Ne); for (let st = 0; st < be; ++st)if (Fe[st] !== Qe[st]) { Pe = Fe[st], qe = Qe[st]; break } return Pe < qe ? -1 : qe < Pe ? 1 : 0 }; function Me(Le, xe, Ce, Ne, Ye) { if (Le.length === 0) return -1; if (typeof Ce == "string" ? (Ne = Ce, Ce = 0) : Ce > 2147483647 ? Ce = 2147483647 : Ce < -2147483648 && (Ce = -2147483648), Ce = +Ce, tr(Ce) && (Ce = Ye ? 0 : Le.length - 1), Ce < 0 && (Ce = Le.length + Ce), Ce >= Le.length) { if (Ye) return -1; Ce = Le.length - 1 } else if (Ce < 0) if (Ye) Ce = 0; else return -1; if (typeof xe == "string" && (xe = g.from(xe, Ne)), g.isBuffer(xe)) return xe.length === 0 ? -1 : De(Le, xe, Ce, Ne, Ye); if (typeof xe == "number") return xe = xe & 255, typeof ve.prototype.indexOf == "function" ? Ye ? ve.prototype.indexOf.call(Le, xe, Ce) : ve.prototype.lastIndexOf.call(Le, xe, Ce) : De(Le, [xe], Ce, Ne, Ye); throw new TypeError("val must be string, number or Buffer") } function De(Le, xe, Ce, Ne, Ye) { let Re = 1, Pe = Le.length, qe = xe.length; if (Ne !== void 0 && (Ne = String(Ne).toLowerCase(), Ne === "ucs2" || Ne === "ucs-2" || Ne === "utf16le" || Ne === "utf-16le")) { if (Le.length < 2 || xe.length < 2) return -1; Re = 2, Pe /= 2, qe /= 2, Ce /= 2 } function be(Qe, st) { return Re === 1 ? Qe[st] : Qe.readUInt16BE(st * Re) } let Fe; if (Ye) { let Qe = -1; for (Fe = Ce; Fe < Pe; Fe++)if (be(Le, Fe) === be(xe, Qe === -1 ? 0 : Fe - Qe)) { if (Qe === -1 && (Qe = Fe), Fe - Qe + 1 === qe) return Qe * Re } else Qe !== -1 && (Fe -= Fe - Qe), Qe = -1 } else for (Ce + qe > Pe && (Ce = Pe - qe), Fe = Ce; Fe >= 0; Fe--) { let Qe = !0; for (let st = 0; st < qe; st++)if (be(Le, Fe + st) !== be(xe, st)) { Qe = !1; break } if (Qe) return Fe } return -1 } g.prototype.includes = function (xe, Ce, Ne) { return this.indexOf(xe, Ce, Ne) !== -1 }, g.prototype.indexOf = function (xe, Ce, Ne) { return Me(this, xe, Ce, Ne, !0) }, g.prototype.lastIndexOf = function (xe, Ce, Ne) { return Me(this, xe, Ce, Ne, !1) }; function Ue(Le, xe, Ce, Ne) { Ce = Number(Ce) || 0; const Ye = Le.length - Ce; Ne ? (Ne = Number(Ne), Ne > Ye && (Ne = Ye)) : Ne = Ye; const Re = xe.length; Ne > Re / 2 && (Ne = Re / 2); let Pe; for (Pe = 0; Pe < Ne; ++Pe) { const qe = parseInt(xe.substr(Pe * 2, 2), 16); if (tr(qe)) return Pe; Le[Ce + Pe] = qe } return Pe } function Ke(Le, xe, Ce, Ne) { return wt(Tt(xe, Le.length - Ce), Le, Ce, Ne) } function Ve(Le, xe, Ce, Ne) { return wt(tt(xe), Le, Ce, Ne) } function ke(Le, xe, Ce, Ne) { return wt(kt(xe), Le, Ce, Ne) } function Je(Le, xe, Ce, Ne) { return wt(yt(xe, Le.length - Ce), Le, Ce, Ne) } g.prototype.write = function (xe, Ce, Ne, Ye) { if (Ce === void 0) Ye = "utf8", Ne = this.length, Ce = 0; else if (Ne === void 0 && typeof Ce == "string") Ye = Ce, Ne = this.length, Ce = 0; else if (isFinite(Ce)) Ce = Ce >>> 0, isFinite(Ne) ? (Ne = Ne >>> 0, Ye === void 0 && (Ye = "utf8")) : (Ye = Ne, Ne = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); const Re = this.length - Ce; if ((Ne === void 0 || Ne > Re) && (Ne = Re), xe.length > 0 && (Ne < 0 || Ce < 0) || Ce > this.length) throw new RangeError("Attempt to write outside buffer bounds"); Ye || (Ye = "utf8"); let Pe = !1; for (; ;)switch (Ye) { case "hex": return Ue(this, xe, Ce, Ne); case "utf8": case "utf-8": return Ke(this, xe, Ce, Ne); case "ascii": case "latin1": case "binary": return Ve(this, xe, Ce, Ne); case "base64": return ke(this, xe, Ce, Ne); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return Je(this, xe, Ce, Ne); default: if (Pe) throw new TypeError("Unknown encoding: " + Ye); Ye = ("" + Ye).toLowerCase(), Pe = !0 } }, g.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function dt(Le, xe, Ce) { return xe === 0 && Ce === Le.length ? le.fromByteArray(Le) : le.fromByteArray(Le.slice(xe, Ce)) } function lt(Le, xe, Ce) { Ce = Math.min(Le.length, Ce); const Ne = []; let Ye = xe; for (; Ye < Ce;) { const Re = Le[Ye]; let Pe = null, qe = Re > 239 ? 4 : Re > 223 ? 3 : Re > 191 ? 2 : 1; if (Ye + qe <= Ce) { let be, Fe, Qe, st; switch (qe) { case 1: Re < 128 && (Pe = Re); break; case 2: be = Le[Ye + 1], (be & 192) === 128 && (st = (Re & 31) << 6 | be & 63, st > 127 && (Pe = st)); break; case 3: be = Le[Ye + 1], Fe = Le[Ye + 2], (be & 192) === 128 && (Fe & 192) === 128 && (st = (Re & 15) << 12 | (be & 63) << 6 | Fe & 63, st > 2047 && (st < 55296 || st > 57343) && (Pe = st)); break; case 4: be = Le[Ye + 1], Fe = Le[Ye + 2], Qe = Le[Ye + 3], (be & 192) === 128 && (Fe & 192) === 128 && (Qe & 192) === 128 && (st = (Re & 15) << 18 | (be & 63) << 12 | (Fe & 63) << 6 | Qe & 63, st > 65535 && st < 1114112 && (Pe = st)) } } Pe === null ? (Pe = 65533, qe = 1) : Pe > 65535 && (Pe -= 65536, Ne.push(Pe >>> 10 & 1023 | 55296), Pe = 56320 | Pe & 1023), Ne.push(Pe), Ye += qe } return Bt(Ne) } const ht = 4096; function Bt(Le) { const xe = Le.length; if (xe <= ht) return String.fromCharCode.apply(String, Le); let Ce = "", Ne = 0; for (; Ne < xe;)Ce += String.fromCharCode.apply(String, Le.slice(Ne, Ne += ht)); return Ce } function mt(Le, xe, Ce) { let Ne = ""; Ce = Math.min(Le.length, Ce); for (let Ye = xe; Ye < Ce; ++Ye)Ne += String.fromCharCode(Le[Ye] & 127); return Ne } function et(Le, xe, Ce) { let Ne = ""; Ce = Math.min(Le.length, Ce); for (let Ye = xe; Ye < Ce; ++Ye)Ne += String.fromCharCode(Le[Ye]); return Ne } function Gt(Le, xe, Ce) { const Ne = Le.length; (!xe || xe < 0) && (xe = 0), (!Ce || Ce < 0 || Ce > Ne) && (Ce = Ne); let Ye = ""; for (let Re = xe; Re < Ce; ++Re)Ye += St[Le[Re]]; return Ye } function pt(Le, xe, Ce) { const Ne = Le.slice(xe, Ce); let Ye = ""; for (let Re = 0; Re < Ne.length - 1; Re += 2)Ye += String.fromCharCode(Ne[Re] + Ne[Re + 1] * 256); return Ye } g.prototype.slice = function (xe, Ce) { const Ne = this.length; xe = ~~xe, Ce = Ce === void 0 ? Ne : ~~Ce, xe < 0 ? (xe += Ne, xe < 0 && (xe = 0)) : xe > Ne && (xe = Ne), Ce < 0 ? (Ce += Ne, Ce < 0 && (Ce = 0)) : Ce > Ne && (Ce = Ne), Ce < xe && (Ce = xe); const Ye = this.subarray(xe, Ce); return Object.setPrototypeOf(Ye, g.prototype), Ye }; function _t(Le, xe, Ce) { if (Le % 1 !== 0 || Le < 0) throw new RangeError("offset is not uint"); if (Le + xe > Ce) throw new RangeError("Trying to access beyond buffer length") } g.prototype.readUintLE = g.prototype.readUIntLE = function (xe, Ce, Ne) { xe = xe >>> 0, Ce = Ce >>> 0, Ne || _t(xe, Ce, this.length); let Ye = this[xe], Re = 1, Pe = 0; for (; ++Pe < Ce && (Re *= 256);)Ye += this[xe + Pe] * Re; return Ye }, g.prototype.readUintBE = g.prototype.readUIntBE = function (xe, Ce, Ne) { xe = xe >>> 0, Ce = Ce >>> 0, Ne || _t(xe, Ce, this.length); let Ye = this[xe + --Ce], Re = 1; for (; Ce > 0 && (Re *= 256);)Ye += this[xe + --Ce] * Re; return Ye }, g.prototype.readUint8 = g.prototype.readUInt8 = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 1, this.length), this[xe] }, g.prototype.readUint16LE = g.prototype.readUInt16LE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 2, this.length), this[xe] | this[xe + 1] << 8 }, g.prototype.readUint16BE = g.prototype.readUInt16BE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 2, this.length), this[xe] << 8 | this[xe + 1] }, g.prototype.readUint32LE = g.prototype.readUInt32LE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 4, this.length), (this[xe] | this[xe + 1] << 8 | this[xe + 2] << 16) + this[xe + 3] * 16777216 }, g.prototype.readUint32BE = g.prototype.readUInt32BE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 4, this.length), this[xe] * 16777216 + (this[xe + 1] << 16 | this[xe + 2] << 8 | this[xe + 3]) }, g.prototype.readBigUInt64LE = gt(function (xe) { xe = xe >>> 0, je(xe, "offset"); const Ce = this[xe], Ne = this[xe + 7]; (Ce === void 0 || Ne === void 0) && nt(xe, this.length - 8); const Ye = Ce + this[++xe] * 2 ** 8 + this[++xe] * 2 ** 16 + this[++xe] * 2 ** 24, Re = this[++xe] + this[++xe] * 2 ** 8 + this[++xe] * 2 ** 16 + Ne * 2 ** 24; return BigInt(Ye) + (BigInt(Re) << BigInt(32)) }), g.prototype.readBigUInt64BE = gt(function (xe) { xe = xe >>> 0, je(xe, "offset"); const Ce = this[xe], Ne = this[xe + 7]; (Ce === void 0 || Ne === void 0) && nt(xe, this.length - 8); const Ye = Ce * 2 ** 24 + this[++xe] * 2 ** 16 + this[++xe] * 2 ** 8 + this[++xe], Re = this[++xe] * 2 ** 24 + this[++xe] * 2 ** 16 + this[++xe] * 2 ** 8 + Ne; return (BigInt(Ye) << BigInt(32)) + BigInt(Re) }), g.prototype.readIntLE = function (xe, Ce, Ne) { xe = xe >>> 0, Ce = Ce >>> 0, Ne || _t(xe, Ce, this.length); let Ye = this[xe], Re = 1, Pe = 0; for (; ++Pe < Ce && (Re *= 256);)Ye += this[xe + Pe] * Re; return Re *= 128, Ye >= Re && (Ye -= Math.pow(2, 8 * Ce)), Ye }, g.prototype.readIntBE = function (xe, Ce, Ne) { xe = xe >>> 0, Ce = Ce >>> 0, Ne || _t(xe, Ce, this.length); let Ye = Ce, Re = 1, Pe = this[xe + --Ye]; for (; Ye > 0 && (Re *= 256);)Pe += this[xe + --Ye] * Re; return Re *= 128, Pe >= Re && (Pe -= Math.pow(2, 8 * Ce)), Pe }, g.prototype.readInt8 = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 1, this.length), this[xe] & 128 ? (255 - this[xe] + 1) * -1 : this[xe] }, g.prototype.readInt16LE = function (xe, Ce) { xe = xe >>> 0, Ce || _t(xe, 2, this.length); const Ne = this[xe] | this[xe + 1] << 8; return Ne & 32768 ? Ne | 4294901760 : Ne }, g.prototype.readInt16BE = function (xe, Ce) { xe = xe >>> 0, Ce || _t(xe, 2, this.length); const Ne = this[xe + 1] | this[xe] << 8; return Ne & 32768 ? Ne | 4294901760 : Ne }, g.prototype.readInt32LE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 4, this.length), this[xe] | this[xe + 1] << 8 | this[xe + 2] << 16 | this[xe + 3] << 24 }, g.prototype.readInt32BE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 4, this.length), this[xe] << 24 | this[xe + 1] << 16 | this[xe + 2] << 8 | this[xe + 3] }, g.prototype.readBigInt64LE = gt(function (xe) { xe = xe >>> 0, je(xe, "offset"); const Ce = this[xe], Ne = this[xe + 7]; (Ce === void 0 || Ne === void 0) && nt(xe, this.length - 8); const Ye = this[xe + 4] + this[xe + 5] * 2 ** 8 + this[xe + 6] * 2 ** 16 + (Ne << 24); return (BigInt(Ye) << BigInt(32)) + BigInt(Ce + this[++xe] * 2 ** 8 + this[++xe] * 2 ** 16 + this[++xe] * 2 ** 24) }), g.prototype.readBigInt64BE = gt(function (xe) { xe = xe >>> 0, je(xe, "offset"); const Ce = this[xe], Ne = this[xe + 7]; (Ce === void 0 || Ne === void 0) && nt(xe, this.length - 8); const Ye = (Ce << 24) + this[++xe] * 2 ** 16 + this[++xe] * 2 ** 8 + this[++xe]; return (BigInt(Ye) << BigInt(32)) + BigInt(this[++xe] * 2 ** 24 + this[++xe] * 2 ** 16 + this[++xe] * 2 ** 8 + Ne) }), g.prototype.readFloatLE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 4, this.length), ue.read(this, xe, !0, 23, 4) }, g.prototype.readFloatBE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 4, this.length), ue.read(this, xe, !1, 23, 4) }, g.prototype.readDoubleLE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 8, this.length), ue.read(this, xe, !0, 52, 8) }, g.prototype.readDoubleBE = function (xe, Ce) { return xe = xe >>> 0, Ce || _t(xe, 8, this.length), ue.read(this, xe, !1, 52, 8) }; function zt(Le, xe, Ce, Ne, Ye, Re) { if (!g.isBuffer(Le)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (xe > Ye || xe < Re) throw new RangeError('"value" argument is out of bounds'); if (Ce + Ne > Le.length) throw new RangeError("Index out of range") } g.prototype.writeUintLE = g.prototype.writeUIntLE = function (xe, Ce, Ne, Ye) { if (xe = +xe, Ce = Ce >>> 0, Ne = Ne >>> 0, !Ye) { const qe = Math.pow(2, 8 * Ne) - 1; zt(this, xe, Ce, Ne, qe, 0) } let Re = 1, Pe = 0; for (this[Ce] = xe & 255; ++Pe < Ne && (Re *= 256);)this[Ce + Pe] = xe / Re & 255; return Ce + Ne }, g.prototype.writeUintBE = g.prototype.writeUIntBE = function (xe, Ce, Ne, Ye) { if (xe = +xe, Ce = Ce >>> 0, Ne = Ne >>> 0, !Ye) { const qe = Math.pow(2, 8 * Ne) - 1; zt(this, xe, Ce, Ne, qe, 0) } let Re = Ne - 1, Pe = 1; for (this[Ce + Re] = xe & 255; --Re >= 0 && (Pe *= 256);)this[Ce + Re] = xe / Pe & 255; return Ce + Ne }, g.prototype.writeUint8 = g.prototype.writeUInt8 = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 1, 255, 0), this[Ce] = xe & 255, Ce + 1 }, g.prototype.writeUint16LE = g.prototype.writeUInt16LE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 2, 65535, 0), this[Ce] = xe & 255, this[Ce + 1] = xe >>> 8, Ce + 2 }, g.prototype.writeUint16BE = g.prototype.writeUInt16BE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 2, 65535, 0), this[Ce] = xe >>> 8, this[Ce + 1] = xe & 255, Ce + 2 }, g.prototype.writeUint32LE = g.prototype.writeUInt32LE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 4, 4294967295, 0), this[Ce + 3] = xe >>> 24, this[Ce + 2] = xe >>> 16, this[Ce + 1] = xe >>> 8, this[Ce] = xe & 255, Ce + 4 }, g.prototype.writeUint32BE = g.prototype.writeUInt32BE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 4, 4294967295, 0), this[Ce] = xe >>> 24, this[Ce + 1] = xe >>> 16, this[Ce + 2] = xe >>> 8, this[Ce + 3] = xe & 255, Ce + 4 }; function bt(Le, xe, Ce, Ne, Ye) { Oe(xe, Ne, Ye, Le, Ce, 7); let Re = Number(xe & BigInt(4294967295)); Le[Ce++] = Re, Re = Re >> 8, Le[Ce++] = Re, Re = Re >> 8, Le[Ce++] = Re, Re = Re >> 8, Le[Ce++] = Re; let Pe = Number(xe >> BigInt(32) & BigInt(4294967295)); return Le[Ce++] = Pe, Pe = Pe >> 8, Le[Ce++] = Pe, Pe = Pe >> 8, Le[Ce++] = Pe, Pe = Pe >> 8, Le[Ce++] = Pe, Ce } function We(Le, xe, Ce, Ne, Ye) { Oe(xe, Ne, Ye, Le, Ce, 7); let Re = Number(xe & BigInt(4294967295)); Le[Ce + 7] = Re, Re = Re >> 8, Le[Ce + 6] = Re, Re = Re >> 8, Le[Ce + 5] = Re, Re = Re >> 8, Le[Ce + 4] = Re; let Pe = Number(xe >> BigInt(32) & BigInt(4294967295)); return Le[Ce + 3] = Pe, Pe = Pe >> 8, Le[Ce + 2] = Pe, Pe = Pe >> 8, Le[Ce + 1] = Pe, Pe = Pe >> 8, Le[Ce] = Pe, Ce + 8 } g.prototype.writeBigUInt64LE = gt(function (xe, Ce = 0) { return bt(this, xe, Ce, BigInt(0), BigInt("0xffffffffffffffff")) }), g.prototype.writeBigUInt64BE = gt(function (xe, Ce = 0) { return We(this, xe, Ce, BigInt(0), BigInt("0xffffffffffffffff")) }), g.prototype.writeIntLE = function (xe, Ce, Ne, Ye) { if (xe = +xe, Ce = Ce >>> 0, !Ye) { const be = Math.pow(2, 8 * Ne - 1); zt(this, xe, Ce, Ne, be - 1, -be) } let Re = 0, Pe = 1, qe = 0; for (this[Ce] = xe & 255; ++Re < Ne && (Pe *= 256);)xe < 0 && qe === 0 && this[Ce + Re - 1] !== 0 && (qe = 1), this[Ce + Re] = (xe / Pe >> 0) - qe & 255; return Ce + Ne }, g.prototype.writeIntBE = function (xe, Ce, Ne, Ye) { if (xe = +xe, Ce = Ce >>> 0, !Ye) { const be = Math.pow(2, 8 * Ne - 1); zt(this, xe, Ce, Ne, be - 1, -be) } let Re = Ne - 1, Pe = 1, qe = 0; for (this[Ce + Re] = xe & 255; --Re >= 0 && (Pe *= 256);)xe < 0 && qe === 0 && this[Ce + Re + 1] !== 0 && (qe = 1), this[Ce + Re] = (xe / Pe >> 0) - qe & 255; return Ce + Ne }, g.prototype.writeInt8 = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 1, 127, -128), xe < 0 && (xe = 255 + xe + 1), this[Ce] = xe & 255, Ce + 1 }, g.prototype.writeInt16LE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 2, 32767, -32768), this[Ce] = xe & 255, this[Ce + 1] = xe >>> 8, Ce + 2 }, g.prototype.writeInt16BE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 2, 32767, -32768), this[Ce] = xe >>> 8, this[Ce + 1] = xe & 255, Ce + 2 }, g.prototype.writeInt32LE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 4, 2147483647, -2147483648), this[Ce] = xe & 255, this[Ce + 1] = xe >>> 8, this[Ce + 2] = xe >>> 16, this[Ce + 3] = xe >>> 24, Ce + 4 }, g.prototype.writeInt32BE = function (xe, Ce, Ne) { return xe = +xe, Ce = Ce >>> 0, Ne || zt(this, xe, Ce, 4, 2147483647, -2147483648), xe < 0 && (xe = 4294967295 + xe + 1), this[Ce] = xe >>> 24, this[Ce + 1] = xe >>> 16, this[Ce + 2] = xe >>> 8, this[Ce + 3] = xe & 255, Ce + 4 }, g.prototype.writeBigInt64LE = gt(function (xe, Ce = 0) { return bt(this, xe, Ce, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }), g.prototype.writeBigInt64BE = gt(function (xe, Ce = 0) { return We(this, xe, Ce, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }); function Ge(Le, xe, Ce, Ne, Ye, Re) { if (Ce + Ne > Le.length) throw new RangeError("Index out of range"); if (Ce < 0) throw new RangeError("Index out of range") } function ze(Le, xe, Ce, Ne, Ye) { return xe = +xe, Ce = Ce >>> 0, Ye || Ge(Le, xe, Ce, 4), ue.write(Le, xe, Ce, Ne, 23, 4), Ce + 4 } g.prototype.writeFloatLE = function (xe, Ce, Ne) { return ze(this, xe, Ce, !0, Ne) }, g.prototype.writeFloatBE = function (xe, Ce, Ne) { return ze(this, xe, Ce, !1, Ne) }; function Ze(Le, xe, Ce, Ne, Ye) { return xe = +xe, Ce = Ce >>> 0, Ye || Ge(Le, xe, Ce, 8), ue.write(Le, xe, Ce, Ne, 52, 8), Ce + 8 } g.prototype.writeDoubleLE = function (xe, Ce, Ne) { return Ze(this, xe, Ce, !0, Ne) }, g.prototype.writeDoubleBE = function (xe, Ce, Ne) { return Ze(this, xe, Ce, !1, Ne) }, g.prototype.copy = function (xe, Ce, Ne, Ye) { if (!g.isBuffer(xe)) throw new TypeError("argument should be a Buffer"); if (Ne || (Ne = 0), !Ye && Ye !== 0 && (Ye = this.length), Ce >= xe.length && (Ce = xe.length), Ce || (Ce = 0), Ye > 0 && Ye < Ne && (Ye = Ne), Ye === Ne || xe.length === 0 || this.length === 0) return 0; if (Ce < 0) throw new RangeError("targetStart out of bounds"); if (Ne < 0 || Ne >= this.length) throw new RangeError("Index out of range"); if (Ye < 0) throw new RangeError("sourceEnd out of bounds"); Ye > this.length && (Ye = this.length), xe.length - Ce < Ye - Ne && (Ye = xe.length - Ce + Ne); const Re = Ye - Ne; return this === xe && typeof ve.prototype.copyWithin == "function" ? this.copyWithin(Ce, Ne, Ye) : ve.prototype.set.call(xe, this.subarray(Ne, Ye), Ce), Re }, g.prototype.fill = function (xe, Ce, Ne, Ye) { if (typeof xe == "string") { if (typeof Ce == "string" ? (Ye = Ce, Ce = 0, Ne = this.length) : typeof Ne == "string" && (Ye = Ne, Ne = this.length), Ye !== void 0 && typeof Ye != "string") throw new TypeError("encoding must be a string"); if (typeof Ye == "string" && !g.isEncoding(Ye)) throw new TypeError("Unknown encoding: " + Ye); if (xe.length === 1) { const Pe = xe.charCodeAt(0); (Ye === "utf8" && Pe < 128 || Ye === "latin1") && (xe = Pe) } } else typeof xe == "number" ? xe = xe & 255 : typeof xe == "boolean" && (xe = Number(xe)); if (Ce < 0 || this.length < Ce || this.length < Ne) throw new RangeError("Out of range index"); if (Ne <= Ce) return this; Ce = Ce >>> 0, Ne = Ne === void 0 ? this.length : Ne >>> 0, xe || (xe = 0); let Re; if (typeof xe == "number") for (Re = Ce; Re < Ne; ++Re)this[Re] = xe; else { const Pe = g.isBuffer(xe) ? xe : g.from(xe, Ye), qe = Pe.length; if (qe === 0) throw new TypeError('The value "' + xe + '" is invalid for argument "value"'); for (Re = 0; Re < Ne - Ce; ++Re)this[Re + Ce] = Pe[Re % qe] } return this }; const ut = {}; function ye(Le, xe, Ce) { ut[Le] = class extends Ce { constructor() { super(), Object.defineProperty(this, "message", { value: xe.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${Le}]`, this.stack, delete this.name } get code() { return Le } set code(Ye) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: Ye, writable: !0 }) } toString() { return `${this.name} [${Le}]: ${this.message}` } } } ye("ERR_BUFFER_OUT_OF_BOUNDS", function (Le) { return Le ? `${Le} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }, RangeError), ye("ERR_INVALID_ARG_TYPE", function (Le, xe) { return `The "${Le}" argument must be of type number. Received type ${typeof xe}` }, TypeError), ye("ERR_OUT_OF_RANGE", function (Le, xe, Ce) { let Ne = `The value of "${Le}" is out of range.`, Ye = Ce; return Number.isInteger(Ce) && Math.abs(Ce) > 2 ** 32 ? Ye = ge(String(Ce)) : typeof Ce == "bigint" && (Ye = String(Ce), (Ce > BigInt(2) ** BigInt(32) || Ce < -(BigInt(2) ** BigInt(32))) && (Ye = ge(Ye)), Ye += "n"), Ne += ` It must be ${xe}. Received ${Ye}`, Ne }, RangeError); function ge(Le) { let xe = "", Ce = Le.length; const Ne = Le[0] === "-" ? 1 : 0; for (; Ce >= Ne + 4; Ce -= 3)xe = `_${Le.slice(Ce - 3, Ce)}${xe}`; return `${Le.slice(0, Ce)}${xe}` } function Ee(Le, xe, Ce) { je(xe, "offset"), (Le[xe] === void 0 || Le[xe + Ce] === void 0) && nt(xe, Le.length - (Ce + 1)) } function Oe(Le, xe, Ce, Ne, Ye, Re) { if (Le > Ce || Le < xe) { const Pe = typeof xe == "bigint" ? "n" : ""; let qe; throw xe === 0 || xe === BigInt(0) ? qe = `>= 0${Pe} and < 2${Pe} ** ${(Re + 1) * 8}${Pe}` : qe = `>= -(2${Pe} ** ${(Re + 1) * 8 - 1}${Pe}) and < 2 ** ${(Re + 1) * 8 - 1}${Pe}`, new ut.ERR_OUT_OF_RANGE("value", qe, Le) } Ee(Ne, Ye, Re) } function je(Le, xe) { if (typeof Le != "number") throw new ut.ERR_INVALID_ARG_TYPE(xe, "number", Le) } function nt(Le, xe, Ce) { throw Math.floor(Le) !== Le ? (je(Le, Ce), new ut.ERR_OUT_OF_RANGE("offset", "an integer", Le)) : xe < 0 ? new ut.ERR_BUFFER_OUT_OF_BOUNDS : new ut.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${xe}`, Le) } const Xe = /[^+/0-9A-Za-z-_]/g; function it(Le) { if (Le = Le.split("=")[0], Le = Le.trim().replace(Xe, ""), Le.length < 2) return ""; for (; Le.length % 4 !== 0;)Le = Le + "="; return Le } function Tt(Le, xe) { xe = xe || 1 / 0; let Ce; const Ne = Le.length; let Ye = null; const Re = []; for (let Pe = 0; Pe < Ne; ++Pe) { if (Ce = Le.charCodeAt(Pe), Ce > 55295 && Ce < 57344) { if (!Ye) { if (Ce > 56319) { (xe -= 3) > -1 && Re.push(239, 191, 189); continue } else if (Pe + 1 === Ne) { (xe -= 3) > -1 && Re.push(239, 191, 189); continue } Ye = Ce; continue } if (Ce < 56320) { (xe -= 3) > -1 && Re.push(239, 191, 189), Ye = Ce; continue } Ce = (Ye - 55296 << 10 | Ce - 56320) + 65536 } else Ye && (xe -= 3) > -1 && Re.push(239, 191, 189); if (Ye = null, Ce < 128) { if ((xe -= 1) < 0) break; Re.push(Ce) } else if (Ce < 2048) { if ((xe -= 2) < 0) break; Re.push(Ce >> 6 | 192, Ce & 63 | 128) } else if (Ce < 65536) { if ((xe -= 3) < 0) break; Re.push(Ce >> 12 | 224, Ce >> 6 & 63 | 128, Ce & 63 | 128) } else if (Ce < 1114112) { if ((xe -= 4) < 0) break; Re.push(Ce >> 18 | 240, Ce >> 12 & 63 | 128, Ce >> 6 & 63 | 128, Ce & 63 | 128) } else throw new Error("Invalid code point") } return Re } function tt(Le) { const xe = []; for (let Ce = 0; Ce < Le.length; ++Ce)xe.push(Le.charCodeAt(Ce) & 255); return xe } function yt(Le, xe) { let Ce, Ne, Ye; const Re = []; for (let Pe = 0; Pe < Le.length && !((xe -= 2) < 0); ++Pe)Ce = Le.charCodeAt(Pe), Ne = Ce >> 8, Ye = Ce % 256, Re.push(Ye), Re.push(Ne); return Re } function kt(Le) { return le.toByteArray(it(Le)) } function wt(Le, xe, Ce, Ne) { let Ye; for (Ye = 0; Ye < Ne && !(Ye + Ce >= xe.length || Ye >= Le.length); ++Ye)xe[Ye + Ce] = Le[Ye]; return Ye } function Mt(Le, xe) { return Le instanceof xe || Le != null && Le.constructor != null && Le.constructor.name != null && Le.constructor.name === xe.name } function tr(Le) { return Le !== Le } const St = function () { const Le = "0123456789abcdef", xe = new Array(256); for (let Ce = 0; Ce < 16; ++Ce) { const Ne = Ce * 16; for (let Ye = 0; Ye < 16; ++Ye)xe[Ne + Ye] = Le[Ce] + Le[Ye] } return xe }(); function gt(Le) { return typeof BigInt > "u" ? rr : Le } function rr() { throw new Error("BigInt not supported") } })(l); const ae = l.Buffer; o.Blob = l.Blob, o.BlobOptions = l.BlobOptions, o.Buffer = l.Buffer, o.File = l.File, o.FileOptions = l.FileOptions, o.INSPECT_MAX_BYTES = l.INSPECT_MAX_BYTES, o.SlowBuffer = l.SlowBuffer, o.TranscodeEncoding = l.TranscodeEncoding, o.atob = l.atob, o.btoa = l.btoa, o.constants = l.constants, o.default = ae, o.isAscii = l.isAscii, o.isUtf8 = l.isUtf8, o.kMaxLength = l.kMaxLength, o.kStringMaxLength = l.kStringMaxLength, o.resolveObjectURL = l.resolveObjectURL, o.transcode = l.transcode
  }(dist)), dist
}/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var hasRequiredSafeBuffer$1; function requireSafeBuffer$1() { return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function (o, l) { var u = requireDist$2(), f = u.Buffer; function p(m, v) { for (var I in m) v[I] = m[I] } f.from && f.alloc && f.allocUnsafe && f.allocUnsafeSlow ? o.exports = u : (p(u, l), l.Buffer = d); function d(m, v, I) { return f(m, v, I) } d.prototype = Object.create(f.prototype), p(f, d), d.from = function (m, v, I) { if (typeof m == "number") throw new TypeError("Argument must not be a number"); return f(m, v, I) }, d.alloc = function (m, v, I) { if (typeof m != "number") throw new TypeError("Argument must be a number"); var F = f(m); return v !== void 0 ? typeof I == "string" ? F.fill(v, I) : F.fill(v) : F.fill(0), F }, d.allocUnsafe = function (m) { if (typeof m != "number") throw new TypeError("Argument must be a number"); return f(m) }, d.allocUnsafeSlow = function (m) { if (typeof m != "number") throw new TypeError("Argument must be a number"); return u.SlowBuffer(m) } }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports } var hasRequiredBrowser$b; function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$c.exports; hasRequiredBrowser$b = 1; var o = 65536, l = 4294967295; function u() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
  } var f = requireSafeBuffer$1().Buffer, p = commonjsGlobal.crypto || commonjsGlobal.msCrypto; p && p.getRandomValues ? browser$c.exports = d : browser$c.exports = u; function d(m, v) { if (m > l) throw new RangeError("requested too many random bytes"); var I = f.allocUnsafe(m); if (m > 0) if (m > o) for (var F = 0; F < m; F += o)p.getRandomValues(I.slice(F, F + o)); else p.getRandomValues(I); return typeof v == "function" ? process$1.nextTick(function () { v(null, I) }) : I } return browser$c.exports
} var inherits_browser = { exports: {} }, hasRequiredInherits_browser; function requireInherits_browser() { return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function (l, u) { u && (l.super_ = u, l.prototype = Object.create(u.prototype, { constructor: { value: l, enumerable: !1, writable: !0, configurable: !0 } })) } : inherits_browser.exports = function (l, u) { if (u) { l.super_ = u; var f = function () { }; f.prototype = u.prototype, l.prototype = new f, l.prototype.constructor = l } }), inherits_browser.exports } var events = { exports: {} }, hasRequiredEvents; function requireEvents() { if (hasRequiredEvents) return events.exports; hasRequiredEvents = 1; var o = typeof Reflect == "object" ? Reflect : null, l = o && typeof o.apply == "function" ? o.apply : function (he, pe, ve) { return Function.prototype.apply.call(he, pe, ve) }, u; o && typeof o.ownKeys == "function" ? u = o.ownKeys : Object.getOwnPropertySymbols ? u = function (he) { return Object.getOwnPropertyNames(he).concat(Object.getOwnPropertySymbols(he)) } : u = function (he) { return Object.getOwnPropertyNames(he) }; function f(ue) { console && console.warn && console.warn(ue) } var p = Number.isNaN || function (he) { return he !== he }; function d() { d.init.call(this) } events.exports = d, events.exports.once = ae, d.EventEmitter = d, d.prototype._events = void 0, d.prototype._eventsCount = 0, d.prototype._maxListeners = void 0; var m = 10; function v(ue) { if (typeof ue != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof ue) } Object.defineProperty(d, "defaultMaxListeners", { enumerable: !0, get: function () { return m }, set: function (ue) { if (typeof ue != "number" || ue < 0 || p(ue)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + ue + "."); m = ue } }), d.init = function () { (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, d.prototype.setMaxListeners = function (he) { if (typeof he != "number" || he < 0 || p(he)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + he + "."); return this._maxListeners = he, this }; function I(ue) { return ue._maxListeners === void 0 ? d.defaultMaxListeners : ue._maxListeners } d.prototype.getMaxListeners = function () { return I(this) }, d.prototype.emit = function (he) { for (var pe = [], ve = 1; ve < arguments.length; ve++)pe.push(arguments[ve]); var _e = he === "error", Se = this._events; if (Se !== void 0) _e = _e && Se.error === void 0; else if (!_e) return !1; if (_e) { var $e; if (pe.length > 0 && ($e = pe[0]), $e instanceof Error) throw $e; var ie = new Error("Unhandled error." + ($e ? " (" + $e.message + ")" : "")); throw ie.context = $e, ie } var g = Se[he]; if (g === void 0) return !1; if (typeof g == "function") l(g, this, pe); else for (var P = g.length, U = re(g, P), ve = 0; ve < P; ++ve)l(U[ve], this, pe); return !0 }; function F(ue, he, pe, ve) { var _e, Se, $e; if (v(pe), Se = ue._events, Se === void 0 ? (Se = ue._events = Object.create(null), ue._eventsCount = 0) : (Se.newListener !== void 0 && (ue.emit("newListener", he, pe.listener ? pe.listener : pe), Se = ue._events), $e = Se[he]), $e === void 0) $e = Se[he] = pe, ++ue._eventsCount; else if (typeof $e == "function" ? $e = Se[he] = ve ? [pe, $e] : [$e, pe] : ve ? $e.unshift(pe) : $e.push(pe), _e = I(ue), _e > 0 && $e.length > _e && !$e.warned) { $e.warned = !0; var ie = new Error("Possible EventEmitter memory leak detected. " + $e.length + " " + String(he) + " listeners added. Use emitter.setMaxListeners() to increase limit"); ie.name = "MaxListenersExceededWarning", ie.emitter = ue, ie.type = he, ie.count = $e.length, f(ie) } return ue } d.prototype.addListener = function (he, pe) { return F(this, he, pe, !1) }, d.prototype.on = d.prototype.addListener, d.prototype.prependListener = function (he, pe) { return F(this, he, pe, !0) }; function B() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function W(ue, he, pe) { var ve = { fired: !1, wrapFn: void 0, target: ue, type: he, listener: pe }, _e = B.bind(ve); return _e.listener = pe, ve.wrapFn = _e, _e } d.prototype.once = function (he, pe) { return v(pe), this.on(he, W(this, he, pe)), this }, d.prototype.prependOnceListener = function (he, pe) { return v(pe), this.prependListener(he, W(this, he, pe)), this }, d.prototype.removeListener = function (he, pe) { var ve, _e, Se, $e, ie; if (v(pe), _e = this._events, _e === void 0) return this; if (ve = _e[he], ve === void 0) return this; if (ve === pe || ve.listener === pe) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete _e[he], _e.removeListener && this.emit("removeListener", he, ve.listener || pe)); else if (typeof ve != "function") { for (Se = -1, $e = ve.length - 1; $e >= 0; $e--)if (ve[$e] === pe || ve[$e].listener === pe) { ie = ve[$e].listener, Se = $e; break } if (Se < 0) return this; Se === 0 ? ve.shift() : ne(ve, Se), ve.length === 1 && (_e[he] = ve[0]), _e.removeListener !== void 0 && this.emit("removeListener", he, ie || pe) } return this }, d.prototype.off = d.prototype.removeListener, d.prototype.removeAllListeners = function (he) { var pe, ve, _e; if (ve = this._events, ve === void 0) return this; if (ve.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : ve[he] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete ve[he]), this; if (arguments.length === 0) { var Se = Object.keys(ve), $e; for (_e = 0; _e < Se.length; ++_e)$e = Se[_e], $e !== "removeListener" && this.removeAllListeners($e); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if (pe = ve[he], typeof pe == "function") this.removeListener(he, pe); else if (pe !== void 0) for (_e = pe.length - 1; _e >= 0; _e--)this.removeListener(he, pe[_e]); return this }; function Z(ue, he, pe) { var ve = ue._events; if (ve === void 0) return []; var _e = ve[he]; return _e === void 0 ? [] : typeof _e == "function" ? pe ? [_e.listener || _e] : [_e] : pe ? oe(_e) : re(_e, _e.length) } d.prototype.listeners = function (he) { return Z(this, he, !0) }, d.prototype.rawListeners = function (he) { return Z(this, he, !1) }, d.listenerCount = function (ue, he) { return typeof ue.listenerCount == "function" ? ue.listenerCount(he) : Q.call(ue, he) }, d.prototype.listenerCount = Q; function Q(ue) { var he = this._events; if (he !== void 0) { var pe = he[ue]; if (typeof pe == "function") return 1; if (pe !== void 0) return pe.length } return 0 } d.prototype.eventNames = function () { return this._eventsCount > 0 ? u(this._events) : [] }; function re(ue, he) { for (var pe = new Array(he), ve = 0; ve < he; ++ve)pe[ve] = ue[ve]; return pe } function ne(ue, he) { for (; he + 1 < ue.length; he++)ue[he] = ue[he + 1]; ue.pop() } function oe(ue) { for (var he = new Array(ue.length), pe = 0; pe < he.length; ++pe)he[pe] = ue[pe].listener || ue[pe]; return he } function ae(ue, he) { return new Promise(function (pe, ve) { function _e($e) { ue.removeListener(he, Se), ve($e) } function Se() { typeof ue.removeListener == "function" && ue.removeListener("error", _e), pe([].slice.call(arguments)) } le(ue, he, Se, { once: !0 }), he !== "error" && se(ue, _e, { once: !0 }) }) } function se(ue, he, pe) { typeof ue.on == "function" && le(ue, "error", he, pe) } function le(ue, he, pe, ve) { if (typeof ue.on == "function") ve.once ? ue.once(he, pe) : ue.on(he, pe); else if (typeof ue.addEventListener == "function") ue.addEventListener(he, function _e(Se) { ve.once && ue.removeEventListener(he, _e), pe(Se) }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof ue) } return events.exports } var streamBrowser$1, hasRequiredStreamBrowser$1; function requireStreamBrowser$1() { return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1 } var util$1 = {}, types = {}, shams$1, hasRequiredShams$1; function requireShams$1() { return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function () { if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1; if (typeof Symbol.iterator == "symbol") return !0; var l = {}, u = Symbol("test"), f = Object(u); if (typeof u == "string" || Object.prototype.toString.call(u) !== "[object Symbol]" || Object.prototype.toString.call(f) !== "[object Symbol]") return !1; var p = 42; l[u] = p; for (u in l) return !1; if (typeof Object.keys == "function" && Object.keys(l).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(l).length !== 0) return !1; var d = Object.getOwnPropertySymbols(l); if (d.length !== 1 || d[0] !== u || !Object.prototype.propertyIsEnumerable.call(l, u)) return !1; if (typeof Object.getOwnPropertyDescriptor == "function") { var m = Object.getOwnPropertyDescriptor(l, u); if (m.value !== p || m.enumerable !== !0) return !1 } return !0 }), shams$1 } var shams, hasRequiredShams; function requireShams() { if (hasRequiredShams) return shams; hasRequiredShams = 1; var o = requireShams$1(); return shams = function () { return o() && !!Symbol.toStringTag }, shams } var esErrors, hasRequiredEsErrors; function requireEsErrors() { return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors } var _eval, hasRequired_eval; function require_eval() { return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval } var range$1, hasRequiredRange$1; function requireRange$1() { return hasRequiredRange$1 || (hasRequiredRange$1 = 1, range$1 = RangeError), range$1 } var ref, hasRequiredRef; function requireRef() { return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref } var syntax, hasRequiredSyntax; function requireSyntax() { return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax } var type, hasRequiredType; function requireType() { return hasRequiredType || (hasRequiredType = 1, type = TypeError), type } var uri, hasRequiredUri; function requireUri() { return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri } var hasSymbols, hasRequiredHasSymbols; function requireHasSymbols() { if (hasRequiredHasSymbols) return hasSymbols; hasRequiredHasSymbols = 1; var o = typeof Symbol < "u" && Symbol, l = requireShams$1(); return hasSymbols = function () { return typeof o != "function" || typeof Symbol != "function" || typeof o("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : l() }, hasSymbols } var hasProto, hasRequiredHasProto; function requireHasProto() { if (hasRequiredHasProto) return hasProto; hasRequiredHasProto = 1; var o = { __proto__: null, foo: {} }, l = Object; return hasProto = function () { return { __proto__: o }.foo === o.foo && !(o instanceof l) }, hasProto } var implementation, hasRequiredImplementation; function requireImplementation() { if (hasRequiredImplementation) return implementation; hasRequiredImplementation = 1; var o = "Function.prototype.bind called on incompatible ", l = Object.prototype.toString, u = Math.max, f = "[object Function]", p = function (I, F) { for (var B = [], W = 0; W < I.length; W += 1)B[W] = I[W]; for (var Z = 0; Z < F.length; Z += 1)B[Z + I.length] = F[Z]; return B }, d = function (I, F) { for (var B = [], W = F, Z = 0; W < I.length; W += 1, Z += 1)B[Z] = I[W]; return B }, m = function (v, I) { for (var F = "", B = 0; B < v.length; B += 1)F += v[B], B + 1 < v.length && (F += I); return F }; return implementation = function (I) { var F = this; if (typeof F != "function" || l.apply(F) !== f) throw new TypeError(o + F); for (var B = d(arguments, 1), W, Z = function () { if (this instanceof W) { var ae = F.apply(this, p(B, arguments)); return Object(ae) === ae ? ae : this } return F.apply(I, p(B, arguments)) }, Q = u(0, F.length - B.length), re = [], ne = 0; ne < Q; ne++)re[ne] = "$" + ne; if (W = Function("binder", "return function (" + m(re, ",") + "){ return binder.apply(this,arguments); }")(Z), F.prototype) { var oe = function () { }; oe.prototype = F.prototype, W.prototype = new oe, oe.prototype = null } return W }, implementation } var functionBind, hasRequiredFunctionBind; function requireFunctionBind() { if (hasRequiredFunctionBind) return functionBind; hasRequiredFunctionBind = 1; var o = requireImplementation(); return functionBind = Function.prototype.bind || o, functionBind } var hasown, hasRequiredHasown; function requireHasown() { if (hasRequiredHasown) return hasown; hasRequiredHasown = 1; var o = Function.prototype.call, l = Object.prototype.hasOwnProperty, u = requireFunctionBind(); return hasown = u.call(o, l), hasown } var getIntrinsic, hasRequiredGetIntrinsic; function requireGetIntrinsic() { if (hasRequiredGetIntrinsic) return getIntrinsic; hasRequiredGetIntrinsic = 1; var o, l = requireEsErrors(), u = require_eval(), f = requireRange$1(), p = requireRef(), d = requireSyntax(), m = requireType(), v = requireUri(), I = Function, F = function (te) { try { return I('"use strict"; return (' + te + ").constructor;")() } catch { } }, B = Object.getOwnPropertyDescriptor; if (B) try { B({}, "") } catch { B = null } var W = function () { throw new m }, Z = B ? function () { try { return arguments.callee, W } catch { try { return B(arguments, "callee").get } catch { return W } } }() : W, Q = requireHasSymbols()(), re = requireHasProto()(), ne = Object.getPrototypeOf || (re ? function (te) { return te.__proto__ } : null), oe = {}, ae = typeof Uint8Array > "u" || !ne ? o : ne(Uint8Array), se = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? o : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? o : ArrayBuffer, "%ArrayIteratorPrototype%": Q && ne ? ne([][Symbol.iterator]()) : o, "%AsyncFromSyncIteratorPrototype%": o, "%AsyncFunction%": oe, "%AsyncGenerator%": oe, "%AsyncGeneratorFunction%": oe, "%AsyncIteratorPrototype%": oe, "%Atomics%": typeof Atomics > "u" ? o : Atomics, "%BigInt%": typeof BigInt > "u" ? o : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? o : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? o : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? o : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": l, "%eval%": eval, "%EvalError%": u, "%Float32Array%": typeof Float32Array > "u" ? o : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? o : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? o : FinalizationRegistry, "%Function%": I, "%GeneratorFunction%": oe, "%Int8Array%": typeof Int8Array > "u" ? o : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? o : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? o : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": Q && ne ? ne(ne([][Symbol.iterator]())) : o, "%JSON%": typeof JSON == "object" ? JSON : o, "%Map%": typeof Map > "u" ? o : Map, "%MapIteratorPrototype%": typeof Map > "u" || !Q || !ne ? o : ne(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? o : Promise, "%Proxy%": typeof Proxy > "u" ? o : Proxy, "%RangeError%": f, "%ReferenceError%": p, "%Reflect%": typeof Reflect > "u" ? o : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? o : Set, "%SetIteratorPrototype%": typeof Set > "u" || !Q || !ne ? o : ne(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? o : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": Q && ne ? ne(""[Symbol.iterator]()) : o, "%Symbol%": Q ? Symbol : o, "%SyntaxError%": d, "%ThrowTypeError%": Z, "%TypedArray%": ae, "%TypeError%": m, "%Uint8Array%": typeof Uint8Array > "u" ? o : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? o : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? o : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? o : Uint32Array, "%URIError%": v, "%WeakMap%": typeof WeakMap > "u" ? o : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? o : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? o : WeakSet }; if (ne) try { null.error } catch (te) { var le = ne(ne(te)); se["%Error.prototype%"] = le } var ue = function te(ee) { var G; if (ee === "%AsyncFunction%") G = F("async function () {}"); else if (ee === "%GeneratorFunction%") G = F("function* () {}"); else if (ee === "%AsyncGeneratorFunction%") G = F("async function* () {}"); else if (ee === "%AsyncGenerator%") { var y = te("%AsyncGeneratorFunction%"); y && (G = y.prototype) } else if (ee === "%AsyncIteratorPrototype%") { var X = te("%AsyncGenerator%"); X && ne && (G = ne(X.prototype)) } return se[ee] = G, G }, he = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, pe = requireFunctionBind(), ve = requireHasown(), _e = pe.call(Function.call, Array.prototype.concat), Se = pe.call(Function.apply, Array.prototype.splice), $e = pe.call(Function.call, String.prototype.replace), ie = pe.call(Function.call, String.prototype.slice), g = pe.call(Function.call, RegExp.prototype.exec), P = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, U = /\\(\\)?/g, K = function (ee) { var G = ie(ee, 0, 1), y = ie(ee, -1); if (G === "%" && y !== "%") throw new d("invalid intrinsic syntax, expected closing `%`"); if (y === "%" && G !== "%") throw new d("invalid intrinsic syntax, expected opening `%`"); var X = []; return $e(ee, P, function (ce, me, Ae, Ie) { X[X.length] = Ae ? $e(Ie, U, "$1") : me || ce }), X }, Y = function (ee, G) { var y = ee, X; if (ve(he, y) && (X = he[y], y = "%" + X[0] + "%"), ve(se, y)) { var ce = se[y]; if (ce === oe && (ce = ue(y)), typeof ce > "u" && !G) throw new m("intrinsic " + ee + " exists, but is not available. Please file an issue!"); return { alias: X, name: y, value: ce } } throw new d("intrinsic " + ee + " does not exist!") }; return getIntrinsic = function (ee, G) { if (typeof ee != "string" || ee.length === 0) throw new m("intrinsic name must be a non-empty string"); if (arguments.length > 1 && typeof G != "boolean") throw new m('"allowMissing" argument must be a boolean'); if (g(/^%?[^%]*%?$/, ee) === null) throw new d("`%` may not be present anywhere but at the beginning and end of the intrinsic name"); var y = K(ee), X = y.length > 0 ? y[0] : "", ce = Y("%" + X + "%", G), me = ce.name, Ae = ce.value, Ie = !1, Be = ce.alias; Be && (X = Be[0], Se(y, _e([0, 1], Be))); for (var Me = 1, De = !0; Me < y.length; Me += 1) { var Ue = y[Me], Ke = ie(Ue, 0, 1), Ve = ie(Ue, -1); if ((Ke === '"' || Ke === "'" || Ke === "`" || Ve === '"' || Ve === "'" || Ve === "`") && Ke !== Ve) throw new d("property names with quotes must have matching quotes"); if ((Ue === "constructor" || !De) && (Ie = !0), X += "." + Ue, me = "%" + X + "%", ve(se, me)) Ae = se[me]; else if (Ae != null) { if (!(Ue in Ae)) { if (!G) throw new m("base intrinsic for " + ee + " exists, but the property is not available."); return } if (B && Me + 1 >= y.length) { var ke = B(Ae, Ue); De = !!ke, De && "get" in ke && !("originalValue" in ke.get) ? Ae = ke.get : Ae = Ae[Ue] } else De = ve(Ae, Ue), Ae = Ae[Ue]; De && !Ie && (se[me] = Ae) } } return Ae }, getIntrinsic } var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty; function requireEsDefineProperty() { if (hasRequiredEsDefineProperty) return esDefineProperty; hasRequiredEsDefineProperty = 1; var o = requireGetIntrinsic(), l = o("%Object.defineProperty%", !0) || !1; if (l) try { l({}, "a", { value: 1 }) } catch { l = !1 } return esDefineProperty = l, esDefineProperty } var gopd, hasRequiredGopd; function requireGopd() { if (hasRequiredGopd) return gopd; hasRequiredGopd = 1; var o = requireGetIntrinsic(), l = o("%Object.getOwnPropertyDescriptor%", !0); if (l) try { l([], "length") } catch { l = null } return gopd = l, gopd } var defineDataProperty, hasRequiredDefineDataProperty; function requireDefineDataProperty() { if (hasRequiredDefineDataProperty) return defineDataProperty; hasRequiredDefineDataProperty = 1; var o = requireEsDefineProperty(), l = requireSyntax(), u = requireType(), f = requireGopd(); return defineDataProperty = function (d, m, v) { if (!d || typeof d != "object" && typeof d != "function") throw new u("`obj` must be an object or a function`"); if (typeof m != "string" && typeof m != "symbol") throw new u("`property` must be a string or a symbol`"); if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new u("`nonEnumerable`, if provided, must be a boolean or null"); if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new u("`nonWritable`, if provided, must be a boolean or null"); if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new u("`nonConfigurable`, if provided, must be a boolean or null"); if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new u("`loose`, if provided, must be a boolean"); var I = arguments.length > 3 ? arguments[3] : null, F = arguments.length > 4 ? arguments[4] : null, B = arguments.length > 5 ? arguments[5] : null, W = arguments.length > 6 ? arguments[6] : !1, Z = !!f && f(d, m); if (o) o(d, m, { configurable: B === null && Z ? Z.configurable : !B, enumerable: I === null && Z ? Z.enumerable : !I, value: v, writable: F === null && Z ? Z.writable : !F }); else if (W || !I && !F && !B) d[m] = v; else throw new l("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.") }, defineDataProperty } var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors; function requireHasPropertyDescriptors() { if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1; hasRequiredHasPropertyDescriptors = 1; var o = requireEsDefineProperty(), l = function () { return !!o }; return l.hasArrayLengthDefineBug = function () { if (!o) return null; try { return o([], "length", { value: 1 }).length !== 1 } catch { return !0 } }, hasPropertyDescriptors_1 = l, hasPropertyDescriptors_1 } var setFunctionLength, hasRequiredSetFunctionLength; function requireSetFunctionLength() { if (hasRequiredSetFunctionLength) return setFunctionLength; hasRequiredSetFunctionLength = 1; var o = requireGetIntrinsic(), l = requireDefineDataProperty(), u = requireHasPropertyDescriptors()(), f = requireGopd(), p = requireType(), d = o("%Math.floor%"); return setFunctionLength = function (v, I) { if (typeof v != "function") throw new p("`fn` is not a function"); if (typeof I != "number" || I < 0 || I > 4294967295 || d(I) !== I) throw new p("`length` must be a positive 32-bit integer"); var F = arguments.length > 2 && !!arguments[2], B = !0, W = !0; if ("length" in v && f) { var Z = f(v, "length"); Z && !Z.configurable && (B = !1), Z && !Z.writable && (W = !1) } return (B || W || !F) && (u ? l(v, "length", I, !0, !0) : l(v, "length", I)), v }, setFunctionLength } var hasRequiredCallBind; function requireCallBind() { return hasRequiredCallBind || (hasRequiredCallBind = 1, function (o) { var l = requireFunctionBind(), u = requireGetIntrinsic(), f = requireSetFunctionLength(), p = requireType(), d = u("%Function.prototype.apply%"), m = u("%Function.prototype.call%"), v = u("%Reflect.apply%", !0) || l.call(m, d), I = requireEsDefineProperty(), F = u("%Math.max%"); o.exports = function (Z) { if (typeof Z != "function") throw new p("a function is required"); var Q = v(l, m, arguments); return f(Q, 1 + F(0, Z.length - (arguments.length - 1)), !0) }; var B = function () { return v(l, d, arguments) }; I ? I(o.exports, "apply", { value: B }) : o.exports.apply = B }(callBind)), callBind.exports } var callBound, hasRequiredCallBound; function requireCallBound() { if (hasRequiredCallBound) return callBound; hasRequiredCallBound = 1; var o = requireGetIntrinsic(), l = requireCallBind(), u = l(o("String.prototype.indexOf")); return callBound = function (p, d) { var m = o(p, !!d); return typeof m == "function" && u(p, ".prototype.") > -1 ? l(m) : m }, callBound } var isArguments, hasRequiredIsArguments$1; function requireIsArguments$1() { if (hasRequiredIsArguments$1) return isArguments; hasRequiredIsArguments$1 = 1; var o = requireShams()(), l = requireCallBound(), u = l("Object.prototype.toString"), f = function (v) { return o && v && typeof v == "object" && Symbol.toStringTag in v ? !1 : u(v) === "[object Arguments]" }, p = function (v) { return f(v) ? !0 : v !== null && typeof v == "object" && typeof v.length == "number" && v.length >= 0 && u(v) !== "[object Array]" && u(v.callee) === "[object Function]" }, d = function () { return f(arguments) }(); return f.isLegacyArguments = p, isArguments = d ? f : p, isArguments } var isGeneratorFunction, hasRequiredIsGeneratorFunction; function requireIsGeneratorFunction() { if (hasRequiredIsGeneratorFunction) return isGeneratorFunction; hasRequiredIsGeneratorFunction = 1; var o = Object.prototype.toString, l = Function.prototype.toString, u = /^\s*(?:function)?\*/, f = requireShams()(), p = Object.getPrototypeOf, d = function () { if (!f) return !1; try { return Function("return function*() {}")() } catch { } }, m; return isGeneratorFunction = function (I) { if (typeof I != "function") return !1; if (u.test(l.call(I))) return !0; if (!f) { var F = o.call(I); return F === "[object GeneratorFunction]" } if (!p) return !1; if (typeof m > "u") { var B = d(); m = B ? p(B) : !1 } return p(I) === m }, isGeneratorFunction } var isCallable, hasRequiredIsCallable; function requireIsCallable() { if (hasRequiredIsCallable) return isCallable; hasRequiredIsCallable = 1; var o = Function.prototype.toString, l = typeof Reflect == "object" && Reflect !== null && Reflect.apply, u, f; if (typeof l == "function" && typeof Object.defineProperty == "function") try { u = Object.defineProperty({}, "length", { get: function () { throw f } }), f = {}, l(function () { throw 42 }, null, u) } catch (se) { se !== f && (l = null) } else l = null; var p = /^\s*class\b/, d = function (le) { try { var ue = o.call(le); return p.test(ue) } catch { return !1 } }, m = function (le) { try { return d(le) ? !1 : (o.call(le), !0) } catch { return !1 } }, v = Object.prototype.toString, I = "[object Object]", F = "[object Function]", B = "[object GeneratorFunction]", W = "[object HTMLAllCollection]", Z = "[object HTML document.all class]", Q = "[object HTMLCollection]", re = typeof Symbol == "function" && !!Symbol.toStringTag, ne = !(0 in [,]), oe = function () { return !1 }; if (typeof document == "object") { var ae = document.all; v.call(ae) === v.call(document.all) && (oe = function (le) { if ((ne || !le) && (typeof le > "u" || typeof le == "object")) try { var ue = v.call(le); return (ue === W || ue === Z || ue === Q || ue === I) && le("") == null } catch { } return !1 }) } return isCallable = l ? function (le) { if (oe(le)) return !0; if (!le || typeof le != "function" && typeof le != "object") return !1; try { l(le, null, u) } catch (ue) { if (ue !== f) return !1 } return !d(le) && m(le) } : function (le) { if (oe(le)) return !0; if (!le || typeof le != "function" && typeof le != "object") return !1; if (re) return m(le); if (d(le)) return !1; var ue = v.call(le); return ue !== F && ue !== B && !/^\[object HTML/.test(ue) ? !1 : m(le) }, isCallable } var forEach_1, hasRequiredForEach; function requireForEach() { if (hasRequiredForEach) return forEach_1; hasRequiredForEach = 1; var o = requireIsCallable(), l = Object.prototype.toString, u = Object.prototype.hasOwnProperty, f = function (I, F, B) { for (var W = 0, Z = I.length; W < Z; W++)u.call(I, W) && (B == null ? F(I[W], W, I) : F.call(B, I[W], W, I)) }, p = function (I, F, B) { for (var W = 0, Z = I.length; W < Z; W++)B == null ? F(I.charAt(W), W, I) : F.call(B, I.charAt(W), W, I) }, d = function (I, F, B) { for (var W in I) u.call(I, W) && (B == null ? F(I[W], W, I) : F.call(B, I[W], W, I)) }, m = function (I, F, B) { if (!o(F)) throw new TypeError("iterator must be a function"); var W; arguments.length >= 3 && (W = B), l.call(I) === "[object Array]" ? f(I, F, W) : typeof I == "string" ? p(I, F, W) : d(I, F, W) }; return forEach_1 = m, forEach_1 } var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames; function requirePossibleTypedArrayNames() { return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]), possibleTypedArrayNames } var availableTypedArrays, hasRequiredAvailableTypedArrays; function requireAvailableTypedArrays() { if (hasRequiredAvailableTypedArrays) return availableTypedArrays; hasRequiredAvailableTypedArrays = 1; var o = requirePossibleTypedArrayNames(), l = typeof globalThis > "u" ? commonjsGlobal : globalThis; return availableTypedArrays = function () { for (var f = [], p = 0; p < o.length; p++)typeof l[o[p]] == "function" && (f[f.length] = o[p]); return f }, availableTypedArrays } var whichTypedArray, hasRequiredWhichTypedArray; function requireWhichTypedArray() { if (hasRequiredWhichTypedArray) return whichTypedArray; hasRequiredWhichTypedArray = 1; var o = requireForEach(), l = requireAvailableTypedArrays(), u = requireCallBind(), f = requireCallBound(), p = requireGopd(), d = f("Object.prototype.toString"), m = requireShams()(), v = typeof globalThis > "u" ? commonjsGlobal : globalThis, I = l(), F = f("String.prototype.slice"), B = Object.getPrototypeOf, W = f("Array.prototype.indexOf", !0) || function (oe, ae) { for (var se = 0; se < oe.length; se += 1)if (oe[se] === ae) return se; return -1 }, Z = { __proto__: null }; m && p && B ? o(I, function (ne) { var oe = new v[ne]; if (Symbol.toStringTag in oe) { var ae = B(oe), se = p(ae, Symbol.toStringTag); if (!se) { var le = B(ae); se = p(le, Symbol.toStringTag) } Z["$" + ne] = u(se.get) } }) : o(I, function (ne) { var oe = new v[ne], ae = oe.slice || oe.set; ae && (Z["$" + ne] = u(ae)) }); var Q = function (oe) { var ae = !1; return o(Z, function (se, le) { if (!ae) try { "$" + se(oe) === le && (ae = F(le, 1)) } catch { } }), ae }, re = function (oe) { var ae = !1; return o(Z, function (se, le) { if (!ae) try { se(oe), ae = F(le, 1) } catch { } }), ae }; return whichTypedArray = function (oe) { if (!oe || typeof oe != "object") return !1; if (!m) { var ae = F(d(oe), 8, -1); return W(I, ae) > -1 ? ae : ae !== "Object" ? !1 : re(oe) } return p ? Q(oe) : null }, whichTypedArray } var isTypedArray, hasRequiredIsTypedArray$1; function requireIsTypedArray$1() { if (hasRequiredIsTypedArray$1) return isTypedArray; hasRequiredIsTypedArray$1 = 1; var o = requireWhichTypedArray(); return isTypedArray = function (u) { return !!o(u) }, isTypedArray } var hasRequiredTypes; function requireTypes() { return hasRequiredTypes || (hasRequiredTypes = 1, function (o) { var l = requireIsArguments$1(), u = requireIsGeneratorFunction(), f = requireWhichTypedArray(), p = requireIsTypedArray$1(); function d(et) { return et.call.bind(et) } var m = typeof BigInt < "u", v = typeof Symbol < "u", I = d(Object.prototype.toString), F = d(Number.prototype.valueOf), B = d(String.prototype.valueOf), W = d(Boolean.prototype.valueOf); if (m) var Z = d(BigInt.prototype.valueOf); if (v) var Q = d(Symbol.prototype.valueOf); function re(et, Gt) { if (typeof et != "object") return !1; try { return Gt(et), !0 } catch { return !1 } } o.isArgumentsObject = l, o.isGeneratorFunction = u, o.isTypedArray = p; function ne(et) { return typeof Promise < "u" && et instanceof Promise || et !== null && typeof et == "object" && typeof et.then == "function" && typeof et.catch == "function" } o.isPromise = ne; function oe(et) { return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(et) : p(et) || me(et) } o.isArrayBufferView = oe; function ae(et) { return f(et) === "Uint8Array" } o.isUint8Array = ae; function se(et) { return f(et) === "Uint8ClampedArray" } o.isUint8ClampedArray = se; function le(et) { return f(et) === "Uint16Array" } o.isUint16Array = le; function ue(et) { return f(et) === "Uint32Array" } o.isUint32Array = ue; function he(et) { return f(et) === "Int8Array" } o.isInt8Array = he; function pe(et) { return f(et) === "Int16Array" } o.isInt16Array = pe; function ve(et) { return f(et) === "Int32Array" } o.isInt32Array = ve; function _e(et) { return f(et) === "Float32Array" } o.isFloat32Array = _e; function Se(et) { return f(et) === "Float64Array" } o.isFloat64Array = Se; function $e(et) { return f(et) === "BigInt64Array" } o.isBigInt64Array = $e; function ie(et) { return f(et) === "BigUint64Array" } o.isBigUint64Array = ie; function g(et) { return I(et) === "[object Map]" } g.working = typeof Map < "u" && g(new Map); function P(et) { return typeof Map > "u" ? !1 : g.working ? g(et) : et instanceof Map } o.isMap = P; function U(et) { return I(et) === "[object Set]" } U.working = typeof Set < "u" && U(new Set); function K(et) { return typeof Set > "u" ? !1 : U.working ? U(et) : et instanceof Set } o.isSet = K; function Y(et) { return I(et) === "[object WeakMap]" } Y.working = typeof WeakMap < "u" && Y(new WeakMap); function te(et) { return typeof WeakMap > "u" ? !1 : Y.working ? Y(et) : et instanceof WeakMap } o.isWeakMap = te; function ee(et) { return I(et) === "[object WeakSet]" } ee.working = typeof WeakSet < "u" && ee(new WeakSet); function G(et) { return ee(et) } o.isWeakSet = G; function y(et) { return I(et) === "[object ArrayBuffer]" } y.working = typeof ArrayBuffer < "u" && y(new ArrayBuffer); function X(et) { return typeof ArrayBuffer > "u" ? !1 : y.working ? y(et) : et instanceof ArrayBuffer } o.isArrayBuffer = X; function ce(et) { return I(et) === "[object DataView]" } ce.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ce(new DataView(new ArrayBuffer(1), 0, 1)); function me(et) { return typeof DataView > "u" ? !1 : ce.working ? ce(et) : et instanceof DataView } o.isDataView = me; var Ae = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0; function Ie(et) { return I(et) === "[object SharedArrayBuffer]" } function Be(et) { return typeof Ae > "u" ? !1 : (typeof Ie.working > "u" && (Ie.working = Ie(new Ae)), Ie.working ? Ie(et) : et instanceof Ae) } o.isSharedArrayBuffer = Be; function Me(et) { return I(et) === "[object AsyncFunction]" } o.isAsyncFunction = Me; function De(et) { return I(et) === "[object Map Iterator]" } o.isMapIterator = De; function Ue(et) { return I(et) === "[object Set Iterator]" } o.isSetIterator = Ue; function Ke(et) { return I(et) === "[object Generator]" } o.isGeneratorObject = Ke; function Ve(et) { return I(et) === "[object WebAssembly.Module]" } o.isWebAssemblyCompiledModule = Ve; function ke(et) { return re(et, F) } o.isNumberObject = ke; function Je(et) { return re(et, B) } o.isStringObject = Je; function dt(et) { return re(et, W) } o.isBooleanObject = dt; function lt(et) { return m && re(et, Z) } o.isBigIntObject = lt; function ht(et) { return v && re(et, Q) } o.isSymbolObject = ht; function Bt(et) { return ke(et) || Je(et) || dt(et) || lt(et) || ht(et) } o.isBoxedPrimitive = Bt; function mt(et) { return typeof Uint8Array < "u" && (X(et) || Be(et)) } o.isAnyArrayBuffer = mt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (et) { Object.defineProperty(o, et, { enumerable: !1, value: function () { throw new Error(et + " is not supported in userland") } }) }) }(types)), types } var isBufferBrowser, hasRequiredIsBufferBrowser; function requireIsBufferBrowser() { return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function (l) { return l && typeof l == "object" && typeof l.copy == "function" && typeof l.fill == "function" && typeof l.readUInt8 == "function" }), isBufferBrowser } var hasRequiredUtil$1; function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function (o) {
    var l = {}, u = Object.getOwnPropertyDescriptors || function (Ae) { for (var Ie = Object.keys(Ae), Be = {}, Me = 0; Me < Ie.length; Me++)Be[Ie[Me]] = Object.getOwnPropertyDescriptor(Ae, Ie[Me]); return Be }, f = /%[sdj%]/g; o.format = function (me) { if (!pe(me)) { for (var Ae = [], Ie = 0; Ie < arguments.length; Ie++)Ae.push(v(arguments[Ie])); return Ae.join(" ") } for (var Ie = 1, Be = arguments, Me = Be.length, De = String(me).replace(f, function (Ke) { if (Ke === "%%") return "%"; if (Ie >= Me) return Ke; switch (Ke) { case "%s": return String(Be[Ie++]); case "%d": return Number(Be[Ie++]); case "%j": try { return JSON.stringify(Be[Ie++]) } catch { return "[Circular]" } default: return Ke } }), Ue = Be[Ie]; Ie < Me; Ue = Be[++Ie])le(Ue) || !$e(Ue) ? De += " " + Ue : De += " " + v(Ue); return De }, o.deprecate = function (me, Ae) { if (typeof process$1 < "u" && process$1.noDeprecation === !0) return me; if (typeof process$1 > "u") return function () { return o.deprecate(me, Ae).apply(this, arguments) }; var Ie = !1; function Be() { if (!Ie) { if (process$1.throwDeprecation) throw new Error(Ae); process$1.traceDeprecation ? console.trace(Ae) : console.error(Ae), Ie = !0 } return me.apply(this, arguments) } return Be }; var p = {}, d = /^$/; if (l.NODE_DEBUG) { var m = l.NODE_DEBUG; m = m.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), d = new RegExp("^" + m + "$", "i") } o.debuglog = function (me) { if (me = me.toUpperCase(), !p[me]) if (d.test(me)) { var Ae = process$1.pid; p[me] = function () { var Ie = o.format.apply(o, arguments); console.error("%s %d: %s", me, Ae, Ie) } } else p[me] = function () { }; return p[me] }; function v(me, Ae) { var Ie = { seen: [], stylize: F }; return arguments.length >= 3 && (Ie.depth = arguments[2]), arguments.length >= 4 && (Ie.colors = arguments[3]), se(Ae) ? Ie.showHidden = Ae : Ae && o._extend(Ie, Ae), _e(Ie.showHidden) && (Ie.showHidden = !1), _e(Ie.depth) && (Ie.depth = 2), _e(Ie.colors) && (Ie.colors = !1), _e(Ie.customInspect) && (Ie.customInspect = !0), Ie.colors && (Ie.stylize = I), W(Ie, me, Ie.depth) } o.inspect = v, v.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, v.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }; function I(me, Ae) { var Ie = v.styles[Ae]; return Ie ? "\x1B[" + v.colors[Ie][0] + "m" + me + "\x1B[" + v.colors[Ie][1] + "m" : me } function F(me, Ae) { return me } function B(me) { var Ae = {}; return me.forEach(function (Ie, Be) { Ae[Ie] = !0 }), Ae } function W(me, Ae, Ie) { if (me.customInspect && Ae && P(Ae.inspect) && Ae.inspect !== o.inspect && !(Ae.constructor && Ae.constructor.prototype === Ae)) { var Be = Ae.inspect(Ie, me); return pe(Be) || (Be = W(me, Be, Ie)), Be } var Me = Z(me, Ae); if (Me) return Me; var De = Object.keys(Ae), Ue = B(De); if (me.showHidden && (De = Object.getOwnPropertyNames(Ae)), g(Ae) && (De.indexOf("message") >= 0 || De.indexOf("description") >= 0)) return Q(Ae); if (De.length === 0) { if (P(Ae)) { var Ke = Ae.name ? ": " + Ae.name : ""; return me.stylize("[Function" + Ke + "]", "special") } if (Se(Ae)) return me.stylize(RegExp.prototype.toString.call(Ae), "regexp"); if (ie(Ae)) return me.stylize(Date.prototype.toString.call(Ae), "date"); if (g(Ae)) return Q(Ae) } var Ve = "", ke = !1, Je = ["{", "}"]; if (ae(Ae) && (ke = !0, Je = ["[", "]"]), P(Ae)) { var dt = Ae.name ? ": " + Ae.name : ""; Ve = " [Function" + dt + "]" } if (Se(Ae) && (Ve = " " + RegExp.prototype.toString.call(Ae)), ie(Ae) && (Ve = " " + Date.prototype.toUTCString.call(Ae)), g(Ae) && (Ve = " " + Q(Ae)), De.length === 0 && (!ke || Ae.length == 0)) return Je[0] + Ve + Je[1]; if (Ie < 0) return Se(Ae) ? me.stylize(RegExp.prototype.toString.call(Ae), "regexp") : me.stylize("[Object]", "special"); me.seen.push(Ae); var lt; return ke ? lt = re(me, Ae, Ie, Ue, De) : lt = De.map(function (ht) { return ne(me, Ae, Ie, Ue, ht, ke) }), me.seen.pop(), oe(lt, Ve, Je) } function Z(me, Ae) { if (_e(Ae)) return me.stylize("undefined", "undefined"); if (pe(Ae)) { var Ie = "'" + JSON.stringify(Ae).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return me.stylize(Ie, "string") } if (he(Ae)) return me.stylize("" + Ae, "number"); if (se(Ae)) return me.stylize("" + Ae, "boolean"); if (le(Ae)) return me.stylize("null", "null") } function Q(me) { return "[" + Error.prototype.toString.call(me) + "]" } function re(me, Ae, Ie, Be, Me) { for (var De = [], Ue = 0, Ke = Ae.length; Ue < Ke; ++Ue)G(Ae, String(Ue)) ? De.push(ne(me, Ae, Ie, Be, String(Ue), !0)) : De.push(""); return Me.forEach(function (Ve) { Ve.match(/^\d+$/) || De.push(ne(me, Ae, Ie, Be, Ve, !0)) }), De } function ne(me, Ae, Ie, Be, Me, De) {
      var Ue, Ke, Ve; if (Ve = Object.getOwnPropertyDescriptor(Ae, Me) || { value: Ae[Me] }, Ve.get ? Ve.set ? Ke = me.stylize("[Getter/Setter]", "special") : Ke = me.stylize("[Getter]", "special") : Ve.set && (Ke = me.stylize("[Setter]", "special")), G(Be, Me) || (Ue = "[" + Me + "]"), Ke || (me.seen.indexOf(Ve.value) < 0 ? (le(Ie) ? Ke = W(me, Ve.value, null) : Ke = W(me, Ve.value, Ie - 1), Ke.indexOf(`
`) > -1 && (De ? Ke = Ke.split(`
`).map(function (ke) { return "  " + ke }).join(`
`).slice(2) : Ke = `
`+ Ke.split(`
`).map(function (ke) { return "   " + ke }).join(`
`))) : Ke = me.stylize("[Circular]", "special")), _e(Ue)) { if (De && Me.match(/^\d+$/)) return Ke; Ue = JSON.stringify("" + Me), Ue.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Ue = Ue.slice(1, -1), Ue = me.stylize(Ue, "name")) : (Ue = Ue.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Ue = me.stylize(Ue, "string")) } return Ue + ": " + Ke
    } function oe(me, Ae, Ie) {
      var Be = me.reduce(function (Me, De) {
        return De.indexOf(`
`) >= 0, Me + De.replace(/\u001b\[\d\d?m/g, "").length + 1
      }, 0); return Be > 60 ? Ie[0] + (Ae === "" ? "" : Ae + `
 `) + " " + me.join(`,
  `) + " " + Ie[1] : Ie[0] + Ae + " " + me.join(", ") + " " + Ie[1]
    } o.types = requireTypes(); function ae(me) { return Array.isArray(me) } o.isArray = ae; function se(me) { return typeof me == "boolean" } o.isBoolean = se; function le(me) { return me === null } o.isNull = le; function ue(me) { return me == null } o.isNullOrUndefined = ue; function he(me) { return typeof me == "number" } o.isNumber = he; function pe(me) { return typeof me == "string" } o.isString = pe; function ve(me) { return typeof me == "symbol" } o.isSymbol = ve; function _e(me) { return me === void 0 } o.isUndefined = _e; function Se(me) { return $e(me) && K(me) === "[object RegExp]" } o.isRegExp = Se, o.types.isRegExp = Se; function $e(me) { return typeof me == "object" && me !== null } o.isObject = $e; function ie(me) { return $e(me) && K(me) === "[object Date]" } o.isDate = ie, o.types.isDate = ie; function g(me) { return $e(me) && (K(me) === "[object Error]" || me instanceof Error) } o.isError = g, o.types.isNativeError = g; function P(me) { return typeof me == "function" } o.isFunction = P; function U(me) { return me === null || typeof me == "boolean" || typeof me == "number" || typeof me == "string" || typeof me == "symbol" || typeof me > "u" } o.isPrimitive = U, o.isBuffer = requireIsBufferBrowser(); function K(me) { return Object.prototype.toString.call(me) } function Y(me) { return me < 10 ? "0" + me.toString(10) : me.toString(10) } var te = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function ee() { var me = new Date, Ae = [Y(me.getHours()), Y(me.getMinutes()), Y(me.getSeconds())].join(":"); return [me.getDate(), te[me.getMonth()], Ae].join(" ") } o.log = function () { console.log("%s - %s", ee(), o.format.apply(o, arguments)) }, o.inherits = requireInherits_browser(), o._extend = function (me, Ae) { if (!Ae || !$e(Ae)) return me; for (var Ie = Object.keys(Ae), Be = Ie.length; Be--;)me[Ie[Be]] = Ae[Ie[Be]]; return me }; function G(me, Ae) { return Object.prototype.hasOwnProperty.call(me, Ae) } var y = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0; o.promisify = function (Ae) { if (typeof Ae != "function") throw new TypeError('The "original" argument must be of type Function'); if (y && Ae[y]) { var Ie = Ae[y]; if (typeof Ie != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(Ie, y, { value: Ie, enumerable: !1, writable: !1, configurable: !0 }), Ie } function Ie() { for (var Be, Me, De = new Promise(function (Ve, ke) { Be = Ve, Me = ke }), Ue = [], Ke = 0; Ke < arguments.length; Ke++)Ue.push(arguments[Ke]); Ue.push(function (Ve, ke) { Ve ? Me(Ve) : Be(ke) }); try { Ae.apply(this, Ue) } catch (Ve) { Me(Ve) } return De } return Object.setPrototypeOf(Ie, Object.getPrototypeOf(Ae)), y && Object.defineProperty(Ie, y, { value: Ie, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(Ie, u(Ae)) }, o.promisify.custom = y; function X(me, Ae) { if (!me) { var Ie = new Error("Promise was rejected with a falsy value"); Ie.reason = me, me = Ie } return Ae(me) } function ce(me) { if (typeof me != "function") throw new TypeError('The "original" argument must be of type Function'); function Ae() { for (var Ie = [], Be = 0; Be < arguments.length; Be++)Ie.push(arguments[Be]); var Me = Ie.pop(); if (typeof Me != "function") throw new TypeError("The last argument must be of type Function"); var De = this, Ue = function () { return Me.apply(De, arguments) }; me.apply(this, Ie).then(function (Ke) { process$1.nextTick(Ue.bind(null, null, Ke)) }, function (Ke) { process$1.nextTick(X.bind(null, Ke, Ue)) }) } return Object.setPrototypeOf(Ae, Object.getPrototypeOf(me)), Object.defineProperties(Ae, u(me)), Ae } o.callbackify = ce
  }(util$1)), util$1
} var buffer_list, hasRequiredBuffer_list; function requireBuffer_list() { if (hasRequiredBuffer_list) return buffer_list; hasRequiredBuffer_list = 1; function o(re, ne) { var oe = Object.keys(re); if (Object.getOwnPropertySymbols) { var ae = Object.getOwnPropertySymbols(re); ne && (ae = ae.filter(function (se) { return Object.getOwnPropertyDescriptor(re, se).enumerable })), oe.push.apply(oe, ae) } return oe } function l(re) { for (var ne = 1; ne < arguments.length; ne++) { var oe = arguments[ne] != null ? arguments[ne] : {}; ne % 2 ? o(Object(oe), !0).forEach(function (ae) { u(re, ae, oe[ae]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(re, Object.getOwnPropertyDescriptors(oe)) : o(Object(oe)).forEach(function (ae) { Object.defineProperty(re, ae, Object.getOwnPropertyDescriptor(oe, ae)) }) } return re } function u(re, ne, oe) { return ne = m(ne), ne in re ? Object.defineProperty(re, ne, { value: oe, enumerable: !0, configurable: !0, writable: !0 }) : re[ne] = oe, re } function f(re, ne) { if (!(re instanceof ne)) throw new TypeError("Cannot call a class as a function") } function p(re, ne) { for (var oe = 0; oe < ne.length; oe++) { var ae = ne[oe]; ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(re, m(ae.key), ae) } } function d(re, ne, oe) { return ne && p(re.prototype, ne), Object.defineProperty(re, "prototype", { writable: !1 }), re } function m(re) { var ne = v(re, "string"); return typeof ne == "symbol" ? ne : String(ne) } function v(re, ne) { if (typeof re != "object" || re === null) return re; var oe = re[Symbol.toPrimitive]; if (oe !== void 0) { var ae = oe.call(re, ne); if (typeof ae != "object") return ae; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(re) } var I = requireDist$2(), F = I.Buffer, B = requireUtil$1(), W = B.inspect, Z = W && W.custom || "inspect"; function Q(re, ne, oe) { F.prototype.copy.call(re, ne, oe) } return buffer_list = function () { function re() { f(this, re), this.head = null, this.tail = null, this.length = 0 } return d(re, [{ key: "push", value: function (oe) { var ae = { data: oe, next: null }; this.length > 0 ? this.tail.next = ae : this.head = ae, this.tail = ae, ++this.length } }, { key: "unshift", value: function (oe) { var ae = { data: oe, next: this.head }; this.length === 0 && (this.tail = ae), this.head = ae, ++this.length } }, { key: "shift", value: function () { if (this.length !== 0) { var oe = this.head.data; return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, oe } } }, { key: "clear", value: function () { this.head = this.tail = null, this.length = 0 } }, { key: "join", value: function (oe) { if (this.length === 0) return ""; for (var ae = this.head, se = "" + ae.data; ae = ae.next;)se += oe + ae.data; return se } }, { key: "concat", value: function (oe) { if (this.length === 0) return F.alloc(0); for (var ae = F.allocUnsafe(oe >>> 0), se = this.head, le = 0; se;)Q(se.data, ae, le), le += se.data.length, se = se.next; return ae } }, { key: "consume", value: function (oe, ae) { var se; return oe < this.head.data.length ? (se = this.head.data.slice(0, oe), this.head.data = this.head.data.slice(oe)) : oe === this.head.data.length ? se = this.shift() : se = ae ? this._getString(oe) : this._getBuffer(oe), se } }, { key: "first", value: function () { return this.head.data } }, { key: "_getString", value: function (oe) { var ae = this.head, se = 1, le = ae.data; for (oe -= le.length; ae = ae.next;) { var ue = ae.data, he = oe > ue.length ? ue.length : oe; if (he === ue.length ? le += ue : le += ue.slice(0, oe), oe -= he, oe === 0) { he === ue.length ? (++se, ae.next ? this.head = ae.next : this.head = this.tail = null) : (this.head = ae, ae.data = ue.slice(he)); break } ++se } return this.length -= se, le } }, { key: "_getBuffer", value: function (oe) { var ae = F.allocUnsafe(oe), se = this.head, le = 1; for (se.data.copy(ae), oe -= se.data.length; se = se.next;) { var ue = se.data, he = oe > ue.length ? ue.length : oe; if (ue.copy(ae, ae.length - oe, 0, he), oe -= he, oe === 0) { he === ue.length ? (++le, se.next ? this.head = se.next : this.head = this.tail = null) : (this.head = se, se.data = ue.slice(he)); break } ++le } return this.length -= le, ae } }, { key: Z, value: function (oe, ae) { return W(this, l(l({}, ae), {}, { depth: 0, customInspect: !1 })) } }]), re }(), buffer_list } var destroy_1$1, hasRequiredDestroy$1; function requireDestroy$1() { if (hasRequiredDestroy$1) return destroy_1$1; hasRequiredDestroy$1 = 1; function o(m, v) { var I = this, F = this._readableState && this._readableState.destroyed, B = this._writableState && this._writableState.destroyed; return F || B ? (v ? v(m) : m && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(p, this, m)) : process$1.nextTick(p, this, m)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(m || null, function (W) { !v && W ? I._writableState ? I._writableState.errorEmitted ? process$1.nextTick(u, I) : (I._writableState.errorEmitted = !0, process$1.nextTick(l, I, W)) : process$1.nextTick(l, I, W) : v ? (process$1.nextTick(u, I), v(W)) : process$1.nextTick(u, I) }), this) } function l(m, v) { p(m, v), u(m) } function u(m) { m._writableState && !m._writableState.emitClose || m._readableState && !m._readableState.emitClose || m.emit("close") } function f() { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } function p(m, v) { m.emit("error", v) } function d(m, v) { var I = m._readableState, F = m._writableState; I && I.autoDestroy || F && F.autoDestroy ? m.destroy(v) : m.emit("error", v) } return destroy_1$1 = { destroy: o, undestroy: f, errorOrDestroy: d }, destroy_1$1 } var errorsBrowser = {}, hasRequiredErrorsBrowser; function requireErrorsBrowser() { if (hasRequiredErrorsBrowser) return errorsBrowser; hasRequiredErrorsBrowser = 1; function o(v, I) { v.prototype = Object.create(I.prototype), v.prototype.constructor = v, v.__proto__ = I } var l = {}; function u(v, I, F) { F || (F = Error); function B(Z, Q, re) { return typeof I == "string" ? I : I(Z, Q, re) } var W = function (Z) { o(Q, Z); function Q(re, ne, oe) { return Z.call(this, B(re, ne, oe)) || this } return Q }(F); W.prototype.name = F.name, W.prototype.code = v, l[v] = W } function f(v, I) { if (Array.isArray(v)) { var F = v.length; return v = v.map(function (B) { return String(B) }), F > 2 ? "one of ".concat(I, " ").concat(v.slice(0, F - 1).join(", "), ", or ") + v[F - 1] : F === 2 ? "one of ".concat(I, " ").concat(v[0], " or ").concat(v[1]) : "of ".concat(I, " ").concat(v[0]) } else return "of ".concat(I, " ").concat(String(v)) } function p(v, I, F) { return v.substr(0, I.length) === I } function d(v, I, F) { return (F === void 0 || F > v.length) && (F = v.length), v.substring(F - I.length, F) === I } function m(v, I, F) { return typeof F != "number" && (F = 0), F + I.length > v.length ? !1 : v.indexOf(I, F) !== -1 } return u("ERR_INVALID_OPT_VALUE", function (v, I) { return 'The value "' + I + '" is invalid for option "' + v + '"' }, TypeError), u("ERR_INVALID_ARG_TYPE", function (v, I, F) { var B; typeof I == "string" && p(I, "not ") ? (B = "must not be", I = I.replace(/^not /, "")) : B = "must be"; var W; if (d(v, " argument")) W = "The ".concat(v, " ").concat(B, " ").concat(f(I, "type")); else { var Z = m(v, ".") ? "property" : "argument"; W = 'The "'.concat(v, '" ').concat(Z, " ").concat(B, " ").concat(f(I, "type")) } return W += ". Received type ".concat(typeof F), W }, TypeError), u("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), u("ERR_METHOD_NOT_IMPLEMENTED", function (v) { return "The " + v + " method is not implemented" }), u("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), u("ERR_STREAM_DESTROYED", function (v) { return "Cannot call " + v + " after a stream was destroyed" }), u("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), u("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), u("ERR_STREAM_WRITE_AFTER_END", "write after end"), u("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), u("ERR_UNKNOWN_ENCODING", function (v) { return "Unknown encoding: " + v }, TypeError), u("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = l, errorsBrowser } var state, hasRequiredState; function requireState() { if (hasRequiredState) return state; hasRequiredState = 1; var o = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE; function l(f, p, d) { return f.highWaterMark != null ? f.highWaterMark : p ? f[d] : null } function u(f, p, d, m) { var v = l(p, m, d); if (v != null) { if (!(isFinite(v) && Math.floor(v) === v) || v < 0) { var I = m ? d : "highWaterMark"; throw new o(I, v) } return Math.floor(v) } return f.objectMode ? 16 : 16 * 1024 } return state = { getHighWaterMark: u }, state } var browser$b, hasRequiredBrowser$a; function requireBrowser$a() { if (hasRequiredBrowser$a) return browser$b; hasRequiredBrowser$a = 1, browser$b = o; function o(u, f) { if (l("noDeprecation")) return u; var p = !1; function d() { if (!p) { if (l("throwDeprecation")) throw new Error(f); l("traceDeprecation") ? console.trace(f) : console.warn(f), p = !0 } return u.apply(this, arguments) } return d } function l(u) { try { if (!commonjsGlobal.localStorage) return !1 } catch { return !1 } var f = commonjsGlobal.localStorage[u]; return f == null ? !1 : String(f).toLowerCase() === "true" } return browser$b } var _stream_writable$1, hasRequired_stream_writable$1; function require_stream_writable$1() { if (hasRequired_stream_writable$1) return _stream_writable$1; hasRequired_stream_writable$1 = 1, _stream_writable$1 = _e; function o(Be) { var Me = this; this.next = null, this.entry = null, this.finish = function () { Ie(Me, Be) } } var l; _e.WritableState = pe; var u = { deprecate: requireBrowser$a() }, f = requireStreamBrowser$1(), p = requireDist$2().Buffer, d = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function () { }; function m(Be) { return p.from(Be) } function v(Be) { return p.isBuffer(Be) || Be instanceof d } var I = requireDestroy$1(), F = requireState(), B = F.getHighWaterMark, W = requireErrorsBrowser().codes, Z = W.ERR_INVALID_ARG_TYPE, Q = W.ERR_METHOD_NOT_IMPLEMENTED, re = W.ERR_MULTIPLE_CALLBACK, ne = W.ERR_STREAM_CANNOT_PIPE, oe = W.ERR_STREAM_DESTROYED, ae = W.ERR_STREAM_NULL_VALUES, se = W.ERR_STREAM_WRITE_AFTER_END, le = W.ERR_UNKNOWN_ENCODING, ue = I.errorOrDestroy; requireInherits_browser()(_e, f); function he() { } function pe(Be, Me, De) { l = l || require_stream_duplex$1(), Be = Be || {}, typeof De != "boolean" && (De = Me instanceof l), this.objectMode = !!Be.objectMode, De && (this.objectMode = this.objectMode || !!Be.writableObjectMode), this.highWaterMark = B(this, Be, "writableHighWaterMark", De), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var Ue = Be.decodeStrings === !1; this.decodeStrings = !Ue, this.defaultEncoding = Be.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (Ke) { Y(Me, Ke) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Be.emitClose !== !1, this.autoDestroy = !!Be.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this) } pe.prototype.getBuffer = function () { for (var Me = this.bufferedRequest, De = []; Me;)De.push(Me), Me = Me.next; return De }, function () { try { Object.defineProperty(pe.prototype, "buffer", { get: u.deprecate(function () { return this.getBuffer() }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch { } }(); var ve; typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ve = Function.prototype[Symbol.hasInstance], Object.defineProperty(_e, Symbol.hasInstance, { value: function (Me) { return ve.call(this, Me) ? !0 : this !== _e ? !1 : Me && Me._writableState instanceof pe } })) : ve = function (Me) { return Me instanceof this }; function _e(Be) { l = l || require_stream_duplex$1(); var Me = this instanceof l; if (!Me && !ve.call(_e, this)) return new _e(Be); this._writableState = new pe(Be, this, Me), this.writable = !0, Be && (typeof Be.write == "function" && (this._write = Be.write), typeof Be.writev == "function" && (this._writev = Be.writev), typeof Be.destroy == "function" && (this._destroy = Be.destroy), typeof Be.final == "function" && (this._final = Be.final)), f.call(this) } _e.prototype.pipe = function () { ue(this, new ne) }; function Se(Be, Me) { var De = new se; ue(Be, De), process$1.nextTick(Me, De) } function $e(Be, Me, De, Ue) { var Ke; return De === null ? Ke = new ae : typeof De != "string" && !Me.objectMode && (Ke = new Z("chunk", ["string", "Buffer"], De)), Ke ? (ue(Be, Ke), process$1.nextTick(Ue, Ke), !1) : !0 } _e.prototype.write = function (Be, Me, De) { var Ue = this._writableState, Ke = !1, Ve = !Ue.objectMode && v(Be); return Ve && !p.isBuffer(Be) && (Be = m(Be)), typeof Me == "function" && (De = Me, Me = null), Ve ? Me = "buffer" : Me || (Me = Ue.defaultEncoding), typeof De != "function" && (De = he), Ue.ending ? Se(this, De) : (Ve || $e(this, Ue, Be, De)) && (Ue.pendingcb++, Ke = g(this, Ue, Ve, Be, Me, De)), Ke }, _e.prototype.cork = function () { this._writableState.corked++ }, _e.prototype.uncork = function () { var Be = this._writableState; Be.corked && (Be.corked--, !Be.writing && !Be.corked && !Be.bufferProcessing && Be.bufferedRequest && G(this, Be)) }, _e.prototype.setDefaultEncoding = function (Me) { if (typeof Me == "string" && (Me = Me.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Me + "").toLowerCase()) > -1)) throw new le(Me); return this._writableState.defaultEncoding = Me, this }, Object.defineProperty(_e.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }); function ie(Be, Me, De) { return !Be.objectMode && Be.decodeStrings !== !1 && typeof Me == "string" && (Me = p.from(Me, De)), Me } Object.defineProperty(_e.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }); function g(Be, Me, De, Ue, Ke, Ve) { if (!De) { var ke = ie(Me, Ue, Ke); Ue !== ke && (De = !0, Ke = "buffer", Ue = ke) } var Je = Me.objectMode ? 1 : Ue.length; Me.length += Je; var dt = Me.length < Me.highWaterMark; if (dt || (Me.needDrain = !0), Me.writing || Me.corked) { var lt = Me.lastBufferedRequest; Me.lastBufferedRequest = { chunk: Ue, encoding: Ke, isBuf: De, callback: Ve, next: null }, lt ? lt.next = Me.lastBufferedRequest : Me.bufferedRequest = Me.lastBufferedRequest, Me.bufferedRequestCount += 1 } else P(Be, Me, !1, Je, Ue, Ke, Ve); return dt } function P(Be, Me, De, Ue, Ke, Ve, ke) { Me.writelen = Ue, Me.writecb = ke, Me.writing = !0, Me.sync = !0, Me.destroyed ? Me.onwrite(new oe("write")) : De ? Be._writev(Ke, Me.onwrite) : Be._write(Ke, Ve, Me.onwrite), Me.sync = !1 } function U(Be, Me, De, Ue, Ke) { --Me.pendingcb, De ? (process$1.nextTick(Ke, Ue), process$1.nextTick(me, Be, Me), Be._writableState.errorEmitted = !0, ue(Be, Ue)) : (Ke(Ue), Be._writableState.errorEmitted = !0, ue(Be, Ue), me(Be, Me)) } function K(Be) { Be.writing = !1, Be.writecb = null, Be.length -= Be.writelen, Be.writelen = 0 } function Y(Be, Me) { var De = Be._writableState, Ue = De.sync, Ke = De.writecb; if (typeof Ke != "function") throw new re; if (K(De), Me) U(Be, De, Ue, Me, Ke); else { var Ve = y(De) || Be.destroyed; !Ve && !De.corked && !De.bufferProcessing && De.bufferedRequest && G(Be, De), Ue ? process$1.nextTick(te, Be, De, Ve, Ke) : te(Be, De, Ve, Ke) } } function te(Be, Me, De, Ue) { De || ee(Be, Me), Me.pendingcb--, Ue(), me(Be, Me) } function ee(Be, Me) { Me.length === 0 && Me.needDrain && (Me.needDrain = !1, Be.emit("drain")) } function G(Be, Me) { Me.bufferProcessing = !0; var De = Me.bufferedRequest; if (Be._writev && De && De.next) { var Ue = Me.bufferedRequestCount, Ke = new Array(Ue), Ve = Me.corkedRequestsFree; Ve.entry = De; for (var ke = 0, Je = !0; De;)Ke[ke] = De, De.isBuf || (Je = !1), De = De.next, ke += 1; Ke.allBuffers = Je, P(Be, Me, !0, Me.length, Ke, "", Ve.finish), Me.pendingcb++, Me.lastBufferedRequest = null, Ve.next ? (Me.corkedRequestsFree = Ve.next, Ve.next = null) : Me.corkedRequestsFree = new o(Me), Me.bufferedRequestCount = 0 } else { for (; De;) { var dt = De.chunk, lt = De.encoding, ht = De.callback, Bt = Me.objectMode ? 1 : dt.length; if (P(Be, Me, !1, Bt, dt, lt, ht), De = De.next, Me.bufferedRequestCount--, Me.writing) break } De === null && (Me.lastBufferedRequest = null) } Me.bufferedRequest = De, Me.bufferProcessing = !1 } _e.prototype._write = function (Be, Me, De) { De(new Q("_write()")) }, _e.prototype._writev = null, _e.prototype.end = function (Be, Me, De) { var Ue = this._writableState; return typeof Be == "function" ? (De = Be, Be = null, Me = null) : typeof Me == "function" && (De = Me, Me = null), Be != null && this.write(Be, Me), Ue.corked && (Ue.corked = 1, this.uncork()), Ue.ending || Ae(this, Ue, De), this }, Object.defineProperty(_e.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length } }); function y(Be) { return Be.ending && Be.length === 0 && Be.bufferedRequest === null && !Be.finished && !Be.writing } function X(Be, Me) { Be._final(function (De) { Me.pendingcb--, De && ue(Be, De), Me.prefinished = !0, Be.emit("prefinish"), me(Be, Me) }) } function ce(Be, Me) { !Me.prefinished && !Me.finalCalled && (typeof Be._final == "function" && !Me.destroyed ? (Me.pendingcb++, Me.finalCalled = !0, process$1.nextTick(X, Be, Me)) : (Me.prefinished = !0, Be.emit("prefinish"))) } function me(Be, Me) { var De = y(Me); if (De && (ce(Be, Me), Me.pendingcb === 0 && (Me.finished = !0, Be.emit("finish"), Me.autoDestroy))) { var Ue = Be._readableState; (!Ue || Ue.autoDestroy && Ue.endEmitted) && Be.destroy() } return De } function Ae(Be, Me, De) { Me.ending = !0, me(Be, Me), De && (Me.finished ? process$1.nextTick(De) : Be.once("finish", De)), Me.ended = !0, Be.writable = !1 } function Ie(Be, Me, De) { var Ue = Be.entry; for (Be.entry = null; Ue;) { var Ke = Ue.callback; Me.pendingcb--, Ke(De), Ue = Ue.next } Me.corkedRequestsFree.next = Be } return Object.defineProperty(_e.prototype, "destroyed", { enumerable: !1, get: function () { return this._writableState === void 0 ? !1 : this._writableState.destroyed }, set: function (Me) { this._writableState && (this._writableState.destroyed = Me) } }), _e.prototype.destroy = I.destroy, _e.prototype._undestroy = I.undestroy, _e.prototype._destroy = function (Be, Me) { Me(Be) }, _stream_writable$1 } var _stream_duplex$1, hasRequired_stream_duplex$1; function require_stream_duplex$1() { if (hasRequired_stream_duplex$1) return _stream_duplex$1; hasRequired_stream_duplex$1 = 1; var o = Object.keys || function (F) { var B = []; for (var W in F) B.push(W); return B }; _stream_duplex$1 = m; var l = require_stream_readable$1(), u = require_stream_writable$1(); requireInherits_browser()(m, l); for (var f = o(u.prototype), p = 0; p < f.length; p++) { var d = f[p]; m.prototype[d] || (m.prototype[d] = u.prototype[d]) } function m(F) { if (!(this instanceof m)) return new m(F); l.call(this, F), u.call(this, F), this.allowHalfOpen = !0, F && (F.readable === !1 && (this.readable = !1), F.writable === !1 && (this.writable = !1), F.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", v))) } Object.defineProperty(m.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), Object.defineProperty(m.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }), Object.defineProperty(m.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length } }); function v() { this._writableState.ended || process$1.nextTick(I, this) } function I(F) { F.end() } return Object.defineProperty(m.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed }, set: function (B) { this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = B, this._writableState.destroyed = B) } }), _stream_duplex$1 } var string_decoder = {}, hasRequiredString_decoder; function requireString_decoder() { if (hasRequiredString_decoder) return string_decoder; hasRequiredString_decoder = 1; var o = requireSafeBuffer$1().Buffer, l = o.isEncoding || function (ae) { switch (ae = "" + ae, ae && ae.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function u(ae) { if (!ae) return "utf8"; for (var se; ;)switch (ae) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return ae; default: if (se) return; ae = ("" + ae).toLowerCase(), se = !0 } } function f(ae) { var se = u(ae); if (typeof se != "string" && (o.isEncoding === l || !l(ae))) throw new Error("Unknown encoding: " + ae); return se || ae } string_decoder.StringDecoder = p; function p(ae) { this.encoding = f(ae); var se; switch (this.encoding) { case "utf16le": this.text = W, this.end = Z, se = 4; break; case "utf8": this.fillLast = I, se = 4; break; case "base64": this.text = Q, this.end = re, se = 3; break; default: this.write = ne, this.end = oe; return }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = o.allocUnsafe(se) } p.prototype.write = function (ae) { if (ae.length === 0) return ""; var se, le; if (this.lastNeed) { if (se = this.fillLast(ae), se === void 0) return ""; le = this.lastNeed, this.lastNeed = 0 } else le = 0; return le < ae.length ? se ? se + this.text(ae, le) : this.text(ae, le) : se || "" }, p.prototype.end = B, p.prototype.text = F, p.prototype.fillLast = function (ae) { if (this.lastNeed <= ae.length) return ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ae.length), this.lastNeed -= ae.length }; function d(ae) { return ae <= 127 ? 0 : ae >> 5 === 6 ? 2 : ae >> 4 === 14 ? 3 : ae >> 3 === 30 ? 4 : ae >> 6 === 2 ? -1 : -2 } function m(ae, se, le) { var ue = se.length - 1; if (ue < le) return 0; var he = d(se[ue]); return he >= 0 ? (he > 0 && (ae.lastNeed = he - 1), he) : --ue < le || he === -2 ? 0 : (he = d(se[ue]), he >= 0 ? (he > 0 && (ae.lastNeed = he - 2), he) : --ue < le || he === -2 ? 0 : (he = d(se[ue]), he >= 0 ? (he > 0 && (he === 2 ? he = 0 : ae.lastNeed = he - 3), he) : 0)) } function v(ae, se, le) { if ((se[0] & 192) !== 128) return ae.lastNeed = 0, ""; if (ae.lastNeed > 1 && se.length > 1) { if ((se[1] & 192) !== 128) return ae.lastNeed = 1, ""; if (ae.lastNeed > 2 && se.length > 2 && (se[2] & 192) !== 128) return ae.lastNeed = 2, "" } } function I(ae) { var se = this.lastTotal - this.lastNeed, le = v(this, ae); if (le !== void 0) return le; if (this.lastNeed <= ae.length) return ae.copy(this.lastChar, se, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); ae.copy(this.lastChar, se, 0, ae.length), this.lastNeed -= ae.length } function F(ae, se) { var le = m(this, ae, se); if (!this.lastNeed) return ae.toString("utf8", se); this.lastTotal = le; var ue = ae.length - (le - this.lastNeed); return ae.copy(this.lastChar, 0, ue), ae.toString("utf8", se, ue) } function B(ae) { var se = ae && ae.length ? this.write(ae) : ""; return this.lastNeed ? se + "" : se } function W(ae, se) { if ((ae.length - se) % 2 === 0) { var le = ae.toString("utf16le", se); if (le) { var ue = le.charCodeAt(le.length - 1); if (ue >= 55296 && ue <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = ae[ae.length - 2], this.lastChar[1] = ae[ae.length - 1], le.slice(0, -1) } return le } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = ae[ae.length - 1], ae.toString("utf16le", se, ae.length - 1) } function Z(ae) { var se = ae && ae.length ? this.write(ae) : ""; if (this.lastNeed) { var le = this.lastTotal - this.lastNeed; return se + this.lastChar.toString("utf16le", 0, le) } return se } function Q(ae, se) { var le = (ae.length - se) % 3; return le === 0 ? ae.toString("base64", se) : (this.lastNeed = 3 - le, this.lastTotal = 3, le === 1 ? this.lastChar[0] = ae[ae.length - 1] : (this.lastChar[0] = ae[ae.length - 2], this.lastChar[1] = ae[ae.length - 1]), ae.toString("base64", se, ae.length - le)) } function re(ae) { var se = ae && ae.length ? this.write(ae) : ""; return this.lastNeed ? se + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : se } function ne(ae) { return ae.toString(this.encoding) } function oe(ae) { return ae && ae.length ? this.write(ae) : "" } return string_decoder } var endOfStream, hasRequiredEndOfStream; function requireEndOfStream() { if (hasRequiredEndOfStream) return endOfStream; hasRequiredEndOfStream = 1; var o = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE; function l(d) { var m = !1; return function () { if (!m) { m = !0; for (var v = arguments.length, I = new Array(v), F = 0; F < v; F++)I[F] = arguments[F]; d.apply(this, I) } } } function u() { } function f(d) { return d.setHeader && typeof d.abort == "function" } function p(d, m, v) { if (typeof m == "function") return p(d, null, m); m || (m = {}), v = l(v || u); var I = m.readable || m.readable !== !1 && d.readable, F = m.writable || m.writable !== !1 && d.writable, B = function () { d.writable || Z() }, W = d._writableState && d._writableState.finished, Z = function () { F = !1, W = !0, I || v.call(d) }, Q = d._readableState && d._readableState.endEmitted, re = function () { I = !1, Q = !0, F || v.call(d) }, ne = function (le) { v.call(d, le) }, oe = function () { var le; if (I && !Q) return (!d._readableState || !d._readableState.ended) && (le = new o), v.call(d, le); if (F && !W) return (!d._writableState || !d._writableState.ended) && (le = new o), v.call(d, le) }, ae = function () { d.req.on("finish", Z) }; return f(d) ? (d.on("complete", Z), d.on("abort", oe), d.req ? ae() : d.on("request", ae)) : F && !d._writableState && (d.on("end", B), d.on("close", B)), d.on("end", re), d.on("finish", Z), m.error !== !1 && d.on("error", ne), d.on("close", oe), function () { d.removeListener("complete", Z), d.removeListener("abort", oe), d.removeListener("request", ae), d.req && d.req.removeListener("finish", Z), d.removeListener("end", B), d.removeListener("close", B), d.removeListener("finish", Z), d.removeListener("end", re), d.removeListener("error", ne), d.removeListener("close", oe) } } return endOfStream = p, endOfStream } var async_iterator, hasRequiredAsync_iterator; function requireAsync_iterator() { if (hasRequiredAsync_iterator) return async_iterator; hasRequiredAsync_iterator = 1; var o; function l(le, ue, he) { return ue = u(ue), ue in le ? Object.defineProperty(le, ue, { value: he, enumerable: !0, configurable: !0, writable: !0 }) : le[ue] = he, le } function u(le) { var ue = f(le, "string"); return typeof ue == "symbol" ? ue : String(ue) } function f(le, ue) { if (typeof le != "object" || le === null) return le; var he = le[Symbol.toPrimitive]; if (he !== void 0) { var pe = he.call(le, ue); if (typeof pe != "object") return pe; throw new TypeError("@@toPrimitive must return a primitive value.") } return (ue === "string" ? String : Number)(le) } var p = requireEndOfStream(), d = Symbol("lastResolve"), m = Symbol("lastReject"), v = Symbol("error"), I = Symbol("ended"), F = Symbol("lastPromise"), B = Symbol("handlePromise"), W = Symbol("stream"); function Z(le, ue) { return { value: le, done: ue } } function Q(le) { var ue = le[d]; if (ue !== null) { var he = le[W].read(); he !== null && (le[F] = null, le[d] = null, le[m] = null, ue(Z(he, !1))) } } function re(le) { process$1.nextTick(Q, le) } function ne(le, ue) { return function (he, pe) { le.then(function () { if (ue[I]) { he(Z(void 0, !0)); return } ue[B](he, pe) }, pe) } } var oe = Object.getPrototypeOf(function () { }), ae = Object.setPrototypeOf((o = { get stream() { return this[W] }, next: function () { var ue = this, he = this[v]; if (he !== null) return Promise.reject(he); if (this[I]) return Promise.resolve(Z(void 0, !0)); if (this[W].destroyed) return new Promise(function (Se, $e) { process$1.nextTick(function () { ue[v] ? $e(ue[v]) : Se(Z(void 0, !0)) }) }); var pe = this[F], ve; if (pe) ve = new Promise(ne(pe, this)); else { var _e = this[W].read(); if (_e !== null) return Promise.resolve(Z(_e, !1)); ve = new Promise(this[B]) } return this[F] = ve, ve } }, l(o, Symbol.asyncIterator, function () { return this }), l(o, "return", function () { var ue = this; return new Promise(function (he, pe) { ue[W].destroy(null, function (ve) { if (ve) { pe(ve); return } he(Z(void 0, !0)) }) }) }), o), oe), se = function (ue) { var he, pe = Object.create(ae, (he = {}, l(he, W, { value: ue, writable: !0 }), l(he, d, { value: null, writable: !0 }), l(he, m, { value: null, writable: !0 }), l(he, v, { value: null, writable: !0 }), l(he, I, { value: ue._readableState.endEmitted, writable: !0 }), l(he, B, { value: function (_e, Se) { var $e = pe[W].read(); $e ? (pe[F] = null, pe[d] = null, pe[m] = null, _e(Z($e, !1))) : (pe[d] = _e, pe[m] = Se) }, writable: !0 }), he)); return pe[F] = null, p(ue, function (ve) { if (ve && ve.code !== "ERR_STREAM_PREMATURE_CLOSE") { var _e = pe[m]; _e !== null && (pe[F] = null, pe[d] = null, pe[m] = null, _e(ve)), pe[v] = ve; return } var Se = pe[d]; Se !== null && (pe[F] = null, pe[d] = null, pe[m] = null, Se(Z(void 0, !0))), pe[I] = !0 }), ue.on("readable", re.bind(null, pe)), pe }; return async_iterator = se, async_iterator } var fromBrowser, hasRequiredFromBrowser; function requireFromBrowser() { return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function () { throw new Error("Readable.from is not available in the browser") }), fromBrowser } var _stream_readable$1, hasRequired_stream_readable$1; function require_stream_readable$1() { if (hasRequired_stream_readable$1) return _stream_readable$1; hasRequired_stream_readable$1 = 1, _stream_readable$1 = Se; var o; Se.ReadableState = _e, requireEvents().EventEmitter; var l = function (ke, Je) { return ke.listeners(Je).length }, u = requireStreamBrowser$1(), f = requireDist$2().Buffer, p = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function () { }; function d(Ve) { return f.from(Ve) } function m(Ve) { return f.isBuffer(Ve) || Ve instanceof p } var v = requireUtil$1(), I; v && v.debuglog ? I = v.debuglog("stream") : I = function () { }; var F = requireBuffer_list(), B = requireDestroy$1(), W = requireState(), Z = W.getHighWaterMark, Q = requireErrorsBrowser().codes, re = Q.ERR_INVALID_ARG_TYPE, ne = Q.ERR_STREAM_PUSH_AFTER_EOF, oe = Q.ERR_METHOD_NOT_IMPLEMENTED, ae = Q.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, se, le, ue; requireInherits_browser()(Se, u); var he = B.errorOrDestroy, pe = ["error", "close", "destroy", "pause", "resume"]; function ve(Ve, ke, Je) { if (typeof Ve.prependListener == "function") return Ve.prependListener(ke, Je); !Ve._events || !Ve._events[ke] ? Ve.on(ke, Je) : Array.isArray(Ve._events[ke]) ? Ve._events[ke].unshift(Je) : Ve._events[ke] = [Je, Ve._events[ke]] } function _e(Ve, ke, Je) { o = o || require_stream_duplex$1(), Ve = Ve || {}, typeof Je != "boolean" && (Je = ke instanceof o), this.objectMode = !!Ve.objectMode, Je && (this.objectMode = this.objectMode || !!Ve.readableObjectMode), this.highWaterMark = Z(this, Ve, "readableHighWaterMark", Je), this.buffer = new F, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Ve.emitClose !== !1, this.autoDestroy = !!Ve.autoDestroy, this.destroyed = !1, this.defaultEncoding = Ve.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ve.encoding && (se || (se = requireString_decoder().StringDecoder), this.decoder = new se(Ve.encoding), this.encoding = Ve.encoding) } function Se(Ve) { if (o = o || require_stream_duplex$1(), !(this instanceof Se)) return new Se(Ve); var ke = this instanceof o; this._readableState = new _e(Ve, this, ke), this.readable = !0, Ve && (typeof Ve.read == "function" && (this._read = Ve.read), typeof Ve.destroy == "function" && (this._destroy = Ve.destroy)), u.call(this) } Object.defineProperty(Se.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState === void 0 ? !1 : this._readableState.destroyed }, set: function (ke) { this._readableState && (this._readableState.destroyed = ke) } }), Se.prototype.destroy = B.destroy, Se.prototype._undestroy = B.undestroy, Se.prototype._destroy = function (Ve, ke) { ke(Ve) }, Se.prototype.push = function (Ve, ke) { var Je = this._readableState, dt; return Je.objectMode ? dt = !0 : typeof Ve == "string" && (ke = ke || Je.defaultEncoding, ke !== Je.encoding && (Ve = f.from(Ve, ke), ke = ""), dt = !0), $e(this, Ve, ke, !1, dt) }, Se.prototype.unshift = function (Ve) { return $e(this, Ve, null, !0, !1) }; function $e(Ve, ke, Je, dt, lt) { I("readableAddChunk", ke); var ht = Ve._readableState; if (ke === null) ht.reading = !1, Y(Ve, ht); else { var Bt; if (lt || (Bt = g(ht, ke)), Bt) he(Ve, Bt); else if (ht.objectMode || ke && ke.length > 0) if (typeof ke != "string" && !ht.objectMode && Object.getPrototypeOf(ke) !== f.prototype && (ke = d(ke)), dt) ht.endEmitted ? he(Ve, new ae) : ie(Ve, ht, ke, !0); else if (ht.ended) he(Ve, new ne); else { if (ht.destroyed) return !1; ht.reading = !1, ht.decoder && !Je ? (ke = ht.decoder.write(ke), ht.objectMode || ke.length !== 0 ? ie(Ve, ht, ke, !1) : G(Ve, ht)) : ie(Ve, ht, ke, !1) } else dt || (ht.reading = !1, G(Ve, ht)) } return !ht.ended && (ht.length < ht.highWaterMark || ht.length === 0) } function ie(Ve, ke, Je, dt) { ke.flowing && ke.length === 0 && !ke.sync ? (ke.awaitDrain = 0, Ve.emit("data", Je)) : (ke.length += ke.objectMode ? 1 : Je.length, dt ? ke.buffer.unshift(Je) : ke.buffer.push(Je), ke.needReadable && te(Ve)), G(Ve, ke) } function g(Ve, ke) { var Je; return !m(ke) && typeof ke != "string" && ke !== void 0 && !Ve.objectMode && (Je = new re("chunk", ["string", "Buffer", "Uint8Array"], ke)), Je } Se.prototype.isPaused = function () { return this._readableState.flowing === !1 }, Se.prototype.setEncoding = function (Ve) { se || (se = requireString_decoder().StringDecoder); var ke = new se(Ve); this._readableState.decoder = ke, this._readableState.encoding = this._readableState.decoder.encoding; for (var Je = this._readableState.buffer.head, dt = ""; Je !== null;)dt += ke.write(Je.data), Je = Je.next; return this._readableState.buffer.clear(), dt !== "" && this._readableState.buffer.push(dt), this._readableState.length = dt.length, this }; var P = 1073741824; function U(Ve) { return Ve >= P ? Ve = P : (Ve--, Ve |= Ve >>> 1, Ve |= Ve >>> 2, Ve |= Ve >>> 4, Ve |= Ve >>> 8, Ve |= Ve >>> 16, Ve++), Ve } function K(Ve, ke) { return Ve <= 0 || ke.length === 0 && ke.ended ? 0 : ke.objectMode ? 1 : Ve !== Ve ? ke.flowing && ke.length ? ke.buffer.head.data.length : ke.length : (Ve > ke.highWaterMark && (ke.highWaterMark = U(Ve)), Ve <= ke.length ? Ve : ke.ended ? ke.length : (ke.needReadable = !0, 0)) } Se.prototype.read = function (Ve) { I("read", Ve), Ve = parseInt(Ve, 10); var ke = this._readableState, Je = Ve; if (Ve !== 0 && (ke.emittedReadable = !1), Ve === 0 && ke.needReadable && ((ke.highWaterMark !== 0 ? ke.length >= ke.highWaterMark : ke.length > 0) || ke.ended)) return I("read: emitReadable", ke.length, ke.ended), ke.length === 0 && ke.ended ? De(this) : te(this), null; if (Ve = K(Ve, ke), Ve === 0 && ke.ended) return ke.length === 0 && De(this), null; var dt = ke.needReadable; I("need readable", dt), (ke.length === 0 || ke.length - Ve < ke.highWaterMark) && (dt = !0, I("length less than watermark", dt)), ke.ended || ke.reading ? (dt = !1, I("reading or ended", dt)) : dt && (I("do read"), ke.reading = !0, ke.sync = !0, ke.length === 0 && (ke.needReadable = !0), this._read(ke.highWaterMark), ke.sync = !1, ke.reading || (Ve = K(Je, ke))); var lt; return Ve > 0 ? lt = Me(Ve, ke) : lt = null, lt === null ? (ke.needReadable = ke.length <= ke.highWaterMark, Ve = 0) : (ke.length -= Ve, ke.awaitDrain = 0), ke.length === 0 && (ke.ended || (ke.needReadable = !0), Je !== Ve && ke.ended && De(this)), lt !== null && this.emit("data", lt), lt }; function Y(Ve, ke) { if (I("onEofChunk"), !ke.ended) { if (ke.decoder) { var Je = ke.decoder.end(); Je && Je.length && (ke.buffer.push(Je), ke.length += ke.objectMode ? 1 : Je.length) } ke.ended = !0, ke.sync ? te(Ve) : (ke.needReadable = !1, ke.emittedReadable || (ke.emittedReadable = !0, ee(Ve))) } } function te(Ve) { var ke = Ve._readableState; I("emitReadable", ke.needReadable, ke.emittedReadable), ke.needReadable = !1, ke.emittedReadable || (I("emitReadable", ke.flowing), ke.emittedReadable = !0, process$1.nextTick(ee, Ve)) } function ee(Ve) { var ke = Ve._readableState; I("emitReadable_", ke.destroyed, ke.length, ke.ended), !ke.destroyed && (ke.length || ke.ended) && (Ve.emit("readable"), ke.emittedReadable = !1), ke.needReadable = !ke.flowing && !ke.ended && ke.length <= ke.highWaterMark, Be(Ve) } function G(Ve, ke) { ke.readingMore || (ke.readingMore = !0, process$1.nextTick(y, Ve, ke)) } function y(Ve, ke) { for (; !ke.reading && !ke.ended && (ke.length < ke.highWaterMark || ke.flowing && ke.length === 0);) { var Je = ke.length; if (I("maybeReadMore read 0"), Ve.read(0), Je === ke.length) break } ke.readingMore = !1 } Se.prototype._read = function (Ve) { he(this, new oe("_read()")) }, Se.prototype.pipe = function (Ve, ke) { var Je = this, dt = this._readableState; switch (dt.pipesCount) { case 0: dt.pipes = Ve; break; case 1: dt.pipes = [dt.pipes, Ve]; break; default: dt.pipes.push(Ve); break }dt.pipesCount += 1, I("pipe count=%d opts=%j", dt.pipesCount, ke); var lt = (!ke || ke.end !== !1) && Ve !== process$1.stdout && Ve !== process$1.stderr, ht = lt ? mt : Ge; dt.endEmitted ? process$1.nextTick(ht) : Je.once("end", ht), Ve.on("unpipe", Bt); function Bt(ze, Ze) { I("onunpipe"), ze === Je && Ze && Ze.hasUnpiped === !1 && (Ze.hasUnpiped = !0, pt()) } function mt() { I("onend"), Ve.end() } var et = X(Je); Ve.on("drain", et); var Gt = !1; function pt() { I("cleanup"), Ve.removeListener("close", bt), Ve.removeListener("finish", We), Ve.removeListener("drain", et), Ve.removeListener("error", zt), Ve.removeListener("unpipe", Bt), Je.removeListener("end", mt), Je.removeListener("end", Ge), Je.removeListener("data", _t), Gt = !0, dt.awaitDrain && (!Ve._writableState || Ve._writableState.needDrain) && et() } Je.on("data", _t); function _t(ze) { I("ondata"); var Ze = Ve.write(ze); I("dest.write", Ze), Ze === !1 && ((dt.pipesCount === 1 && dt.pipes === Ve || dt.pipesCount > 1 && Ke(dt.pipes, Ve) !== -1) && !Gt && (I("false write response, pause", dt.awaitDrain), dt.awaitDrain++), Je.pause()) } function zt(ze) { I("onerror", ze), Ge(), Ve.removeListener("error", zt), l(Ve, "error") === 0 && he(Ve, ze) } ve(Ve, "error", zt); function bt() { Ve.removeListener("finish", We), Ge() } Ve.once("close", bt); function We() { I("onfinish"), Ve.removeListener("close", bt), Ge() } Ve.once("finish", We); function Ge() { I("unpipe"), Je.unpipe(Ve) } return Ve.emit("pipe", Je), dt.flowing || (I("pipe resume"), Je.resume()), Ve }; function X(Ve) { return function () { var Je = Ve._readableState; I("pipeOnDrain", Je.awaitDrain), Je.awaitDrain && Je.awaitDrain--, Je.awaitDrain === 0 && l(Ve, "data") && (Je.flowing = !0, Be(Ve)) } } Se.prototype.unpipe = function (Ve) { var ke = this._readableState, Je = { hasUnpiped: !1 }; if (ke.pipesCount === 0) return this; if (ke.pipesCount === 1) return Ve && Ve !== ke.pipes ? this : (Ve || (Ve = ke.pipes), ke.pipes = null, ke.pipesCount = 0, ke.flowing = !1, Ve && Ve.emit("unpipe", this, Je), this); if (!Ve) { var dt = ke.pipes, lt = ke.pipesCount; ke.pipes = null, ke.pipesCount = 0, ke.flowing = !1; for (var ht = 0; ht < lt; ht++)dt[ht].emit("unpipe", this, { hasUnpiped: !1 }); return this } var Bt = Ke(ke.pipes, Ve); return Bt === -1 ? this : (ke.pipes.splice(Bt, 1), ke.pipesCount -= 1, ke.pipesCount === 1 && (ke.pipes = ke.pipes[0]), Ve.emit("unpipe", this, Je), this) }, Se.prototype.on = function (Ve, ke) { var Je = u.prototype.on.call(this, Ve, ke), dt = this._readableState; return Ve === "data" ? (dt.readableListening = this.listenerCount("readable") > 0, dt.flowing !== !1 && this.resume()) : Ve === "readable" && !dt.endEmitted && !dt.readableListening && (dt.readableListening = dt.needReadable = !0, dt.flowing = !1, dt.emittedReadable = !1, I("on readable", dt.length, dt.reading), dt.length ? te(this) : dt.reading || process$1.nextTick(me, this)), Je }, Se.prototype.addListener = Se.prototype.on, Se.prototype.removeListener = function (Ve, ke) { var Je = u.prototype.removeListener.call(this, Ve, ke); return Ve === "readable" && process$1.nextTick(ce, this), Je }, Se.prototype.removeAllListeners = function (Ve) { var ke = u.prototype.removeAllListeners.apply(this, arguments); return (Ve === "readable" || Ve === void 0) && process$1.nextTick(ce, this), ke }; function ce(Ve) { var ke = Ve._readableState; ke.readableListening = Ve.listenerCount("readable") > 0, ke.resumeScheduled && !ke.paused ? ke.flowing = !0 : Ve.listenerCount("data") > 0 && Ve.resume() } function me(Ve) { I("readable nexttick read 0"), Ve.read(0) } Se.prototype.resume = function () { var Ve = this._readableState; return Ve.flowing || (I("resume"), Ve.flowing = !Ve.readableListening, Ae(this, Ve)), Ve.paused = !1, this }; function Ae(Ve, ke) { ke.resumeScheduled || (ke.resumeScheduled = !0, process$1.nextTick(Ie, Ve, ke)) } function Ie(Ve, ke) { I("resume", ke.reading), ke.reading || Ve.read(0), ke.resumeScheduled = !1, Ve.emit("resume"), Be(Ve), ke.flowing && !ke.reading && Ve.read(0) } Se.prototype.pause = function () { return I("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (I("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this }; function Be(Ve) { var ke = Ve._readableState; for (I("flow", ke.flowing); ke.flowing && Ve.read() !== null;); } Se.prototype.wrap = function (Ve) { var ke = this, Je = this._readableState, dt = !1; Ve.on("end", function () { if (I("wrapped end"), Je.decoder && !Je.ended) { var Bt = Je.decoder.end(); Bt && Bt.length && ke.push(Bt) } ke.push(null) }), Ve.on("data", function (Bt) { if (I("wrapped data"), Je.decoder && (Bt = Je.decoder.write(Bt)), !(Je.objectMode && Bt == null) && !(!Je.objectMode && (!Bt || !Bt.length))) { var mt = ke.push(Bt); mt || (dt = !0, Ve.pause()) } }); for (var lt in Ve) this[lt] === void 0 && typeof Ve[lt] == "function" && (this[lt] = function (mt) { return function () { return Ve[mt].apply(Ve, arguments) } }(lt)); for (var ht = 0; ht < pe.length; ht++)Ve.on(pe[ht], this.emit.bind(this, pe[ht])); return this._read = function (Bt) { I("wrapped _read", Bt), dt && (dt = !1, Ve.resume()) }, this }, typeof Symbol == "function" && (Se.prototype[Symbol.asyncIterator] = function () { return le === void 0 && (le = requireAsync_iterator()), le(this) }), Object.defineProperty(Se.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), Object.defineProperty(Se.prototype, "readableBuffer", { enumerable: !1, get: function () { return this._readableState && this._readableState.buffer } }), Object.defineProperty(Se.prototype, "readableFlowing", { enumerable: !1, get: function () { return this._readableState.flowing }, set: function (ke) { this._readableState && (this._readableState.flowing = ke) } }), Se._fromList = Me, Object.defineProperty(Se.prototype, "readableLength", { enumerable: !1, get: function () { return this._readableState.length } }); function Me(Ve, ke) { if (ke.length === 0) return null; var Je; return ke.objectMode ? Je = ke.buffer.shift() : !Ve || Ve >= ke.length ? (ke.decoder ? Je = ke.buffer.join("") : ke.buffer.length === 1 ? Je = ke.buffer.first() : Je = ke.buffer.concat(ke.length), ke.buffer.clear()) : Je = ke.buffer.consume(Ve, ke.decoder), Je } function De(Ve) { var ke = Ve._readableState; I("endReadable", ke.endEmitted), ke.endEmitted || (ke.ended = !0, process$1.nextTick(Ue, ke, Ve)) } function Ue(Ve, ke) { if (I("endReadableNT", Ve.endEmitted, Ve.length), !Ve.endEmitted && Ve.length === 0 && (Ve.endEmitted = !0, ke.readable = !1, ke.emit("end"), Ve.autoDestroy)) { var Je = ke._writableState; (!Je || Je.autoDestroy && Je.finished) && ke.destroy() } } typeof Symbol == "function" && (Se.from = function (Ve, ke) { return ue === void 0 && (ue = requireFromBrowser()), ue(Se, Ve, ke) }); function Ke(Ve, ke) { for (var Je = 0, dt = Ve.length; Je < dt; Je++)if (Ve[Je] === ke) return Je; return -1 } return _stream_readable$1 } var _stream_transform$1, hasRequired_stream_transform$1; function require_stream_transform$1() { if (hasRequired_stream_transform$1) return _stream_transform$1; hasRequired_stream_transform$1 = 1, _stream_transform$1 = v; var o = requireErrorsBrowser().codes, l = o.ERR_METHOD_NOT_IMPLEMENTED, u = o.ERR_MULTIPLE_CALLBACK, f = o.ERR_TRANSFORM_ALREADY_TRANSFORMING, p = o.ERR_TRANSFORM_WITH_LENGTH_0, d = require_stream_duplex$1(); requireInherits_browser()(v, d); function m(B, W) { var Z = this._transformState; Z.transforming = !1; var Q = Z.writecb; if (Q === null) return this.emit("error", new u); Z.writechunk = null, Z.writecb = null, W != null && this.push(W), Q(B); var re = this._readableState; re.reading = !1, (re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark) } function v(B) { if (!(this instanceof v)) return new v(B); d.call(this, B), this._transformState = { afterTransform: m.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", I) } function I() { var B = this; typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function (W, Z) { F(B, W, Z) }) : F(this, null, null) } v.prototype.push = function (B, W) { return this._transformState.needTransform = !1, d.prototype.push.call(this, B, W) }, v.prototype._transform = function (B, W, Z) { Z(new l("_transform()")) }, v.prototype._write = function (B, W, Z) { var Q = this._transformState; if (Q.writecb = Z, Q.writechunk = B, Q.writeencoding = W, !Q.transforming) { var re = this._readableState; (Q.needTransform || re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark) } }, v.prototype._read = function (B) { var W = this._transformState; W.writechunk !== null && !W.transforming ? (W.transforming = !0, this._transform(W.writechunk, W.writeencoding, W.afterTransform)) : W.needTransform = !0 }, v.prototype._destroy = function (B, W) { d.prototype._destroy.call(this, B, function (Z) { W(Z) }) }; function F(B, W, Z) { if (W) return B.emit("error", W); if (Z != null && B.push(Z), B._writableState.length) throw new p; if (B._transformState.transforming) throw new f; return B.push(null) } return _stream_transform$1 } var _stream_passthrough$1, hasRequired_stream_passthrough$1; function require_stream_passthrough$1() { if (hasRequired_stream_passthrough$1) return _stream_passthrough$1; hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = l; var o = require_stream_transform$1(); requireInherits_browser()(l, o); function l(u) { if (!(this instanceof l)) return new l(u); o.call(this, u) } return l.prototype._transform = function (u, f, p) { p(null, u) }, _stream_passthrough$1 } var pipeline_1, hasRequiredPipeline; function requirePipeline() { if (hasRequiredPipeline) return pipeline_1; hasRequiredPipeline = 1; var o; function l(Z) { var Q = !1; return function () { Q || (Q = !0, Z.apply(void 0, arguments)) } } var u = requireErrorsBrowser().codes, f = u.ERR_MISSING_ARGS, p = u.ERR_STREAM_DESTROYED; function d(Z) { if (Z) throw Z } function m(Z) { return Z.setHeader && typeof Z.abort == "function" } function v(Z, Q, re, ne) { ne = l(ne); var oe = !1; Z.on("close", function () { oe = !0 }), o === void 0 && (o = requireEndOfStream()), o(Z, { readable: Q, writable: re }, function (se) { if (se) return ne(se); oe = !0, ne() }); var ae = !1; return function (se) { if (!oe && !ae) { if (ae = !0, m(Z)) return Z.abort(); if (typeof Z.destroy == "function") return Z.destroy(); ne(se || new p("pipe")) } } } function I(Z) { Z() } function F(Z, Q) { return Z.pipe(Q) } function B(Z) { return !Z.length || typeof Z[Z.length - 1] != "function" ? d : Z.pop() } function W() { for (var Z = arguments.length, Q = new Array(Z), re = 0; re < Z; re++)Q[re] = arguments[re]; var ne = B(Q); if (Array.isArray(Q[0]) && (Q = Q[0]), Q.length < 2) throw new f("streams"); var oe, ae = Q.map(function (se, le) { var ue = le < Q.length - 1, he = le > 0; return v(se, ue, he, function (pe) { oe || (oe = pe), pe && ae.forEach(I), !ue && (ae.forEach(I), ne(oe)) }) }); return Q.reduce(F) } return pipeline_1 = W, pipeline_1 } var streamBrowserify, hasRequiredStreamBrowserify; function requireStreamBrowserify() { if (hasRequiredStreamBrowserify) return streamBrowserify; hasRequiredStreamBrowserify = 1, streamBrowserify = u; var o = requireEvents().EventEmitter, l = requireInherits_browser(); l(u, o), u.Readable = require_stream_readable$1(), u.Writable = require_stream_writable$1(), u.Duplex = require_stream_duplex$1(), u.Transform = require_stream_transform$1(), u.PassThrough = require_stream_passthrough$1(), u.finished = requireEndOfStream(), u.pipeline = requirePipeline(), u.Stream = u; function u() { o.call(this) } return u.prototype.pipe = function (f, p) { var d = this; function m(Q) { f.writable && f.write(Q) === !1 && d.pause && d.pause() } d.on("data", m); function v() { d.readable && d.resume && d.resume() } f.on("drain", v), !f._isStdio && (!p || p.end !== !1) && (d.on("end", F), d.on("close", B)); var I = !1; function F() { I || (I = !0, f.end()) } function B() { I || (I = !0, typeof f.destroy == "function" && f.destroy()) } function W(Q) { if (Z(), o.listenerCount(this, "error") === 0) throw Q } d.on("error", W), f.on("error", W); function Z() { d.removeListener("data", m), f.removeListener("drain", v), d.removeListener("end", F), d.removeListener("close", B), d.removeListener("error", W), f.removeListener("error", W), d.removeListener("end", Z), d.removeListener("close", Z), f.removeListener("close", Z) } return d.on("end", Z), d.on("close", Z), f.on("close", Z), f.emit("pipe", d), f }, streamBrowserify } var hashBase, hasRequiredHashBase; function requireHashBase() { if (hasRequiredHashBase) return hashBase; hasRequiredHashBase = 1; var o = requireSafeBuffer$1().Buffer, l = requireStreamBrowserify().Transform, u = requireInherits_browser(); function f(d, m) { if (!o.isBuffer(d) && typeof d != "string") throw new TypeError(m + " must be a string or a buffer") } function p(d) { l.call(this), this._block = o.allocUnsafe(d), this._blockSize = d, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1 } return u(p, l), p.prototype._transform = function (d, m, v) { var I = null; try { this.update(d, m) } catch (F) { I = F } v(I) }, p.prototype._flush = function (d) { var m = null; try { this.push(this.digest()) } catch (v) { m = v } d(m) }, p.prototype.update = function (d, m) { if (f(d, "Data"), this._finalized) throw new Error("Digest already called"); o.isBuffer(d) || (d = o.from(d, m)); for (var v = this._block, I = 0; this._blockOffset + d.length - I >= this._blockSize;) { for (var F = this._blockOffset; F < this._blockSize;)v[F++] = d[I++]; this._update(), this._blockOffset = 0 } for (; I < d.length;)v[this._blockOffset++] = d[I++]; for (var B = 0, W = d.length * 8; W > 0; ++B)this._length[B] += W, W = this._length[B] / 4294967296 | 0, W > 0 && (this._length[B] -= 4294967296 * W); return this }, p.prototype._update = function () { throw new Error("_update is not implemented") }, p.prototype.digest = function (d) { if (this._finalized) throw new Error("Digest already called"); this._finalized = !0; var m = this._digest(); d !== void 0 && (m = m.toString(d)), this._block.fill(0), this._blockOffset = 0; for (var v = 0; v < 4; ++v)this._length[v] = 0; return m }, p.prototype._digest = function () { throw new Error("_digest is not implemented") }, hashBase = p, hashBase } var md5_js, hasRequiredMd5_js; function requireMd5_js() { if (hasRequiredMd5_js) return md5_js; hasRequiredMd5_js = 1; var o = requireInherits_browser(), l = requireHashBase(), u = requireSafeBuffer$1().Buffer, f = new Array(16); function p() { l.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878 } o(p, l), p.prototype._update = function () { for (var B = f, W = 0; W < 16; ++W)B[W] = this._block.readInt32LE(W * 4); var Z = this._a, Q = this._b, re = this._c, ne = this._d; Z = m(Z, Q, re, ne, B[0], 3614090360, 7), ne = m(ne, Z, Q, re, B[1], 3905402710, 12), re = m(re, ne, Z, Q, B[2], 606105819, 17), Q = m(Q, re, ne, Z, B[3], 3250441966, 22), Z = m(Z, Q, re, ne, B[4], 4118548399, 7), ne = m(ne, Z, Q, re, B[5], 1200080426, 12), re = m(re, ne, Z, Q, B[6], 2821735955, 17), Q = m(Q, re, ne, Z, B[7], 4249261313, 22), Z = m(Z, Q, re, ne, B[8], 1770035416, 7), ne = m(ne, Z, Q, re, B[9], 2336552879, 12), re = m(re, ne, Z, Q, B[10], 4294925233, 17), Q = m(Q, re, ne, Z, B[11], 2304563134, 22), Z = m(Z, Q, re, ne, B[12], 1804603682, 7), ne = m(ne, Z, Q, re, B[13], 4254626195, 12), re = m(re, ne, Z, Q, B[14], 2792965006, 17), Q = m(Q, re, ne, Z, B[15], 1236535329, 22), Z = v(Z, Q, re, ne, B[1], 4129170786, 5), ne = v(ne, Z, Q, re, B[6], 3225465664, 9), re = v(re, ne, Z, Q, B[11], 643717713, 14), Q = v(Q, re, ne, Z, B[0], 3921069994, 20), Z = v(Z, Q, re, ne, B[5], 3593408605, 5), ne = v(ne, Z, Q, re, B[10], 38016083, 9), re = v(re, ne, Z, Q, B[15], 3634488961, 14), Q = v(Q, re, ne, Z, B[4], 3889429448, 20), Z = v(Z, Q, re, ne, B[9], 568446438, 5), ne = v(ne, Z, Q, re, B[14], 3275163606, 9), re = v(re, ne, Z, Q, B[3], 4107603335, 14), Q = v(Q, re, ne, Z, B[8], 1163531501, 20), Z = v(Z, Q, re, ne, B[13], 2850285829, 5), ne = v(ne, Z, Q, re, B[2], 4243563512, 9), re = v(re, ne, Z, Q, B[7], 1735328473, 14), Q = v(Q, re, ne, Z, B[12], 2368359562, 20), Z = I(Z, Q, re, ne, B[5], 4294588738, 4), ne = I(ne, Z, Q, re, B[8], 2272392833, 11), re = I(re, ne, Z, Q, B[11], 1839030562, 16), Q = I(Q, re, ne, Z, B[14], 4259657740, 23), Z = I(Z, Q, re, ne, B[1], 2763975236, 4), ne = I(ne, Z, Q, re, B[4], 1272893353, 11), re = I(re, ne, Z, Q, B[7], 4139469664, 16), Q = I(Q, re, ne, Z, B[10], 3200236656, 23), Z = I(Z, Q, re, ne, B[13], 681279174, 4), ne = I(ne, Z, Q, re, B[0], 3936430074, 11), re = I(re, ne, Z, Q, B[3], 3572445317, 16), Q = I(Q, re, ne, Z, B[6], 76029189, 23), Z = I(Z, Q, re, ne, B[9], 3654602809, 4), ne = I(ne, Z, Q, re, B[12], 3873151461, 11), re = I(re, ne, Z, Q, B[15], 530742520, 16), Q = I(Q, re, ne, Z, B[2], 3299628645, 23), Z = F(Z, Q, re, ne, B[0], 4096336452, 6), ne = F(ne, Z, Q, re, B[7], 1126891415, 10), re = F(re, ne, Z, Q, B[14], 2878612391, 15), Q = F(Q, re, ne, Z, B[5], 4237533241, 21), Z = F(Z, Q, re, ne, B[12], 1700485571, 6), ne = F(ne, Z, Q, re, B[3], 2399980690, 10), re = F(re, ne, Z, Q, B[10], 4293915773, 15), Q = F(Q, re, ne, Z, B[1], 2240044497, 21), Z = F(Z, Q, re, ne, B[8], 1873313359, 6), ne = F(ne, Z, Q, re, B[15], 4264355552, 10), re = F(re, ne, Z, Q, B[6], 2734768916, 15), Q = F(Q, re, ne, Z, B[13], 1309151649, 21), Z = F(Z, Q, re, ne, B[4], 4149444226, 6), ne = F(ne, Z, Q, re, B[11], 3174756917, 10), re = F(re, ne, Z, Q, B[2], 718787259, 15), Q = F(Q, re, ne, Z, B[9], 3951481745, 21), this._a = this._a + Z | 0, this._b = this._b + Q | 0, this._c = this._c + re | 0, this._d = this._d + ne | 0 }, p.prototype._digest = function () { this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update(); var B = u.allocUnsafe(16); return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B }; function d(B, W) { return B << W | B >>> 32 - W } function m(B, W, Z, Q, re, ne, oe) { return d(B + (W & Z | ~W & Q) + re + ne | 0, oe) + W | 0 } function v(B, W, Z, Q, re, ne, oe) { return d(B + (W & Q | Z & ~Q) + re + ne | 0, oe) + W | 0 } function I(B, W, Z, Q, re, ne, oe) { return d(B + (W ^ Z ^ Q) + re + ne | 0, oe) + W | 0 } function F(B, W, Z, Q, re, ne, oe) { return d(B + (Z ^ (W | ~Q)) + re + ne | 0, oe) + W | 0 } return md5_js = p, md5_js } var ripemd160, hasRequiredRipemd160; function requireRipemd160() { if (hasRequiredRipemd160) return ripemd160; hasRequiredRipemd160 = 1; var o = requireDist$2().Buffer, l = requireInherits_browser(), u = requireHashBase(), f = new Array(16), p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], d = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], m = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], v = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], I = [0, 1518500249, 1859775393, 2400959708, 2840853838], F = [1352829926, 1548603684, 1836072691, 2053994217, 0]; function B() { u.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520 } l(B, u), B.prototype._update = function () { for (var ae = f, se = 0; se < 16; ++se)ae[se] = this._block.readInt32LE(se * 4); for (var le = this._a | 0, ue = this._b | 0, he = this._c | 0, pe = this._d | 0, ve = this._e | 0, _e = this._a | 0, Se = this._b | 0, $e = this._c | 0, ie = this._d | 0, g = this._e | 0, P = 0; P < 80; P += 1) { var U, K; P < 16 ? (U = Z(le, ue, he, pe, ve, ae[p[P]], I[0], m[P]), K = oe(_e, Se, $e, ie, g, ae[d[P]], F[0], v[P])) : P < 32 ? (U = Q(le, ue, he, pe, ve, ae[p[P]], I[1], m[P]), K = ne(_e, Se, $e, ie, g, ae[d[P]], F[1], v[P])) : P < 48 ? (U = re(le, ue, he, pe, ve, ae[p[P]], I[2], m[P]), K = re(_e, Se, $e, ie, g, ae[d[P]], F[2], v[P])) : P < 64 ? (U = ne(le, ue, he, pe, ve, ae[p[P]], I[3], m[P]), K = Q(_e, Se, $e, ie, g, ae[d[P]], F[3], v[P])) : (U = oe(le, ue, he, pe, ve, ae[p[P]], I[4], m[P]), K = Z(_e, Se, $e, ie, g, ae[d[P]], F[4], v[P])), le = ve, ve = pe, pe = W(he, 10), he = ue, ue = U, _e = g, g = ie, ie = W($e, 10), $e = Se, Se = K } var Y = this._b + he + ie | 0; this._b = this._c + pe + g | 0, this._c = this._d + ve + _e | 0, this._d = this._e + le + Se | 0, this._e = this._a + ue + $e | 0, this._a = Y }, B.prototype._digest = function () { this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update(); var ae = o.alloc ? o.alloc(20) : new o(20); return ae.writeInt32LE(this._a, 0), ae.writeInt32LE(this._b, 4), ae.writeInt32LE(this._c, 8), ae.writeInt32LE(this._d, 12), ae.writeInt32LE(this._e, 16), ae }; function W(ae, se) { return ae << se | ae >>> 32 - se } function Z(ae, se, le, ue, he, pe, ve, _e) { return W(ae + (se ^ le ^ ue) + pe + ve | 0, _e) + he | 0 } function Q(ae, se, le, ue, he, pe, ve, _e) { return W(ae + (se & le | ~se & ue) + pe + ve | 0, _e) + he | 0 } function re(ae, se, le, ue, he, pe, ve, _e) { return W(ae + ((se | ~le) ^ ue) + pe + ve | 0, _e) + he | 0 } function ne(ae, se, le, ue, he, pe, ve, _e) { return W(ae + (se & ue | le & ~ue) + pe + ve | 0, _e) + he | 0 } function oe(ae, se, le, ue, he, pe, ve, _e) { return W(ae + (se ^ (le | ~ue)) + pe + ve | 0, _e) + he | 0 } return ripemd160 = B, ripemd160 } var sha_js = { exports: {} }, hash$1, hasRequiredHash$1; function requireHash$1() { if (hasRequiredHash$1) return hash$1; hasRequiredHash$1 = 1; var o = requireSafeBuffer$1().Buffer; function l(u, f) { this._block = o.alloc(u), this._finalSize = f, this._blockSize = u, this._len = 0 } return l.prototype.update = function (u, f) { typeof u == "string" && (f = f || "utf8", u = o.from(u, f)); for (var p = this._block, d = this._blockSize, m = u.length, v = this._len, I = 0; I < m;) { for (var F = v % d, B = Math.min(m - I, d - F), W = 0; W < B; W++)p[F + W] = u[I + W]; v += B, I += B, v % d === 0 && this._update(p) } return this._len += m, this }, l.prototype.digest = function (u) { var f = this._len % this._blockSize; this._block[f] = 128, this._block.fill(0, f + 1), f >= this._finalSize && (this._update(this._block), this._block.fill(0)); var p = this._len * 8; if (p <= 4294967295) this._block.writeUInt32BE(p, this._blockSize - 4); else { var d = (p & 4294967295) >>> 0, m = (p - d) / 4294967296; this._block.writeUInt32BE(m, this._blockSize - 8), this._block.writeUInt32BE(d, this._blockSize - 4) } this._update(this._block); var v = this._hash(); return u ? v.toString(u) : v }, l.prototype._update = function () { throw new Error("_update must be implemented by subclass") }, hash$1 = l, hash$1 } var sha$1, hasRequiredSha$1; function requireSha$1() { if (hasRequiredSha$1) return sha$1; hasRequiredSha$1 = 1; var o = requireInherits_browser(), l = requireHash$1(), u = requireSafeBuffer$1().Buffer, f = [1518500249, 1859775393, -1894007588, -899497514], p = new Array(80); function d() { this.init(), this._w = p, l.call(this, 64, 56) } o(d, l), d.prototype.init = function () { return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this }; function m(F) { return F << 5 | F >>> 27 } function v(F) { return F << 30 | F >>> 2 } function I(F, B, W, Z) { return F === 0 ? B & W | ~B & Z : F === 2 ? B & W | B & Z | W & Z : B ^ W ^ Z } return d.prototype._update = function (F) { for (var B = this._w, W = this._a | 0, Z = this._b | 0, Q = this._c | 0, re = this._d | 0, ne = this._e | 0, oe = 0; oe < 16; ++oe)B[oe] = F.readInt32BE(oe * 4); for (; oe < 80; ++oe)B[oe] = B[oe - 3] ^ B[oe - 8] ^ B[oe - 14] ^ B[oe - 16]; for (var ae = 0; ae < 80; ++ae) { var se = ~~(ae / 20), le = m(W) + I(se, Z, Q, re) + ne + B[ae] + f[se] | 0; ne = re, re = Q, Q = v(Z), Z = W, W = le } this._a = W + this._a | 0, this._b = Z + this._b | 0, this._c = Q + this._c | 0, this._d = re + this._d | 0, this._e = ne + this._e | 0 }, d.prototype._hash = function () { var F = u.allocUnsafe(20); return F.writeInt32BE(this._a | 0, 0), F.writeInt32BE(this._b | 0, 4), F.writeInt32BE(this._c | 0, 8), F.writeInt32BE(this._d | 0, 12), F.writeInt32BE(this._e | 0, 16), F }, sha$1 = d, sha$1 } var sha1, hasRequiredSha1; function requireSha1() { if (hasRequiredSha1) return sha1; hasRequiredSha1 = 1; var o = requireInherits_browser(), l = requireHash$1(), u = requireSafeBuffer$1().Buffer, f = [1518500249, 1859775393, -1894007588, -899497514], p = new Array(80); function d() { this.init(), this._w = p, l.call(this, 64, 56) } o(d, l), d.prototype.init = function () { return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this }; function m(B) { return B << 1 | B >>> 31 } function v(B) { return B << 5 | B >>> 27 } function I(B) { return B << 30 | B >>> 2 } function F(B, W, Z, Q) { return B === 0 ? W & Z | ~W & Q : B === 2 ? W & Z | W & Q | Z & Q : W ^ Z ^ Q } return d.prototype._update = function (B) { for (var W = this._w, Z = this._a | 0, Q = this._b | 0, re = this._c | 0, ne = this._d | 0, oe = this._e | 0, ae = 0; ae < 16; ++ae)W[ae] = B.readInt32BE(ae * 4); for (; ae < 80; ++ae)W[ae] = m(W[ae - 3] ^ W[ae - 8] ^ W[ae - 14] ^ W[ae - 16]); for (var se = 0; se < 80; ++se) { var le = ~~(se / 20), ue = v(Z) + F(le, Q, re, ne) + oe + W[se] + f[le] | 0; oe = ne, ne = re, re = I(Q), Q = Z, Z = ue } this._a = Z + this._a | 0, this._b = Q + this._b | 0, this._c = re + this._c | 0, this._d = ne + this._d | 0, this._e = oe + this._e | 0 }, d.prototype._hash = function () { var B = u.allocUnsafe(20); return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B }, sha1 = d, sha1 } var sha256$1, hasRequiredSha256; function requireSha256() { if (hasRequiredSha256) return sha256$1; hasRequiredSha256 = 1; var o = requireInherits_browser(), l = requireHash$1(), u = requireSafeBuffer$1().Buffer, f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], p = new Array(64); function d() { this.init(), this._w = p, l.call(this, 64, 56) } o(d, l), d.prototype.init = function () { return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this }; function m(Z, Q, re) { return re ^ Z & (Q ^ re) } function v(Z, Q, re) { return Z & Q | re & (Z | Q) } function I(Z) { return (Z >>> 2 | Z << 30) ^ (Z >>> 13 | Z << 19) ^ (Z >>> 22 | Z << 10) } function F(Z) { return (Z >>> 6 | Z << 26) ^ (Z >>> 11 | Z << 21) ^ (Z >>> 25 | Z << 7) } function B(Z) { return (Z >>> 7 | Z << 25) ^ (Z >>> 18 | Z << 14) ^ Z >>> 3 } function W(Z) { return (Z >>> 17 | Z << 15) ^ (Z >>> 19 | Z << 13) ^ Z >>> 10 } return d.prototype._update = function (Z) { for (var Q = this._w, re = this._a | 0, ne = this._b | 0, oe = this._c | 0, ae = this._d | 0, se = this._e | 0, le = this._f | 0, ue = this._g | 0, he = this._h | 0, pe = 0; pe < 16; ++pe)Q[pe] = Z.readInt32BE(pe * 4); for (; pe < 64; ++pe)Q[pe] = W(Q[pe - 2]) + Q[pe - 7] + B(Q[pe - 15]) + Q[pe - 16] | 0; for (var ve = 0; ve < 64; ++ve) { var _e = he + F(se) + m(se, le, ue) + f[ve] + Q[ve] | 0, Se = I(re) + v(re, ne, oe) | 0; he = ue, ue = le, le = se, se = ae + _e | 0, ae = oe, oe = ne, ne = re, re = _e + Se | 0 } this._a = re + this._a | 0, this._b = ne + this._b | 0, this._c = oe + this._c | 0, this._d = ae + this._d | 0, this._e = se + this._e | 0, this._f = le + this._f | 0, this._g = ue + this._g | 0, this._h = he + this._h | 0 }, d.prototype._hash = function () { var Z = u.allocUnsafe(32); return Z.writeInt32BE(this._a, 0), Z.writeInt32BE(this._b, 4), Z.writeInt32BE(this._c, 8), Z.writeInt32BE(this._d, 12), Z.writeInt32BE(this._e, 16), Z.writeInt32BE(this._f, 20), Z.writeInt32BE(this._g, 24), Z.writeInt32BE(this._h, 28), Z }, sha256$1 = d, sha256$1 } var sha224$1, hasRequiredSha224; function requireSha224() { if (hasRequiredSha224) return sha224$1; hasRequiredSha224 = 1; var o = requireInherits_browser(), l = requireSha256(), u = requireHash$1(), f = requireSafeBuffer$1().Buffer, p = new Array(64); function d() { this.init(), this._w = p, u.call(this, 64, 56) } return o(d, l), d.prototype.init = function () { return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this }, d.prototype._hash = function () { var m = f.allocUnsafe(28); return m.writeInt32BE(this._a, 0), m.writeInt32BE(this._b, 4), m.writeInt32BE(this._c, 8), m.writeInt32BE(this._d, 12), m.writeInt32BE(this._e, 16), m.writeInt32BE(this._f, 20), m.writeInt32BE(this._g, 24), m }, sha224$1 = d, sha224$1 } var sha512$1, hasRequiredSha512; function requireSha512() { if (hasRequiredSha512) return sha512$1; hasRequiredSha512 = 1; var o = requireInherits_browser(), l = requireHash$1(), u = requireSafeBuffer$1().Buffer, f = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], p = new Array(160); function d() { this.init(), this._w = p, l.call(this, 128, 112) } o(d, l), d.prototype.init = function () { return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this }; function m(ne, oe, ae) { return ae ^ ne & (oe ^ ae) } function v(ne, oe, ae) { return ne & oe | ae & (ne | oe) } function I(ne, oe) { return (ne >>> 28 | oe << 4) ^ (oe >>> 2 | ne << 30) ^ (oe >>> 7 | ne << 25) } function F(ne, oe) { return (ne >>> 14 | oe << 18) ^ (ne >>> 18 | oe << 14) ^ (oe >>> 9 | ne << 23) } function B(ne, oe) { return (ne >>> 1 | oe << 31) ^ (ne >>> 8 | oe << 24) ^ ne >>> 7 } function W(ne, oe) { return (ne >>> 1 | oe << 31) ^ (ne >>> 8 | oe << 24) ^ (ne >>> 7 | oe << 25) } function Z(ne, oe) { return (ne >>> 19 | oe << 13) ^ (oe >>> 29 | ne << 3) ^ ne >>> 6 } function Q(ne, oe) { return (ne >>> 19 | oe << 13) ^ (oe >>> 29 | ne << 3) ^ (ne >>> 6 | oe << 26) } function re(ne, oe) { return ne >>> 0 < oe >>> 0 ? 1 : 0 } return d.prototype._update = function (ne) { for (var oe = this._w, ae = this._ah | 0, se = this._bh | 0, le = this._ch | 0, ue = this._dh | 0, he = this._eh | 0, pe = this._fh | 0, ve = this._gh | 0, _e = this._hh | 0, Se = this._al | 0, $e = this._bl | 0, ie = this._cl | 0, g = this._dl | 0, P = this._el | 0, U = this._fl | 0, K = this._gl | 0, Y = this._hl | 0, te = 0; te < 32; te += 2)oe[te] = ne.readInt32BE(te * 4), oe[te + 1] = ne.readInt32BE(te * 4 + 4); for (; te < 160; te += 2) { var ee = oe[te - 30], G = oe[te - 15 * 2 + 1], y = B(ee, G), X = W(G, ee); ee = oe[te - 2 * 2], G = oe[te - 2 * 2 + 1]; var ce = Z(ee, G), me = Q(G, ee), Ae = oe[te - 7 * 2], Ie = oe[te - 7 * 2 + 1], Be = oe[te - 16 * 2], Me = oe[te - 16 * 2 + 1], De = X + Ie | 0, Ue = y + Ae + re(De, X) | 0; De = De + me | 0, Ue = Ue + ce + re(De, me) | 0, De = De + Me | 0, Ue = Ue + Be + re(De, Me) | 0, oe[te] = Ue, oe[te + 1] = De } for (var Ke = 0; Ke < 160; Ke += 2) { Ue = oe[Ke], De = oe[Ke + 1]; var Ve = v(ae, se, le), ke = v(Se, $e, ie), Je = I(ae, Se), dt = I(Se, ae), lt = F(he, P), ht = F(P, he), Bt = f[Ke], mt = f[Ke + 1], et = m(he, pe, ve), Gt = m(P, U, K), pt = Y + ht | 0, _t = _e + lt + re(pt, Y) | 0; pt = pt + Gt | 0, _t = _t + et + re(pt, Gt) | 0, pt = pt + mt | 0, _t = _t + Bt + re(pt, mt) | 0, pt = pt + De | 0, _t = _t + Ue + re(pt, De) | 0; var zt = dt + ke | 0, bt = Je + Ve + re(zt, dt) | 0; _e = ve, Y = K, ve = pe, K = U, pe = he, U = P, P = g + pt | 0, he = ue + _t + re(P, g) | 0, ue = le, g = ie, le = se, ie = $e, se = ae, $e = Se, Se = pt + zt | 0, ae = _t + bt + re(Se, pt) | 0 } this._al = this._al + Se | 0, this._bl = this._bl + $e | 0, this._cl = this._cl + ie | 0, this._dl = this._dl + g | 0, this._el = this._el + P | 0, this._fl = this._fl + U | 0, this._gl = this._gl + K | 0, this._hl = this._hl + Y | 0, this._ah = this._ah + ae + re(this._al, Se) | 0, this._bh = this._bh + se + re(this._bl, $e) | 0, this._ch = this._ch + le + re(this._cl, ie) | 0, this._dh = this._dh + ue + re(this._dl, g) | 0, this._eh = this._eh + he + re(this._el, P) | 0, this._fh = this._fh + pe + re(this._fl, U) | 0, this._gh = this._gh + ve + re(this._gl, K) | 0, this._hh = this._hh + _e + re(this._hl, Y) | 0 }, d.prototype._hash = function () { var ne = u.allocUnsafe(64); function oe(ae, se, le) { ne.writeInt32BE(ae, le), ne.writeInt32BE(se, le + 4) } return oe(this._ah, this._al, 0), oe(this._bh, this._bl, 8), oe(this._ch, this._cl, 16), oe(this._dh, this._dl, 24), oe(this._eh, this._el, 32), oe(this._fh, this._fl, 40), oe(this._gh, this._gl, 48), oe(this._hh, this._hl, 56), ne }, sha512$1 = d, sha512$1 } var sha384$1, hasRequiredSha384; function requireSha384() { if (hasRequiredSha384) return sha384$1; hasRequiredSha384 = 1; var o = requireInherits_browser(), l = requireSha512(), u = requireHash$1(), f = requireSafeBuffer$1().Buffer, p = new Array(160); function d() { this.init(), this._w = p, u.call(this, 128, 112) } return o(d, l), d.prototype.init = function () { return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this }, d.prototype._hash = function () { var m = f.allocUnsafe(48); function v(I, F, B) { m.writeInt32BE(I, B), m.writeInt32BE(F, B + 4) } return v(this._ah, this._al, 0), v(this._bh, this._bl, 8), v(this._ch, this._cl, 16), v(this._dh, this._dl, 24), v(this._eh, this._el, 32), v(this._fh, this._fl, 40), m }, sha384$1 = d, sha384$1 } var hasRequiredSha_js; function requireSha_js() { if (hasRequiredSha_js) return sha_js.exports; hasRequiredSha_js = 1; var o = sha_js.exports = function (u) { u = u.toLowerCase(); var f = o[u]; if (!f) throw new Error(u + " is not supported (we accept pull requests)"); return new f }; return o.sha = requireSha$1(), o.sha1 = requireSha1(), o.sha224 = requireSha224(), o.sha256 = requireSha256(), o.sha384 = requireSha384(), o.sha512 = requireSha512(), sha_js.exports } var cipherBase, hasRequiredCipherBase; function requireCipherBase() { if (hasRequiredCipherBase) return cipherBase; hasRequiredCipherBase = 1; var o = requireSafeBuffer$1().Buffer, l = requireStreamBrowserify().Transform, u = requireString_decoder().StringDecoder, f = requireInherits_browser(); function p(d) { l.call(this), this.hashMode = typeof d == "string", this.hashMode ? this[d] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null } return f(p, l), p.prototype.update = function (d, m, v) { typeof d == "string" && (d = o.from(d, m)); var I = this._update(d); return this.hashMode ? this : (v && (I = this._toString(I, v)), I) }, p.prototype.setAutoPadding = function () { }, p.prototype.getAuthTag = function () { throw new Error("trying to get auth tag in unsupported state") }, p.prototype.setAuthTag = function () { throw new Error("trying to set auth tag in unsupported state") }, p.prototype.setAAD = function () { throw new Error("trying to set aad in unsupported state") }, p.prototype._transform = function (d, m, v) { var I; try { this.hashMode ? this._update(d) : this.push(this._update(d)) } catch (F) { I = F } finally { v(I) } }, p.prototype._flush = function (d) { var m; try { this.push(this.__final()) } catch (v) { m = v } d(m) }, p.prototype._finalOrDigest = function (d) { var m = this.__final() || o.alloc(0); return d && (m = this._toString(m, d, !0)), m }, p.prototype._toString = function (d, m, v) { if (this._decoder || (this._decoder = new u(m), this._encoding = m), this._encoding !== m) throw new Error("can't switch encodings"); var I = this._decoder.write(d); return v && (I += this._decoder.end()), I }, cipherBase = p, cipherBase } var browser$a, hasRequiredBrowser$9; function requireBrowser$9() { if (hasRequiredBrowser$9) return browser$a; hasRequiredBrowser$9 = 1; var o = requireInherits_browser(), l = requireMd5_js(), u = requireRipemd160(), f = requireSha_js(), p = requireCipherBase(); function d(m) { p.call(this, "digest"), this._hash = m } return o(d, p), d.prototype._update = function (m) { this._hash.update(m) }, d.prototype._final = function () { return this._hash.digest() }, browser$a = function (v) { return v = v.toLowerCase(), v === "md5" ? new l : v === "rmd160" || v === "ripemd160" ? new u : new d(f(v)) }, browser$a } var legacy, hasRequiredLegacy; function requireLegacy() { if (hasRequiredLegacy) return legacy; hasRequiredLegacy = 1; var o = requireInherits_browser(), l = requireSafeBuffer$1().Buffer, u = requireCipherBase(), f = l.alloc(128), p = 64; function d(m, v) { u.call(this, "digest"), typeof v == "string" && (v = l.from(v)), this._alg = m, this._key = v, v.length > p ? v = m(v) : v.length < p && (v = l.concat([v, f], p)); for (var I = this._ipad = l.allocUnsafe(p), F = this._opad = l.allocUnsafe(p), B = 0; B < p; B++)I[B] = v[B] ^ 54, F[B] = v[B] ^ 92; this._hash = [I] } return o(d, u), d.prototype._update = function (m) { this._hash.push(m) }, d.prototype._final = function () { var m = this._alg(l.concat(this._hash)); return this._alg(l.concat([this._opad, m])) }, legacy = d, legacy } var md5, hasRequiredMd5; function requireMd5() { if (hasRequiredMd5) return md5; hasRequiredMd5 = 1; var o = requireMd5_js(); return md5 = function (l) { return new o().update(l).digest() }, md5 } var browser$9, hasRequiredBrowser$8; function requireBrowser$8() { if (hasRequiredBrowser$8) return browser$9; hasRequiredBrowser$8 = 1; var o = requireInherits_browser(), l = requireLegacy(), u = requireCipherBase(), f = requireSafeBuffer$1().Buffer, p = requireMd5(), d = requireRipemd160(), m = requireSha_js(), v = f.alloc(128); function I(F, B) { u.call(this, "digest"), typeof B == "string" && (B = f.from(B)); var W = F === "sha512" || F === "sha384" ? 128 : 64; if (this._alg = F, this._key = B, B.length > W) { var Z = F === "rmd160" ? new d : m(F); B = Z.update(B).digest() } else B.length < W && (B = f.concat([B, v], W)); for (var Q = this._ipad = f.allocUnsafe(W), re = this._opad = f.allocUnsafe(W), ne = 0; ne < W; ne++)Q[ne] = B[ne] ^ 54, re[ne] = B[ne] ^ 92; this._hash = F === "rmd160" ? new d : m(F), this._hash.update(Q) } return o(I, u), I.prototype._update = function (F) { this._hash.update(F) }, I.prototype._final = function () { var F = this._hash.digest(), B = this._alg === "rmd160" ? new d : m(this._alg); return B.update(this._opad).update(F).digest() }, browser$9 = function (B, W) { return B = B.toLowerCase(), B === "rmd160" || B === "ripemd160" ? new I("rmd160", W) : B === "md5" ? new l(p, W) : new I(B, W) }, browser$9 } const sha224WithRSAEncryption = { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption = { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption = { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption = { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, sha256 = { sign: "ecdsa", hash: "sha256", id: "" }, sha224 = { sign: "ecdsa", hash: "sha224", id: "" }, sha384 = { sign: "ecdsa", hash: "sha384", id: "" }, sha512 = { sign: "ecdsa", hash: "sha512", id: "" }, DSA = { sign: "dsa", hash: "sha1", id: "" }, ripemd160WithRSA = { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption = { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, require$$6 = { sha224WithRSAEncryption, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256, sha224, sha384, sha512, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } }; var algos, hasRequiredAlgos; function requireAlgos() { return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos } var browser$8 = {}, precondition, hasRequiredPrecondition; function requirePrecondition() { if (hasRequiredPrecondition) return precondition; hasRequiredPrecondition = 1; var o = Math.pow(2, 30) - 1; return precondition = function (l, u) { if (typeof l != "number") throw new TypeError("Iterations not a number"); if (l < 0) throw new TypeError("Bad iterations"); if (typeof u != "number") throw new TypeError("Key length not a number"); if (u < 0 || u > o || u !== u) throw new TypeError("Bad key length") }, precondition } var defaultEncoding_1, hasRequiredDefaultEncoding; function requireDefaultEncoding() { if (hasRequiredDefaultEncoding) return defaultEncoding_1; hasRequiredDefaultEncoding = 1; var o; if (commonjsGlobal.process && commonjsGlobal.process.browser) o = "utf-8"; else if (commonjsGlobal.process && commonjsGlobal.process.version) { var l = parseInt(process$1.version.split(".")[0].slice(1), 10); o = l >= 6 ? "utf-8" : "binary" } else o = "utf-8"; return defaultEncoding_1 = o, defaultEncoding_1 } var toBuffer, hasRequiredToBuffer; function requireToBuffer() { if (hasRequiredToBuffer) return toBuffer; hasRequiredToBuffer = 1; var o = requireSafeBuffer$1().Buffer; return toBuffer = function (l, u, f) { if (o.isBuffer(l)) return l; if (typeof l == "string") return o.from(l, u); if (ArrayBuffer.isView(l)) return o.from(l.buffer); throw new TypeError(f + " must be a string, a Buffer, a typed array or a DataView") }, toBuffer } var syncBrowser, hasRequiredSyncBrowser; function requireSyncBrowser() { if (hasRequiredSyncBrowser) return syncBrowser; hasRequiredSyncBrowser = 1; var o = requireMd5(), l = requireRipemd160(), u = requireSha_js(), f = requireSafeBuffer$1().Buffer, p = requirePrecondition(), d = requireDefaultEncoding(), m = requireToBuffer(), v = f.alloc(128), I = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }; function F(Z, Q, re) { var ne = B(Z), oe = Z === "sha512" || Z === "sha384" ? 128 : 64; Q.length > oe ? Q = ne(Q) : Q.length < oe && (Q = f.concat([Q, v], oe)); for (var ae = f.allocUnsafe(oe + I[Z]), se = f.allocUnsafe(oe + I[Z]), le = 0; le < oe; le++)ae[le] = Q[le] ^ 54, se[le] = Q[le] ^ 92; var ue = f.allocUnsafe(oe + re + 4); ae.copy(ue, 0, 0, oe), this.ipad1 = ue, this.ipad2 = ae, this.opad = se, this.alg = Z, this.blocksize = oe, this.hash = ne, this.size = I[Z] } F.prototype.run = function (Z, Q) { Z.copy(Q, this.blocksize); var re = this.hash(Q); return re.copy(this.opad, this.blocksize), this.hash(this.opad) }; function B(Z) { function Q(ne) { return u(Z).update(ne).digest() } function re(ne) { return new l().update(ne).digest() } return Z === "rmd160" || Z === "ripemd160" ? re : Z === "md5" ? o : Q } function W(Z, Q, re, ne, oe) { p(re, ne), Z = m(Z, d, "Password"), Q = m(Q, d, "Salt"), oe = oe || "sha1"; var ae = new F(oe, Z, Q.length), se = f.allocUnsafe(ne), le = f.allocUnsafe(Q.length + 4); Q.copy(le, 0, 0, Q.length); for (var ue = 0, he = I[oe], pe = Math.ceil(ne / he), ve = 1; ve <= pe; ve++) { le.writeUInt32BE(ve, Q.length); for (var _e = ae.run(le, ae.ipad1), Se = _e, $e = 1; $e < re; $e++) { Se = ae.run(Se, ae.ipad2); for (var ie = 0; ie < he; ie++)_e[ie] ^= Se[ie] } _e.copy(se, ue), ue += he } return se } return syncBrowser = W, syncBrowser } var async, hasRequiredAsync; function requireAsync() { if (hasRequiredAsync) return async; hasRequiredAsync = 1; var o = requireSafeBuffer$1().Buffer, l = requirePrecondition(), u = requireDefaultEncoding(), f = requireSyncBrowser(), p = requireToBuffer(), d, m = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, v = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, I = []; function F(re) { if (commonjsGlobal.process && !commonjsGlobal.process.browser || !m || !m.importKey || !m.deriveBits) return Promise.resolve(!1); if (I[re] !== void 0) return I[re]; d = d || o.alloc(8); var ne = Z(d, d, 10, 128, re).then(function () { return !0 }).catch(function () { return !1 }); return I[re] = ne, ne } var B; function W() { return B || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? B = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? B = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? B = commonjsGlobal.setImmediate : B = commonjsGlobal.setTimeout, B) } function Z(re, ne, oe, ae, se) { return m.importKey("raw", re, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function (le) { return m.deriveBits({ name: "PBKDF2", salt: ne, iterations: oe, hash: { name: se } }, le, ae << 3) }).then(function (le) { return o.from(le) }) } function Q(re, ne) { re.then(function (oe) { W()(function () { ne(null, oe) }) }, function (oe) { W()(function () { ne(oe) }) }) } return async = function (re, ne, oe, ae, se, le) { typeof se == "function" && (le = se, se = void 0), se = se || "sha1"; var ue = v[se.toLowerCase()]; if (!ue || typeof commonjsGlobal.Promise != "function") { W()(function () { var he; try { he = f(re, ne, oe, ae, se) } catch (pe) { return le(pe) } le(null, he) }); return } if (l(oe, ae), re = p(re, u, "Password"), ne = p(ne, u, "Salt"), typeof le != "function") throw new Error("No callback provided to pbkdf2"); Q(F(ue).then(function (he) { return he ? Z(re, ne, oe, ae, ue) : f(re, ne, oe, ae, se) }), le) }, async } var hasRequiredBrowser$7; function requireBrowser$7() { return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$8.pbkdf2 = requireAsync(), browser$8.pbkdf2Sync = requireSyncBrowser()), browser$8 } var browser$7 = {}, des$1 = {}, utils$3 = {}, hasRequiredUtils$3; function requireUtils$3() { if (hasRequiredUtils$3) return utils$3; hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function (p, d) { var m = p[0 + d] << 24 | p[1 + d] << 16 | p[2 + d] << 8 | p[3 + d]; return m >>> 0 }, utils$3.writeUInt32BE = function (p, d, m) { p[0 + m] = d >>> 24, p[1 + m] = d >>> 16 & 255, p[2 + m] = d >>> 8 & 255, p[3 + m] = d & 255 }, utils$3.ip = function (p, d, m, v) { for (var I = 0, F = 0, B = 6; B >= 0; B -= 2) { for (var W = 0; W <= 24; W += 8)I <<= 1, I |= d >>> W + B & 1; for (var W = 0; W <= 24; W += 8)I <<= 1, I |= p >>> W + B & 1 } for (var B = 6; B >= 0; B -= 2) { for (var W = 1; W <= 25; W += 8)F <<= 1, F |= d >>> W + B & 1; for (var W = 1; W <= 25; W += 8)F <<= 1, F |= p >>> W + B & 1 } m[v + 0] = I >>> 0, m[v + 1] = F >>> 0 }, utils$3.rip = function (p, d, m, v) { for (var I = 0, F = 0, B = 0; B < 4; B++)for (var W = 24; W >= 0; W -= 8)I <<= 1, I |= d >>> W + B & 1, I <<= 1, I |= p >>> W + B & 1; for (var B = 4; B < 8; B++)for (var W = 24; W >= 0; W -= 8)F <<= 1, F |= d >>> W + B & 1, F <<= 1, F |= p >>> W + B & 1; m[v + 0] = I >>> 0, m[v + 1] = F >>> 0 }, utils$3.pc1 = function (p, d, m, v) { for (var I = 0, F = 0, B = 7; B >= 5; B--) { for (var W = 0; W <= 24; W += 8)I <<= 1, I |= d >> W + B & 1; for (var W = 0; W <= 24; W += 8)I <<= 1, I |= p >> W + B & 1 } for (var W = 0; W <= 24; W += 8)I <<= 1, I |= d >> W + B & 1; for (var B = 1; B <= 3; B++) { for (var W = 0; W <= 24; W += 8)F <<= 1, F |= d >> W + B & 1; for (var W = 0; W <= 24; W += 8)F <<= 1, F |= p >> W + B & 1 } for (var W = 0; W <= 24; W += 8)F <<= 1, F |= p >> W + B & 1; m[v + 0] = I >>> 0, m[v + 1] = F >>> 0 }, utils$3.r28shl = function (p, d) { return p << d & 268435455 | p >>> 28 - d }; var o = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24]; utils$3.pc2 = function (p, d, m, v) { for (var I = 0, F = 0, B = o.length >>> 1, W = 0; W < B; W++)I <<= 1, I |= p >>> o[W] & 1; for (var W = B; W < o.length; W++)F <<= 1, F |= d >>> o[W] & 1; m[v + 0] = I >>> 0, m[v + 1] = F >>> 0 }, utils$3.expand = function (p, d, m) { var v = 0, I = 0; v = (p & 1) << 5 | p >>> 27; for (var F = 23; F >= 15; F -= 4)v <<= 6, v |= p >>> F & 63; for (var F = 11; F >= 3; F -= 4)I |= p >>> F & 63, I <<= 6; I |= (p & 31) << 1 | p >>> 31, d[m + 0] = v >>> 0, d[m + 1] = I >>> 0 }; var l = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11]; utils$3.substitute = function (p, d) { for (var m = 0, v = 0; v < 4; v++) { var I = p >>> 18 - v * 6 & 63, F = l[v * 64 + I]; m <<= 4, m |= F } for (var v = 0; v < 4; v++) { var I = d >>> 18 - v * 6 & 63, F = l[4 * 64 + v * 64 + I]; m <<= 4, m |= F } return m >>> 0 }; var u = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7]; return utils$3.permute = function (p) { for (var d = 0, m = 0; m < u.length; m++)d <<= 1, d |= p >>> u[m] & 1; return d >>> 0 }, utils$3.padSplit = function (p, d, m) { for (var v = p.toString(2); v.length < d;)v = "0" + v; for (var I = [], F = 0; F < d; F += m)I.push(v.slice(F, F + m)); return I.join(" ") }, utils$3 } var minimalisticAssert, hasRequiredMinimalisticAssert; function requireMinimalisticAssert() { if (hasRequiredMinimalisticAssert) return minimalisticAssert; hasRequiredMinimalisticAssert = 1, minimalisticAssert = o; function o(l, u) { if (!l) throw new Error(u || "Assertion failed") } return o.equal = function (u, f, p) { if (u != f) throw new Error(p || "Assertion failed: " + u + " != " + f) }, minimalisticAssert } var cipher, hasRequiredCipher; function requireCipher() { if (hasRequiredCipher) return cipher; hasRequiredCipher = 1; var o = requireMinimalisticAssert(); function l(u) { this.options = u, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = u.padding !== !1 } return cipher = l, l.prototype._init = function () { }, l.prototype.update = function (f) { return f.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(f) : this._updateEncrypt(f) }, l.prototype._buffer = function (f, p) { for (var d = Math.min(this.buffer.length - this.bufferOff, f.length - p), m = 0; m < d; m++)this.buffer[this.bufferOff + m] = f[p + m]; return this.bufferOff += d, d }, l.prototype._flushBuffer = function (f, p) { return this._update(this.buffer, 0, f, p), this.bufferOff = 0, this.blockSize }, l.prototype._updateEncrypt = function (f) { var p = 0, d = 0, m = (this.bufferOff + f.length) / this.blockSize | 0, v = new Array(m * this.blockSize); this.bufferOff !== 0 && (p += this._buffer(f, p), this.bufferOff === this.buffer.length && (d += this._flushBuffer(v, d))); for (var I = f.length - (f.length - p) % this.blockSize; p < I; p += this.blockSize)this._update(f, p, v, d), d += this.blockSize; for (; p < f.length; p++, this.bufferOff++)this.buffer[this.bufferOff] = f[p]; return v }, l.prototype._updateDecrypt = function (f) { for (var p = 0, d = 0, m = Math.ceil((this.bufferOff + f.length) / this.blockSize) - 1, v = new Array(m * this.blockSize); m > 0; m--)p += this._buffer(f, p), d += this._flushBuffer(v, d); return p += this._buffer(f, p), v }, l.prototype.final = function (f) { var p; f && (p = this.update(f)); var d; return this.type === "encrypt" ? d = this._finalEncrypt() : d = this._finalDecrypt(), p ? p.concat(d) : d }, l.prototype._pad = function (f, p) { if (p === 0) return !1; for (; p < f.length;)f[p++] = 0; return !0 }, l.prototype._finalEncrypt = function () { if (!this._pad(this.buffer, this.bufferOff)) return []; var f = new Array(this.blockSize); return this._update(this.buffer, 0, f, 0), f }, l.prototype._unpad = function (f) { return f }, l.prototype._finalDecrypt = function () { o.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt"); var f = new Array(this.blockSize); return this._flushBuffer(f, 0), this._unpad(f) }, cipher } var des, hasRequiredDes$1; function requireDes$1() { if (hasRequiredDes$1) return des; hasRequiredDes$1 = 1; var o = requireMinimalisticAssert(), l = requireInherits_browser(), u = requireUtils$3(), f = requireCipher(); function p() { this.tmp = new Array(2), this.keys = null } function d(v) { f.call(this, v); var I = new p; this._desState = I, this.deriveKeys(I, v.key) } l(d, f), des = d, d.create = function (I) { return new d(I) }; var m = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]; return d.prototype.deriveKeys = function (I, F) { I.keys = new Array(16 * 2), o.equal(F.length, this.blockSize, "Invalid key length"); var B = u.readUInt32BE(F, 0), W = u.readUInt32BE(F, 4); u.pc1(B, W, I.tmp, 0), B = I.tmp[0], W = I.tmp[1]; for (var Z = 0; Z < I.keys.length; Z += 2) { var Q = m[Z >>> 1]; B = u.r28shl(B, Q), W = u.r28shl(W, Q), u.pc2(B, W, I.keys, Z) } }, d.prototype._update = function (I, F, B, W) { var Z = this._desState, Q = u.readUInt32BE(I, F), re = u.readUInt32BE(I, F + 4); u.ip(Q, re, Z.tmp, 0), Q = Z.tmp[0], re = Z.tmp[1], this.type === "encrypt" ? this._encrypt(Z, Q, re, Z.tmp, 0) : this._decrypt(Z, Q, re, Z.tmp, 0), Q = Z.tmp[0], re = Z.tmp[1], u.writeUInt32BE(B, Q, W), u.writeUInt32BE(B, re, W + 4) }, d.prototype._pad = function (I, F) { if (this.padding === !1) return !1; for (var B = I.length - F, W = F; W < I.length; W++)I[W] = B; return !0 }, d.prototype._unpad = function (I) { if (this.padding === !1) return I; for (var F = I[I.length - 1], B = I.length - F; B < I.length; B++)o.equal(I[B], F); return I.slice(0, I.length - F) }, d.prototype._encrypt = function (I, F, B, W, Z) { for (var Q = F, re = B, ne = 0; ne < I.keys.length; ne += 2) { var oe = I.keys[ne], ae = I.keys[ne + 1]; u.expand(re, I.tmp, 0), oe ^= I.tmp[0], ae ^= I.tmp[1]; var se = u.substitute(oe, ae), le = u.permute(se), ue = re; re = (Q ^ le) >>> 0, Q = ue } u.rip(re, Q, W, Z) }, d.prototype._decrypt = function (I, F, B, W, Z) { for (var Q = B, re = F, ne = I.keys.length - 2; ne >= 0; ne -= 2) { var oe = I.keys[ne], ae = I.keys[ne + 1]; u.expand(Q, I.tmp, 0), oe ^= I.tmp[0], ae ^= I.tmp[1]; var se = u.substitute(oe, ae), le = u.permute(se), ue = Q; Q = (re ^ le) >>> 0, re = ue } u.rip(Q, re, W, Z) }, des } var cbc$1 = {}, hasRequiredCbc$1; function requireCbc$1() { if (hasRequiredCbc$1) return cbc$1; hasRequiredCbc$1 = 1; var o = requireMinimalisticAssert(), l = requireInherits_browser(), u = {}; function f(d) { o.equal(d.length, 8, "Invalid IV length"), this.iv = new Array(8); for (var m = 0; m < this.iv.length; m++)this.iv[m] = d[m] } function p(d) { function m(B) { d.call(this, B), this._cbcInit() } l(m, d); for (var v = Object.keys(u), I = 0; I < v.length; I++) { var F = v[I]; m.prototype[F] = u[F] } return m.create = function (W) { return new m(W) }, m } return cbc$1.instantiate = p, u._cbcInit = function () { var m = new f(this.options.iv); this._cbcState = m }, u._update = function (m, v, I, F) { var B = this._cbcState, W = this.constructor.super_.prototype, Z = B.iv; if (this.type === "encrypt") { for (var Q = 0; Q < this.blockSize; Q++)Z[Q] ^= m[v + Q]; W._update.call(this, Z, 0, I, F); for (var Q = 0; Q < this.blockSize; Q++)Z[Q] = I[F + Q] } else { W._update.call(this, m, v, I, F); for (var Q = 0; Q < this.blockSize; Q++)I[F + Q] ^= Z[Q]; for (var Q = 0; Q < this.blockSize; Q++)Z[Q] = m[v + Q] } }, cbc$1 } var ede, hasRequiredEde; function requireEde() { if (hasRequiredEde) return ede; hasRequiredEde = 1; var o = requireMinimalisticAssert(), l = requireInherits_browser(), u = requireCipher(), f = requireDes$1(); function p(m, v) { o.equal(v.length, 24, "Invalid key length"); var I = v.slice(0, 8), F = v.slice(8, 16), B = v.slice(16, 24); m === "encrypt" ? this.ciphers = [f.create({ type: "encrypt", key: I }), f.create({ type: "decrypt", key: F }), f.create({ type: "encrypt", key: B })] : this.ciphers = [f.create({ type: "decrypt", key: B }), f.create({ type: "encrypt", key: F }), f.create({ type: "decrypt", key: I })] } function d(m) { u.call(this, m); var v = new p(this.type, this.options.key); this._edeState = v } return l(d, u), ede = d, d.create = function (v) { return new d(v) }, d.prototype._update = function (v, I, F, B) { var W = this._edeState; W.ciphers[0]._update(v, I, F, B), W.ciphers[1]._update(F, B, F, B), W.ciphers[2]._update(F, B, F, B) }, d.prototype._pad = f.prototype._pad, d.prototype._unpad = f.prototype._unpad, ede } var hasRequiredDes; function requireDes() { return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1 } var browserifyDes, hasRequiredBrowserifyDes; function requireBrowserifyDes() { if (hasRequiredBrowserifyDes) return browserifyDes; hasRequiredBrowserifyDes = 1; var o = requireCipherBase(), l = requireDes(), u = requireInherits_browser(), f = requireSafeBuffer$1().Buffer, p = { "des-ede3-cbc": l.CBC.instantiate(l.EDE), "des-ede3": l.EDE, "des-ede-cbc": l.CBC.instantiate(l.EDE), "des-ede": l.EDE, "des-cbc": l.CBC.instantiate(l.DES), "des-ecb": l.DES }; p.des = p["des-cbc"], p.des3 = p["des-ede3-cbc"], browserifyDes = d, u(d, o); function d(m) { o.call(this); var v = m.mode.toLowerCase(), I = p[v], F; m.decrypt ? F = "decrypt" : F = "encrypt"; var B = m.key; f.isBuffer(B) || (B = f.from(B)), (v === "des-ede" || v === "des-ede-cbc") && (B = f.concat([B, B.slice(0, 8)])); var W = m.iv; f.isBuffer(W) || (W = f.from(W)), this._des = I.create({ key: B, iv: W, type: F }) } return d.prototype._update = function (m) { return f.from(this._des.update(m)) }, d.prototype._final = function () { return f.from(this._des.final()) }, browserifyDes } var browser$6 = {}, encrypter = {}, ecb = {}, hasRequiredEcb; function requireEcb() { return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function (o, l) { return o._cipher.encryptBlock(l) }, ecb.decrypt = function (o, l) { return o._cipher.decryptBlock(l) }), ecb } var cbc = {}, bufferXor, hasRequiredBufferXor; function requireBufferXor() { return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function (l, u) { for (var f = Math.min(l.length, u.length), p = new Buffer(f), d = 0; d < f; ++d)p[d] = l[d] ^ u[d]; return p }), bufferXor } var hasRequiredCbc; function requireCbc() { if (hasRequiredCbc) return cbc; hasRequiredCbc = 1; var o = requireBufferXor(); return cbc.encrypt = function (l, u) { var f = o(u, l._prev); return l._prev = l._cipher.encryptBlock(f), l._prev }, cbc.decrypt = function (l, u) { var f = l._prev; l._prev = u; var p = l._cipher.decryptBlock(u); return o(p, f) }, cbc } var cfb = {}, hasRequiredCfb; function requireCfb() { if (hasRequiredCfb) return cfb; hasRequiredCfb = 1; var o = requireSafeBuffer$1().Buffer, l = requireBufferXor(); function u(f, p, d) { var m = p.length, v = l(p, f._cache); return f._cache = f._cache.slice(m), f._prev = o.concat([f._prev, d ? p : v]), v } return cfb.encrypt = function (f, p, d) { for (var m = o.allocUnsafe(0), v; p.length;)if (f._cache.length === 0 && (f._cache = f._cipher.encryptBlock(f._prev), f._prev = o.allocUnsafe(0)), f._cache.length <= p.length) v = f._cache.length, m = o.concat([m, u(f, p.slice(0, v), d)]), p = p.slice(v); else { m = o.concat([m, u(f, p, d)]); break } return m }, cfb } var cfb8 = {}, hasRequiredCfb8; function requireCfb8() { if (hasRequiredCfb8) return cfb8; hasRequiredCfb8 = 1; var o = requireSafeBuffer$1().Buffer; function l(u, f, p) { var d = u._cipher.encryptBlock(u._prev), m = d[0] ^ f; return u._prev = o.concat([u._prev.slice(1), o.from([p ? f : m])]), m } return cfb8.encrypt = function (u, f, p) { for (var d = f.length, m = o.allocUnsafe(d), v = -1; ++v < d;)m[v] = l(u, f[v], p); return m }, cfb8 } var cfb1 = {}, hasRequiredCfb1; function requireCfb1() { if (hasRequiredCfb1) return cfb1; hasRequiredCfb1 = 1; var o = requireSafeBuffer$1().Buffer; function l(f, p, d) { for (var m, v = -1, I = 8, F = 0, B, W; ++v < I;)m = f._cipher.encryptBlock(f._prev), B = p & 1 << 7 - v ? 128 : 0, W = m[0] ^ B, F += (W & 128) >> v % 8, f._prev = u(f._prev, d ? B : W); return F } function u(f, p) { var d = f.length, m = -1, v = o.allocUnsafe(f.length); for (f = o.concat([f, o.from([p])]); ++m < d;)v[m] = f[m] << 1 | f[m + 1] >> 7; return v } return cfb1.encrypt = function (f, p, d) { for (var m = p.length, v = o.allocUnsafe(m), I = -1; ++I < m;)v[I] = l(f, p[I], d); return v }, cfb1 } var ofb = {}, hasRequiredOfb; function requireOfb() { if (hasRequiredOfb) return ofb; hasRequiredOfb = 1; var o = requireBufferXor(); function l(u) { return u._prev = u._cipher.encryptBlock(u._prev), u._prev } return ofb.encrypt = function (u, f) { for (; u._cache.length < f.length;)u._cache = Buffer.concat([u._cache, l(u)]); var p = u._cache.slice(0, f.length); return u._cache = u._cache.slice(f.length), o(f, p) }, ofb } var ctr = {}, incr32_1, hasRequiredIncr32; function requireIncr32() { if (hasRequiredIncr32) return incr32_1; hasRequiredIncr32 = 1; function o(l) { for (var u = l.length, f; u--;)if (f = l.readUInt8(u), f === 255) l.writeUInt8(0, u); else { f++, l.writeUInt8(f, u); break } } return incr32_1 = o, incr32_1 } var hasRequiredCtr; function requireCtr() { if (hasRequiredCtr) return ctr; hasRequiredCtr = 1; var o = requireBufferXor(), l = requireSafeBuffer$1().Buffer, u = requireIncr32(); function f(d) { var m = d._cipher.encryptBlockRaw(d._prev); return u(d._prev), m } var p = 16; return ctr.encrypt = function (d, m) { var v = Math.ceil(m.length / p), I = d._cache.length; d._cache = l.concat([d._cache, l.allocUnsafe(v * p)]); for (var F = 0; F < v; F++) { var B = f(d), W = I + F * p; d._cache.writeUInt32BE(B[0], W + 0), d._cache.writeUInt32BE(B[1], W + 4), d._cache.writeUInt32BE(B[2], W + 8), d._cache.writeUInt32BE(B[3], W + 12) } var Z = d._cache.slice(0, m.length); return d._cache = d._cache.slice(m.length), o(m, Z) }, ctr } const aes128 = { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192 = { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256 = { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, require$$2 = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128, aes192, aes256, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } }; var modes_1, hasRequiredModes$1; function requireModes$1() { if (hasRequiredModes$1) return modes_1; hasRequiredModes$1 = 1; var o = { ECB: requireEcb(), CBC: requireCbc(), CFB: requireCfb(), CFB8: requireCfb8(), CFB1: requireCfb1(), OFB: requireOfb(), CTR: requireCtr(), GCM: requireCtr() }, l = require$$2; for (var u in l) l[u].module = o[l[u].mode]; return modes_1 = l, modes_1 } var aes = {}, hasRequiredAes; function requireAes() { if (hasRequiredAes) return aes; hasRequiredAes = 1; var o = requireSafeBuffer$1().Buffer; function l(v) { o.isBuffer(v) || (v = o.from(v)); for (var I = v.length / 4 | 0, F = new Array(I), B = 0; B < I; B++)F[B] = v.readUInt32BE(B * 4); return F } function u(v) { for (var I = 0; I < v.length; v++)v[I] = 0 } function f(v, I, F, B, W) { for (var Z = F[0], Q = F[1], re = F[2], ne = F[3], oe = v[0] ^ I[0], ae = v[1] ^ I[1], se = v[2] ^ I[2], le = v[3] ^ I[3], ue, he, pe, ve, _e = 4, Se = 1; Se < W; Se++)ue = Z[oe >>> 24] ^ Q[ae >>> 16 & 255] ^ re[se >>> 8 & 255] ^ ne[le & 255] ^ I[_e++], he = Z[ae >>> 24] ^ Q[se >>> 16 & 255] ^ re[le >>> 8 & 255] ^ ne[oe & 255] ^ I[_e++], pe = Z[se >>> 24] ^ Q[le >>> 16 & 255] ^ re[oe >>> 8 & 255] ^ ne[ae & 255] ^ I[_e++], ve = Z[le >>> 24] ^ Q[oe >>> 16 & 255] ^ re[ae >>> 8 & 255] ^ ne[se & 255] ^ I[_e++], oe = ue, ae = he, se = pe, le = ve; return ue = (B[oe >>> 24] << 24 | B[ae >>> 16 & 255] << 16 | B[se >>> 8 & 255] << 8 | B[le & 255]) ^ I[_e++], he = (B[ae >>> 24] << 24 | B[se >>> 16 & 255] << 16 | B[le >>> 8 & 255] << 8 | B[oe & 255]) ^ I[_e++], pe = (B[se >>> 24] << 24 | B[le >>> 16 & 255] << 16 | B[oe >>> 8 & 255] << 8 | B[ae & 255]) ^ I[_e++], ve = (B[le >>> 24] << 24 | B[oe >>> 16 & 255] << 16 | B[ae >>> 8 & 255] << 8 | B[se & 255]) ^ I[_e++], ue = ue >>> 0, he = he >>> 0, pe = pe >>> 0, ve = ve >>> 0, [ue, he, pe, ve] } var p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], d = function () { for (var v = new Array(256), I = 0; I < 256; I++)I < 128 ? v[I] = I << 1 : v[I] = I << 1 ^ 283; for (var F = [], B = [], W = [[], [], [], []], Z = [[], [], [], []], Q = 0, re = 0, ne = 0; ne < 256; ++ne) { var oe = re ^ re << 1 ^ re << 2 ^ re << 3 ^ re << 4; oe = oe >>> 8 ^ oe & 255 ^ 99, F[Q] = oe, B[oe] = Q; var ae = v[Q], se = v[ae], le = v[se], ue = v[oe] * 257 ^ oe * 16843008; W[0][Q] = ue << 24 | ue >>> 8, W[1][Q] = ue << 16 | ue >>> 16, W[2][Q] = ue << 8 | ue >>> 24, W[3][Q] = ue, ue = le * 16843009 ^ se * 65537 ^ ae * 257 ^ Q * 16843008, Z[0][oe] = ue << 24 | ue >>> 8, Z[1][oe] = ue << 16 | ue >>> 16, Z[2][oe] = ue << 8 | ue >>> 24, Z[3][oe] = ue, Q === 0 ? Q = re = 1 : (Q = ae ^ v[v[v[le ^ ae]]], re ^= v[v[re]]) } return { SBOX: F, INV_SBOX: B, SUB_MIX: W, INV_SUB_MIX: Z } }(); function m(v) { this._key = l(v), this._reset() } return m.blockSize = 4 * 4, m.keySize = 256 / 8, m.prototype.blockSize = m.blockSize, m.prototype.keySize = m.keySize, m.prototype._reset = function () { for (var v = this._key, I = v.length, F = I + 6, B = (F + 1) * 4, W = [], Z = 0; Z < I; Z++)W[Z] = v[Z]; for (Z = I; Z < B; Z++) { var Q = W[Z - 1]; Z % I === 0 ? (Q = Q << 8 | Q >>> 24, Q = d.SBOX[Q >>> 24] << 24 | d.SBOX[Q >>> 16 & 255] << 16 | d.SBOX[Q >>> 8 & 255] << 8 | d.SBOX[Q & 255], Q ^= p[Z / I | 0] << 24) : I > 6 && Z % I === 4 && (Q = d.SBOX[Q >>> 24] << 24 | d.SBOX[Q >>> 16 & 255] << 16 | d.SBOX[Q >>> 8 & 255] << 8 | d.SBOX[Q & 255]), W[Z] = W[Z - I] ^ Q } for (var re = [], ne = 0; ne < B; ne++) { var oe = B - ne, ae = W[oe - (ne % 4 ? 0 : 4)]; ne < 4 || oe <= 4 ? re[ne] = ae : re[ne] = d.INV_SUB_MIX[0][d.SBOX[ae >>> 24]] ^ d.INV_SUB_MIX[1][d.SBOX[ae >>> 16 & 255]] ^ d.INV_SUB_MIX[2][d.SBOX[ae >>> 8 & 255]] ^ d.INV_SUB_MIX[3][d.SBOX[ae & 255]] } this._nRounds = F, this._keySchedule = W, this._invKeySchedule = re }, m.prototype.encryptBlockRaw = function (v) { return v = l(v), f(v, this._keySchedule, d.SUB_MIX, d.SBOX, this._nRounds) }, m.prototype.encryptBlock = function (v) { var I = this.encryptBlockRaw(v), F = o.allocUnsafe(16); return F.writeUInt32BE(I[0], 0), F.writeUInt32BE(I[1], 4), F.writeUInt32BE(I[2], 8), F.writeUInt32BE(I[3], 12), F }, m.prototype.decryptBlock = function (v) { v = l(v); var I = v[1]; v[1] = v[3], v[3] = I; var F = f(v, this._invKeySchedule, d.INV_SUB_MIX, d.INV_SBOX, this._nRounds), B = o.allocUnsafe(16); return B.writeUInt32BE(F[0], 0), B.writeUInt32BE(F[3], 4), B.writeUInt32BE(F[2], 8), B.writeUInt32BE(F[1], 12), B }, m.prototype.scrub = function () { u(this._keySchedule), u(this._invKeySchedule), u(this._key) }, aes.AES = m, aes } var ghash, hasRequiredGhash; function requireGhash() { if (hasRequiredGhash) return ghash; hasRequiredGhash = 1; var o = requireSafeBuffer$1().Buffer, l = o.alloc(16, 0); function u(d) { return [d.readUInt32BE(0), d.readUInt32BE(4), d.readUInt32BE(8), d.readUInt32BE(12)] } function f(d) { var m = o.allocUnsafe(16); return m.writeUInt32BE(d[0] >>> 0, 0), m.writeUInt32BE(d[1] >>> 0, 4), m.writeUInt32BE(d[2] >>> 0, 8), m.writeUInt32BE(d[3] >>> 0, 12), m } function p(d) { this.h = d, this.state = o.alloc(16, 0), this.cache = o.allocUnsafe(0) } return p.prototype.ghash = function (d) { for (var m = -1; ++m < d.length;)this.state[m] ^= d[m]; this._multiply() }, p.prototype._multiply = function () { for (var d = u(this.h), m = [0, 0, 0, 0], v, I, F, B = -1; ++B < 128;) { for (I = (this.state[~~(B / 8)] & 1 << 7 - B % 8) !== 0, I && (m[0] ^= d[0], m[1] ^= d[1], m[2] ^= d[2], m[3] ^= d[3]), F = (d[3] & 1) !== 0, v = 3; v > 0; v--)d[v] = d[v] >>> 1 | (d[v - 1] & 1) << 31; d[0] = d[0] >>> 1, F && (d[0] = d[0] ^ 225 << 24) } this.state = f(m) }, p.prototype.update = function (d) { this.cache = o.concat([this.cache, d]); for (var m; this.cache.length >= 16;)m = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(m) }, p.prototype.final = function (d, m) { return this.cache.length && this.ghash(o.concat([this.cache, l], 16)), this.ghash(f([0, d, 0, m])), this.state }, ghash = p, ghash } var authCipher, hasRequiredAuthCipher; function requireAuthCipher() { if (hasRequiredAuthCipher) return authCipher; hasRequiredAuthCipher = 1; var o = requireAes(), l = requireSafeBuffer$1().Buffer, u = requireCipherBase(), f = requireInherits_browser(), p = requireGhash(), d = requireBufferXor(), m = requireIncr32(); function v(B, W) { var Z = 0; B.length !== W.length && Z++; for (var Q = Math.min(B.length, W.length), re = 0; re < Q; ++re)Z += B[re] ^ W[re]; return Z } function I(B, W, Z) { if (W.length === 12) return B._finID = l.concat([W, l.from([0, 0, 0, 1])]), l.concat([W, l.from([0, 0, 0, 2])]); var Q = new p(Z), re = W.length, ne = re % 16; Q.update(W), ne && (ne = 16 - ne, Q.update(l.alloc(ne, 0))), Q.update(l.alloc(8, 0)); var oe = re * 8, ae = l.alloc(8); ae.writeUIntBE(oe, 0, 8), Q.update(ae), B._finID = Q.state; var se = l.from(B._finID); return m(se), se } function F(B, W, Z, Q) { u.call(this); var re = l.alloc(4, 0); this._cipher = new o.AES(W); var ne = this._cipher.encryptBlock(re); this._ghash = new p(ne), Z = I(this, Z, ne), this._prev = l.from(Z), this._cache = l.allocUnsafe(0), this._secCache = l.allocUnsafe(0), this._decrypt = Q, this._alen = 0, this._len = 0, this._mode = B, this._authTag = null, this._called = !1 } return f(F, u), F.prototype._update = function (B) { if (!this._called && this._alen) { var W = 16 - this._alen % 16; W < 16 && (W = l.alloc(W, 0), this._ghash.update(W)) } this._called = !0; var Z = this._mode.encrypt(this, B); return this._decrypt ? this._ghash.update(B) : this._ghash.update(Z), this._len += B.length, Z }, F.prototype._final = function () { if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data"); var B = d(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID)); if (this._decrypt && v(B, this._authTag)) throw new Error("Unsupported state or unable to authenticate data"); this._authTag = B, this._cipher.scrub() }, F.prototype.getAuthTag = function () { if (this._decrypt || !l.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state"); return this._authTag }, F.prototype.setAuthTag = function (W) { if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state"); this._authTag = W }, F.prototype.setAAD = function (W) { if (this._called) throw new Error("Attempting to set AAD in unsupported state"); this._ghash.update(W), this._alen += W.length }, authCipher = F, authCipher } var streamCipher, hasRequiredStreamCipher; function requireStreamCipher() { if (hasRequiredStreamCipher) return streamCipher; hasRequiredStreamCipher = 1; var o = requireAes(), l = requireSafeBuffer$1().Buffer, u = requireCipherBase(), f = requireInherits_browser(); function p(d, m, v, I) { u.call(this), this._cipher = new o.AES(m), this._prev = l.from(v), this._cache = l.allocUnsafe(0), this._secCache = l.allocUnsafe(0), this._decrypt = I, this._mode = d } return f(p, u), p.prototype._update = function (d) { return this._mode.encrypt(this, d, this._decrypt) }, p.prototype._final = function () { this._cipher.scrub() }, streamCipher = p, streamCipher } var evp_bytestokey, hasRequiredEvp_bytestokey; function requireEvp_bytestokey() { if (hasRequiredEvp_bytestokey) return evp_bytestokey; hasRequiredEvp_bytestokey = 1; var o = requireSafeBuffer$1().Buffer, l = requireMd5_js(); function u(f, p, d, m) { if (o.isBuffer(f) || (f = o.from(f, "binary")), p && (o.isBuffer(p) || (p = o.from(p, "binary")), p.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length"); for (var v = d / 8, I = o.alloc(v), F = o.alloc(m || 0), B = o.alloc(0); v > 0 || m > 0;) { var W = new l; W.update(B), W.update(f), p && W.update(p), B = W.digest(); var Z = 0; if (v > 0) { var Q = I.length - v; Z = Math.min(v, B.length), B.copy(I, Q, 0, Z), v -= Z } if (Z < B.length && m > 0) { var re = F.length - m, ne = Math.min(m, B.length - Z); B.copy(F, re, Z, Z + ne), m -= ne } } return B.fill(0), { key: I, iv: F } } return evp_bytestokey = u, evp_bytestokey } var hasRequiredEncrypter; function requireEncrypter() { if (hasRequiredEncrypter) return encrypter; hasRequiredEncrypter = 1; var o = requireModes$1(), l = requireAuthCipher(), u = requireSafeBuffer$1().Buffer, f = requireStreamCipher(), p = requireCipherBase(), d = requireAes(), m = requireEvp_bytestokey(), v = requireInherits_browser(); function I(Q, re, ne) { p.call(this), this._cache = new B, this._cipher = new d.AES(re), this._prev = u.from(ne), this._mode = Q, this._autopadding = !0 } v(I, p), I.prototype._update = function (Q) { this._cache.add(Q); for (var re, ne, oe = []; re = this._cache.get();)ne = this._mode.encrypt(this, re), oe.push(ne); return u.concat(oe) }; var F = u.alloc(16, 16); I.prototype._final = function () { var Q = this._cache.flush(); if (this._autopadding) return Q = this._mode.encrypt(this, Q), this._cipher.scrub(), Q; if (!Q.equals(F)) throw this._cipher.scrub(), new Error("data not multiple of block length") }, I.prototype.setAutoPadding = function (Q) { return this._autopadding = !!Q, this }; function B() { this.cache = u.allocUnsafe(0) } B.prototype.add = function (Q) { this.cache = u.concat([this.cache, Q]) }, B.prototype.get = function () { if (this.cache.length > 15) { var Q = this.cache.slice(0, 16); return this.cache = this.cache.slice(16), Q } return null }, B.prototype.flush = function () { for (var Q = 16 - this.cache.length, re = u.allocUnsafe(Q), ne = -1; ++ne < Q;)re.writeUInt8(Q, ne); return u.concat([this.cache, re]) }; function W(Q, re, ne) { var oe = o[Q.toLowerCase()]; if (!oe) throw new TypeError("invalid suite type"); if (typeof re == "string" && (re = u.from(re)), re.length !== oe.key / 8) throw new TypeError("invalid key length " + re.length); if (typeof ne == "string" && (ne = u.from(ne)), oe.mode !== "GCM" && ne.length !== oe.iv) throw new TypeError("invalid iv length " + ne.length); return oe.type === "stream" ? new f(oe.module, re, ne) : oe.type === "auth" ? new l(oe.module, re, ne) : new I(oe.module, re, ne) } function Z(Q, re) { var ne = o[Q.toLowerCase()]; if (!ne) throw new TypeError("invalid suite type"); var oe = m(re, !1, ne.key, ne.iv); return W(Q, oe.key, oe.iv) } return encrypter.createCipheriv = W, encrypter.createCipher = Z, encrypter } var decrypter = {}, hasRequiredDecrypter; function requireDecrypter() { if (hasRequiredDecrypter) return decrypter; hasRequiredDecrypter = 1; var o = requireAuthCipher(), l = requireSafeBuffer$1().Buffer, u = requireModes$1(), f = requireStreamCipher(), p = requireCipherBase(), d = requireAes(), m = requireEvp_bytestokey(), v = requireInherits_browser(); function I(Q, re, ne) { p.call(this), this._cache = new F, this._last = void 0, this._cipher = new d.AES(re), this._prev = l.from(ne), this._mode = Q, this._autopadding = !0 } v(I, p), I.prototype._update = function (Q) { this._cache.add(Q); for (var re, ne, oe = []; re = this._cache.get(this._autopadding);)ne = this._mode.decrypt(this, re), oe.push(ne); return l.concat(oe) }, I.prototype._final = function () { var Q = this._cache.flush(); if (this._autopadding) return B(this._mode.decrypt(this, Q)); if (Q) throw new Error("data not multiple of block length") }, I.prototype.setAutoPadding = function (Q) { return this._autopadding = !!Q, this }; function F() { this.cache = l.allocUnsafe(0) } F.prototype.add = function (Q) { this.cache = l.concat([this.cache, Q]) }, F.prototype.get = function (Q) { var re; if (Q) { if (this.cache.length > 16) return re = this.cache.slice(0, 16), this.cache = this.cache.slice(16), re } else if (this.cache.length >= 16) return re = this.cache.slice(0, 16), this.cache = this.cache.slice(16), re; return null }, F.prototype.flush = function () { if (this.cache.length) return this.cache }; function B(Q) { var re = Q[15]; if (re < 1 || re > 16) throw new Error("unable to decrypt data"); for (var ne = -1; ++ne < re;)if (Q[ne + (16 - re)] !== re) throw new Error("unable to decrypt data"); if (re !== 16) return Q.slice(0, 16 - re) } function W(Q, re, ne) { var oe = u[Q.toLowerCase()]; if (!oe) throw new TypeError("invalid suite type"); if (typeof ne == "string" && (ne = l.from(ne)), oe.mode !== "GCM" && ne.length !== oe.iv) throw new TypeError("invalid iv length " + ne.length); if (typeof re == "string" && (re = l.from(re)), re.length !== oe.key / 8) throw new TypeError("invalid key length " + re.length); return oe.type === "stream" ? new f(oe.module, re, ne, !0) : oe.type === "auth" ? new o(oe.module, re, ne, !0) : new I(oe.module, re, ne) } function Z(Q, re) { var ne = u[Q.toLowerCase()]; if (!ne) throw new TypeError("invalid suite type"); var oe = m(re, !1, ne.key, ne.iv); return W(Q, oe.key, oe.iv) } return decrypter.createDecipher = Z, decrypter.createDecipheriv = W, decrypter } var hasRequiredBrowser$6; function requireBrowser$6() { if (hasRequiredBrowser$6) return browser$6; hasRequiredBrowser$6 = 1; var o = requireEncrypter(), l = requireDecrypter(), u = require$$2; function f() { return Object.keys(u) } return browser$6.createCipher = browser$6.Cipher = o.createCipher, browser$6.createCipheriv = browser$6.Cipheriv = o.createCipheriv, browser$6.createDecipher = browser$6.Decipher = l.createDecipher, browser$6.createDecipheriv = browser$6.Decipheriv = l.createDecipheriv, browser$6.listCiphers = browser$6.getCiphers = f, browser$6 } var modes = {}, hasRequiredModes; function requireModes() { return hasRequiredModes || (hasRequiredModes = 1, function (o) { o["des-ecb"] = { key: 8, iv: 0 }, o["des-cbc"] = o.des = { key: 8, iv: 8 }, o["des-ede3-cbc"] = o.des3 = { key: 24, iv: 8 }, o["des-ede3"] = { key: 24, iv: 0 }, o["des-ede-cbc"] = { key: 16, iv: 8 }, o["des-ede"] = { key: 16, iv: 0 } }(modes)), modes } var hasRequiredBrowser$5; function requireBrowser$5() { if (hasRequiredBrowser$5) return browser$7; hasRequiredBrowser$5 = 1; var o = requireBrowserifyDes(), l = requireBrowser$6(), u = requireModes$1(), f = requireModes(), p = requireEvp_bytestokey(); function d(B, W) { B = B.toLowerCase(); var Z, Q; if (u[B]) Z = u[B].key, Q = u[B].iv; else if (f[B]) Z = f[B].key * 8, Q = f[B].iv; else throw new TypeError("invalid suite type"); var re = p(W, !1, Z, Q); return v(B, re.key, re.iv) } function m(B, W) { B = B.toLowerCase(); var Z, Q; if (u[B]) Z = u[B].key, Q = u[B].iv; else if (f[B]) Z = f[B].key * 8, Q = f[B].iv; else throw new TypeError("invalid suite type"); var re = p(W, !1, Z, Q); return I(B, re.key, re.iv) } function v(B, W, Z) { if (B = B.toLowerCase(), u[B]) return l.createCipheriv(B, W, Z); if (f[B]) return new o({ key: W, iv: Z, mode: B }); throw new TypeError("invalid suite type") } function I(B, W, Z) { if (B = B.toLowerCase(), u[B]) return l.createDecipheriv(B, W, Z); if (f[B]) return new o({ key: W, iv: Z, mode: B, decrypt: !0 }); throw new TypeError("invalid suite type") } function F() { return Object.keys(f).concat(l.getCiphers()) } return browser$7.createCipher = browser$7.Cipher = d, browser$7.createCipheriv = browser$7.Cipheriv = v, browser$7.createDecipher = browser$7.Decipher = m, browser$7.createDecipheriv = browser$7.Decipheriv = I, browser$7.listCiphers = browser$7.getCiphers = F, browser$7 } var browser$5 = {}, bn$d = { exports: {} }, bn$c = bn$d.exports, hasRequiredBn$6; function requireBn$6() { return hasRequiredBn$6 || (hasRequiredBn$6 = 1, function (o) { (function (l, u) { function f(ie, g) { if (!ie) throw new Error(g || "Assertion failed") } function p(ie, g) { ie.super_ = g; var P = function () { }; P.prototype = g.prototype, ie.prototype = new P, ie.prototype.constructor = ie } function d(ie, g, P) { if (d.isBN(ie)) return ie; this.negative = 0, this.words = null, this.length = 0, this.red = null, ie !== null && ((g === "le" || g === "be") && (P = g, g = 10), this._init(ie || 0, g || 10, P || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (g) { return g instanceof d ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === d.wordSize && Array.isArray(g.words) }, d.max = function (g, P) { return g.cmp(P) > 0 ? g : P }, d.min = function (g, P) { return g.cmp(P) < 0 ? g : P }, d.prototype._init = function (g, P, U) { if (typeof g == "number") return this._initNumber(g, P, U); if (typeof g == "object") return this._initArray(g, P, U); P === "hex" && (P = 16), f(P === (P | 0) && P >= 2 && P <= 36), g = g.toString().replace(/\s+/g, ""); var K = 0; g[0] === "-" && (K++, this.negative = 1), K < g.length && (P === 16 ? this._parseHex(g, K, U) : (this._parseBase(g, P, K), U === "le" && this._initArray(this.toArray(), P, U))) }, d.prototype._initNumber = function (g, P, U) { g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [g & 67108863, g / 67108864 & 67108863], this.length = 2) : (f(g < 9007199254740992), this.words = [g & 67108863, g / 67108864 & 67108863, 1], this.length = 3), U === "le" && this._initArray(this.toArray(), P, U) }, d.prototype._initArray = function (g, P, U) { if (f(typeof g.length == "number"), g.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(g.length / 3), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y, te, ee = 0; if (U === "be") for (K = g.length - 1, Y = 0; K >= 0; K -= 3)te = g[K] | g[K - 1] << 8 | g[K - 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); else if (U === "le") for (K = 0, Y = 0; K < g.length; K += 3)te = g[K] | g[K + 1] << 8 | g[K + 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); return this.strip() }; function v(ie, g) { var P = ie.charCodeAt(g); return P >= 65 && P <= 70 ? P - 55 : P >= 97 && P <= 102 ? P - 87 : P - 48 & 15 } function I(ie, g, P) { var U = v(ie, P); return P - 1 >= g && (U |= v(ie, P - 1) << 4), U } d.prototype._parseHex = function (g, P, U) { this.length = Math.ceil((g.length - P) / 6), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y = 0, te = 0, ee; if (U === "be") for (K = g.length - 1; K >= P; K -= 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8; else { var G = g.length - P; for (K = G % 2 === 0 ? P + 1 : P; K < g.length; K += 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8 } this.strip() }; function F(ie, g, P, U) { for (var K = 0, Y = Math.min(ie.length, P), te = g; te < Y; te++) { var ee = ie.charCodeAt(te) - 48; K *= U, ee >= 49 ? K += ee - 49 + 10 : ee >= 17 ? K += ee - 17 + 10 : K += ee } return K } d.prototype._parseBase = function (g, P, U) { this.words = [0], this.length = 1; for (var K = 0, Y = 1; Y <= 67108863; Y *= P)K++; K--, Y = Y / P | 0; for (var te = g.length - U, ee = te % K, G = Math.min(te, te - ee) + U, y = 0, X = U; X < G; X += K)y = F(g, X, X + K, P), this.imuln(Y), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y); if (ee !== 0) { var ce = 1; for (y = F(g, X, g.length, P), X = 0; X < ee; X++)ce *= P; this.imuln(ce), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y) } this.strip() }, d.prototype.copy = function (g) { g.words = new Array(this.length); for (var P = 0; P < this.length; P++)g.words[P] = this.words[P]; g.length = this.length, g.negative = this.negative, g.red = this.red }, d.prototype.clone = function () { var g = new d(null); return this.copy(g), g }, d.prototype._expand = function (g) { for (; this.length < g;)this.words[this.length++] = 0; return this }, d.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, d.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var B = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], W = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (g, P) { g = g || 10, P = P | 0 || 1; var U; if (g === 16 || g === "hex") { U = ""; for (var K = 0, Y = 0, te = 0; te < this.length; te++) { var ee = this.words[te], G = ((ee << K | Y) & 16777215).toString(16); Y = ee >>> 24 - K & 16777215, Y !== 0 || te !== this.length - 1 ? U = B[6 - G.length] + G + U : U = G + U, K += 2, K >= 26 && (K -= 26, te--) } for (Y !== 0 && (U = Y.toString(16) + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } if (g === (g | 0) && g >= 2 && g <= 36) { var y = W[g], X = Z[g]; U = ""; var ce = this.clone(); for (ce.negative = 0; !ce.isZero();) { var me = ce.modn(X).toString(g); ce = ce.idivn(X), ce.isZero() ? U = me + U : U = B[y - me.length] + me + U } for (this.isZero() && (U = "0" + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var g = this.words[0]; return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g }, d.prototype.toJSON = function () { return this.toString(16) }, d.prototype.toBuffer = function (g, P) { return f(typeof m < "u"), this.toArrayLike(m, g, P) }, d.prototype.toArray = function (g, P) { return this.toArrayLike(Array, g, P) }, d.prototype.toArrayLike = function (g, P, U) { var K = this.byteLength(), Y = U || Math.max(1, K); f(K <= Y, "byte array longer than desired length"), f(Y > 0, "Requested array length <= 0"), this.strip(); var te = P === "le", ee = new g(Y), G, y, X = this.clone(); if (te) { for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[y] = G; for (; y < Y; y++)ee[y] = 0 } else { for (y = 0; y < Y - K; y++)ee[y] = 0; for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[Y - y - 1] = G } return ee }, Math.clz32 ? d.prototype._countBits = function (g) { return 32 - Math.clz32(g) } : d.prototype._countBits = function (g) { var P = g, U = 0; return P >= 4096 && (U += 13, P >>>= 13), P >= 64 && (U += 7, P >>>= 7), P >= 8 && (U += 4, P >>>= 4), P >= 2 && (U += 2, P >>>= 2), U + P }, d.prototype._zeroBits = function (g) { if (g === 0) return 26; var P = g, U = 0; return (P & 8191) === 0 && (U += 13, P >>>= 13), (P & 127) === 0 && (U += 7, P >>>= 7), (P & 15) === 0 && (U += 4, P >>>= 4), (P & 3) === 0 && (U += 2, P >>>= 2), (P & 1) === 0 && U++, U }, d.prototype.bitLength = function () { var g = this.words[this.length - 1], P = this._countBits(g); return (this.length - 1) * 26 + P }; function Q(ie) { for (var g = new Array(ie.bitLength()), P = 0; P < g.length; P++) { var U = P / 26 | 0, K = P % 26; g[P] = (ie.words[U] & 1 << K) >>> K } return g } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var g = 0, P = 0; P < this.length; P++) { var U = this._zeroBits(this.words[P]); if (g += U, U !== 26) break } return g }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (g) { return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (g) { return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (g) { for (; this.length < g.length;)this.words[this.length++] = 0; for (var P = 0; P < g.length; P++)this.words[P] = this.words[P] | g.words[P]; return this.strip() }, d.prototype.ior = function (g) { return f((this.negative | g.negative) === 0), this.iuor(g) }, d.prototype.or = function (g) { return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this) }, d.prototype.uor = function (g) { return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this) }, d.prototype.iuand = function (g) { var P; this.length > g.length ? P = g : P = this; for (var U = 0; U < P.length; U++)this.words[U] = this.words[U] & g.words[U]; return this.length = P.length, this.strip() }, d.prototype.iand = function (g) { return f((this.negative | g.negative) === 0), this.iuand(g) }, d.prototype.and = function (g) { return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this) }, d.prototype.uand = function (g) { return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this) }, d.prototype.iuxor = function (g) { var P, U; this.length > g.length ? (P = this, U = g) : (P = g, U = this); for (var K = 0; K < U.length; K++)this.words[K] = P.words[K] ^ U.words[K]; if (this !== P) for (; K < P.length; K++)this.words[K] = P.words[K]; return this.length = P.length, this.strip() }, d.prototype.ixor = function (g) { return f((this.negative | g.negative) === 0), this.iuxor(g) }, d.prototype.xor = function (g) { return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this) }, d.prototype.uxor = function (g) { return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this) }, d.prototype.inotn = function (g) { f(typeof g == "number" && g >= 0); var P = Math.ceil(g / 26) | 0, U = g % 26; this._expand(P), U > 0 && P--; for (var K = 0; K < P; K++)this.words[K] = ~this.words[K] & 67108863; return U > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - U), this.strip() }, d.prototype.notn = function (g) { return this.clone().inotn(g) }, d.prototype.setn = function (g, P) { f(typeof g == "number" && g >= 0); var U = g / 26 | 0, K = g % 26; return this._expand(U + 1), P ? this.words[U] = this.words[U] | 1 << K : this.words[U] = this.words[U] & ~(1 << K), this.strip() }, d.prototype.iadd = function (g) { var P; if (this.negative !== 0 && g.negative === 0) return this.negative = 0, P = this.isub(g), this.negative ^= 1, this._normSign(); if (this.negative === 0 && g.negative !== 0) return g.negative = 0, P = this.isub(g), g.negative = 1, P._normSign(); var U, K; this.length > g.length ? (U = this, K = g) : (U = g, K = this); for (var Y = 0, te = 0; te < K.length; te++)P = (U.words[te] | 0) + (K.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; for (; Y !== 0 && te < U.length; te++)P = (U.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; if (this.length = U.length, Y !== 0) this.words[this.length] = Y, this.length++; else if (U !== this) for (; te < U.length; te++)this.words[te] = U.words[te]; return this }, d.prototype.add = function (g) { var P; return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, P = this.sub(g), g.negative ^= 1, P) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = g.sub(this), this.negative = 1, P) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this) }, d.prototype.isub = function (g) { if (g.negative !== 0) { g.negative = 0; var P = this.iadd(g); return g.negative = 1, P._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign(); var U = this.cmp(g); if (U === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var K, Y; U > 0 ? (K = this, Y = g) : (K = g, Y = this); for (var te = 0, ee = 0; ee < Y.length; ee++)P = (K.words[ee] | 0) - (Y.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; for (; te !== 0 && ee < K.length; ee++)P = (K.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; if (te === 0 && ee < K.length && K !== this) for (; ee < K.length; ee++)this.words[ee] = K.words[ee]; return this.length = Math.max(this.length, ee), K !== this && (this.negative = 1), this.strip() }, d.prototype.sub = function (g) { return this.clone().isub(g) }; function re(ie, g, P) { P.negative = g.negative ^ ie.negative; var U = ie.length + g.length | 0; P.length = U, U = U - 1 | 0; var K = ie.words[0] | 0, Y = g.words[0] | 0, te = K * Y, ee = te & 67108863, G = te / 67108864 | 0; P.words[0] = ee; for (var y = 1; y < U; y++) { for (var X = G >>> 26, ce = G & 67108863, me = Math.min(y, g.length - 1), Ae = Math.max(0, y - ie.length + 1); Ae <= me; Ae++) { var Ie = y - Ae | 0; K = ie.words[Ie] | 0, Y = g.words[Ae] | 0, te = K * Y + ce, X += te / 67108864 | 0, ce = te & 67108863 } P.words[y] = ce | 0, G = X | 0 } return G !== 0 ? P.words[y] = G | 0 : P.length--, P.strip() } var ne = function (g, P, U) { var K = g.words, Y = P.words, te = U.words, ee = 0, G, y, X, ce = K[0] | 0, me = ce & 8191, Ae = ce >>> 13, Ie = K[1] | 0, Be = Ie & 8191, Me = Ie >>> 13, De = K[2] | 0, Ue = De & 8191, Ke = De >>> 13, Ve = K[3] | 0, ke = Ve & 8191, Je = Ve >>> 13, dt = K[4] | 0, lt = dt & 8191, ht = dt >>> 13, Bt = K[5] | 0, mt = Bt & 8191, et = Bt >>> 13, Gt = K[6] | 0, pt = Gt & 8191, _t = Gt >>> 13, zt = K[7] | 0, bt = zt & 8191, We = zt >>> 13, Ge = K[8] | 0, ze = Ge & 8191, Ze = Ge >>> 13, ut = K[9] | 0, ye = ut & 8191, ge = ut >>> 13, Ee = Y[0] | 0, Oe = Ee & 8191, je = Ee >>> 13, nt = Y[1] | 0, Xe = nt & 8191, it = nt >>> 13, Tt = Y[2] | 0, tt = Tt & 8191, yt = Tt >>> 13, kt = Y[3] | 0, wt = kt & 8191, Mt = kt >>> 13, tr = Y[4] | 0, St = tr & 8191, gt = tr >>> 13, rr = Y[5] | 0, Le = rr & 8191, xe = rr >>> 13, Ce = Y[6] | 0, Ne = Ce & 8191, Ye = Ce >>> 13, Re = Y[7] | 0, Pe = Re & 8191, qe = Re >>> 13, be = Y[8] | 0, Fe = be & 8191, Qe = be >>> 13, st = Y[9] | 0, rt = st & 8191, ct = st >>> 13; U.negative = g.negative ^ P.negative, U.length = 19, G = Math.imul(me, Oe), y = Math.imul(me, je), y = y + Math.imul(Ae, Oe) | 0, X = Math.imul(Ae, je); var Lt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(Be, Oe), y = Math.imul(Be, je), y = y + Math.imul(Me, Oe) | 0, X = Math.imul(Me, je), G = G + Math.imul(me, Xe) | 0, y = y + Math.imul(me, it) | 0, y = y + Math.imul(Ae, Xe) | 0, X = X + Math.imul(Ae, it) | 0; var It = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(Ue, Oe), y = Math.imul(Ue, je), y = y + Math.imul(Ke, Oe) | 0, X = Math.imul(Ke, je), G = G + Math.imul(Be, Xe) | 0, y = y + Math.imul(Be, it) | 0, y = y + Math.imul(Me, Xe) | 0, X = X + Math.imul(Me, it) | 0, G = G + Math.imul(me, tt) | 0, y = y + Math.imul(me, yt) | 0, y = y + Math.imul(Ae, tt) | 0, X = X + Math.imul(Ae, yt) | 0; var lr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, G = Math.imul(ke, Oe), y = Math.imul(ke, je), y = y + Math.imul(Je, Oe) | 0, X = Math.imul(Je, je), G = G + Math.imul(Ue, Xe) | 0, y = y + Math.imul(Ue, it) | 0, y = y + Math.imul(Ke, Xe) | 0, X = X + Math.imul(Ke, it) | 0, G = G + Math.imul(Be, tt) | 0, y = y + Math.imul(Be, yt) | 0, y = y + Math.imul(Me, tt) | 0, X = X + Math.imul(Me, yt) | 0, G = G + Math.imul(me, wt) | 0, y = y + Math.imul(me, Mt) | 0, y = y + Math.imul(Ae, wt) | 0, X = X + Math.imul(Ae, Mt) | 0; var jt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(lt, Oe), y = Math.imul(lt, je), y = y + Math.imul(ht, Oe) | 0, X = Math.imul(ht, je), G = G + Math.imul(ke, Xe) | 0, y = y + Math.imul(ke, it) | 0, y = y + Math.imul(Je, Xe) | 0, X = X + Math.imul(Je, it) | 0, G = G + Math.imul(Ue, tt) | 0, y = y + Math.imul(Ue, yt) | 0, y = y + Math.imul(Ke, tt) | 0, X = X + Math.imul(Ke, yt) | 0, G = G + Math.imul(Be, wt) | 0, y = y + Math.imul(Be, Mt) | 0, y = y + Math.imul(Me, wt) | 0, X = X + Math.imul(Me, Mt) | 0, G = G + Math.imul(me, St) | 0, y = y + Math.imul(me, gt) | 0, y = y + Math.imul(Ae, St) | 0, X = X + Math.imul(Ae, gt) | 0; var Ft = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(mt, Oe), y = Math.imul(mt, je), y = y + Math.imul(et, Oe) | 0, X = Math.imul(et, je), G = G + Math.imul(lt, Xe) | 0, y = y + Math.imul(lt, it) | 0, y = y + Math.imul(ht, Xe) | 0, X = X + Math.imul(ht, it) | 0, G = G + Math.imul(ke, tt) | 0, y = y + Math.imul(ke, yt) | 0, y = y + Math.imul(Je, tt) | 0, X = X + Math.imul(Je, yt) | 0, G = G + Math.imul(Ue, wt) | 0, y = y + Math.imul(Ue, Mt) | 0, y = y + Math.imul(Ke, wt) | 0, X = X + Math.imul(Ke, Mt) | 0, G = G + Math.imul(Be, St) | 0, y = y + Math.imul(Be, gt) | 0, y = y + Math.imul(Me, St) | 0, X = X + Math.imul(Me, gt) | 0, G = G + Math.imul(me, Le) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(Ae, Le) | 0, X = X + Math.imul(Ae, xe) | 0; var er = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, G = Math.imul(pt, Oe), y = Math.imul(pt, je), y = y + Math.imul(_t, Oe) | 0, X = Math.imul(_t, je), G = G + Math.imul(mt, Xe) | 0, y = y + Math.imul(mt, it) | 0, y = y + Math.imul(et, Xe) | 0, X = X + Math.imul(et, it) | 0, G = G + Math.imul(lt, tt) | 0, y = y + Math.imul(lt, yt) | 0, y = y + Math.imul(ht, tt) | 0, X = X + Math.imul(ht, yt) | 0, G = G + Math.imul(ke, wt) | 0, y = y + Math.imul(ke, Mt) | 0, y = y + Math.imul(Je, wt) | 0, X = X + Math.imul(Je, Mt) | 0, G = G + Math.imul(Ue, St) | 0, y = y + Math.imul(Ue, gt) | 0, y = y + Math.imul(Ke, St) | 0, X = X + Math.imul(Ke, gt) | 0, G = G + Math.imul(Be, Le) | 0, y = y + Math.imul(Be, xe) | 0, y = y + Math.imul(Me, Le) | 0, X = X + Math.imul(Me, xe) | 0, G = G + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Ye) | 0, y = y + Math.imul(Ae, Ne) | 0, X = X + Math.imul(Ae, Ye) | 0; var ar = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, G = Math.imul(bt, Oe), y = Math.imul(bt, je), y = y + Math.imul(We, Oe) | 0, X = Math.imul(We, je), G = G + Math.imul(pt, Xe) | 0, y = y + Math.imul(pt, it) | 0, y = y + Math.imul(_t, Xe) | 0, X = X + Math.imul(_t, it) | 0, G = G + Math.imul(mt, tt) | 0, y = y + Math.imul(mt, yt) | 0, y = y + Math.imul(et, tt) | 0, X = X + Math.imul(et, yt) | 0, G = G + Math.imul(lt, wt) | 0, y = y + Math.imul(lt, Mt) | 0, y = y + Math.imul(ht, wt) | 0, X = X + Math.imul(ht, Mt) | 0, G = G + Math.imul(ke, St) | 0, y = y + Math.imul(ke, gt) | 0, y = y + Math.imul(Je, St) | 0, X = X + Math.imul(Je, gt) | 0, G = G + Math.imul(Ue, Le) | 0, y = y + Math.imul(Ue, xe) | 0, y = y + Math.imul(Ke, Le) | 0, X = X + Math.imul(Ke, xe) | 0, G = G + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, Ye) | 0, y = y + Math.imul(Me, Ne) | 0, X = X + Math.imul(Me, Ye) | 0, G = G + Math.imul(me, Pe) | 0, y = y + Math.imul(me, qe) | 0, y = y + Math.imul(Ae, Pe) | 0, X = X + Math.imul(Ae, qe) | 0; var nr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, G = Math.imul(ze, Oe), y = Math.imul(ze, je), y = y + Math.imul(Ze, Oe) | 0, X = Math.imul(Ze, je), G = G + Math.imul(bt, Xe) | 0, y = y + Math.imul(bt, it) | 0, y = y + Math.imul(We, Xe) | 0, X = X + Math.imul(We, it) | 0, G = G + Math.imul(pt, tt) | 0, y = y + Math.imul(pt, yt) | 0, y = y + Math.imul(_t, tt) | 0, X = X + Math.imul(_t, yt) | 0, G = G + Math.imul(mt, wt) | 0, y = y + Math.imul(mt, Mt) | 0, y = y + Math.imul(et, wt) | 0, X = X + Math.imul(et, Mt) | 0, G = G + Math.imul(lt, St) | 0, y = y + Math.imul(lt, gt) | 0, y = y + Math.imul(ht, St) | 0, X = X + Math.imul(ht, gt) | 0, G = G + Math.imul(ke, Le) | 0, y = y + Math.imul(ke, xe) | 0, y = y + Math.imul(Je, Le) | 0, X = X + Math.imul(Je, xe) | 0, G = G + Math.imul(Ue, Ne) | 0, y = y + Math.imul(Ue, Ye) | 0, y = y + Math.imul(Ke, Ne) | 0, X = X + Math.imul(Ke, Ye) | 0, G = G + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, qe) | 0, y = y + Math.imul(Me, Pe) | 0, X = X + Math.imul(Me, qe) | 0, G = G + Math.imul(me, Fe) | 0, y = y + Math.imul(me, Qe) | 0, y = y + Math.imul(Ae, Fe) | 0, X = X + Math.imul(Ae, Qe) | 0; var ir = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, G = Math.imul(ye, Oe), y = Math.imul(ye, je), y = y + Math.imul(ge, Oe) | 0, X = Math.imul(ge, je), G = G + Math.imul(ze, Xe) | 0, y = y + Math.imul(ze, it) | 0, y = y + Math.imul(Ze, Xe) | 0, X = X + Math.imul(Ze, it) | 0, G = G + Math.imul(bt, tt) | 0, y = y + Math.imul(bt, yt) | 0, y = y + Math.imul(We, tt) | 0, X = X + Math.imul(We, yt) | 0, G = G + Math.imul(pt, wt) | 0, y = y + Math.imul(pt, Mt) | 0, y = y + Math.imul(_t, wt) | 0, X = X + Math.imul(_t, Mt) | 0, G = G + Math.imul(mt, St) | 0, y = y + Math.imul(mt, gt) | 0, y = y + Math.imul(et, St) | 0, X = X + Math.imul(et, gt) | 0, G = G + Math.imul(lt, Le) | 0, y = y + Math.imul(lt, xe) | 0, y = y + Math.imul(ht, Le) | 0, X = X + Math.imul(ht, xe) | 0, G = G + Math.imul(ke, Ne) | 0, y = y + Math.imul(ke, Ye) | 0, y = y + Math.imul(Je, Ne) | 0, X = X + Math.imul(Je, Ye) | 0, G = G + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, qe) | 0, y = y + Math.imul(Ke, Pe) | 0, X = X + Math.imul(Ke, qe) | 0, G = G + Math.imul(Be, Fe) | 0, y = y + Math.imul(Be, Qe) | 0, y = y + Math.imul(Me, Fe) | 0, X = X + Math.imul(Me, Qe) | 0, G = G + Math.imul(me, rt) | 0, y = y + Math.imul(me, ct) | 0, y = y + Math.imul(Ae, rt) | 0, X = X + Math.imul(Ae, ct) | 0; var Ht = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(ye, Xe), y = Math.imul(ye, it), y = y + Math.imul(ge, Xe) | 0, X = Math.imul(ge, it), G = G + Math.imul(ze, tt) | 0, y = y + Math.imul(ze, yt) | 0, y = y + Math.imul(Ze, tt) | 0, X = X + Math.imul(Ze, yt) | 0, G = G + Math.imul(bt, wt) | 0, y = y + Math.imul(bt, Mt) | 0, y = y + Math.imul(We, wt) | 0, X = X + Math.imul(We, Mt) | 0, G = G + Math.imul(pt, St) | 0, y = y + Math.imul(pt, gt) | 0, y = y + Math.imul(_t, St) | 0, X = X + Math.imul(_t, gt) | 0, G = G + Math.imul(mt, Le) | 0, y = y + Math.imul(mt, xe) | 0, y = y + Math.imul(et, Le) | 0, X = X + Math.imul(et, xe) | 0, G = G + Math.imul(lt, Ne) | 0, y = y + Math.imul(lt, Ye) | 0, y = y + Math.imul(ht, Ne) | 0, X = X + Math.imul(ht, Ye) | 0, G = G + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, qe) | 0, y = y + Math.imul(Je, Pe) | 0, X = X + Math.imul(Je, qe) | 0, G = G + Math.imul(Ue, Fe) | 0, y = y + Math.imul(Ue, Qe) | 0, y = y + Math.imul(Ke, Fe) | 0, X = X + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, ct) | 0, y = y + Math.imul(Me, rt) | 0, X = X + Math.imul(Me, ct) | 0; var sr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, G = Math.imul(ye, tt), y = Math.imul(ye, yt), y = y + Math.imul(ge, tt) | 0, X = Math.imul(ge, yt), G = G + Math.imul(ze, wt) | 0, y = y + Math.imul(ze, Mt) | 0, y = y + Math.imul(Ze, wt) | 0, X = X + Math.imul(Ze, Mt) | 0, G = G + Math.imul(bt, St) | 0, y = y + Math.imul(bt, gt) | 0, y = y + Math.imul(We, St) | 0, X = X + Math.imul(We, gt) | 0, G = G + Math.imul(pt, Le) | 0, y = y + Math.imul(pt, xe) | 0, y = y + Math.imul(_t, Le) | 0, X = X + Math.imul(_t, xe) | 0, G = G + Math.imul(mt, Ne) | 0, y = y + Math.imul(mt, Ye) | 0, y = y + Math.imul(et, Ne) | 0, X = X + Math.imul(et, Ye) | 0, G = G + Math.imul(lt, Pe) | 0, y = y + Math.imul(lt, qe) | 0, y = y + Math.imul(ht, Pe) | 0, X = X + Math.imul(ht, qe) | 0, G = G + Math.imul(ke, Fe) | 0, y = y + Math.imul(ke, Qe) | 0, y = y + Math.imul(Je, Fe) | 0, X = X + Math.imul(Je, Qe) | 0, G = G + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ke, rt) | 0, X = X + Math.imul(Ke, ct) | 0; var Kt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, G = Math.imul(ye, wt), y = Math.imul(ye, Mt), y = y + Math.imul(ge, wt) | 0, X = Math.imul(ge, Mt), G = G + Math.imul(ze, St) | 0, y = y + Math.imul(ze, gt) | 0, y = y + Math.imul(Ze, St) | 0, X = X + Math.imul(Ze, gt) | 0, G = G + Math.imul(bt, Le) | 0, y = y + Math.imul(bt, xe) | 0, y = y + Math.imul(We, Le) | 0, X = X + Math.imul(We, xe) | 0, G = G + Math.imul(pt, Ne) | 0, y = y + Math.imul(pt, Ye) | 0, y = y + Math.imul(_t, Ne) | 0, X = X + Math.imul(_t, Ye) | 0, G = G + Math.imul(mt, Pe) | 0, y = y + Math.imul(mt, qe) | 0, y = y + Math.imul(et, Pe) | 0, X = X + Math.imul(et, qe) | 0, G = G + Math.imul(lt, Fe) | 0, y = y + Math.imul(lt, Qe) | 0, y = y + Math.imul(ht, Fe) | 0, X = X + Math.imul(ht, Qe) | 0, G = G + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, ct) | 0, y = y + Math.imul(Je, rt) | 0, X = X + Math.imul(Je, ct) | 0; var Qt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, G = Math.imul(ye, St), y = Math.imul(ye, gt), y = y + Math.imul(ge, St) | 0, X = Math.imul(ge, gt), G = G + Math.imul(ze, Le) | 0, y = y + Math.imul(ze, xe) | 0, y = y + Math.imul(Ze, Le) | 0, X = X + Math.imul(Ze, xe) | 0, G = G + Math.imul(bt, Ne) | 0, y = y + Math.imul(bt, Ye) | 0, y = y + Math.imul(We, Ne) | 0, X = X + Math.imul(We, Ye) | 0, G = G + Math.imul(pt, Pe) | 0, y = y + Math.imul(pt, qe) | 0, y = y + Math.imul(_t, Pe) | 0, X = X + Math.imul(_t, qe) | 0, G = G + Math.imul(mt, Fe) | 0, y = y + Math.imul(mt, Qe) | 0, y = y + Math.imul(et, Fe) | 0, X = X + Math.imul(et, Qe) | 0, G = G + Math.imul(lt, rt) | 0, y = y + Math.imul(lt, ct) | 0, y = y + Math.imul(ht, rt) | 0, X = X + Math.imul(ht, ct) | 0; var $t = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, G = Math.imul(ye, Le), y = Math.imul(ye, xe), y = y + Math.imul(ge, Le) | 0, X = Math.imul(ge, xe), G = G + Math.imul(ze, Ne) | 0, y = y + Math.imul(ze, Ye) | 0, y = y + Math.imul(Ze, Ne) | 0, X = X + Math.imul(Ze, Ye) | 0, G = G + Math.imul(bt, Pe) | 0, y = y + Math.imul(bt, qe) | 0, y = y + Math.imul(We, Pe) | 0, X = X + Math.imul(We, qe) | 0, G = G + Math.imul(pt, Fe) | 0, y = y + Math.imul(pt, Qe) | 0, y = y + Math.imul(_t, Fe) | 0, X = X + Math.imul(_t, Qe) | 0, G = G + Math.imul(mt, rt) | 0, y = y + Math.imul(mt, ct) | 0, y = y + Math.imul(et, rt) | 0, X = X + Math.imul(et, ct) | 0; var Yt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, G = Math.imul(ye, Ne), y = Math.imul(ye, Ye), y = y + Math.imul(ge, Ne) | 0, X = Math.imul(ge, Ye), G = G + Math.imul(ze, Pe) | 0, y = y + Math.imul(ze, qe) | 0, y = y + Math.imul(Ze, Pe) | 0, X = X + Math.imul(Ze, qe) | 0, G = G + Math.imul(bt, Fe) | 0, y = y + Math.imul(bt, Qe) | 0, y = y + Math.imul(We, Fe) | 0, X = X + Math.imul(We, Qe) | 0, G = G + Math.imul(pt, rt) | 0, y = y + Math.imul(pt, ct) | 0, y = y + Math.imul(_t, rt) | 0, X = X + Math.imul(_t, ct) | 0; var Xt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, G = Math.imul(ye, Pe), y = Math.imul(ye, qe), y = y + Math.imul(ge, Pe) | 0, X = Math.imul(ge, qe), G = G + Math.imul(ze, Fe) | 0, y = y + Math.imul(ze, Qe) | 0, y = y + Math.imul(Ze, Fe) | 0, X = X + Math.imul(Ze, Qe) | 0, G = G + Math.imul(bt, rt) | 0, y = y + Math.imul(bt, ct) | 0, y = y + Math.imul(We, rt) | 0, X = X + Math.imul(We, ct) | 0; var Nt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ye, Fe), y = Math.imul(ye, Qe), y = y + Math.imul(ge, Fe) | 0, X = Math.imul(ge, Qe), G = G + Math.imul(ze, rt) | 0, y = y + Math.imul(ze, ct) | 0, y = y + Math.imul(Ze, rt) | 0, X = X + Math.imul(Ze, ct) | 0; var Et = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, G = Math.imul(ye, rt), y = Math.imul(ye, ct), y = y + Math.imul(ge, rt) | 0, X = Math.imul(ge, ct); var At = (ee + G | 0) + ((y & 8191) << 13) | 0; return ee = (X + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, te[0] = Lt, te[1] = It, te[2] = lr, te[3] = jt, te[4] = Ft, te[5] = er, te[6] = ar, te[7] = nr, te[8] = ir, te[9] = Ht, te[10] = sr, te[11] = Kt, te[12] = Qt, te[13] = $t, te[14] = Yt, te[15] = Xt, te[16] = Nt, te[17] = Et, te[18] = At, ee !== 0 && (te[19] = ee, U.length++), U }; Math.imul || (ne = re); function oe(ie, g, P) { P.negative = g.negative ^ ie.negative, P.length = ie.length + g.length; for (var U = 0, K = 0, Y = 0; Y < P.length - 1; Y++) { var te = K; K = 0; for (var ee = U & 67108863, G = Math.min(Y, g.length - 1), y = Math.max(0, Y - ie.length + 1); y <= G; y++) { var X = Y - y, ce = ie.words[X] | 0, me = g.words[y] | 0, Ae = ce * me, Ie = Ae & 67108863; te = te + (Ae / 67108864 | 0) | 0, Ie = Ie + ee | 0, ee = Ie & 67108863, te = te + (Ie >>> 26) | 0, K += te >>> 26, te &= 67108863 } P.words[Y] = ee, U = te, te = K } return U !== 0 ? P.words[Y] = U : P.length--, P.strip() } function ae(ie, g, P) { var U = new se; return U.mulp(ie, g, P) } d.prototype.mulTo = function (g, P) { var U, K = this.length + g.length; return this.length === 10 && g.length === 10 ? U = ne(this, g, P) : K < 63 ? U = re(this, g, P) : K < 1024 ? U = oe(this, g, P) : U = ae(this, g, P), U }; function se(ie, g) { this.x = ie, this.y = g } se.prototype.makeRBT = function (g) { for (var P = new Array(g), U = d.prototype._countBits(g) - 1, K = 0; K < g; K++)P[K] = this.revBin(K, U, g); return P }, se.prototype.revBin = function (g, P, U) { if (g === 0 || g === U - 1) return g; for (var K = 0, Y = 0; Y < P; Y++)K |= (g & 1) << P - Y - 1, g >>= 1; return K }, se.prototype.permute = function (g, P, U, K, Y, te) { for (var ee = 0; ee < te; ee++)K[ee] = P[g[ee]], Y[ee] = U[g[ee]] }, se.prototype.transform = function (g, P, U, K, Y, te) { this.permute(te, g, P, U, K, Y); for (var ee = 1; ee < Y; ee <<= 1)for (var G = ee << 1, y = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), ce = 0; ce < Y; ce += G)for (var me = y, Ae = X, Ie = 0; Ie < ee; Ie++) { var Be = U[ce + Ie], Me = K[ce + Ie], De = U[ce + Ie + ee], Ue = K[ce + Ie + ee], Ke = me * De - Ae * Ue; Ue = me * Ue + Ae * De, De = Ke, U[ce + Ie] = Be + De, K[ce + Ie] = Me + Ue, U[ce + Ie + ee] = Be - De, K[ce + Ie + ee] = Me - Ue, Ie !== G && (Ke = y * me - X * Ae, Ae = y * Ae + X * me, me = Ke) } }, se.prototype.guessLen13b = function (g, P) { var U = Math.max(P, g) | 1, K = U & 1, Y = 0; for (U = U / 2 | 0; U; U = U >>> 1)Y++; return 1 << Y + 1 + K }, se.prototype.conjugate = function (g, P, U) { if (!(U <= 1)) for (var K = 0; K < U / 2; K++) { var Y = g[K]; g[K] = g[U - K - 1], g[U - K - 1] = Y, Y = P[K], P[K] = -P[U - K - 1], P[U - K - 1] = -Y } }, se.prototype.normalize13b = function (g, P) { for (var U = 0, K = 0; K < P / 2; K++) { var Y = Math.round(g[2 * K + 1] / P) * 8192 + Math.round(g[2 * K] / P) + U; g[K] = Y & 67108863, Y < 67108864 ? U = 0 : U = Y / 67108864 | 0 } return g }, se.prototype.convert13b = function (g, P, U, K) { for (var Y = 0, te = 0; te < P; te++)Y = Y + (g[te] | 0), U[2 * te] = Y & 8191, Y = Y >>> 13, U[2 * te + 1] = Y & 8191, Y = Y >>> 13; for (te = 2 * P; te < K; ++te)U[te] = 0; f(Y === 0), f((Y & -8192) === 0) }, se.prototype.stub = function (g) { for (var P = new Array(g), U = 0; U < g; U++)P[U] = 0; return P }, se.prototype.mulp = function (g, P, U) { var K = 2 * this.guessLen13b(g.length, P.length), Y = this.makeRBT(K), te = this.stub(K), ee = new Array(K), G = new Array(K), y = new Array(K), X = new Array(K), ce = new Array(K), me = new Array(K), Ae = U.words; Ae.length = K, this.convert13b(g.words, g.length, ee, K), this.convert13b(P.words, P.length, X, K), this.transform(ee, te, G, y, K, Y), this.transform(X, te, ce, me, K, Y); for (var Ie = 0; Ie < K; Ie++) { var Be = G[Ie] * ce[Ie] - y[Ie] * me[Ie]; y[Ie] = G[Ie] * me[Ie] + y[Ie] * ce[Ie], G[Ie] = Be } return this.conjugate(G, y, K), this.transform(G, y, Ae, te, K, Y), this.conjugate(Ae, te, K), this.normalize13b(Ae, K), U.negative = g.negative ^ P.negative, U.length = g.length + P.length, U.strip() }, d.prototype.mul = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), this.mulTo(g, P) }, d.prototype.mulf = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), ae(this, g, P) }, d.prototype.imul = function (g) { return this.clone().mulTo(g, this) }, d.prototype.imuln = function (g) { f(typeof g == "number"), f(g < 67108864); for (var P = 0, U = 0; U < this.length; U++) { var K = (this.words[U] | 0) * g, Y = (K & 67108863) + (P & 67108863); P >>= 26, P += K / 67108864 | 0, P += Y >>> 26, this.words[U] = Y & 67108863 } return P !== 0 && (this.words[U] = P, this.length++), this }, d.prototype.muln = function (g) { return this.clone().imuln(g) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (g) { var P = Q(g); if (P.length === 0) return new d(1); for (var U = this, K = 0; K < P.length && P[K] === 0; K++, U = U.sqr()); if (++K < P.length) for (var Y = U.sqr(); K < P.length; K++, Y = Y.sqr())P[K] !== 0 && (U = U.mul(Y)); return U }, d.prototype.iushln = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 67108863 >>> 26 - P << 26 - P, Y; if (P !== 0) { var te = 0; for (Y = 0; Y < this.length; Y++) { var ee = this.words[Y] & K, G = (this.words[Y] | 0) - ee << P; this.words[Y] = G | te, te = ee >>> 26 - P } te && (this.words[Y] = te, this.length++) } if (U !== 0) { for (Y = this.length - 1; Y >= 0; Y--)this.words[Y + U] = this.words[Y]; for (Y = 0; Y < U; Y++)this.words[Y] = 0; this.length += U } return this.strip() }, d.prototype.ishln = function (g) { return f(this.negative === 0), this.iushln(g) }, d.prototype.iushrn = function (g, P, U) { f(typeof g == "number" && g >= 0); var K; P ? K = (P - P % 26) / 26 : K = 0; var Y = g % 26, te = Math.min((g - Y) / 26, this.length), ee = 67108863 ^ 67108863 >>> Y << Y, G = U; if (K -= te, K = Math.max(0, K), G) { for (var y = 0; y < te; y++)G.words[y] = this.words[y]; G.length = te } if (te !== 0) if (this.length > te) for (this.length -= te, y = 0; y < this.length; y++)this.words[y] = this.words[y + te]; else this.words[0] = 0, this.length = 1; var X = 0; for (y = this.length - 1; y >= 0 && (X !== 0 || y >= K); y--) { var ce = this.words[y] | 0; this.words[y] = X << 26 - Y | ce >>> Y, X = ce & ee } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, d.prototype.ishrn = function (g, P, U) { return f(this.negative === 0), this.iushrn(g, P, U) }, d.prototype.shln = function (g) { return this.clone().ishln(g) }, d.prototype.ushln = function (g) { return this.clone().iushln(g) }, d.prototype.shrn = function (g) { return this.clone().ishrn(g) }, d.prototype.ushrn = function (g) { return this.clone().iushrn(g) }, d.prototype.testn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return !1; var Y = this.words[U]; return !!(Y & K) }, d.prototype.imaskn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U) return this; if (P !== 0 && U++, this.length = Math.min(U, this.length), P !== 0) { var K = 67108863 ^ 67108863 >>> P << P; this.words[this.length - 1] &= K } return this.strip() }, d.prototype.maskn = function (g) { return this.clone().imaskn(g) }, d.prototype.iaddn = function (g) { return f(typeof g == "number"), f(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g) }, d.prototype._iaddn = function (g) { this.words[0] += g; for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++; return this.length = Math.max(this.length, P + 1), this }, d.prototype.isubn = function (g) { if (f(typeof g == "number"), f(g < 67108864), g < 0) return this.iaddn(-g); if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this; if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var P = 0; P < this.length && this.words[P] < 0; P++)this.words[P] += 67108864, this.words[P + 1] -= 1; return this.strip() }, d.prototype.addn = function (g) { return this.clone().iaddn(g) }, d.prototype.subn = function (g) { return this.clone().isubn(g) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (g, P, U) { var K = g.length + U, Y; this._expand(K); var te, ee = 0; for (Y = 0; Y < g.length; Y++) { te = (this.words[Y + U] | 0) + ee; var G = (g.words[Y] | 0) * P; te -= G & 67108863, ee = (te >> 26) - (G / 67108864 | 0), this.words[Y + U] = te & 67108863 } for (; Y < this.length - U; Y++)te = (this.words[Y + U] | 0) + ee, ee = te >> 26, this.words[Y + U] = te & 67108863; if (ee === 0) return this.strip(); for (f(ee === -1), ee = 0, Y = 0; Y < this.length; Y++)te = -(this.words[Y] | 0) + ee, ee = te >> 26, this.words[Y] = te & 67108863; return this.negative = 1, this.strip() }, d.prototype._wordDiv = function (g, P) { var U = this.length - g.length, K = this.clone(), Y = g, te = Y.words[Y.length - 1] | 0, ee = this._countBits(te); U = 26 - ee, U !== 0 && (Y = Y.ushln(U), K.iushln(U), te = Y.words[Y.length - 1] | 0); var G = K.length - Y.length, y; if (P !== "mod") { y = new d(null), y.length = G + 1, y.words = new Array(y.length); for (var X = 0; X < y.length; X++)y.words[X] = 0 } var ce = K.clone()._ishlnsubmul(Y, 1, G); ce.negative === 0 && (K = ce, y && (y.words[G] = 1)); for (var me = G - 1; me >= 0; me--) { var Ae = (K.words[Y.length + me] | 0) * 67108864 + (K.words[Y.length + me - 1] | 0); for (Ae = Math.min(Ae / te | 0, 67108863), K._ishlnsubmul(Y, Ae, me); K.negative !== 0;)Ae--, K.negative = 0, K._ishlnsubmul(Y, 1, me), K.isZero() || (K.negative ^= 1); y && (y.words[me] = Ae) } return y && y.strip(), K.strip(), P !== "div" && U !== 0 && K.iushrn(U), { div: y || null, mod: K } }, d.prototype.divmod = function (g, P, U) { if (f(!g.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var K, Y, te; return this.negative !== 0 && g.negative === 0 ? (te = this.neg().divmod(g, P), P !== "mod" && (K = te.div.neg()), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.iadd(g)), { div: K, mod: Y }) : this.negative === 0 && g.negative !== 0 ? (te = this.divmod(g.neg(), P), P !== "mod" && (K = te.div.neg()), { div: K, mod: te.mod }) : (this.negative & g.negative) !== 0 ? (te = this.neg().divmod(g.neg(), P), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.isub(g)), { div: te.div, mod: Y }) : g.length > this.length || this.cmp(g) < 0 ? { div: new d(0), mod: this } : g.length === 1 ? P === "div" ? { div: this.divn(g.words[0]), mod: null } : P === "mod" ? { div: null, mod: new d(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new d(this.modn(g.words[0])) } : this._wordDiv(g, P) }, d.prototype.div = function (g) { return this.divmod(g, "div", !1).div }, d.prototype.mod = function (g) { return this.divmod(g, "mod", !1).mod }, d.prototype.umod = function (g) { return this.divmod(g, "mod", !0).mod }, d.prototype.divRound = function (g) { var P = this.divmod(g); if (P.mod.isZero()) return P.div; var U = P.div.negative !== 0 ? P.mod.isub(g) : P.mod, K = g.ushrn(1), Y = g.andln(1), te = U.cmp(K); return te < 0 || Y === 1 && te === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1) }, d.prototype.modn = function (g) { f(g <= 67108863); for (var P = (1 << 26) % g, U = 0, K = this.length - 1; K >= 0; K--)U = (P * U + (this.words[K] | 0)) % g; return U }, d.prototype.idivn = function (g) { f(g <= 67108863); for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = (this.words[U] | 0) + P * 67108864; this.words[U] = K / g | 0, P = K % g } return this.strip() }, d.prototype.divn = function (g) { return this.clone().idivn(g) }, d.prototype.egcd = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = new d(0), ee = new d(1), G = 0; P.isEven() && U.isEven();)P.iushrn(1), U.iushrn(1), ++G; for (var y = U.clone(), X = P.clone(); !P.isZero();) { for (var ce = 0, me = 1; (P.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (P.iushrn(ce); ce-- > 0;)(K.isOdd() || Y.isOdd()) && (K.iadd(y), Y.isub(X)), K.iushrn(1), Y.iushrn(1); for (var Ae = 0, Ie = 1; (U.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (U.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(y), ee.isub(X)), te.iushrn(1), ee.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(te), Y.isub(ee)) : (U.isub(P), te.isub(K), ee.isub(Y)) } return { a: te, b: ee, gcd: U.iushln(G) } }, d.prototype._invmp = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = U.clone(); P.cmpn(1) > 0 && U.cmpn(1) > 0;) { for (var ee = 0, G = 1; (P.words[0] & G) === 0 && ee < 26; ++ee, G <<= 1); if (ee > 0) for (P.iushrn(ee); ee-- > 0;)K.isOdd() && K.iadd(te), K.iushrn(1); for (var y = 0, X = 1; (U.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (U.iushrn(y); y-- > 0;)Y.isOdd() && Y.iadd(te), Y.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(Y)) : (U.isub(P), Y.isub(K)) } var ce; return P.cmpn(1) === 0 ? ce = K : ce = Y, ce.cmpn(0) < 0 && ce.iadd(g), ce }, d.prototype.gcd = function (g) { if (this.isZero()) return g.abs(); if (g.isZero()) return this.abs(); var P = this.clone(), U = g.clone(); P.negative = 0, U.negative = 0; for (var K = 0; P.isEven() && U.isEven(); K++)P.iushrn(1), U.iushrn(1); do { for (; P.isEven();)P.iushrn(1); for (; U.isEven();)U.iushrn(1); var Y = P.cmp(U); if (Y < 0) { var te = P; P = U, U = te } else if (Y === 0 || U.cmpn(1) === 0) break; P.isub(U) } while (!0); return U.iushln(K) }, d.prototype.invm = function (g) { return this.egcd(g).a.umod(g) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (g) { return this.words[0] & g }, d.prototype.bincn = function (g) { f(typeof g == "number"); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return this._expand(U + 1), this.words[U] |= K, this; for (var Y = K, te = U; Y !== 0 && te < this.length; te++) { var ee = this.words[te] | 0; ee += Y, Y = ee >>> 26, ee &= 67108863, this.words[te] = ee } return Y !== 0 && (this.words[te] = Y, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (g) { var P = g < 0; if (this.negative !== 0 && !P) return -1; if (this.negative === 0 && P) return 1; this.strip(); var U; if (this.length > 1) U = 1; else { P && (g = -g), f(g <= 67108863, "Number is too big"); var K = this.words[0] | 0; U = K === g ? 0 : K < g ? -1 : 1 } return this.negative !== 0 ? -U | 0 : U }, d.prototype.cmp = function (g) { if (this.negative !== 0 && g.negative === 0) return -1; if (this.negative === 0 && g.negative !== 0) return 1; var P = this.ucmp(g); return this.negative !== 0 ? -P | 0 : P }, d.prototype.ucmp = function (g) { if (this.length > g.length) return 1; if (this.length < g.length) return -1; for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = this.words[U] | 0, Y = g.words[U] | 0; if (K !== Y) { K < Y ? P = -1 : K > Y && (P = 1); break } } return P }, d.prototype.gtn = function (g) { return this.cmpn(g) === 1 }, d.prototype.gt = function (g) { return this.cmp(g) === 1 }, d.prototype.gten = function (g) { return this.cmpn(g) >= 0 }, d.prototype.gte = function (g) { return this.cmp(g) >= 0 }, d.prototype.ltn = function (g) { return this.cmpn(g) === -1 }, d.prototype.lt = function (g) { return this.cmp(g) === -1 }, d.prototype.lten = function (g) { return this.cmpn(g) <= 0 }, d.prototype.lte = function (g) { return this.cmp(g) <= 0 }, d.prototype.eqn = function (g) { return this.cmpn(g) === 0 }, d.prototype.eq = function (g) { return this.cmp(g) === 0 }, d.red = function (g) { return new Se(g) }, d.prototype.toRed = function (g) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (g) { return this.red = g, this }, d.prototype.forceRed = function (g) { return f(!this.red, "Already a number in reduction context"), this._forceRed(g) }, d.prototype.redAdd = function (g) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, g) }, d.prototype.redIAdd = function (g) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g) }, d.prototype.redSub = function (g) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, g) }, d.prototype.redISub = function (g) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, g) }, d.prototype.redShl = function (g) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, g) }, d.prototype.redMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g) }, d.prototype.redIMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (g) { return f(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g) }; var le = { k256: null, p224: null, p192: null, p25519: null }; function ue(ie, g) { this.name = ie, this.p = new d(g, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } ue.prototype._tmp = function () { var g = new d(null); return g.words = new Array(Math.ceil(this.n / 13)), g }, ue.prototype.ireduce = function (g) { var P = g, U; do this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), U = P.bitLength(); while (U > this.n); var K = U < this.n ? -1 : P.ucmp(this.p); return K === 0 ? (P.words[0] = 0, P.length = 1) : K > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P }, ue.prototype.split = function (g, P) { g.iushrn(this.n, 0, P) }, ue.prototype.imulK = function (g) { return g.imul(this.k) }; function he() { ue.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(he, ue), he.prototype.split = function (g, P) { for (var U = 4194303, K = Math.min(g.length, 9), Y = 0; Y < K; Y++)P.words[Y] = g.words[Y]; if (P.length = K, g.length <= 9) { g.words[0] = 0, g.length = 1; return } var te = g.words[9]; for (P.words[P.length++] = te & U, Y = 10; Y < g.length; Y++) { var ee = g.words[Y] | 0; g.words[Y - 10] = (ee & U) << 4 | te >>> 22, te = ee } te >>>= 22, g.words[Y - 10] = te, te === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9 }, he.prototype.imulK = function (g) { g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2; for (var P = 0, U = 0; U < g.length; U++) { var K = g.words[U] | 0; P += K * 977, g.words[U] = P & 67108863, P = K * 64 + (P / 67108864 | 0) } return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g }; function pe() { ue.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(pe, ue); function ve() { ue.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(ve, ue); function _e() { ue.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p(_e, ue), _e.prototype.imulK = function (g) { for (var P = 0, U = 0; U < g.length; U++) { var K = (g.words[U] | 0) * 19 + P, Y = K & 67108863; K >>>= 26, g.words[U] = Y, P = K } return P !== 0 && (g.words[g.length++] = P), g }, d._prime = function (g) { if (le[g]) return le[g]; var P; if (g === "k256") P = new he; else if (g === "p224") P = new pe; else if (g === "p192") P = new ve; else if (g === "p25519") P = new _e; else throw new Error("Unknown prime " + g); return le[g] = P, P }; function Se(ie) { if (typeof ie == "string") { var g = d._prime(ie); this.m = g.p, this.prime = g } else f(ie.gtn(1), "modulus must be greater than 1"), this.m = ie, this.prime = null } Se.prototype._verify1 = function (g) { f(g.negative === 0, "red works only with positives"), f(g.red, "red works only with red numbers") }, Se.prototype._verify2 = function (g, P) { f((g.negative | P.negative) === 0, "red works only with positives"), f(g.red && g.red === P.red, "red works only with red numbers") }, Se.prototype.imod = function (g) { return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this) }, Se.prototype.neg = function (g) { return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this) }, Se.prototype.add = function (g, P) { this._verify2(g, P); var U = g.add(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this) }, Se.prototype.iadd = function (g, P) { this._verify2(g, P); var U = g.iadd(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U }, Se.prototype.sub = function (g, P) { this._verify2(g, P); var U = g.sub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this) }, Se.prototype.isub = function (g, P) { this._verify2(g, P); var U = g.isub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U }, Se.prototype.shl = function (g, P) { return this._verify1(g), this.imod(g.ushln(P)) }, Se.prototype.imul = function (g, P) { return this._verify2(g, P), this.imod(g.imul(P)) }, Se.prototype.mul = function (g, P) { return this._verify2(g, P), this.imod(g.mul(P)) }, Se.prototype.isqr = function (g) { return this.imul(g, g.clone()) }, Se.prototype.sqr = function (g) { return this.mul(g, g) }, Se.prototype.sqrt = function (g) { if (g.isZero()) return g.clone(); var P = this.m.andln(3); if (f(P % 2 === 1), P === 3) { var U = this.m.add(new d(1)).iushrn(2); return this.pow(g, U) } for (var K = this.m.subn(1), Y = 0; !K.isZero() && K.andln(1) === 0;)Y++, K.iushrn(1); f(!K.isZero()); var te = new d(1).toRed(this), ee = te.redNeg(), G = this.m.subn(1).iushrn(1), y = this.m.bitLength(); for (y = new d(2 * y * y).toRed(this); this.pow(y, G).cmp(ee) !== 0;)y.redIAdd(ee); for (var X = this.pow(y, K), ce = this.pow(g, K.addn(1).iushrn(1)), me = this.pow(g, K), Ae = Y; me.cmp(te) !== 0;) { for (var Ie = me, Be = 0; Ie.cmp(te) !== 0; Be++)Ie = Ie.redSqr(); f(Be < Ae); var Me = this.pow(X, new d(1).iushln(Ae - Be - 1)); ce = ce.redMul(Me), X = Me.redSqr(), me = me.redMul(X), Ae = Be } return ce }, Se.prototype.invm = function (g) { var P = g._invmp(this.m); return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P) }, Se.prototype.pow = function (g, P) { if (P.isZero()) return new d(1).toRed(this); if (P.cmpn(1) === 0) return g.clone(); var U = 4, K = new Array(1 << U); K[0] = new d(1).toRed(this), K[1] = g; for (var Y = 2; Y < K.length; Y++)K[Y] = this.mul(K[Y - 1], g); var te = K[0], ee = 0, G = 0, y = P.bitLength() % 26; for (y === 0 && (y = 26), Y = P.length - 1; Y >= 0; Y--) { for (var X = P.words[Y], ce = y - 1; ce >= 0; ce--) { var me = X >> ce & 1; if (te !== K[0] && (te = this.sqr(te)), me === 0 && ee === 0) { G = 0; continue } ee <<= 1, ee |= me, G++, !(G !== U && (Y !== 0 || ce !== 0)) && (te = this.mul(te, K[ee]), G = 0, ee = 0) } y = 26 } return te }, Se.prototype.convertTo = function (g) { var P = g.umod(this.m); return P === g ? P.clone() : P }, Se.prototype.convertFrom = function (g) { var P = g.clone(); return P.red = null, P }, d.mont = function (g) { return new $e(g) }; function $e(ie) { Se.call(this, ie), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p($e, Se), $e.prototype.convertTo = function (g) { return this.imod(g.ushln(this.shift)) }, $e.prototype.convertFrom = function (g) { var P = this.imod(g.mul(this.rinv)); return P.red = null, P }, $e.prototype.imul = function (g, P) { if (g.isZero() || P.isZero()) return g.words[0] = 0, g.length = 1, g; var U = g.imul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.mul = function (g, P) { if (g.isZero() || P.isZero()) return new d(0)._forceRed(this); var U = g.mul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.invm = function (g) { var P = this.imod(g._invmp(this.m).mul(this.r2)); return P._forceRed(this) } })(o, bn$c) }(bn$d)), bn$d.exports } var bn$b = { exports: {} }, bn$a = bn$b.exports, hasRequiredBn$5; function requireBn$5() { return hasRequiredBn$5 || (hasRequiredBn$5 = 1, function (o) { (function (l, u) { function f(ie, g) { if (!ie) throw new Error(g || "Assertion failed") } function p(ie, g) { ie.super_ = g; var P = function () { }; P.prototype = g.prototype, ie.prototype = new P, ie.prototype.constructor = ie } function d(ie, g, P) { if (d.isBN(ie)) return ie; this.negative = 0, this.words = null, this.length = 0, this.red = null, ie !== null && ((g === "le" || g === "be") && (P = g, g = 10), this._init(ie || 0, g || 10, P || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (g) { return g instanceof d ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === d.wordSize && Array.isArray(g.words) }, d.max = function (g, P) { return g.cmp(P) > 0 ? g : P }, d.min = function (g, P) { return g.cmp(P) < 0 ? g : P }, d.prototype._init = function (g, P, U) { if (typeof g == "number") return this._initNumber(g, P, U); if (typeof g == "object") return this._initArray(g, P, U); P === "hex" && (P = 16), f(P === (P | 0) && P >= 2 && P <= 36), g = g.toString().replace(/\s+/g, ""); var K = 0; g[0] === "-" && (K++, this.negative = 1), K < g.length && (P === 16 ? this._parseHex(g, K, U) : (this._parseBase(g, P, K), U === "le" && this._initArray(this.toArray(), P, U))) }, d.prototype._initNumber = function (g, P, U) { g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [g & 67108863, g / 67108864 & 67108863], this.length = 2) : (f(g < 9007199254740992), this.words = [g & 67108863, g / 67108864 & 67108863, 1], this.length = 3), U === "le" && this._initArray(this.toArray(), P, U) }, d.prototype._initArray = function (g, P, U) { if (f(typeof g.length == "number"), g.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(g.length / 3), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y, te, ee = 0; if (U === "be") for (K = g.length - 1, Y = 0; K >= 0; K -= 3)te = g[K] | g[K - 1] << 8 | g[K - 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); else if (U === "le") for (K = 0, Y = 0; K < g.length; K += 3)te = g[K] | g[K + 1] << 8 | g[K + 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); return this.strip() }; function v(ie, g) { var P = ie.charCodeAt(g); return P >= 65 && P <= 70 ? P - 55 : P >= 97 && P <= 102 ? P - 87 : P - 48 & 15 } function I(ie, g, P) { var U = v(ie, P); return P - 1 >= g && (U |= v(ie, P - 1) << 4), U } d.prototype._parseHex = function (g, P, U) { this.length = Math.ceil((g.length - P) / 6), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y = 0, te = 0, ee; if (U === "be") for (K = g.length - 1; K >= P; K -= 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8; else { var G = g.length - P; for (K = G % 2 === 0 ? P + 1 : P; K < g.length; K += 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8 } this.strip() }; function F(ie, g, P, U) { for (var K = 0, Y = Math.min(ie.length, P), te = g; te < Y; te++) { var ee = ie.charCodeAt(te) - 48; K *= U, ee >= 49 ? K += ee - 49 + 10 : ee >= 17 ? K += ee - 17 + 10 : K += ee } return K } d.prototype._parseBase = function (g, P, U) { this.words = [0], this.length = 1; for (var K = 0, Y = 1; Y <= 67108863; Y *= P)K++; K--, Y = Y / P | 0; for (var te = g.length - U, ee = te % K, G = Math.min(te, te - ee) + U, y = 0, X = U; X < G; X += K)y = F(g, X, X + K, P), this.imuln(Y), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y); if (ee !== 0) { var ce = 1; for (y = F(g, X, g.length, P), X = 0; X < ee; X++)ce *= P; this.imuln(ce), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y) } this.strip() }, d.prototype.copy = function (g) { g.words = new Array(this.length); for (var P = 0; P < this.length; P++)g.words[P] = this.words[P]; g.length = this.length, g.negative = this.negative, g.red = this.red }, d.prototype.clone = function () { var g = new d(null); return this.copy(g), g }, d.prototype._expand = function (g) { for (; this.length < g;)this.words[this.length++] = 0; return this }, d.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, d.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var B = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], W = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (g, P) { g = g || 10, P = P | 0 || 1; var U; if (g === 16 || g === "hex") { U = ""; for (var K = 0, Y = 0, te = 0; te < this.length; te++) { var ee = this.words[te], G = ((ee << K | Y) & 16777215).toString(16); Y = ee >>> 24 - K & 16777215, Y !== 0 || te !== this.length - 1 ? U = B[6 - G.length] + G + U : U = G + U, K += 2, K >= 26 && (K -= 26, te--) } for (Y !== 0 && (U = Y.toString(16) + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } if (g === (g | 0) && g >= 2 && g <= 36) { var y = W[g], X = Z[g]; U = ""; var ce = this.clone(); for (ce.negative = 0; !ce.isZero();) { var me = ce.modn(X).toString(g); ce = ce.idivn(X), ce.isZero() ? U = me + U : U = B[y - me.length] + me + U } for (this.isZero() && (U = "0" + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var g = this.words[0]; return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g }, d.prototype.toJSON = function () { return this.toString(16) }, d.prototype.toBuffer = function (g, P) { return f(typeof m < "u"), this.toArrayLike(m, g, P) }, d.prototype.toArray = function (g, P) { return this.toArrayLike(Array, g, P) }, d.prototype.toArrayLike = function (g, P, U) { var K = this.byteLength(), Y = U || Math.max(1, K); f(K <= Y, "byte array longer than desired length"), f(Y > 0, "Requested array length <= 0"), this.strip(); var te = P === "le", ee = new g(Y), G, y, X = this.clone(); if (te) { for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[y] = G; for (; y < Y; y++)ee[y] = 0 } else { for (y = 0; y < Y - K; y++)ee[y] = 0; for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[Y - y - 1] = G } return ee }, Math.clz32 ? d.prototype._countBits = function (g) { return 32 - Math.clz32(g) } : d.prototype._countBits = function (g) { var P = g, U = 0; return P >= 4096 && (U += 13, P >>>= 13), P >= 64 && (U += 7, P >>>= 7), P >= 8 && (U += 4, P >>>= 4), P >= 2 && (U += 2, P >>>= 2), U + P }, d.prototype._zeroBits = function (g) { if (g === 0) return 26; var P = g, U = 0; return (P & 8191) === 0 && (U += 13, P >>>= 13), (P & 127) === 0 && (U += 7, P >>>= 7), (P & 15) === 0 && (U += 4, P >>>= 4), (P & 3) === 0 && (U += 2, P >>>= 2), (P & 1) === 0 && U++, U }, d.prototype.bitLength = function () { var g = this.words[this.length - 1], P = this._countBits(g); return (this.length - 1) * 26 + P }; function Q(ie) { for (var g = new Array(ie.bitLength()), P = 0; P < g.length; P++) { var U = P / 26 | 0, K = P % 26; g[P] = (ie.words[U] & 1 << K) >>> K } return g } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var g = 0, P = 0; P < this.length; P++) { var U = this._zeroBits(this.words[P]); if (g += U, U !== 26) break } return g }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (g) { return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (g) { return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (g) { for (; this.length < g.length;)this.words[this.length++] = 0; for (var P = 0; P < g.length; P++)this.words[P] = this.words[P] | g.words[P]; return this.strip() }, d.prototype.ior = function (g) { return f((this.negative | g.negative) === 0), this.iuor(g) }, d.prototype.or = function (g) { return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this) }, d.prototype.uor = function (g) { return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this) }, d.prototype.iuand = function (g) { var P; this.length > g.length ? P = g : P = this; for (var U = 0; U < P.length; U++)this.words[U] = this.words[U] & g.words[U]; return this.length = P.length, this.strip() }, d.prototype.iand = function (g) { return f((this.negative | g.negative) === 0), this.iuand(g) }, d.prototype.and = function (g) { return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this) }, d.prototype.uand = function (g) { return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this) }, d.prototype.iuxor = function (g) { var P, U; this.length > g.length ? (P = this, U = g) : (P = g, U = this); for (var K = 0; K < U.length; K++)this.words[K] = P.words[K] ^ U.words[K]; if (this !== P) for (; K < P.length; K++)this.words[K] = P.words[K]; return this.length = P.length, this.strip() }, d.prototype.ixor = function (g) { return f((this.negative | g.negative) === 0), this.iuxor(g) }, d.prototype.xor = function (g) { return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this) }, d.prototype.uxor = function (g) { return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this) }, d.prototype.inotn = function (g) { f(typeof g == "number" && g >= 0); var P = Math.ceil(g / 26) | 0, U = g % 26; this._expand(P), U > 0 && P--; for (var K = 0; K < P; K++)this.words[K] = ~this.words[K] & 67108863; return U > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - U), this.strip() }, d.prototype.notn = function (g) { return this.clone().inotn(g) }, d.prototype.setn = function (g, P) { f(typeof g == "number" && g >= 0); var U = g / 26 | 0, K = g % 26; return this._expand(U + 1), P ? this.words[U] = this.words[U] | 1 << K : this.words[U] = this.words[U] & ~(1 << K), this.strip() }, d.prototype.iadd = function (g) { var P; if (this.negative !== 0 && g.negative === 0) return this.negative = 0, P = this.isub(g), this.negative ^= 1, this._normSign(); if (this.negative === 0 && g.negative !== 0) return g.negative = 0, P = this.isub(g), g.negative = 1, P._normSign(); var U, K; this.length > g.length ? (U = this, K = g) : (U = g, K = this); for (var Y = 0, te = 0; te < K.length; te++)P = (U.words[te] | 0) + (K.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; for (; Y !== 0 && te < U.length; te++)P = (U.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; if (this.length = U.length, Y !== 0) this.words[this.length] = Y, this.length++; else if (U !== this) for (; te < U.length; te++)this.words[te] = U.words[te]; return this }, d.prototype.add = function (g) { var P; return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, P = this.sub(g), g.negative ^= 1, P) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = g.sub(this), this.negative = 1, P) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this) }, d.prototype.isub = function (g) { if (g.negative !== 0) { g.negative = 0; var P = this.iadd(g); return g.negative = 1, P._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign(); var U = this.cmp(g); if (U === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var K, Y; U > 0 ? (K = this, Y = g) : (K = g, Y = this); for (var te = 0, ee = 0; ee < Y.length; ee++)P = (K.words[ee] | 0) - (Y.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; for (; te !== 0 && ee < K.length; ee++)P = (K.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; if (te === 0 && ee < K.length && K !== this) for (; ee < K.length; ee++)this.words[ee] = K.words[ee]; return this.length = Math.max(this.length, ee), K !== this && (this.negative = 1), this.strip() }, d.prototype.sub = function (g) { return this.clone().isub(g) }; function re(ie, g, P) { P.negative = g.negative ^ ie.negative; var U = ie.length + g.length | 0; P.length = U, U = U - 1 | 0; var K = ie.words[0] | 0, Y = g.words[0] | 0, te = K * Y, ee = te & 67108863, G = te / 67108864 | 0; P.words[0] = ee; for (var y = 1; y < U; y++) { for (var X = G >>> 26, ce = G & 67108863, me = Math.min(y, g.length - 1), Ae = Math.max(0, y - ie.length + 1); Ae <= me; Ae++) { var Ie = y - Ae | 0; K = ie.words[Ie] | 0, Y = g.words[Ae] | 0, te = K * Y + ce, X += te / 67108864 | 0, ce = te & 67108863 } P.words[y] = ce | 0, G = X | 0 } return G !== 0 ? P.words[y] = G | 0 : P.length--, P.strip() } var ne = function (g, P, U) { var K = g.words, Y = P.words, te = U.words, ee = 0, G, y, X, ce = K[0] | 0, me = ce & 8191, Ae = ce >>> 13, Ie = K[1] | 0, Be = Ie & 8191, Me = Ie >>> 13, De = K[2] | 0, Ue = De & 8191, Ke = De >>> 13, Ve = K[3] | 0, ke = Ve & 8191, Je = Ve >>> 13, dt = K[4] | 0, lt = dt & 8191, ht = dt >>> 13, Bt = K[5] | 0, mt = Bt & 8191, et = Bt >>> 13, Gt = K[6] | 0, pt = Gt & 8191, _t = Gt >>> 13, zt = K[7] | 0, bt = zt & 8191, We = zt >>> 13, Ge = K[8] | 0, ze = Ge & 8191, Ze = Ge >>> 13, ut = K[9] | 0, ye = ut & 8191, ge = ut >>> 13, Ee = Y[0] | 0, Oe = Ee & 8191, je = Ee >>> 13, nt = Y[1] | 0, Xe = nt & 8191, it = nt >>> 13, Tt = Y[2] | 0, tt = Tt & 8191, yt = Tt >>> 13, kt = Y[3] | 0, wt = kt & 8191, Mt = kt >>> 13, tr = Y[4] | 0, St = tr & 8191, gt = tr >>> 13, rr = Y[5] | 0, Le = rr & 8191, xe = rr >>> 13, Ce = Y[6] | 0, Ne = Ce & 8191, Ye = Ce >>> 13, Re = Y[7] | 0, Pe = Re & 8191, qe = Re >>> 13, be = Y[8] | 0, Fe = be & 8191, Qe = be >>> 13, st = Y[9] | 0, rt = st & 8191, ct = st >>> 13; U.negative = g.negative ^ P.negative, U.length = 19, G = Math.imul(me, Oe), y = Math.imul(me, je), y = y + Math.imul(Ae, Oe) | 0, X = Math.imul(Ae, je); var Lt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(Be, Oe), y = Math.imul(Be, je), y = y + Math.imul(Me, Oe) | 0, X = Math.imul(Me, je), G = G + Math.imul(me, Xe) | 0, y = y + Math.imul(me, it) | 0, y = y + Math.imul(Ae, Xe) | 0, X = X + Math.imul(Ae, it) | 0; var It = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(Ue, Oe), y = Math.imul(Ue, je), y = y + Math.imul(Ke, Oe) | 0, X = Math.imul(Ke, je), G = G + Math.imul(Be, Xe) | 0, y = y + Math.imul(Be, it) | 0, y = y + Math.imul(Me, Xe) | 0, X = X + Math.imul(Me, it) | 0, G = G + Math.imul(me, tt) | 0, y = y + Math.imul(me, yt) | 0, y = y + Math.imul(Ae, tt) | 0, X = X + Math.imul(Ae, yt) | 0; var lr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, G = Math.imul(ke, Oe), y = Math.imul(ke, je), y = y + Math.imul(Je, Oe) | 0, X = Math.imul(Je, je), G = G + Math.imul(Ue, Xe) | 0, y = y + Math.imul(Ue, it) | 0, y = y + Math.imul(Ke, Xe) | 0, X = X + Math.imul(Ke, it) | 0, G = G + Math.imul(Be, tt) | 0, y = y + Math.imul(Be, yt) | 0, y = y + Math.imul(Me, tt) | 0, X = X + Math.imul(Me, yt) | 0, G = G + Math.imul(me, wt) | 0, y = y + Math.imul(me, Mt) | 0, y = y + Math.imul(Ae, wt) | 0, X = X + Math.imul(Ae, Mt) | 0; var jt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(lt, Oe), y = Math.imul(lt, je), y = y + Math.imul(ht, Oe) | 0, X = Math.imul(ht, je), G = G + Math.imul(ke, Xe) | 0, y = y + Math.imul(ke, it) | 0, y = y + Math.imul(Je, Xe) | 0, X = X + Math.imul(Je, it) | 0, G = G + Math.imul(Ue, tt) | 0, y = y + Math.imul(Ue, yt) | 0, y = y + Math.imul(Ke, tt) | 0, X = X + Math.imul(Ke, yt) | 0, G = G + Math.imul(Be, wt) | 0, y = y + Math.imul(Be, Mt) | 0, y = y + Math.imul(Me, wt) | 0, X = X + Math.imul(Me, Mt) | 0, G = G + Math.imul(me, St) | 0, y = y + Math.imul(me, gt) | 0, y = y + Math.imul(Ae, St) | 0, X = X + Math.imul(Ae, gt) | 0; var Ft = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(mt, Oe), y = Math.imul(mt, je), y = y + Math.imul(et, Oe) | 0, X = Math.imul(et, je), G = G + Math.imul(lt, Xe) | 0, y = y + Math.imul(lt, it) | 0, y = y + Math.imul(ht, Xe) | 0, X = X + Math.imul(ht, it) | 0, G = G + Math.imul(ke, tt) | 0, y = y + Math.imul(ke, yt) | 0, y = y + Math.imul(Je, tt) | 0, X = X + Math.imul(Je, yt) | 0, G = G + Math.imul(Ue, wt) | 0, y = y + Math.imul(Ue, Mt) | 0, y = y + Math.imul(Ke, wt) | 0, X = X + Math.imul(Ke, Mt) | 0, G = G + Math.imul(Be, St) | 0, y = y + Math.imul(Be, gt) | 0, y = y + Math.imul(Me, St) | 0, X = X + Math.imul(Me, gt) | 0, G = G + Math.imul(me, Le) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(Ae, Le) | 0, X = X + Math.imul(Ae, xe) | 0; var er = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, G = Math.imul(pt, Oe), y = Math.imul(pt, je), y = y + Math.imul(_t, Oe) | 0, X = Math.imul(_t, je), G = G + Math.imul(mt, Xe) | 0, y = y + Math.imul(mt, it) | 0, y = y + Math.imul(et, Xe) | 0, X = X + Math.imul(et, it) | 0, G = G + Math.imul(lt, tt) | 0, y = y + Math.imul(lt, yt) | 0, y = y + Math.imul(ht, tt) | 0, X = X + Math.imul(ht, yt) | 0, G = G + Math.imul(ke, wt) | 0, y = y + Math.imul(ke, Mt) | 0, y = y + Math.imul(Je, wt) | 0, X = X + Math.imul(Je, Mt) | 0, G = G + Math.imul(Ue, St) | 0, y = y + Math.imul(Ue, gt) | 0, y = y + Math.imul(Ke, St) | 0, X = X + Math.imul(Ke, gt) | 0, G = G + Math.imul(Be, Le) | 0, y = y + Math.imul(Be, xe) | 0, y = y + Math.imul(Me, Le) | 0, X = X + Math.imul(Me, xe) | 0, G = G + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Ye) | 0, y = y + Math.imul(Ae, Ne) | 0, X = X + Math.imul(Ae, Ye) | 0; var ar = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, G = Math.imul(bt, Oe), y = Math.imul(bt, je), y = y + Math.imul(We, Oe) | 0, X = Math.imul(We, je), G = G + Math.imul(pt, Xe) | 0, y = y + Math.imul(pt, it) | 0, y = y + Math.imul(_t, Xe) | 0, X = X + Math.imul(_t, it) | 0, G = G + Math.imul(mt, tt) | 0, y = y + Math.imul(mt, yt) | 0, y = y + Math.imul(et, tt) | 0, X = X + Math.imul(et, yt) | 0, G = G + Math.imul(lt, wt) | 0, y = y + Math.imul(lt, Mt) | 0, y = y + Math.imul(ht, wt) | 0, X = X + Math.imul(ht, Mt) | 0, G = G + Math.imul(ke, St) | 0, y = y + Math.imul(ke, gt) | 0, y = y + Math.imul(Je, St) | 0, X = X + Math.imul(Je, gt) | 0, G = G + Math.imul(Ue, Le) | 0, y = y + Math.imul(Ue, xe) | 0, y = y + Math.imul(Ke, Le) | 0, X = X + Math.imul(Ke, xe) | 0, G = G + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, Ye) | 0, y = y + Math.imul(Me, Ne) | 0, X = X + Math.imul(Me, Ye) | 0, G = G + Math.imul(me, Pe) | 0, y = y + Math.imul(me, qe) | 0, y = y + Math.imul(Ae, Pe) | 0, X = X + Math.imul(Ae, qe) | 0; var nr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, G = Math.imul(ze, Oe), y = Math.imul(ze, je), y = y + Math.imul(Ze, Oe) | 0, X = Math.imul(Ze, je), G = G + Math.imul(bt, Xe) | 0, y = y + Math.imul(bt, it) | 0, y = y + Math.imul(We, Xe) | 0, X = X + Math.imul(We, it) | 0, G = G + Math.imul(pt, tt) | 0, y = y + Math.imul(pt, yt) | 0, y = y + Math.imul(_t, tt) | 0, X = X + Math.imul(_t, yt) | 0, G = G + Math.imul(mt, wt) | 0, y = y + Math.imul(mt, Mt) | 0, y = y + Math.imul(et, wt) | 0, X = X + Math.imul(et, Mt) | 0, G = G + Math.imul(lt, St) | 0, y = y + Math.imul(lt, gt) | 0, y = y + Math.imul(ht, St) | 0, X = X + Math.imul(ht, gt) | 0, G = G + Math.imul(ke, Le) | 0, y = y + Math.imul(ke, xe) | 0, y = y + Math.imul(Je, Le) | 0, X = X + Math.imul(Je, xe) | 0, G = G + Math.imul(Ue, Ne) | 0, y = y + Math.imul(Ue, Ye) | 0, y = y + Math.imul(Ke, Ne) | 0, X = X + Math.imul(Ke, Ye) | 0, G = G + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, qe) | 0, y = y + Math.imul(Me, Pe) | 0, X = X + Math.imul(Me, qe) | 0, G = G + Math.imul(me, Fe) | 0, y = y + Math.imul(me, Qe) | 0, y = y + Math.imul(Ae, Fe) | 0, X = X + Math.imul(Ae, Qe) | 0; var ir = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, G = Math.imul(ye, Oe), y = Math.imul(ye, je), y = y + Math.imul(ge, Oe) | 0, X = Math.imul(ge, je), G = G + Math.imul(ze, Xe) | 0, y = y + Math.imul(ze, it) | 0, y = y + Math.imul(Ze, Xe) | 0, X = X + Math.imul(Ze, it) | 0, G = G + Math.imul(bt, tt) | 0, y = y + Math.imul(bt, yt) | 0, y = y + Math.imul(We, tt) | 0, X = X + Math.imul(We, yt) | 0, G = G + Math.imul(pt, wt) | 0, y = y + Math.imul(pt, Mt) | 0, y = y + Math.imul(_t, wt) | 0, X = X + Math.imul(_t, Mt) | 0, G = G + Math.imul(mt, St) | 0, y = y + Math.imul(mt, gt) | 0, y = y + Math.imul(et, St) | 0, X = X + Math.imul(et, gt) | 0, G = G + Math.imul(lt, Le) | 0, y = y + Math.imul(lt, xe) | 0, y = y + Math.imul(ht, Le) | 0, X = X + Math.imul(ht, xe) | 0, G = G + Math.imul(ke, Ne) | 0, y = y + Math.imul(ke, Ye) | 0, y = y + Math.imul(Je, Ne) | 0, X = X + Math.imul(Je, Ye) | 0, G = G + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, qe) | 0, y = y + Math.imul(Ke, Pe) | 0, X = X + Math.imul(Ke, qe) | 0, G = G + Math.imul(Be, Fe) | 0, y = y + Math.imul(Be, Qe) | 0, y = y + Math.imul(Me, Fe) | 0, X = X + Math.imul(Me, Qe) | 0, G = G + Math.imul(me, rt) | 0, y = y + Math.imul(me, ct) | 0, y = y + Math.imul(Ae, rt) | 0, X = X + Math.imul(Ae, ct) | 0; var Ht = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(ye, Xe), y = Math.imul(ye, it), y = y + Math.imul(ge, Xe) | 0, X = Math.imul(ge, it), G = G + Math.imul(ze, tt) | 0, y = y + Math.imul(ze, yt) | 0, y = y + Math.imul(Ze, tt) | 0, X = X + Math.imul(Ze, yt) | 0, G = G + Math.imul(bt, wt) | 0, y = y + Math.imul(bt, Mt) | 0, y = y + Math.imul(We, wt) | 0, X = X + Math.imul(We, Mt) | 0, G = G + Math.imul(pt, St) | 0, y = y + Math.imul(pt, gt) | 0, y = y + Math.imul(_t, St) | 0, X = X + Math.imul(_t, gt) | 0, G = G + Math.imul(mt, Le) | 0, y = y + Math.imul(mt, xe) | 0, y = y + Math.imul(et, Le) | 0, X = X + Math.imul(et, xe) | 0, G = G + Math.imul(lt, Ne) | 0, y = y + Math.imul(lt, Ye) | 0, y = y + Math.imul(ht, Ne) | 0, X = X + Math.imul(ht, Ye) | 0, G = G + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, qe) | 0, y = y + Math.imul(Je, Pe) | 0, X = X + Math.imul(Je, qe) | 0, G = G + Math.imul(Ue, Fe) | 0, y = y + Math.imul(Ue, Qe) | 0, y = y + Math.imul(Ke, Fe) | 0, X = X + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, ct) | 0, y = y + Math.imul(Me, rt) | 0, X = X + Math.imul(Me, ct) | 0; var sr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, G = Math.imul(ye, tt), y = Math.imul(ye, yt), y = y + Math.imul(ge, tt) | 0, X = Math.imul(ge, yt), G = G + Math.imul(ze, wt) | 0, y = y + Math.imul(ze, Mt) | 0, y = y + Math.imul(Ze, wt) | 0, X = X + Math.imul(Ze, Mt) | 0, G = G + Math.imul(bt, St) | 0, y = y + Math.imul(bt, gt) | 0, y = y + Math.imul(We, St) | 0, X = X + Math.imul(We, gt) | 0, G = G + Math.imul(pt, Le) | 0, y = y + Math.imul(pt, xe) | 0, y = y + Math.imul(_t, Le) | 0, X = X + Math.imul(_t, xe) | 0, G = G + Math.imul(mt, Ne) | 0, y = y + Math.imul(mt, Ye) | 0, y = y + Math.imul(et, Ne) | 0, X = X + Math.imul(et, Ye) | 0, G = G + Math.imul(lt, Pe) | 0, y = y + Math.imul(lt, qe) | 0, y = y + Math.imul(ht, Pe) | 0, X = X + Math.imul(ht, qe) | 0, G = G + Math.imul(ke, Fe) | 0, y = y + Math.imul(ke, Qe) | 0, y = y + Math.imul(Je, Fe) | 0, X = X + Math.imul(Je, Qe) | 0, G = G + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ke, rt) | 0, X = X + Math.imul(Ke, ct) | 0; var Kt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, G = Math.imul(ye, wt), y = Math.imul(ye, Mt), y = y + Math.imul(ge, wt) | 0, X = Math.imul(ge, Mt), G = G + Math.imul(ze, St) | 0, y = y + Math.imul(ze, gt) | 0, y = y + Math.imul(Ze, St) | 0, X = X + Math.imul(Ze, gt) | 0, G = G + Math.imul(bt, Le) | 0, y = y + Math.imul(bt, xe) | 0, y = y + Math.imul(We, Le) | 0, X = X + Math.imul(We, xe) | 0, G = G + Math.imul(pt, Ne) | 0, y = y + Math.imul(pt, Ye) | 0, y = y + Math.imul(_t, Ne) | 0, X = X + Math.imul(_t, Ye) | 0, G = G + Math.imul(mt, Pe) | 0, y = y + Math.imul(mt, qe) | 0, y = y + Math.imul(et, Pe) | 0, X = X + Math.imul(et, qe) | 0, G = G + Math.imul(lt, Fe) | 0, y = y + Math.imul(lt, Qe) | 0, y = y + Math.imul(ht, Fe) | 0, X = X + Math.imul(ht, Qe) | 0, G = G + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, ct) | 0, y = y + Math.imul(Je, rt) | 0, X = X + Math.imul(Je, ct) | 0; var Qt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, G = Math.imul(ye, St), y = Math.imul(ye, gt), y = y + Math.imul(ge, St) | 0, X = Math.imul(ge, gt), G = G + Math.imul(ze, Le) | 0, y = y + Math.imul(ze, xe) | 0, y = y + Math.imul(Ze, Le) | 0, X = X + Math.imul(Ze, xe) | 0, G = G + Math.imul(bt, Ne) | 0, y = y + Math.imul(bt, Ye) | 0, y = y + Math.imul(We, Ne) | 0, X = X + Math.imul(We, Ye) | 0, G = G + Math.imul(pt, Pe) | 0, y = y + Math.imul(pt, qe) | 0, y = y + Math.imul(_t, Pe) | 0, X = X + Math.imul(_t, qe) | 0, G = G + Math.imul(mt, Fe) | 0, y = y + Math.imul(mt, Qe) | 0, y = y + Math.imul(et, Fe) | 0, X = X + Math.imul(et, Qe) | 0, G = G + Math.imul(lt, rt) | 0, y = y + Math.imul(lt, ct) | 0, y = y + Math.imul(ht, rt) | 0, X = X + Math.imul(ht, ct) | 0; var $t = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, G = Math.imul(ye, Le), y = Math.imul(ye, xe), y = y + Math.imul(ge, Le) | 0, X = Math.imul(ge, xe), G = G + Math.imul(ze, Ne) | 0, y = y + Math.imul(ze, Ye) | 0, y = y + Math.imul(Ze, Ne) | 0, X = X + Math.imul(Ze, Ye) | 0, G = G + Math.imul(bt, Pe) | 0, y = y + Math.imul(bt, qe) | 0, y = y + Math.imul(We, Pe) | 0, X = X + Math.imul(We, qe) | 0, G = G + Math.imul(pt, Fe) | 0, y = y + Math.imul(pt, Qe) | 0, y = y + Math.imul(_t, Fe) | 0, X = X + Math.imul(_t, Qe) | 0, G = G + Math.imul(mt, rt) | 0, y = y + Math.imul(mt, ct) | 0, y = y + Math.imul(et, rt) | 0, X = X + Math.imul(et, ct) | 0; var Yt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, G = Math.imul(ye, Ne), y = Math.imul(ye, Ye), y = y + Math.imul(ge, Ne) | 0, X = Math.imul(ge, Ye), G = G + Math.imul(ze, Pe) | 0, y = y + Math.imul(ze, qe) | 0, y = y + Math.imul(Ze, Pe) | 0, X = X + Math.imul(Ze, qe) | 0, G = G + Math.imul(bt, Fe) | 0, y = y + Math.imul(bt, Qe) | 0, y = y + Math.imul(We, Fe) | 0, X = X + Math.imul(We, Qe) | 0, G = G + Math.imul(pt, rt) | 0, y = y + Math.imul(pt, ct) | 0, y = y + Math.imul(_t, rt) | 0, X = X + Math.imul(_t, ct) | 0; var Xt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, G = Math.imul(ye, Pe), y = Math.imul(ye, qe), y = y + Math.imul(ge, Pe) | 0, X = Math.imul(ge, qe), G = G + Math.imul(ze, Fe) | 0, y = y + Math.imul(ze, Qe) | 0, y = y + Math.imul(Ze, Fe) | 0, X = X + Math.imul(Ze, Qe) | 0, G = G + Math.imul(bt, rt) | 0, y = y + Math.imul(bt, ct) | 0, y = y + Math.imul(We, rt) | 0, X = X + Math.imul(We, ct) | 0; var Nt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ye, Fe), y = Math.imul(ye, Qe), y = y + Math.imul(ge, Fe) | 0, X = Math.imul(ge, Qe), G = G + Math.imul(ze, rt) | 0, y = y + Math.imul(ze, ct) | 0, y = y + Math.imul(Ze, rt) | 0, X = X + Math.imul(Ze, ct) | 0; var Et = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, G = Math.imul(ye, rt), y = Math.imul(ye, ct), y = y + Math.imul(ge, rt) | 0, X = Math.imul(ge, ct); var At = (ee + G | 0) + ((y & 8191) << 13) | 0; return ee = (X + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, te[0] = Lt, te[1] = It, te[2] = lr, te[3] = jt, te[4] = Ft, te[5] = er, te[6] = ar, te[7] = nr, te[8] = ir, te[9] = Ht, te[10] = sr, te[11] = Kt, te[12] = Qt, te[13] = $t, te[14] = Yt, te[15] = Xt, te[16] = Nt, te[17] = Et, te[18] = At, ee !== 0 && (te[19] = ee, U.length++), U }; Math.imul || (ne = re); function oe(ie, g, P) { P.negative = g.negative ^ ie.negative, P.length = ie.length + g.length; for (var U = 0, K = 0, Y = 0; Y < P.length - 1; Y++) { var te = K; K = 0; for (var ee = U & 67108863, G = Math.min(Y, g.length - 1), y = Math.max(0, Y - ie.length + 1); y <= G; y++) { var X = Y - y, ce = ie.words[X] | 0, me = g.words[y] | 0, Ae = ce * me, Ie = Ae & 67108863; te = te + (Ae / 67108864 | 0) | 0, Ie = Ie + ee | 0, ee = Ie & 67108863, te = te + (Ie >>> 26) | 0, K += te >>> 26, te &= 67108863 } P.words[Y] = ee, U = te, te = K } return U !== 0 ? P.words[Y] = U : P.length--, P.strip() } function ae(ie, g, P) { var U = new se; return U.mulp(ie, g, P) } d.prototype.mulTo = function (g, P) { var U, K = this.length + g.length; return this.length === 10 && g.length === 10 ? U = ne(this, g, P) : K < 63 ? U = re(this, g, P) : K < 1024 ? U = oe(this, g, P) : U = ae(this, g, P), U }; function se(ie, g) { this.x = ie, this.y = g } se.prototype.makeRBT = function (g) { for (var P = new Array(g), U = d.prototype._countBits(g) - 1, K = 0; K < g; K++)P[K] = this.revBin(K, U, g); return P }, se.prototype.revBin = function (g, P, U) { if (g === 0 || g === U - 1) return g; for (var K = 0, Y = 0; Y < P; Y++)K |= (g & 1) << P - Y - 1, g >>= 1; return K }, se.prototype.permute = function (g, P, U, K, Y, te) { for (var ee = 0; ee < te; ee++)K[ee] = P[g[ee]], Y[ee] = U[g[ee]] }, se.prototype.transform = function (g, P, U, K, Y, te) { this.permute(te, g, P, U, K, Y); for (var ee = 1; ee < Y; ee <<= 1)for (var G = ee << 1, y = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), ce = 0; ce < Y; ce += G)for (var me = y, Ae = X, Ie = 0; Ie < ee; Ie++) { var Be = U[ce + Ie], Me = K[ce + Ie], De = U[ce + Ie + ee], Ue = K[ce + Ie + ee], Ke = me * De - Ae * Ue; Ue = me * Ue + Ae * De, De = Ke, U[ce + Ie] = Be + De, K[ce + Ie] = Me + Ue, U[ce + Ie + ee] = Be - De, K[ce + Ie + ee] = Me - Ue, Ie !== G && (Ke = y * me - X * Ae, Ae = y * Ae + X * me, me = Ke) } }, se.prototype.guessLen13b = function (g, P) { var U = Math.max(P, g) | 1, K = U & 1, Y = 0; for (U = U / 2 | 0; U; U = U >>> 1)Y++; return 1 << Y + 1 + K }, se.prototype.conjugate = function (g, P, U) { if (!(U <= 1)) for (var K = 0; K < U / 2; K++) { var Y = g[K]; g[K] = g[U - K - 1], g[U - K - 1] = Y, Y = P[K], P[K] = -P[U - K - 1], P[U - K - 1] = -Y } }, se.prototype.normalize13b = function (g, P) { for (var U = 0, K = 0; K < P / 2; K++) { var Y = Math.round(g[2 * K + 1] / P) * 8192 + Math.round(g[2 * K] / P) + U; g[K] = Y & 67108863, Y < 67108864 ? U = 0 : U = Y / 67108864 | 0 } return g }, se.prototype.convert13b = function (g, P, U, K) { for (var Y = 0, te = 0; te < P; te++)Y = Y + (g[te] | 0), U[2 * te] = Y & 8191, Y = Y >>> 13, U[2 * te + 1] = Y & 8191, Y = Y >>> 13; for (te = 2 * P; te < K; ++te)U[te] = 0; f(Y === 0), f((Y & -8192) === 0) }, se.prototype.stub = function (g) { for (var P = new Array(g), U = 0; U < g; U++)P[U] = 0; return P }, se.prototype.mulp = function (g, P, U) { var K = 2 * this.guessLen13b(g.length, P.length), Y = this.makeRBT(K), te = this.stub(K), ee = new Array(K), G = new Array(K), y = new Array(K), X = new Array(K), ce = new Array(K), me = new Array(K), Ae = U.words; Ae.length = K, this.convert13b(g.words, g.length, ee, K), this.convert13b(P.words, P.length, X, K), this.transform(ee, te, G, y, K, Y), this.transform(X, te, ce, me, K, Y); for (var Ie = 0; Ie < K; Ie++) { var Be = G[Ie] * ce[Ie] - y[Ie] * me[Ie]; y[Ie] = G[Ie] * me[Ie] + y[Ie] * ce[Ie], G[Ie] = Be } return this.conjugate(G, y, K), this.transform(G, y, Ae, te, K, Y), this.conjugate(Ae, te, K), this.normalize13b(Ae, K), U.negative = g.negative ^ P.negative, U.length = g.length + P.length, U.strip() }, d.prototype.mul = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), this.mulTo(g, P) }, d.prototype.mulf = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), ae(this, g, P) }, d.prototype.imul = function (g) { return this.clone().mulTo(g, this) }, d.prototype.imuln = function (g) { f(typeof g == "number"), f(g < 67108864); for (var P = 0, U = 0; U < this.length; U++) { var K = (this.words[U] | 0) * g, Y = (K & 67108863) + (P & 67108863); P >>= 26, P += K / 67108864 | 0, P += Y >>> 26, this.words[U] = Y & 67108863 } return P !== 0 && (this.words[U] = P, this.length++), this }, d.prototype.muln = function (g) { return this.clone().imuln(g) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (g) { var P = Q(g); if (P.length === 0) return new d(1); for (var U = this, K = 0; K < P.length && P[K] === 0; K++, U = U.sqr()); if (++K < P.length) for (var Y = U.sqr(); K < P.length; K++, Y = Y.sqr())P[K] !== 0 && (U = U.mul(Y)); return U }, d.prototype.iushln = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 67108863 >>> 26 - P << 26 - P, Y; if (P !== 0) { var te = 0; for (Y = 0; Y < this.length; Y++) { var ee = this.words[Y] & K, G = (this.words[Y] | 0) - ee << P; this.words[Y] = G | te, te = ee >>> 26 - P } te && (this.words[Y] = te, this.length++) } if (U !== 0) { for (Y = this.length - 1; Y >= 0; Y--)this.words[Y + U] = this.words[Y]; for (Y = 0; Y < U; Y++)this.words[Y] = 0; this.length += U } return this.strip() }, d.prototype.ishln = function (g) { return f(this.negative === 0), this.iushln(g) }, d.prototype.iushrn = function (g, P, U) { f(typeof g == "number" && g >= 0); var K; P ? K = (P - P % 26) / 26 : K = 0; var Y = g % 26, te = Math.min((g - Y) / 26, this.length), ee = 67108863 ^ 67108863 >>> Y << Y, G = U; if (K -= te, K = Math.max(0, K), G) { for (var y = 0; y < te; y++)G.words[y] = this.words[y]; G.length = te } if (te !== 0) if (this.length > te) for (this.length -= te, y = 0; y < this.length; y++)this.words[y] = this.words[y + te]; else this.words[0] = 0, this.length = 1; var X = 0; for (y = this.length - 1; y >= 0 && (X !== 0 || y >= K); y--) { var ce = this.words[y] | 0; this.words[y] = X << 26 - Y | ce >>> Y, X = ce & ee } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, d.prototype.ishrn = function (g, P, U) { return f(this.negative === 0), this.iushrn(g, P, U) }, d.prototype.shln = function (g) { return this.clone().ishln(g) }, d.prototype.ushln = function (g) { return this.clone().iushln(g) }, d.prototype.shrn = function (g) { return this.clone().ishrn(g) }, d.prototype.ushrn = function (g) { return this.clone().iushrn(g) }, d.prototype.testn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return !1; var Y = this.words[U]; return !!(Y & K) }, d.prototype.imaskn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U) return this; if (P !== 0 && U++, this.length = Math.min(U, this.length), P !== 0) { var K = 67108863 ^ 67108863 >>> P << P; this.words[this.length - 1] &= K } return this.strip() }, d.prototype.maskn = function (g) { return this.clone().imaskn(g) }, d.prototype.iaddn = function (g) { return f(typeof g == "number"), f(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g) }, d.prototype._iaddn = function (g) { this.words[0] += g; for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++; return this.length = Math.max(this.length, P + 1), this }, d.prototype.isubn = function (g) { if (f(typeof g == "number"), f(g < 67108864), g < 0) return this.iaddn(-g); if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this; if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var P = 0; P < this.length && this.words[P] < 0; P++)this.words[P] += 67108864, this.words[P + 1] -= 1; return this.strip() }, d.prototype.addn = function (g) { return this.clone().iaddn(g) }, d.prototype.subn = function (g) { return this.clone().isubn(g) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (g, P, U) { var K = g.length + U, Y; this._expand(K); var te, ee = 0; for (Y = 0; Y < g.length; Y++) { te = (this.words[Y + U] | 0) + ee; var G = (g.words[Y] | 0) * P; te -= G & 67108863, ee = (te >> 26) - (G / 67108864 | 0), this.words[Y + U] = te & 67108863 } for (; Y < this.length - U; Y++)te = (this.words[Y + U] | 0) + ee, ee = te >> 26, this.words[Y + U] = te & 67108863; if (ee === 0) return this.strip(); for (f(ee === -1), ee = 0, Y = 0; Y < this.length; Y++)te = -(this.words[Y] | 0) + ee, ee = te >> 26, this.words[Y] = te & 67108863; return this.negative = 1, this.strip() }, d.prototype._wordDiv = function (g, P) { var U = this.length - g.length, K = this.clone(), Y = g, te = Y.words[Y.length - 1] | 0, ee = this._countBits(te); U = 26 - ee, U !== 0 && (Y = Y.ushln(U), K.iushln(U), te = Y.words[Y.length - 1] | 0); var G = K.length - Y.length, y; if (P !== "mod") { y = new d(null), y.length = G + 1, y.words = new Array(y.length); for (var X = 0; X < y.length; X++)y.words[X] = 0 } var ce = K.clone()._ishlnsubmul(Y, 1, G); ce.negative === 0 && (K = ce, y && (y.words[G] = 1)); for (var me = G - 1; me >= 0; me--) { var Ae = (K.words[Y.length + me] | 0) * 67108864 + (K.words[Y.length + me - 1] | 0); for (Ae = Math.min(Ae / te | 0, 67108863), K._ishlnsubmul(Y, Ae, me); K.negative !== 0;)Ae--, K.negative = 0, K._ishlnsubmul(Y, 1, me), K.isZero() || (K.negative ^= 1); y && (y.words[me] = Ae) } return y && y.strip(), K.strip(), P !== "div" && U !== 0 && K.iushrn(U), { div: y || null, mod: K } }, d.prototype.divmod = function (g, P, U) { if (f(!g.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var K, Y, te; return this.negative !== 0 && g.negative === 0 ? (te = this.neg().divmod(g, P), P !== "mod" && (K = te.div.neg()), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.iadd(g)), { div: K, mod: Y }) : this.negative === 0 && g.negative !== 0 ? (te = this.divmod(g.neg(), P), P !== "mod" && (K = te.div.neg()), { div: K, mod: te.mod }) : (this.negative & g.negative) !== 0 ? (te = this.neg().divmod(g.neg(), P), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.isub(g)), { div: te.div, mod: Y }) : g.length > this.length || this.cmp(g) < 0 ? { div: new d(0), mod: this } : g.length === 1 ? P === "div" ? { div: this.divn(g.words[0]), mod: null } : P === "mod" ? { div: null, mod: new d(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new d(this.modn(g.words[0])) } : this._wordDiv(g, P) }, d.prototype.div = function (g) { return this.divmod(g, "div", !1).div }, d.prototype.mod = function (g) { return this.divmod(g, "mod", !1).mod }, d.prototype.umod = function (g) { return this.divmod(g, "mod", !0).mod }, d.prototype.divRound = function (g) { var P = this.divmod(g); if (P.mod.isZero()) return P.div; var U = P.div.negative !== 0 ? P.mod.isub(g) : P.mod, K = g.ushrn(1), Y = g.andln(1), te = U.cmp(K); return te < 0 || Y === 1 && te === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1) }, d.prototype.modn = function (g) { f(g <= 67108863); for (var P = (1 << 26) % g, U = 0, K = this.length - 1; K >= 0; K--)U = (P * U + (this.words[K] | 0)) % g; return U }, d.prototype.idivn = function (g) { f(g <= 67108863); for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = (this.words[U] | 0) + P * 67108864; this.words[U] = K / g | 0, P = K % g } return this.strip() }, d.prototype.divn = function (g) { return this.clone().idivn(g) }, d.prototype.egcd = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = new d(0), ee = new d(1), G = 0; P.isEven() && U.isEven();)P.iushrn(1), U.iushrn(1), ++G; for (var y = U.clone(), X = P.clone(); !P.isZero();) { for (var ce = 0, me = 1; (P.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (P.iushrn(ce); ce-- > 0;)(K.isOdd() || Y.isOdd()) && (K.iadd(y), Y.isub(X)), K.iushrn(1), Y.iushrn(1); for (var Ae = 0, Ie = 1; (U.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (U.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(y), ee.isub(X)), te.iushrn(1), ee.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(te), Y.isub(ee)) : (U.isub(P), te.isub(K), ee.isub(Y)) } return { a: te, b: ee, gcd: U.iushln(G) } }, d.prototype._invmp = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = U.clone(); P.cmpn(1) > 0 && U.cmpn(1) > 0;) { for (var ee = 0, G = 1; (P.words[0] & G) === 0 && ee < 26; ++ee, G <<= 1); if (ee > 0) for (P.iushrn(ee); ee-- > 0;)K.isOdd() && K.iadd(te), K.iushrn(1); for (var y = 0, X = 1; (U.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (U.iushrn(y); y-- > 0;)Y.isOdd() && Y.iadd(te), Y.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(Y)) : (U.isub(P), Y.isub(K)) } var ce; return P.cmpn(1) === 0 ? ce = K : ce = Y, ce.cmpn(0) < 0 && ce.iadd(g), ce }, d.prototype.gcd = function (g) { if (this.isZero()) return g.abs(); if (g.isZero()) return this.abs(); var P = this.clone(), U = g.clone(); P.negative = 0, U.negative = 0; for (var K = 0; P.isEven() && U.isEven(); K++)P.iushrn(1), U.iushrn(1); do { for (; P.isEven();)P.iushrn(1); for (; U.isEven();)U.iushrn(1); var Y = P.cmp(U); if (Y < 0) { var te = P; P = U, U = te } else if (Y === 0 || U.cmpn(1) === 0) break; P.isub(U) } while (!0); return U.iushln(K) }, d.prototype.invm = function (g) { return this.egcd(g).a.umod(g) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (g) { return this.words[0] & g }, d.prototype.bincn = function (g) { f(typeof g == "number"); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return this._expand(U + 1), this.words[U] |= K, this; for (var Y = K, te = U; Y !== 0 && te < this.length; te++) { var ee = this.words[te] | 0; ee += Y, Y = ee >>> 26, ee &= 67108863, this.words[te] = ee } return Y !== 0 && (this.words[te] = Y, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (g) { var P = g < 0; if (this.negative !== 0 && !P) return -1; if (this.negative === 0 && P) return 1; this.strip(); var U; if (this.length > 1) U = 1; else { P && (g = -g), f(g <= 67108863, "Number is too big"); var K = this.words[0] | 0; U = K === g ? 0 : K < g ? -1 : 1 } return this.negative !== 0 ? -U | 0 : U }, d.prototype.cmp = function (g) { if (this.negative !== 0 && g.negative === 0) return -1; if (this.negative === 0 && g.negative !== 0) return 1; var P = this.ucmp(g); return this.negative !== 0 ? -P | 0 : P }, d.prototype.ucmp = function (g) { if (this.length > g.length) return 1; if (this.length < g.length) return -1; for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = this.words[U] | 0, Y = g.words[U] | 0; if (K !== Y) { K < Y ? P = -1 : K > Y && (P = 1); break } } return P }, d.prototype.gtn = function (g) { return this.cmpn(g) === 1 }, d.prototype.gt = function (g) { return this.cmp(g) === 1 }, d.prototype.gten = function (g) { return this.cmpn(g) >= 0 }, d.prototype.gte = function (g) { return this.cmp(g) >= 0 }, d.prototype.ltn = function (g) { return this.cmpn(g) === -1 }, d.prototype.lt = function (g) { return this.cmp(g) === -1 }, d.prototype.lten = function (g) { return this.cmpn(g) <= 0 }, d.prototype.lte = function (g) { return this.cmp(g) <= 0 }, d.prototype.eqn = function (g) { return this.cmpn(g) === 0 }, d.prototype.eq = function (g) { return this.cmp(g) === 0 }, d.red = function (g) { return new Se(g) }, d.prototype.toRed = function (g) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (g) { return this.red = g, this }, d.prototype.forceRed = function (g) { return f(!this.red, "Already a number in reduction context"), this._forceRed(g) }, d.prototype.redAdd = function (g) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, g) }, d.prototype.redIAdd = function (g) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g) }, d.prototype.redSub = function (g) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, g) }, d.prototype.redISub = function (g) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, g) }, d.prototype.redShl = function (g) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, g) }, d.prototype.redMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g) }, d.prototype.redIMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (g) { return f(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g) }; var le = { k256: null, p224: null, p192: null, p25519: null }; function ue(ie, g) { this.name = ie, this.p = new d(g, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } ue.prototype._tmp = function () { var g = new d(null); return g.words = new Array(Math.ceil(this.n / 13)), g }, ue.prototype.ireduce = function (g) { var P = g, U; do this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), U = P.bitLength(); while (U > this.n); var K = U < this.n ? -1 : P.ucmp(this.p); return K === 0 ? (P.words[0] = 0, P.length = 1) : K > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P }, ue.prototype.split = function (g, P) { g.iushrn(this.n, 0, P) }, ue.prototype.imulK = function (g) { return g.imul(this.k) }; function he() { ue.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(he, ue), he.prototype.split = function (g, P) { for (var U = 4194303, K = Math.min(g.length, 9), Y = 0; Y < K; Y++)P.words[Y] = g.words[Y]; if (P.length = K, g.length <= 9) { g.words[0] = 0, g.length = 1; return } var te = g.words[9]; for (P.words[P.length++] = te & U, Y = 10; Y < g.length; Y++) { var ee = g.words[Y] | 0; g.words[Y - 10] = (ee & U) << 4 | te >>> 22, te = ee } te >>>= 22, g.words[Y - 10] = te, te === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9 }, he.prototype.imulK = function (g) { g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2; for (var P = 0, U = 0; U < g.length; U++) { var K = g.words[U] | 0; P += K * 977, g.words[U] = P & 67108863, P = K * 64 + (P / 67108864 | 0) } return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g }; function pe() { ue.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(pe, ue); function ve() { ue.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(ve, ue); function _e() { ue.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p(_e, ue), _e.prototype.imulK = function (g) { for (var P = 0, U = 0; U < g.length; U++) { var K = (g.words[U] | 0) * 19 + P, Y = K & 67108863; K >>>= 26, g.words[U] = Y, P = K } return P !== 0 && (g.words[g.length++] = P), g }, d._prime = function (g) { if (le[g]) return le[g]; var P; if (g === "k256") P = new he; else if (g === "p224") P = new pe; else if (g === "p192") P = new ve; else if (g === "p25519") P = new _e; else throw new Error("Unknown prime " + g); return le[g] = P, P }; function Se(ie) { if (typeof ie == "string") { var g = d._prime(ie); this.m = g.p, this.prime = g } else f(ie.gtn(1), "modulus must be greater than 1"), this.m = ie, this.prime = null } Se.prototype._verify1 = function (g) { f(g.negative === 0, "red works only with positives"), f(g.red, "red works only with red numbers") }, Se.prototype._verify2 = function (g, P) { f((g.negative | P.negative) === 0, "red works only with positives"), f(g.red && g.red === P.red, "red works only with red numbers") }, Se.prototype.imod = function (g) { return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this) }, Se.prototype.neg = function (g) { return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this) }, Se.prototype.add = function (g, P) { this._verify2(g, P); var U = g.add(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this) }, Se.prototype.iadd = function (g, P) { this._verify2(g, P); var U = g.iadd(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U }, Se.prototype.sub = function (g, P) { this._verify2(g, P); var U = g.sub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this) }, Se.prototype.isub = function (g, P) { this._verify2(g, P); var U = g.isub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U }, Se.prototype.shl = function (g, P) { return this._verify1(g), this.imod(g.ushln(P)) }, Se.prototype.imul = function (g, P) { return this._verify2(g, P), this.imod(g.imul(P)) }, Se.prototype.mul = function (g, P) { return this._verify2(g, P), this.imod(g.mul(P)) }, Se.prototype.isqr = function (g) { return this.imul(g, g.clone()) }, Se.prototype.sqr = function (g) { return this.mul(g, g) }, Se.prototype.sqrt = function (g) { if (g.isZero()) return g.clone(); var P = this.m.andln(3); if (f(P % 2 === 1), P === 3) { var U = this.m.add(new d(1)).iushrn(2); return this.pow(g, U) } for (var K = this.m.subn(1), Y = 0; !K.isZero() && K.andln(1) === 0;)Y++, K.iushrn(1); f(!K.isZero()); var te = new d(1).toRed(this), ee = te.redNeg(), G = this.m.subn(1).iushrn(1), y = this.m.bitLength(); for (y = new d(2 * y * y).toRed(this); this.pow(y, G).cmp(ee) !== 0;)y.redIAdd(ee); for (var X = this.pow(y, K), ce = this.pow(g, K.addn(1).iushrn(1)), me = this.pow(g, K), Ae = Y; me.cmp(te) !== 0;) { for (var Ie = me, Be = 0; Ie.cmp(te) !== 0; Be++)Ie = Ie.redSqr(); f(Be < Ae); var Me = this.pow(X, new d(1).iushln(Ae - Be - 1)); ce = ce.redMul(Me), X = Me.redSqr(), me = me.redMul(X), Ae = Be } return ce }, Se.prototype.invm = function (g) { var P = g._invmp(this.m); return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P) }, Se.prototype.pow = function (g, P) { if (P.isZero()) return new d(1).toRed(this); if (P.cmpn(1) === 0) return g.clone(); var U = 4, K = new Array(1 << U); K[0] = new d(1).toRed(this), K[1] = g; for (var Y = 2; Y < K.length; Y++)K[Y] = this.mul(K[Y - 1], g); var te = K[0], ee = 0, G = 0, y = P.bitLength() % 26; for (y === 0 && (y = 26), Y = P.length - 1; Y >= 0; Y--) { for (var X = P.words[Y], ce = y - 1; ce >= 0; ce--) { var me = X >> ce & 1; if (te !== K[0] && (te = this.sqr(te)), me === 0 && ee === 0) { G = 0; continue } ee <<= 1, ee |= me, G++, !(G !== U && (Y !== 0 || ce !== 0)) && (te = this.mul(te, K[ee]), G = 0, ee = 0) } y = 26 } return te }, Se.prototype.convertTo = function (g) { var P = g.umod(this.m); return P === g ? P.clone() : P }, Se.prototype.convertFrom = function (g) { var P = g.clone(); return P.red = null, P }, d.mont = function (g) { return new $e(g) }; function $e(ie) { Se.call(this, ie), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p($e, Se), $e.prototype.convertTo = function (g) { return this.imod(g.ushln(this.shift)) }, $e.prototype.convertFrom = function (g) { var P = this.imod(g.mul(this.rinv)); return P.red = null, P }, $e.prototype.imul = function (g, P) { if (g.isZero() || P.isZero()) return g.words[0] = 0, g.length = 1, g; var U = g.imul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.mul = function (g, P) { if (g.isZero() || P.isZero()) return new d(0)._forceRed(this); var U = g.mul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.invm = function (g) { var P = this.imod(g._invmp(this.m).mul(this.r2)); return P._forceRed(this) } })(o, bn$a) }(bn$b)), bn$b.exports } var brorand = { exports: {} }, hasRequiredBrorand; function requireBrorand() { if (hasRequiredBrorand) return brorand.exports; hasRequiredBrorand = 1; var o; brorand.exports = function (p) { return o || (o = new l(null)), o.generate(p) }; function l(f) { this.rand = f } if (brorand.exports.Rand = l, l.prototype.generate = function (p) { return this._rand(p) }, l.prototype._rand = function (p) { if (this.rand.getBytes) return this.rand.getBytes(p); for (var d = new Uint8Array(p), m = 0; m < d.length; m++)d[m] = this.rand.getByte(); return d }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? l.prototype._rand = function (p) { var d = new Uint8Array(p); return self.crypto.getRandomValues(d), d } : self.msCrypto && self.msCrypto.getRandomValues ? l.prototype._rand = function (p) { var d = new Uint8Array(p); return self.msCrypto.getRandomValues(d), d } : typeof window == "object" && (l.prototype._rand = function () { throw new Error("Not implemented yet") }); else try { var u = requireCryptoBrowserify(); if (typeof u.randomBytes != "function") throw new Error("Not supported"); l.prototype._rand = function (p) { return u.randomBytes(p) } } catch { } return brorand.exports } var mr, hasRequiredMr; function requireMr() { if (hasRequiredMr) return mr; hasRequiredMr = 1; var o = requireBn$5(), l = requireBrorand(); function u(f) { this.rand = f || new l.Rand } return mr = u, u.create = function (p) { return new u(p) }, u.prototype._randbelow = function (p) { var d = p.bitLength(), m = Math.ceil(d / 8); do var v = new o(this.rand.generate(m)); while (v.cmp(p) >= 0); return v }, u.prototype._randrange = function (p, d) { var m = d.sub(p); return p.add(this._randbelow(m)) }, u.prototype.test = function (p, d, m) { var v = p.bitLength(), I = o.mont(p), F = new o(1).toRed(I); d || (d = Math.max(1, v / 48 | 0)); for (var B = p.subn(1), W = 0; !B.testn(W); W++); for (var Z = p.shrn(W), Q = B.toRed(I), re = !0; d > 0; d--) { var ne = this._randrange(new o(2), B); m && m(ne); var oe = ne.toRed(I).redPow(Z); if (!(oe.cmp(F) === 0 || oe.cmp(Q) === 0)) { for (var ae = 1; ae < W; ae++) { if (oe = oe.redSqr(), oe.cmp(F) === 0) return !1; if (oe.cmp(Q) === 0) break } if (ae === W) return !1 } } return re }, u.prototype.getDivisor = function (p, d) { var m = p.bitLength(), v = o.mont(p), I = new o(1).toRed(v); d || (d = Math.max(1, m / 48 | 0)); for (var F = p.subn(1), B = 0; !F.testn(B); B++); for (var W = p.shrn(B), Z = F.toRed(v); d > 0; d--) { var Q = this._randrange(new o(2), F), re = p.gcd(Q); if (re.cmpn(1) !== 0) return re; var ne = Q.toRed(v).redPow(W); if (!(ne.cmp(I) === 0 || ne.cmp(Z) === 0)) { for (var oe = 1; oe < B; oe++) { if (ne = ne.redSqr(), ne.cmp(I) === 0) return ne.fromRed().subn(1).gcd(p); if (ne.cmp(Z) === 0) break } if (oe === B) return ne = ne.redSqr(), ne.fromRed().subn(1).gcd(p) } } return !1 }, mr } var generatePrime, hasRequiredGeneratePrime; function requireGeneratePrime() { if (hasRequiredGeneratePrime) return generatePrime; hasRequiredGeneratePrime = 1; var o = requireBrowser$b(); generatePrime = oe, oe.simpleSieve = re, oe.fermatTest = ne; var l = requireBn$6(), u = new l(24), f = requireMr(), p = new f, d = new l(1), m = new l(2), v = new l(5); new l(16), new l(8); var I = new l(10), F = new l(3); new l(7); var B = new l(11), W = new l(4); new l(12); var Z = null; function Q() { if (Z !== null) return Z; var ae = 1048576, se = []; se[0] = 2; for (var le = 1, ue = 3; ue < ae; ue += 2) { for (var he = Math.ceil(Math.sqrt(ue)), pe = 0; pe < le && se[pe] <= he && ue % se[pe] !== 0; pe++); le !== pe && se[pe] <= he || (se[le++] = ue) } return Z = se, se } function re(ae) { for (var se = Q(), le = 0; le < se.length; le++)if (ae.modn(se[le]) === 0) return ae.cmpn(se[le]) === 0; return !0 } function ne(ae) { var se = l.mont(ae); return m.toRed(se).redPow(ae.subn(1)).fromRed().cmpn(1) === 0 } function oe(ae, se) { if (ae < 16) return se === 2 || se === 5 ? new l([140, 123]) : new l([140, 39]); se = new l(se); for (var le, ue; ;) { for (le = new l(o(Math.ceil(ae / 8))); le.bitLength() > ae;)le.ishrn(1); if (le.isEven() && le.iadd(d), le.testn(1) || le.iadd(m), se.cmp(m)) { if (!se.cmp(v)) for (; le.mod(I).cmp(F);)le.iadd(W) } else for (; le.mod(u).cmp(B);)le.iadd(W); if (ue = le.shrn(1), re(ue) && re(le) && ne(ue) && ne(le) && p.test(ue) && p.test(le)) return le } } return generatePrime } const modp1 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" }, require$$1$1 = { modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18 }; var dh, hasRequiredDh; function requireDh() { if (hasRequiredDh) return dh; hasRequiredDh = 1; var o = requireBn$6(), l = requireMr(), u = new l, f = new o(24), p = new o(11), d = new o(10), m = new o(3), v = new o(7), I = requireGeneratePrime(), F = requireBrowser$b(); dh = re; function B(oe, ae) { return ae = ae || "utf8", Buffer.isBuffer(oe) || (oe = new Buffer(oe, ae)), this._pub = new o(oe), this } function W(oe, ae) { return ae = ae || "utf8", Buffer.isBuffer(oe) || (oe = new Buffer(oe, ae)), this._priv = new o(oe), this } var Z = {}; function Q(oe, ae) { var se = ae.toString("hex"), le = [se, oe.toString(16)].join("_"); if (le in Z) return Z[le]; var ue = 0; if (oe.isEven() || !I.simpleSieve || !I.fermatTest(oe) || !u.test(oe)) return ue += 1, se === "02" || se === "05" ? ue += 8 : ue += 4, Z[le] = ue, ue; u.test(oe.shrn(1)) || (ue += 2); var he; switch (se) { case "02": oe.mod(f).cmp(p) && (ue += 8); break; case "05": he = oe.mod(d), he.cmp(m) && he.cmp(v) && (ue += 8); break; default: ue += 4 }return Z[le] = ue, ue } function re(oe, ae, se) { this.setGenerator(ae), this.__prime = new o(oe), this._prime = o.mont(this.__prime), this._primeLen = oe.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, se ? (this.setPublicKey = B, this.setPrivateKey = W) : this._primeCode = 8 } Object.defineProperty(re.prototype, "verifyError", { enumerable: !0, get: function () { return typeof this._primeCode != "number" && (this._primeCode = Q(this.__prime, this.__gen)), this._primeCode } }), re.prototype.generateKeys = function () { return this._priv || (this._priv = new o(F(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey() }, re.prototype.computeSecret = function (oe) { oe = new o(oe), oe = oe.toRed(this._prime); var ae = oe.redPow(this._priv).fromRed(), se = new Buffer(ae.toArray()), le = this.getPrime(); if (se.length < le.length) { var ue = new Buffer(le.length - se.length); ue.fill(0), se = Buffer.concat([ue, se]) } return se }, re.prototype.getPublicKey = function (ae) { return ne(this._pub, ae) }, re.prototype.getPrivateKey = function (ae) { return ne(this._priv, ae) }, re.prototype.getPrime = function (oe) { return ne(this.__prime, oe) }, re.prototype.getGenerator = function (oe) { return ne(this._gen, oe) }, re.prototype.setGenerator = function (oe, ae) { return ae = ae || "utf8", Buffer.isBuffer(oe) || (oe = new Buffer(oe, ae)), this.__gen = oe, this._gen = new o(oe), this }; function ne(oe, ae) { var se = new Buffer(oe.toArray()); return ae ? se.toString(ae) : se } return dh } var hasRequiredBrowser$4; function requireBrowser$4() { if (hasRequiredBrowser$4) return browser$5; hasRequiredBrowser$4 = 1; var o = requireGeneratePrime(), l = require$$1$1, u = requireDh(); function f(m) { var v = new Buffer(l[m].prime, "hex"), I = new Buffer(l[m].gen, "hex"); return new u(v, I) } var p = { binary: !0, hex: !0, base64: !0 }; function d(m, v, I, F) { return Buffer.isBuffer(v) || p[v] === void 0 ? d(m, "binary", v, I) : (v = v || "binary", F = F || "binary", I = I || new Buffer([2]), Buffer.isBuffer(I) || (I = new Buffer(I, F)), typeof m == "number" ? new u(o(m, I), I, !0) : (Buffer.isBuffer(m) || (m = new Buffer(m, v)), new u(m, I, !0))) } return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = f, browser$5.createDiffieHellman = browser$5.DiffieHellman = d, browser$5 } var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs; function requireProcessNextickArgs() { if (hasRequiredProcessNextickArgs) return processNextickArgs.exports; hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: o } : processNextickArgs.exports = process$1; function o(l, u, f, p) { if (typeof l != "function") throw new TypeError('"callback" argument must be a function'); var d = arguments.length, m, v; switch (d) { case 0: case 1: return process$1.nextTick(l); case 2: return process$1.nextTick(function () { l.call(null, u) }); case 3: return process$1.nextTick(function () { l.call(null, u, f) }); case 4: return process$1.nextTick(function () { l.call(null, u, f, p) }); default: for (m = new Array(d - 1), v = 0; v < m.length;)m[v++] = arguments[v]; return process$1.nextTick(function () { l.apply(null, m) }) } } return processNextickArgs.exports } var isarray, hasRequiredIsarray; function requireIsarray() { if (hasRequiredIsarray) return isarray; hasRequiredIsarray = 1; var o = {}.toString; return isarray = Array.isArray || function (l) { return o.call(l) == "[object Array]" }, isarray } var streamBrowser, hasRequiredStreamBrowser; function requireStreamBrowser() { return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser } var safeBuffer = { exports: {} }, hasRequiredSafeBuffer; function requireSafeBuffer() { return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function (o, l) { var u = requireDist$2(), f = u.Buffer; function p(m, v) { for (var I in m) v[I] = m[I] } f.from && f.alloc && f.allocUnsafe && f.allocUnsafeSlow ? o.exports = u : (p(u, l), l.Buffer = d); function d(m, v, I) { return f(m, v, I) } p(f, d), d.from = function (m, v, I) { if (typeof m == "number") throw new TypeError("Argument must not be a number"); return f(m, v, I) }, d.alloc = function (m, v, I) { if (typeof m != "number") throw new TypeError("Argument must be a number"); var F = f(m); return v !== void 0 ? typeof I == "string" ? F.fill(v, I) : F.fill(v) : F.fill(0), F }, d.allocUnsafe = function (m) { if (typeof m != "number") throw new TypeError("Argument must be a number"); return f(m) }, d.allocUnsafeSlow = function (m) { if (typeof m != "number") throw new TypeError("Argument must be a number"); return u.SlowBuffer(m) } }(safeBuffer, safeBuffer.exports)), safeBuffer.exports } var util = {}, hasRequiredUtil; function requireUtil() { if (hasRequiredUtil) return util; hasRequiredUtil = 1; function o(ne) { return Array.isArray ? Array.isArray(ne) : re(ne) === "[object Array]" } util.isArray = o; function l(ne) { return typeof ne == "boolean" } util.isBoolean = l; function u(ne) { return ne === null } util.isNull = u; function f(ne) { return ne == null } util.isNullOrUndefined = f; function p(ne) { return typeof ne == "number" } util.isNumber = p; function d(ne) { return typeof ne == "string" } util.isString = d; function m(ne) { return typeof ne == "symbol" } util.isSymbol = m; function v(ne) { return ne === void 0 } util.isUndefined = v; function I(ne) { return re(ne) === "[object RegExp]" } util.isRegExp = I; function F(ne) { return typeof ne == "object" && ne !== null } util.isObject = F; function B(ne) { return re(ne) === "[object Date]" } util.isDate = B; function W(ne) { return re(ne) === "[object Error]" || ne instanceof Error } util.isError = W; function Z(ne) { return typeof ne == "function" } util.isFunction = Z; function Q(ne) { return ne === null || typeof ne == "boolean" || typeof ne == "number" || typeof ne == "string" || typeof ne == "symbol" || typeof ne > "u" } util.isPrimitive = Q, util.isBuffer = requireDist$2().Buffer.isBuffer; function re(ne) { return Object.prototype.toString.call(ne) } return util } var BufferList = { exports: {} }, hasRequiredBufferList; function requireBufferList() { return hasRequiredBufferList || (hasRequiredBufferList = 1, function (o) { function l(d, m) { if (!(d instanceof m)) throw new TypeError("Cannot call a class as a function") } var u = requireSafeBuffer().Buffer, f = requireUtil$1(); function p(d, m, v) { d.copy(m, v) } o.exports = function () { function d() { l(this, d), this.head = null, this.tail = null, this.length = 0 } return d.prototype.push = function (v) { var I = { data: v, next: null }; this.length > 0 ? this.tail.next = I : this.head = I, this.tail = I, ++this.length }, d.prototype.unshift = function (v) { var I = { data: v, next: this.head }; this.length === 0 && (this.tail = I), this.head = I, ++this.length }, d.prototype.shift = function () { if (this.length !== 0) { var v = this.head.data; return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, v } }, d.prototype.clear = function () { this.head = this.tail = null, this.length = 0 }, d.prototype.join = function (v) { if (this.length === 0) return ""; for (var I = this.head, F = "" + I.data; I = I.next;)F += v + I.data; return F }, d.prototype.concat = function (v) { if (this.length === 0) return u.alloc(0); for (var I = u.allocUnsafe(v >>> 0), F = this.head, B = 0; F;)p(F.data, I, B), B += F.data.length, F = F.next; return I }, d }(), f && f.inspect && f.inspect.custom && (o.exports.prototype[f.inspect.custom] = function () { var d = f.inspect({ length: this.length }); return this.constructor.name + " " + d }) }(BufferList)), BufferList.exports } var destroy_1, hasRequiredDestroy; function requireDestroy() { if (hasRequiredDestroy) return destroy_1; hasRequiredDestroy = 1; var o = requireProcessNextickArgs(); function l(p, d) { var m = this, v = this._readableState && this._readableState.destroyed, I = this._writableState && this._writableState.destroyed; return v || I ? (d ? d(p) : p && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, o.nextTick(f, this, p)) : o.nextTick(f, this, p)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(p || null, function (F) { !d && F ? m._writableState ? m._writableState.errorEmitted || (m._writableState.errorEmitted = !0, o.nextTick(f, m, F)) : o.nextTick(f, m, F) : d && d(F) }), this) } function u() { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } function f(p, d) { p.emit("error", d) } return destroy_1 = { destroy: l, undestroy: u }, destroy_1 } var _stream_writable, hasRequired_stream_writable; function require_stream_writable() { if (hasRequired_stream_writable) return _stream_writable; hasRequired_stream_writable = 1; var o = requireProcessNextickArgs(); _stream_writable = ne; function l(te) { var ee = this; this.next = null, this.entry = null, this.finish = function () { Y(ee, te) } } var u = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : o.nextTick, f; ne.WritableState = Q; var p = Object.create(requireUtil()); p.inherits = requireInherits_browser(); var d = { deprecate: requireBrowser$a() }, m = requireStreamBrowser(), v = requireSafeBuffer().Buffer, I = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function () { }; function F(te) { return v.from(te) } function B(te) { return v.isBuffer(te) || te instanceof I } var W = requireDestroy(); p.inherits(ne, m); function Z() { } function Q(te, ee) { f = f || require_stream_duplex(), te = te || {}; var G = ee instanceof f; this.objectMode = !!te.objectMode, G && (this.objectMode = this.objectMode || !!te.writableObjectMode); var y = te.highWaterMark, X = te.writableHighWaterMark, ce = this.objectMode ? 16 : 16 * 1024; y || y === 0 ? this.highWaterMark = y : G && (X || X === 0) ? this.highWaterMark = X : this.highWaterMark = ce, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var me = te.decodeStrings === !1; this.decodeStrings = !me, this.defaultEncoding = te.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (Ae) { ve(ee, Ae) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new l(this) } Q.prototype.getBuffer = function () { for (var ee = this.bufferedRequest, G = []; ee;)G.push(ee), ee = ee.next; return G }, function () { try { Object.defineProperty(Q.prototype, "buffer", { get: d.deprecate(function () { return this.getBuffer() }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch { } }(); var re; typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (re = Function.prototype[Symbol.hasInstance], Object.defineProperty(ne, Symbol.hasInstance, { value: function (te) { return re.call(this, te) ? !0 : this !== ne ? !1 : te && te._writableState instanceof Q } })) : re = function (te) { return te instanceof this }; function ne(te) { if (f = f || require_stream_duplex(), !re.call(ne, this) && !(this instanceof f)) return new ne(te); this._writableState = new Q(te, this), this.writable = !0, te && (typeof te.write == "function" && (this._write = te.write), typeof te.writev == "function" && (this._writev = te.writev), typeof te.destroy == "function" && (this._destroy = te.destroy), typeof te.final == "function" && (this._final = te.final)), m.call(this) } ne.prototype.pipe = function () { this.emit("error", new Error("Cannot pipe, not readable")) }; function oe(te, ee) { var G = new Error("write after end"); te.emit("error", G), o.nextTick(ee, G) } function ae(te, ee, G, y) { var X = !0, ce = !1; return G === null ? ce = new TypeError("May not write null values to stream") : typeof G != "string" && G !== void 0 && !ee.objectMode && (ce = new TypeError("Invalid non-string/buffer chunk")), ce && (te.emit("error", ce), o.nextTick(y, ce), X = !1), X } ne.prototype.write = function (te, ee, G) { var y = this._writableState, X = !1, ce = !y.objectMode && B(te); return ce && !v.isBuffer(te) && (te = F(te)), typeof ee == "function" && (G = ee, ee = null), ce ? ee = "buffer" : ee || (ee = y.defaultEncoding), typeof G != "function" && (G = Z), y.ended ? oe(this, G) : (ce || ae(this, y, te, G)) && (y.pendingcb++, X = le(this, y, ce, te, ee, G)), X }, ne.prototype.cork = function () { var te = this._writableState; te.corked++ }, ne.prototype.uncork = function () { var te = this._writableState; te.corked && (te.corked--, !te.writing && !te.corked && !te.bufferProcessing && te.bufferedRequest && $e(this, te)) }, ne.prototype.setDefaultEncoding = function (ee) { if (typeof ee == "string" && (ee = ee.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ee + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ee); return this._writableState.defaultEncoding = ee, this }; function se(te, ee, G) { return !te.objectMode && te.decodeStrings !== !1 && typeof ee == "string" && (ee = v.from(ee, G)), ee } Object.defineProperty(ne.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }); function le(te, ee, G, y, X, ce) { if (!G) { var me = se(ee, y, X); y !== me && (G = !0, X = "buffer", y = me) } var Ae = ee.objectMode ? 1 : y.length; ee.length += Ae; var Ie = ee.length < ee.highWaterMark; if (Ie || (ee.needDrain = !0), ee.writing || ee.corked) { var Be = ee.lastBufferedRequest; ee.lastBufferedRequest = { chunk: y, encoding: X, isBuf: G, callback: ce, next: null }, Be ? Be.next = ee.lastBufferedRequest : ee.bufferedRequest = ee.lastBufferedRequest, ee.bufferedRequestCount += 1 } else ue(te, ee, !1, Ae, y, X, ce); return Ie } function ue(te, ee, G, y, X, ce, me) { ee.writelen = y, ee.writecb = me, ee.writing = !0, ee.sync = !0, G ? te._writev(X, ee.onwrite) : te._write(X, ce, ee.onwrite), ee.sync = !1 } function he(te, ee, G, y, X) { --ee.pendingcb, G ? (o.nextTick(X, y), o.nextTick(U, te, ee), te._writableState.errorEmitted = !0, te.emit("error", y)) : (X(y), te._writableState.errorEmitted = !0, te.emit("error", y), U(te, ee)) } function pe(te) { te.writing = !1, te.writecb = null, te.length -= te.writelen, te.writelen = 0 } function ve(te, ee) { var G = te._writableState, y = G.sync, X = G.writecb; if (pe(G), ee) he(te, G, y, ee, X); else { var ce = ie(G); !ce && !G.corked && !G.bufferProcessing && G.bufferedRequest && $e(te, G), y ? u(_e, te, G, ce, X) : _e(te, G, ce, X) } } function _e(te, ee, G, y) { G || Se(te, ee), ee.pendingcb--, y(), U(te, ee) } function Se(te, ee) { ee.length === 0 && ee.needDrain && (ee.needDrain = !1, te.emit("drain")) } function $e(te, ee) { ee.bufferProcessing = !0; var G = ee.bufferedRequest; if (te._writev && G && G.next) { var y = ee.bufferedRequestCount, X = new Array(y), ce = ee.corkedRequestsFree; ce.entry = G; for (var me = 0, Ae = !0; G;)X[me] = G, G.isBuf || (Ae = !1), G = G.next, me += 1; X.allBuffers = Ae, ue(te, ee, !0, ee.length, X, "", ce.finish), ee.pendingcb++, ee.lastBufferedRequest = null, ce.next ? (ee.corkedRequestsFree = ce.next, ce.next = null) : ee.corkedRequestsFree = new l(ee), ee.bufferedRequestCount = 0 } else { for (; G;) { var Ie = G.chunk, Be = G.encoding, Me = G.callback, De = ee.objectMode ? 1 : Ie.length; if (ue(te, ee, !1, De, Ie, Be, Me), G = G.next, ee.bufferedRequestCount--, ee.writing) break } G === null && (ee.lastBufferedRequest = null) } ee.bufferedRequest = G, ee.bufferProcessing = !1 } ne.prototype._write = function (te, ee, G) { G(new Error("_write() is not implemented")) }, ne.prototype._writev = null, ne.prototype.end = function (te, ee, G) { var y = this._writableState; typeof te == "function" ? (G = te, te = null, ee = null) : typeof ee == "function" && (G = ee, ee = null), te != null && this.write(te, ee), y.corked && (y.corked = 1, this.uncork()), y.ending || K(this, y, G) }; function ie(te) { return te.ending && te.length === 0 && te.bufferedRequest === null && !te.finished && !te.writing } function g(te, ee) { te._final(function (G) { ee.pendingcb--, G && te.emit("error", G), ee.prefinished = !0, te.emit("prefinish"), U(te, ee) }) } function P(te, ee) { !ee.prefinished && !ee.finalCalled && (typeof te._final == "function" ? (ee.pendingcb++, ee.finalCalled = !0, o.nextTick(g, te, ee)) : (ee.prefinished = !0, te.emit("prefinish"))) } function U(te, ee) { var G = ie(ee); return G && (P(te, ee), ee.pendingcb === 0 && (ee.finished = !0, te.emit("finish"))), G } function K(te, ee, G) { ee.ending = !0, U(te, ee), G && (ee.finished ? o.nextTick(G) : te.once("finish", G)), ee.ended = !0, te.writable = !1 } function Y(te, ee, G) { var y = te.entry; for (te.entry = null; y;) { var X = y.callback; ee.pendingcb--, X(G), y = y.next } ee.corkedRequestsFree.next = te } return Object.defineProperty(ne.prototype, "destroyed", { get: function () { return this._writableState === void 0 ? !1 : this._writableState.destroyed }, set: function (te) { this._writableState && (this._writableState.destroyed = te) } }), ne.prototype.destroy = W.destroy, ne.prototype._undestroy = W.undestroy, ne.prototype._destroy = function (te, ee) { this.end(), ee(te) }, _stream_writable } var _stream_duplex, hasRequired_stream_duplex; function require_stream_duplex() { if (hasRequired_stream_duplex) return _stream_duplex; hasRequired_stream_duplex = 1; var o = requireProcessNextickArgs(), l = Object.keys || function (W) { var Z = []; for (var Q in W) Z.push(Q); return Z }; _stream_duplex = I; var u = Object.create(requireUtil()); u.inherits = requireInherits_browser(); var f = require_stream_readable(), p = require_stream_writable(); u.inherits(I, f); for (var d = l(p.prototype), m = 0; m < d.length; m++) { var v = d[m]; I.prototype[v] || (I.prototype[v] = p.prototype[v]) } function I(W) { if (!(this instanceof I)) return new I(W); f.call(this, W), p.call(this, W), W && W.readable === !1 && (this.readable = !1), W && W.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, W && W.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", F) } Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }); function F() { this.allowHalfOpen || this._writableState.ended || o.nextTick(B, this) } function B(W) { W.end() } return Object.defineProperty(I.prototype, "destroyed", { get: function () { return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed }, set: function (W) { this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = W, this._writableState.destroyed = W) } }), I.prototype._destroy = function (W, Z) { this.push(null), this.end(), o.nextTick(Z, W) }, _stream_duplex } var _stream_readable, hasRequired_stream_readable; function require_stream_readable() { if (hasRequired_stream_readable) return _stream_readable; hasRequired_stream_readable = 1; var o = requireProcessNextickArgs(); _stream_readable = se; var l = requireIsarray(), u; se.ReadableState = ae, requireEvents().EventEmitter; var f = function (Me, De) { return Me.listeners(De).length }, p = requireStreamBrowser(), d = requireSafeBuffer().Buffer, m = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function () { }; function v(Me) { return d.from(Me) } function I(Me) { return d.isBuffer(Me) || Me instanceof m } var F = Object.create(requireUtil()); F.inherits = requireInherits_browser(); var B = requireUtil$1(), W = void 0; B && B.debuglog ? W = B.debuglog("stream") : W = function () { }; var Z = requireBufferList(), Q = requireDestroy(), re; F.inherits(se, p); var ne = ["error", "close", "destroy", "pause", "resume"]; function oe(Me, De, Ue) { if (typeof Me.prependListener == "function") return Me.prependListener(De, Ue); !Me._events || !Me._events[De] ? Me.on(De, Ue) : l(Me._events[De]) ? Me._events[De].unshift(Ue) : Me._events[De] = [Ue, Me._events[De]] } function ae(Me, De) { u = u || require_stream_duplex(), Me = Me || {}; var Ue = De instanceof u; this.objectMode = !!Me.objectMode, Ue && (this.objectMode = this.objectMode || !!Me.readableObjectMode); var Ke = Me.highWaterMark, Ve = Me.readableHighWaterMark, ke = this.objectMode ? 16 : 16 * 1024; Ke || Ke === 0 ? this.highWaterMark = Ke : Ue && (Ve || Ve === 0) ? this.highWaterMark = Ve : this.highWaterMark = ke, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Z, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Me.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Me.encoding && (re || (re = requireString_decoder().StringDecoder), this.decoder = new re(Me.encoding), this.encoding = Me.encoding) } function se(Me) { if (u = u || require_stream_duplex(), !(this instanceof se)) return new se(Me); this._readableState = new ae(Me, this), this.readable = !0, Me && (typeof Me.read == "function" && (this._read = Me.read), typeof Me.destroy == "function" && (this._destroy = Me.destroy)), p.call(this) } Object.defineProperty(se.prototype, "destroyed", { get: function () { return this._readableState === void 0 ? !1 : this._readableState.destroyed }, set: function (Me) { this._readableState && (this._readableState.destroyed = Me) } }), se.prototype.destroy = Q.destroy, se.prototype._undestroy = Q.undestroy, se.prototype._destroy = function (Me, De) { this.push(null), De(Me) }, se.prototype.push = function (Me, De) { var Ue = this._readableState, Ke; return Ue.objectMode ? Ke = !0 : typeof Me == "string" && (De = De || Ue.defaultEncoding, De !== Ue.encoding && (Me = d.from(Me, De), De = ""), Ke = !0), le(this, Me, De, !1, Ke) }, se.prototype.unshift = function (Me) { return le(this, Me, null, !0, !1) }; function le(Me, De, Ue, Ke, Ve) { var ke = Me._readableState; if (De === null) ke.reading = !1, $e(Me, ke); else { var Je; Ve || (Je = he(ke, De)), Je ? Me.emit("error", Je) : ke.objectMode || De && De.length > 0 ? (typeof De != "string" && !ke.objectMode && Object.getPrototypeOf(De) !== d.prototype && (De = v(De)), Ke ? ke.endEmitted ? Me.emit("error", new Error("stream.unshift() after end event")) : ue(Me, ke, De, !0) : ke.ended ? Me.emit("error", new Error("stream.push() after EOF")) : (ke.reading = !1, ke.decoder && !Ue ? (De = ke.decoder.write(De), ke.objectMode || De.length !== 0 ? ue(Me, ke, De, !1) : P(Me, ke)) : ue(Me, ke, De, !1))) : Ke || (ke.reading = !1) } return pe(ke) } function ue(Me, De, Ue, Ke) { De.flowing && De.length === 0 && !De.sync ? (Me.emit("data", Ue), Me.read(0)) : (De.length += De.objectMode ? 1 : Ue.length, Ke ? De.buffer.unshift(Ue) : De.buffer.push(Ue), De.needReadable && ie(Me)), P(Me, De) } function he(Me, De) { var Ue; return !I(De) && typeof De != "string" && De !== void 0 && !Me.objectMode && (Ue = new TypeError("Invalid non-string/buffer chunk")), Ue } function pe(Me) { return !Me.ended && (Me.needReadable || Me.length < Me.highWaterMark || Me.length === 0) } se.prototype.isPaused = function () { return this._readableState.flowing === !1 }, se.prototype.setEncoding = function (Me) { return re || (re = requireString_decoder().StringDecoder), this._readableState.decoder = new re(Me), this._readableState.encoding = Me, this }; var ve = 8388608; function _e(Me) { return Me >= ve ? Me = ve : (Me--, Me |= Me >>> 1, Me |= Me >>> 2, Me |= Me >>> 4, Me |= Me >>> 8, Me |= Me >>> 16, Me++), Me } function Se(Me, De) { return Me <= 0 || De.length === 0 && De.ended ? 0 : De.objectMode ? 1 : Me !== Me ? De.flowing && De.length ? De.buffer.head.data.length : De.length : (Me > De.highWaterMark && (De.highWaterMark = _e(Me)), Me <= De.length ? Me : De.ended ? De.length : (De.needReadable = !0, 0)) } se.prototype.read = function (Me) { W("read", Me), Me = parseInt(Me, 10); var De = this._readableState, Ue = Me; if (Me !== 0 && (De.emittedReadable = !1), Me === 0 && De.needReadable && (De.length >= De.highWaterMark || De.ended)) return W("read: emitReadable", De.length, De.ended), De.length === 0 && De.ended ? Ae(this) : ie(this), null; if (Me = Se(Me, De), Me === 0 && De.ended) return De.length === 0 && Ae(this), null; var Ke = De.needReadable; W("need readable", Ke), (De.length === 0 || De.length - Me < De.highWaterMark) && (Ke = !0, W("length less than watermark", Ke)), De.ended || De.reading ? (Ke = !1, W("reading or ended", Ke)) : Ke && (W("do read"), De.reading = !0, De.sync = !0, De.length === 0 && (De.needReadable = !0), this._read(De.highWaterMark), De.sync = !1, De.reading || (Me = Se(Ue, De))); var Ve; return Me > 0 ? Ve = y(Me, De) : Ve = null, Ve === null ? (De.needReadable = !0, Me = 0) : De.length -= Me, De.length === 0 && (De.ended || (De.needReadable = !0), Ue !== Me && De.ended && Ae(this)), Ve !== null && this.emit("data", Ve), Ve }; function $e(Me, De) { if (!De.ended) { if (De.decoder) { var Ue = De.decoder.end(); Ue && Ue.length && (De.buffer.push(Ue), De.length += De.objectMode ? 1 : Ue.length) } De.ended = !0, ie(Me) } } function ie(Me) { var De = Me._readableState; De.needReadable = !1, De.emittedReadable || (W("emitReadable", De.flowing), De.emittedReadable = !0, De.sync ? o.nextTick(g, Me) : g(Me)) } function g(Me) { W("emit readable"), Me.emit("readable"), G(Me) } function P(Me, De) { De.readingMore || (De.readingMore = !0, o.nextTick(U, Me, De)) } function U(Me, De) { for (var Ue = De.length; !De.reading && !De.flowing && !De.ended && De.length < De.highWaterMark && (W("maybeReadMore read 0"), Me.read(0), Ue !== De.length);)Ue = De.length; De.readingMore = !1 } se.prototype._read = function (Me) { this.emit("error", new Error("_read() is not implemented")) }, se.prototype.pipe = function (Me, De) { var Ue = this, Ke = this._readableState; switch (Ke.pipesCount) { case 0: Ke.pipes = Me; break; case 1: Ke.pipes = [Ke.pipes, Me]; break; default: Ke.pipes.push(Me); break }Ke.pipesCount += 1, W("pipe count=%d opts=%j", Ke.pipesCount, De); var Ve = (!De || De.end !== !1) && Me !== process$1.stdout && Me !== process$1.stderr, ke = Ve ? dt : zt; Ke.endEmitted ? o.nextTick(ke) : Ue.once("end", ke), Me.on("unpipe", Je); function Je(bt, We) { W("onunpipe"), bt === Ue && We && We.hasUnpiped === !1 && (We.hasUnpiped = !0, Bt()) } function dt() { W("onend"), Me.end() } var lt = K(Ue); Me.on("drain", lt); var ht = !1; function Bt() { W("cleanup"), Me.removeListener("close", pt), Me.removeListener("finish", _t), Me.removeListener("drain", lt), Me.removeListener("error", Gt), Me.removeListener("unpipe", Je), Ue.removeListener("end", dt), Ue.removeListener("end", zt), Ue.removeListener("data", et), ht = !0, Ke.awaitDrain && (!Me._writableState || Me._writableState.needDrain) && lt() } var mt = !1; Ue.on("data", et); function et(bt) { W("ondata"), mt = !1; var We = Me.write(bt); We === !1 && !mt && ((Ke.pipesCount === 1 && Ke.pipes === Me || Ke.pipesCount > 1 && Be(Ke.pipes, Me) !== -1) && !ht && (W("false write response, pause", Ke.awaitDrain), Ke.awaitDrain++, mt = !0), Ue.pause()) } function Gt(bt) { W("onerror", bt), zt(), Me.removeListener("error", Gt), f(Me, "error") === 0 && Me.emit("error", bt) } oe(Me, "error", Gt); function pt() { Me.removeListener("finish", _t), zt() } Me.once("close", pt); function _t() { W("onfinish"), Me.removeListener("close", pt), zt() } Me.once("finish", _t); function zt() { W("unpipe"), Ue.unpipe(Me) } return Me.emit("pipe", Ue), Ke.flowing || (W("pipe resume"), Ue.resume()), Me }; function K(Me) { return function () { var De = Me._readableState; W("pipeOnDrain", De.awaitDrain), De.awaitDrain && De.awaitDrain--, De.awaitDrain === 0 && f(Me, "data") && (De.flowing = !0, G(Me)) } } se.prototype.unpipe = function (Me) { var De = this._readableState, Ue = { hasUnpiped: !1 }; if (De.pipesCount === 0) return this; if (De.pipesCount === 1) return Me && Me !== De.pipes ? this : (Me || (Me = De.pipes), De.pipes = null, De.pipesCount = 0, De.flowing = !1, Me && Me.emit("unpipe", this, Ue), this); if (!Me) { var Ke = De.pipes, Ve = De.pipesCount; De.pipes = null, De.pipesCount = 0, De.flowing = !1; for (var ke = 0; ke < Ve; ke++)Ke[ke].emit("unpipe", this, { hasUnpiped: !1 }); return this } var Je = Be(De.pipes, Me); return Je === -1 ? this : (De.pipes.splice(Je, 1), De.pipesCount -= 1, De.pipesCount === 1 && (De.pipes = De.pipes[0]), Me.emit("unpipe", this, Ue), this) }, se.prototype.on = function (Me, De) { var Ue = p.prototype.on.call(this, Me, De); if (Me === "data") this._readableState.flowing !== !1 && this.resume(); else if (Me === "readable") { var Ke = this._readableState; !Ke.endEmitted && !Ke.readableListening && (Ke.readableListening = Ke.needReadable = !0, Ke.emittedReadable = !1, Ke.reading ? Ke.length && ie(this) : o.nextTick(Y, this)) } return Ue }, se.prototype.addListener = se.prototype.on; function Y(Me) { W("readable nexttick read 0"), Me.read(0) } se.prototype.resume = function () { var Me = this._readableState; return Me.flowing || (W("resume"), Me.flowing = !0, te(this, Me)), this }; function te(Me, De) { De.resumeScheduled || (De.resumeScheduled = !0, o.nextTick(ee, Me, De)) } function ee(Me, De) { De.reading || (W("resume read 0"), Me.read(0)), De.resumeScheduled = !1, De.awaitDrain = 0, Me.emit("resume"), G(Me), De.flowing && !De.reading && Me.read(0) } se.prototype.pause = function () { return W("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (W("pause"), this._readableState.flowing = !1, this.emit("pause")), this }; function G(Me) { var De = Me._readableState; for (W("flow", De.flowing); De.flowing && Me.read() !== null;); } se.prototype.wrap = function (Me) { var De = this, Ue = this._readableState, Ke = !1; Me.on("end", function () { if (W("wrapped end"), Ue.decoder && !Ue.ended) { var Je = Ue.decoder.end(); Je && Je.length && De.push(Je) } De.push(null) }), Me.on("data", function (Je) { if (W("wrapped data"), Ue.decoder && (Je = Ue.decoder.write(Je)), !(Ue.objectMode && Je == null) && !(!Ue.objectMode && (!Je || !Je.length))) { var dt = De.push(Je); dt || (Ke = !0, Me.pause()) } }); for (var Ve in Me) this[Ve] === void 0 && typeof Me[Ve] == "function" && (this[Ve] = function (Je) { return function () { return Me[Je].apply(Me, arguments) } }(Ve)); for (var ke = 0; ke < ne.length; ke++)Me.on(ne[ke], this.emit.bind(this, ne[ke])); return this._read = function (Je) { W("wrapped _read", Je), Ke && (Ke = !1, Me.resume()) }, this }, Object.defineProperty(se.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), se._fromList = y; function y(Me, De) { if (De.length === 0) return null; var Ue; return De.objectMode ? Ue = De.buffer.shift() : !Me || Me >= De.length ? (De.decoder ? Ue = De.buffer.join("") : De.buffer.length === 1 ? Ue = De.buffer.head.data : Ue = De.buffer.concat(De.length), De.buffer.clear()) : Ue = X(Me, De.buffer, De.decoder), Ue } function X(Me, De, Ue) { var Ke; return Me < De.head.data.length ? (Ke = De.head.data.slice(0, Me), De.head.data = De.head.data.slice(Me)) : Me === De.head.data.length ? Ke = De.shift() : Ke = Ue ? ce(Me, De) : me(Me, De), Ke } function ce(Me, De) { var Ue = De.head, Ke = 1, Ve = Ue.data; for (Me -= Ve.length; Ue = Ue.next;) { var ke = Ue.data, Je = Me > ke.length ? ke.length : Me; if (Je === ke.length ? Ve += ke : Ve += ke.slice(0, Me), Me -= Je, Me === 0) { Je === ke.length ? (++Ke, Ue.next ? De.head = Ue.next : De.head = De.tail = null) : (De.head = Ue, Ue.data = ke.slice(Je)); break } ++Ke } return De.length -= Ke, Ve } function me(Me, De) { var Ue = d.allocUnsafe(Me), Ke = De.head, Ve = 1; for (Ke.data.copy(Ue), Me -= Ke.data.length; Ke = Ke.next;) { var ke = Ke.data, Je = Me > ke.length ? ke.length : Me; if (ke.copy(Ue, Ue.length - Me, 0, Je), Me -= Je, Me === 0) { Je === ke.length ? (++Ve, Ke.next ? De.head = Ke.next : De.head = De.tail = null) : (De.head = Ke, Ke.data = ke.slice(Je)); break } ++Ve } return De.length -= Ve, Ue } function Ae(Me) { var De = Me._readableState; if (De.length > 0) throw new Error('"endReadable()" called on non-empty stream'); De.endEmitted || (De.ended = !0, o.nextTick(Ie, De, Me)) } function Ie(Me, De) { !Me.endEmitted && Me.length === 0 && (Me.endEmitted = !0, De.readable = !1, De.emit("end")) } function Be(Me, De) { for (var Ue = 0, Ke = Me.length; Ue < Ke; Ue++)if (Me[Ue] === De) return Ue; return -1 } return _stream_readable } var _stream_transform, hasRequired_stream_transform; function require_stream_transform() { if (hasRequired_stream_transform) return _stream_transform; hasRequired_stream_transform = 1, _stream_transform = f; var o = require_stream_duplex(), l = Object.create(requireUtil()); l.inherits = requireInherits_browser(), l.inherits(f, o); function u(m, v) { var I = this._transformState; I.transforming = !1; var F = I.writecb; if (!F) return this.emit("error", new Error("write callback called multiple times")); I.writechunk = null, I.writecb = null, v != null && this.push(v), F(m); var B = this._readableState; B.reading = !1, (B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark) } function f(m) { if (!(this instanceof f)) return new f(m); o.call(this, m), this._transformState = { afterTransform: u.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, m && (typeof m.transform == "function" && (this._transform = m.transform), typeof m.flush == "function" && (this._flush = m.flush)), this.on("prefinish", p) } function p() { var m = this; typeof this._flush == "function" ? this._flush(function (v, I) { d(m, v, I) }) : d(this, null, null) } f.prototype.push = function (m, v) { return this._transformState.needTransform = !1, o.prototype.push.call(this, m, v) }, f.prototype._transform = function (m, v, I) { throw new Error("_transform() is not implemented") }, f.prototype._write = function (m, v, I) { var F = this._transformState; if (F.writecb = I, F.writechunk = m, F.writeencoding = v, !F.transforming) { var B = this._readableState; (F.needTransform || B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark) } }, f.prototype._read = function (m) { var v = this._transformState; v.writechunk !== null && v.writecb && !v.transforming ? (v.transforming = !0, this._transform(v.writechunk, v.writeencoding, v.afterTransform)) : v.needTransform = !0 }, f.prototype._destroy = function (m, v) { var I = this; o.prototype._destroy.call(this, m, function (F) { v(F), I.emit("close") }) }; function d(m, v, I) { if (v) return m.emit("error", v); if (I != null && m.push(I), m._writableState.length) throw new Error("Calling transform done when ws.length != 0"); if (m._transformState.transforming) throw new Error("Calling transform done when still transforming"); return m.push(null) } return _stream_transform } var _stream_passthrough, hasRequired_stream_passthrough; function require_stream_passthrough() { if (hasRequired_stream_passthrough) return _stream_passthrough; hasRequired_stream_passthrough = 1, _stream_passthrough = u; var o = require_stream_transform(), l = Object.create(requireUtil()); l.inherits = requireInherits_browser(), l.inherits(u, o); function u(f) { if (!(this instanceof u)) return new u(f); o.call(this, f) } return u.prototype._transform = function (f, p, d) { d(null, f) }, _stream_passthrough } var hasRequiredReadableBrowser; function requireReadableBrowser() { return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function (o, l) { l = o.exports = require_stream_readable(), l.Stream = l, l.Readable = l, l.Writable = require_stream_writable(), l.Duplex = require_stream_duplex(), l.Transform = require_stream_transform(), l.PassThrough = require_stream_passthrough() }(readableBrowser, readableBrowser.exports)), readableBrowser.exports } var sign = { exports: {} }, bn$9 = { exports: {} }, bn$8 = bn$9.exports, hasRequiredBn$4; function requireBn$4() { return hasRequiredBn$4 || (hasRequiredBn$4 = 1, function (o) { (function (l, u) { function f(P, U) { if (!P) throw new Error(U || "Assertion failed") } function p(P, U) { P.super_ = U; var K = function () { }; K.prototype = U.prototype, P.prototype = new K, P.prototype.constructor = P } function d(P, U, K) { if (d.isBN(P)) return P; this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((U === "le" || U === "be") && (K = U, U = 10), this._init(P || 0, U || 10, K || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (U) { return U instanceof d ? !0 : U !== null && typeof U == "object" && U.constructor.wordSize === d.wordSize && Array.isArray(U.words) }, d.max = function (U, K) { return U.cmp(K) > 0 ? U : K }, d.min = function (U, K) { return U.cmp(K) < 0 ? U : K }, d.prototype._init = function (U, K, Y) { if (typeof U == "number") return this._initNumber(U, K, Y); if (typeof U == "object") return this._initArray(U, K, Y); K === "hex" && (K = 16), f(K === (K | 0) && K >= 2 && K <= 36), U = U.toString().replace(/\s+/g, ""); var te = 0; U[0] === "-" && (te++, this.negative = 1), te < U.length && (K === 16 ? this._parseHex(U, te, Y) : (this._parseBase(U, K, te), Y === "le" && this._initArray(this.toArray(), K, Y))) }, d.prototype._initNumber = function (U, K, Y) { U < 0 && (this.negative = 1, U = -U), U < 67108864 ? (this.words = [U & 67108863], this.length = 1) : U < 4503599627370496 ? (this.words = [U & 67108863, U / 67108864 & 67108863], this.length = 2) : (f(U < 9007199254740992), this.words = [U & 67108863, U / 67108864 & 67108863, 1], this.length = 3), Y === "le" && this._initArray(this.toArray(), K, Y) }, d.prototype._initArray = function (U, K, Y) { if (f(typeof U.length == "number"), U.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(U.length / 3), this.words = new Array(this.length); for (var te = 0; te < this.length; te++)this.words[te] = 0; var ee, G, y = 0; if (Y === "be") for (te = U.length - 1, ee = 0; te >= 0; te -= 3)G = U[te] | U[te - 1] << 8 | U[te - 2] << 16, this.words[ee] |= G << y & 67108863, this.words[ee + 1] = G >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, ee++); else if (Y === "le") for (te = 0, ee = 0; te < U.length; te += 3)G = U[te] | U[te + 1] << 8 | U[te + 2] << 16, this.words[ee] |= G << y & 67108863, this.words[ee + 1] = G >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, ee++); return this._strip() }; function v(P, U) { var K = P.charCodeAt(U); if (K >= 48 && K <= 57) return K - 48; if (K >= 65 && K <= 70) return K - 55; if (K >= 97 && K <= 102) return K - 87; f(!1, "Invalid character in " + P) } function I(P, U, K) { var Y = v(P, K); return K - 1 >= U && (Y |= v(P, K - 1) << 4), Y } d.prototype._parseHex = function (U, K, Y) { this.length = Math.ceil((U.length - K) / 6), this.words = new Array(this.length); for (var te = 0; te < this.length; te++)this.words[te] = 0; var ee = 0, G = 0, y; if (Y === "be") for (te = U.length - 1; te >= K; te -= 2)y = I(U, K, te) << ee, this.words[G] |= y & 67108863, ee >= 18 ? (ee -= 18, G += 1, this.words[G] |= y >>> 26) : ee += 8; else { var X = U.length - K; for (te = X % 2 === 0 ? K + 1 : K; te < U.length; te += 2)y = I(U, K, te) << ee, this.words[G] |= y & 67108863, ee >= 18 ? (ee -= 18, G += 1, this.words[G] |= y >>> 26) : ee += 8 } this._strip() }; function F(P, U, K, Y) { for (var te = 0, ee = 0, G = Math.min(P.length, K), y = U; y < G; y++) { var X = P.charCodeAt(y) - 48; te *= Y, X >= 49 ? ee = X - 49 + 10 : X >= 17 ? ee = X - 17 + 10 : ee = X, f(X >= 0 && ee < Y, "Invalid character"), te += ee } return te } d.prototype._parseBase = function (U, K, Y) { this.words = [0], this.length = 1; for (var te = 0, ee = 1; ee <= 67108863; ee *= K)te++; te--, ee = ee / K | 0; for (var G = U.length - Y, y = G % te, X = Math.min(G, G - y) + Y, ce = 0, me = Y; me < X; me += te)ce = F(U, me, me + te, K), this.imuln(ee), this.words[0] + ce < 67108864 ? this.words[0] += ce : this._iaddn(ce); if (y !== 0) { var Ae = 1; for (ce = F(U, me, U.length, K), me = 0; me < y; me++)Ae *= K; this.imuln(Ae), this.words[0] + ce < 67108864 ? this.words[0] += ce : this._iaddn(ce) } this._strip() }, d.prototype.copy = function (U) { U.words = new Array(this.length); for (var K = 0; K < this.length; K++)U.words[K] = this.words[K]; U.length = this.length, U.negative = this.negative, U.red = this.red }; function B(P, U) { P.words = U.words, P.length = U.length, P.negative = U.negative, P.red = U.red } if (d.prototype._move = function (U) { B(U, this) }, d.prototype.clone = function () { var U = new d(null); return this.copy(U), U }, d.prototype._expand = function (U) { for (; this.length < U;)this.words[this.length++] = 0; return this }, d.prototype._strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, typeof Symbol < "u" && typeof Symbol.for == "function") try { d.prototype[Symbol.for("nodejs.util.inspect.custom")] = W } catch { d.prototype.inspect = W } else d.prototype.inspect = W; function W() { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" } var Z = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], Q = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], re = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (U, K) { U = U || 10, K = K | 0 || 1; var Y; if (U === 16 || U === "hex") { Y = ""; for (var te = 0, ee = 0, G = 0; G < this.length; G++) { var y = this.words[G], X = ((y << te | ee) & 16777215).toString(16); ee = y >>> 24 - te & 16777215, te += 2, te >= 26 && (te -= 26, G--), ee !== 0 || G !== this.length - 1 ? Y = Z[6 - X.length] + X + Y : Y = X + Y } for (ee !== 0 && (Y = ee.toString(16) + Y); Y.length % K !== 0;)Y = "0" + Y; return this.negative !== 0 && (Y = "-" + Y), Y } if (U === (U | 0) && U >= 2 && U <= 36) { var ce = Q[U], me = re[U]; Y = ""; var Ae = this.clone(); for (Ae.negative = 0; !Ae.isZero();) { var Ie = Ae.modrn(me).toString(U); Ae = Ae.idivn(me), Ae.isZero() ? Y = Ie + Y : Y = Z[ce - Ie.length] + Ie + Y } for (this.isZero() && (Y = "0" + Y); Y.length % K !== 0;)Y = "0" + Y; return this.negative !== 0 && (Y = "-" + Y), Y } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var U = this.words[0]; return this.length === 2 ? U += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? U += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -U : U }, d.prototype.toJSON = function () { return this.toString(16, 2) }, m && (d.prototype.toBuffer = function (U, K) { return this.toArrayLike(m, U, K) }), d.prototype.toArray = function (U, K) { return this.toArrayLike(Array, U, K) }; var ne = function (U, K) { return U.allocUnsafe ? U.allocUnsafe(K) : new U(K) }; d.prototype.toArrayLike = function (U, K, Y) { this._strip(); var te = this.byteLength(), ee = Y || Math.max(1, te); f(te <= ee, "byte array longer than desired length"), f(ee > 0, "Requested array length <= 0"); var G = ne(U, ee), y = K === "le" ? "LE" : "BE"; return this["_toArrayLike" + y](G, te), G }, d.prototype._toArrayLikeLE = function (U, K) { for (var Y = 0, te = 0, ee = 0, G = 0; ee < this.length; ee++) { var y = this.words[ee] << G | te; U[Y++] = y & 255, Y < U.length && (U[Y++] = y >> 8 & 255), Y < U.length && (U[Y++] = y >> 16 & 255), G === 6 ? (Y < U.length && (U[Y++] = y >> 24 & 255), te = 0, G = 0) : (te = y >>> 24, G += 2) } if (Y < U.length) for (U[Y++] = te; Y < U.length;)U[Y++] = 0 }, d.prototype._toArrayLikeBE = function (U, K) { for (var Y = U.length - 1, te = 0, ee = 0, G = 0; ee < this.length; ee++) { var y = this.words[ee] << G | te; U[Y--] = y & 255, Y >= 0 && (U[Y--] = y >> 8 & 255), Y >= 0 && (U[Y--] = y >> 16 & 255), G === 6 ? (Y >= 0 && (U[Y--] = y >> 24 & 255), te = 0, G = 0) : (te = y >>> 24, G += 2) } if (Y >= 0) for (U[Y--] = te; Y >= 0;)U[Y--] = 0 }, Math.clz32 ? d.prototype._countBits = function (U) { return 32 - Math.clz32(U) } : d.prototype._countBits = function (U) { var K = U, Y = 0; return K >= 4096 && (Y += 13, K >>>= 13), K >= 64 && (Y += 7, K >>>= 7), K >= 8 && (Y += 4, K >>>= 4), K >= 2 && (Y += 2, K >>>= 2), Y + K }, d.prototype._zeroBits = function (U) { if (U === 0) return 26; var K = U, Y = 0; return (K & 8191) === 0 && (Y += 13, K >>>= 13), (K & 127) === 0 && (Y += 7, K >>>= 7), (K & 15) === 0 && (Y += 4, K >>>= 4), (K & 3) === 0 && (Y += 2, K >>>= 2), (K & 1) === 0 && Y++, Y }, d.prototype.bitLength = function () { var U = this.words[this.length - 1], K = this._countBits(U); return (this.length - 1) * 26 + K }; function oe(P) { for (var U = new Array(P.bitLength()), K = 0; K < U.length; K++) { var Y = K / 26 | 0, te = K % 26; U[K] = P.words[Y] >>> te & 1 } return U } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var U = 0, K = 0; K < this.length; K++) { var Y = this._zeroBits(this.words[K]); if (U += Y, Y !== 26) break } return U }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (U) { return this.negative !== 0 ? this.abs().inotn(U).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (U) { return this.testn(U - 1) ? this.notn(U).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (U) { for (; this.length < U.length;)this.words[this.length++] = 0; for (var K = 0; K < U.length; K++)this.words[K] = this.words[K] | U.words[K]; return this._strip() }, d.prototype.ior = function (U) { return f((this.negative | U.negative) === 0), this.iuor(U) }, d.prototype.or = function (U) { return this.length > U.length ? this.clone().ior(U) : U.clone().ior(this) }, d.prototype.uor = function (U) { return this.length > U.length ? this.clone().iuor(U) : U.clone().iuor(this) }, d.prototype.iuand = function (U) { var K; this.length > U.length ? K = U : K = this; for (var Y = 0; Y < K.length; Y++)this.words[Y] = this.words[Y] & U.words[Y]; return this.length = K.length, this._strip() }, d.prototype.iand = function (U) { return f((this.negative | U.negative) === 0), this.iuand(U) }, d.prototype.and = function (U) { return this.length > U.length ? this.clone().iand(U) : U.clone().iand(this) }, d.prototype.uand = function (U) { return this.length > U.length ? this.clone().iuand(U) : U.clone().iuand(this) }, d.prototype.iuxor = function (U) { var K, Y; this.length > U.length ? (K = this, Y = U) : (K = U, Y = this); for (var te = 0; te < Y.length; te++)this.words[te] = K.words[te] ^ Y.words[te]; if (this !== K) for (; te < K.length; te++)this.words[te] = K.words[te]; return this.length = K.length, this._strip() }, d.prototype.ixor = function (U) { return f((this.negative | U.negative) === 0), this.iuxor(U) }, d.prototype.xor = function (U) { return this.length > U.length ? this.clone().ixor(U) : U.clone().ixor(this) }, d.prototype.uxor = function (U) { return this.length > U.length ? this.clone().iuxor(U) : U.clone().iuxor(this) }, d.prototype.inotn = function (U) { f(typeof U == "number" && U >= 0); var K = Math.ceil(U / 26) | 0, Y = U % 26; this._expand(K), Y > 0 && K--; for (var te = 0; te < K; te++)this.words[te] = ~this.words[te] & 67108863; return Y > 0 && (this.words[te] = ~this.words[te] & 67108863 >> 26 - Y), this._strip() }, d.prototype.notn = function (U) { return this.clone().inotn(U) }, d.prototype.setn = function (U, K) { f(typeof U == "number" && U >= 0); var Y = U / 26 | 0, te = U % 26; return this._expand(Y + 1), K ? this.words[Y] = this.words[Y] | 1 << te : this.words[Y] = this.words[Y] & ~(1 << te), this._strip() }, d.prototype.iadd = function (U) { var K; if (this.negative !== 0 && U.negative === 0) return this.negative = 0, K = this.isub(U), this.negative ^= 1, this._normSign(); if (this.negative === 0 && U.negative !== 0) return U.negative = 0, K = this.isub(U), U.negative = 1, K._normSign(); var Y, te; this.length > U.length ? (Y = this, te = U) : (Y = U, te = this); for (var ee = 0, G = 0; G < te.length; G++)K = (Y.words[G] | 0) + (te.words[G] | 0) + ee, this.words[G] = K & 67108863, ee = K >>> 26; for (; ee !== 0 && G < Y.length; G++)K = (Y.words[G] | 0) + ee, this.words[G] = K & 67108863, ee = K >>> 26; if (this.length = Y.length, ee !== 0) this.words[this.length] = ee, this.length++; else if (Y !== this) for (; G < Y.length; G++)this.words[G] = Y.words[G]; return this }, d.prototype.add = function (U) { var K; return U.negative !== 0 && this.negative === 0 ? (U.negative = 0, K = this.sub(U), U.negative ^= 1, K) : U.negative === 0 && this.negative !== 0 ? (this.negative = 0, K = U.sub(this), this.negative = 1, K) : this.length > U.length ? this.clone().iadd(U) : U.clone().iadd(this) }, d.prototype.isub = function (U) { if (U.negative !== 0) { U.negative = 0; var K = this.iadd(U); return U.negative = 1, K._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(U), this.negative = 1, this._normSign(); var Y = this.cmp(U); if (Y === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var te, ee; Y > 0 ? (te = this, ee = U) : (te = U, ee = this); for (var G = 0, y = 0; y < ee.length; y++)K = (te.words[y] | 0) - (ee.words[y] | 0) + G, G = K >> 26, this.words[y] = K & 67108863; for (; G !== 0 && y < te.length; y++)K = (te.words[y] | 0) + G, G = K >> 26, this.words[y] = K & 67108863; if (G === 0 && y < te.length && te !== this) for (; y < te.length; y++)this.words[y] = te.words[y]; return this.length = Math.max(this.length, y), te !== this && (this.negative = 1), this._strip() }, d.prototype.sub = function (U) { return this.clone().isub(U) }; function ae(P, U, K) { K.negative = U.negative ^ P.negative; var Y = P.length + U.length | 0; K.length = Y, Y = Y - 1 | 0; var te = P.words[0] | 0, ee = U.words[0] | 0, G = te * ee, y = G & 67108863, X = G / 67108864 | 0; K.words[0] = y; for (var ce = 1; ce < Y; ce++) { for (var me = X >>> 26, Ae = X & 67108863, Ie = Math.min(ce, U.length - 1), Be = Math.max(0, ce - P.length + 1); Be <= Ie; Be++) { var Me = ce - Be | 0; te = P.words[Me] | 0, ee = U.words[Be] | 0, G = te * ee + Ae, me += G / 67108864 | 0, Ae = G & 67108863 } K.words[ce] = Ae | 0, X = me | 0 } return X !== 0 ? K.words[ce] = X | 0 : K.length--, K._strip() } var se = function (U, K, Y) { var te = U.words, ee = K.words, G = Y.words, y = 0, X, ce, me, Ae = te[0] | 0, Ie = Ae & 8191, Be = Ae >>> 13, Me = te[1] | 0, De = Me & 8191, Ue = Me >>> 13, Ke = te[2] | 0, Ve = Ke & 8191, ke = Ke >>> 13, Je = te[3] | 0, dt = Je & 8191, lt = Je >>> 13, ht = te[4] | 0, Bt = ht & 8191, mt = ht >>> 13, et = te[5] | 0, Gt = et & 8191, pt = et >>> 13, _t = te[6] | 0, zt = _t & 8191, bt = _t >>> 13, We = te[7] | 0, Ge = We & 8191, ze = We >>> 13, Ze = te[8] | 0, ut = Ze & 8191, ye = Ze >>> 13, ge = te[9] | 0, Ee = ge & 8191, Oe = ge >>> 13, je = ee[0] | 0, nt = je & 8191, Xe = je >>> 13, it = ee[1] | 0, Tt = it & 8191, tt = it >>> 13, yt = ee[2] | 0, kt = yt & 8191, wt = yt >>> 13, Mt = ee[3] | 0, tr = Mt & 8191, St = Mt >>> 13, gt = ee[4] | 0, rr = gt & 8191, Le = gt >>> 13, xe = ee[5] | 0, Ce = xe & 8191, Ne = xe >>> 13, Ye = ee[6] | 0, Re = Ye & 8191, Pe = Ye >>> 13, qe = ee[7] | 0, be = qe & 8191, Fe = qe >>> 13, Qe = ee[8] | 0, st = Qe & 8191, rt = Qe >>> 13, ct = ee[9] | 0, Lt = ct & 8191, It = ct >>> 13; Y.negative = U.negative ^ K.negative, Y.length = 19, X = Math.imul(Ie, nt), ce = Math.imul(Ie, Xe), ce = ce + Math.imul(Be, nt) | 0, me = Math.imul(Be, Xe); var lr = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, X = Math.imul(De, nt), ce = Math.imul(De, Xe), ce = ce + Math.imul(Ue, nt) | 0, me = Math.imul(Ue, Xe), X = X + Math.imul(Ie, Tt) | 0, ce = ce + Math.imul(Ie, tt) | 0, ce = ce + Math.imul(Be, Tt) | 0, me = me + Math.imul(Be, tt) | 0; var jt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, X = Math.imul(Ve, nt), ce = Math.imul(Ve, Xe), ce = ce + Math.imul(ke, nt) | 0, me = Math.imul(ke, Xe), X = X + Math.imul(De, Tt) | 0, ce = ce + Math.imul(De, tt) | 0, ce = ce + Math.imul(Ue, Tt) | 0, me = me + Math.imul(Ue, tt) | 0, X = X + Math.imul(Ie, kt) | 0, ce = ce + Math.imul(Ie, wt) | 0, ce = ce + Math.imul(Be, kt) | 0, me = me + Math.imul(Be, wt) | 0; var Ft = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, X = Math.imul(dt, nt), ce = Math.imul(dt, Xe), ce = ce + Math.imul(lt, nt) | 0, me = Math.imul(lt, Xe), X = X + Math.imul(Ve, Tt) | 0, ce = ce + Math.imul(Ve, tt) | 0, ce = ce + Math.imul(ke, Tt) | 0, me = me + Math.imul(ke, tt) | 0, X = X + Math.imul(De, kt) | 0, ce = ce + Math.imul(De, wt) | 0, ce = ce + Math.imul(Ue, kt) | 0, me = me + Math.imul(Ue, wt) | 0, X = X + Math.imul(Ie, tr) | 0, ce = ce + Math.imul(Ie, St) | 0, ce = ce + Math.imul(Be, tr) | 0, me = me + Math.imul(Be, St) | 0; var er = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, X = Math.imul(Bt, nt), ce = Math.imul(Bt, Xe), ce = ce + Math.imul(mt, nt) | 0, me = Math.imul(mt, Xe), X = X + Math.imul(dt, Tt) | 0, ce = ce + Math.imul(dt, tt) | 0, ce = ce + Math.imul(lt, Tt) | 0, me = me + Math.imul(lt, tt) | 0, X = X + Math.imul(Ve, kt) | 0, ce = ce + Math.imul(Ve, wt) | 0, ce = ce + Math.imul(ke, kt) | 0, me = me + Math.imul(ke, wt) | 0, X = X + Math.imul(De, tr) | 0, ce = ce + Math.imul(De, St) | 0, ce = ce + Math.imul(Ue, tr) | 0, me = me + Math.imul(Ue, St) | 0, X = X + Math.imul(Ie, rr) | 0, ce = ce + Math.imul(Ie, Le) | 0, ce = ce + Math.imul(Be, rr) | 0, me = me + Math.imul(Be, Le) | 0; var ar = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, X = Math.imul(Gt, nt), ce = Math.imul(Gt, Xe), ce = ce + Math.imul(pt, nt) | 0, me = Math.imul(pt, Xe), X = X + Math.imul(Bt, Tt) | 0, ce = ce + Math.imul(Bt, tt) | 0, ce = ce + Math.imul(mt, Tt) | 0, me = me + Math.imul(mt, tt) | 0, X = X + Math.imul(dt, kt) | 0, ce = ce + Math.imul(dt, wt) | 0, ce = ce + Math.imul(lt, kt) | 0, me = me + Math.imul(lt, wt) | 0, X = X + Math.imul(Ve, tr) | 0, ce = ce + Math.imul(Ve, St) | 0, ce = ce + Math.imul(ke, tr) | 0, me = me + Math.imul(ke, St) | 0, X = X + Math.imul(De, rr) | 0, ce = ce + Math.imul(De, Le) | 0, ce = ce + Math.imul(Ue, rr) | 0, me = me + Math.imul(Ue, Le) | 0, X = X + Math.imul(Ie, Ce) | 0, ce = ce + Math.imul(Ie, Ne) | 0, ce = ce + Math.imul(Be, Ce) | 0, me = me + Math.imul(Be, Ne) | 0; var nr = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, X = Math.imul(zt, nt), ce = Math.imul(zt, Xe), ce = ce + Math.imul(bt, nt) | 0, me = Math.imul(bt, Xe), X = X + Math.imul(Gt, Tt) | 0, ce = ce + Math.imul(Gt, tt) | 0, ce = ce + Math.imul(pt, Tt) | 0, me = me + Math.imul(pt, tt) | 0, X = X + Math.imul(Bt, kt) | 0, ce = ce + Math.imul(Bt, wt) | 0, ce = ce + Math.imul(mt, kt) | 0, me = me + Math.imul(mt, wt) | 0, X = X + Math.imul(dt, tr) | 0, ce = ce + Math.imul(dt, St) | 0, ce = ce + Math.imul(lt, tr) | 0, me = me + Math.imul(lt, St) | 0, X = X + Math.imul(Ve, rr) | 0, ce = ce + Math.imul(Ve, Le) | 0, ce = ce + Math.imul(ke, rr) | 0, me = me + Math.imul(ke, Le) | 0, X = X + Math.imul(De, Ce) | 0, ce = ce + Math.imul(De, Ne) | 0, ce = ce + Math.imul(Ue, Ce) | 0, me = me + Math.imul(Ue, Ne) | 0, X = X + Math.imul(Ie, Re) | 0, ce = ce + Math.imul(Ie, Pe) | 0, ce = ce + Math.imul(Be, Re) | 0, me = me + Math.imul(Be, Pe) | 0; var ir = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, X = Math.imul(Ge, nt), ce = Math.imul(Ge, Xe), ce = ce + Math.imul(ze, nt) | 0, me = Math.imul(ze, Xe), X = X + Math.imul(zt, Tt) | 0, ce = ce + Math.imul(zt, tt) | 0, ce = ce + Math.imul(bt, Tt) | 0, me = me + Math.imul(bt, tt) | 0, X = X + Math.imul(Gt, kt) | 0, ce = ce + Math.imul(Gt, wt) | 0, ce = ce + Math.imul(pt, kt) | 0, me = me + Math.imul(pt, wt) | 0, X = X + Math.imul(Bt, tr) | 0, ce = ce + Math.imul(Bt, St) | 0, ce = ce + Math.imul(mt, tr) | 0, me = me + Math.imul(mt, St) | 0, X = X + Math.imul(dt, rr) | 0, ce = ce + Math.imul(dt, Le) | 0, ce = ce + Math.imul(lt, rr) | 0, me = me + Math.imul(lt, Le) | 0, X = X + Math.imul(Ve, Ce) | 0, ce = ce + Math.imul(Ve, Ne) | 0, ce = ce + Math.imul(ke, Ce) | 0, me = me + Math.imul(ke, Ne) | 0, X = X + Math.imul(De, Re) | 0, ce = ce + Math.imul(De, Pe) | 0, ce = ce + Math.imul(Ue, Re) | 0, me = me + Math.imul(Ue, Pe) | 0, X = X + Math.imul(Ie, be) | 0, ce = ce + Math.imul(Ie, Fe) | 0, ce = ce + Math.imul(Be, be) | 0, me = me + Math.imul(Be, Fe) | 0; var Ht = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, X = Math.imul(ut, nt), ce = Math.imul(ut, Xe), ce = ce + Math.imul(ye, nt) | 0, me = Math.imul(ye, Xe), X = X + Math.imul(Ge, Tt) | 0, ce = ce + Math.imul(Ge, tt) | 0, ce = ce + Math.imul(ze, Tt) | 0, me = me + Math.imul(ze, tt) | 0, X = X + Math.imul(zt, kt) | 0, ce = ce + Math.imul(zt, wt) | 0, ce = ce + Math.imul(bt, kt) | 0, me = me + Math.imul(bt, wt) | 0, X = X + Math.imul(Gt, tr) | 0, ce = ce + Math.imul(Gt, St) | 0, ce = ce + Math.imul(pt, tr) | 0, me = me + Math.imul(pt, St) | 0, X = X + Math.imul(Bt, rr) | 0, ce = ce + Math.imul(Bt, Le) | 0, ce = ce + Math.imul(mt, rr) | 0, me = me + Math.imul(mt, Le) | 0, X = X + Math.imul(dt, Ce) | 0, ce = ce + Math.imul(dt, Ne) | 0, ce = ce + Math.imul(lt, Ce) | 0, me = me + Math.imul(lt, Ne) | 0, X = X + Math.imul(Ve, Re) | 0, ce = ce + Math.imul(Ve, Pe) | 0, ce = ce + Math.imul(ke, Re) | 0, me = me + Math.imul(ke, Pe) | 0, X = X + Math.imul(De, be) | 0, ce = ce + Math.imul(De, Fe) | 0, ce = ce + Math.imul(Ue, be) | 0, me = me + Math.imul(Ue, Fe) | 0, X = X + Math.imul(Ie, st) | 0, ce = ce + Math.imul(Ie, rt) | 0, ce = ce + Math.imul(Be, st) | 0, me = me + Math.imul(Be, rt) | 0; var sr = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, X = Math.imul(Ee, nt), ce = Math.imul(Ee, Xe), ce = ce + Math.imul(Oe, nt) | 0, me = Math.imul(Oe, Xe), X = X + Math.imul(ut, Tt) | 0, ce = ce + Math.imul(ut, tt) | 0, ce = ce + Math.imul(ye, Tt) | 0, me = me + Math.imul(ye, tt) | 0, X = X + Math.imul(Ge, kt) | 0, ce = ce + Math.imul(Ge, wt) | 0, ce = ce + Math.imul(ze, kt) | 0, me = me + Math.imul(ze, wt) | 0, X = X + Math.imul(zt, tr) | 0, ce = ce + Math.imul(zt, St) | 0, ce = ce + Math.imul(bt, tr) | 0, me = me + Math.imul(bt, St) | 0, X = X + Math.imul(Gt, rr) | 0, ce = ce + Math.imul(Gt, Le) | 0, ce = ce + Math.imul(pt, rr) | 0, me = me + Math.imul(pt, Le) | 0, X = X + Math.imul(Bt, Ce) | 0, ce = ce + Math.imul(Bt, Ne) | 0, ce = ce + Math.imul(mt, Ce) | 0, me = me + Math.imul(mt, Ne) | 0, X = X + Math.imul(dt, Re) | 0, ce = ce + Math.imul(dt, Pe) | 0, ce = ce + Math.imul(lt, Re) | 0, me = me + Math.imul(lt, Pe) | 0, X = X + Math.imul(Ve, be) | 0, ce = ce + Math.imul(Ve, Fe) | 0, ce = ce + Math.imul(ke, be) | 0, me = me + Math.imul(ke, Fe) | 0, X = X + Math.imul(De, st) | 0, ce = ce + Math.imul(De, rt) | 0, ce = ce + Math.imul(Ue, st) | 0, me = me + Math.imul(Ue, rt) | 0, X = X + Math.imul(Ie, Lt) | 0, ce = ce + Math.imul(Ie, It) | 0, ce = ce + Math.imul(Be, Lt) | 0, me = me + Math.imul(Be, It) | 0; var Kt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, X = Math.imul(Ee, Tt), ce = Math.imul(Ee, tt), ce = ce + Math.imul(Oe, Tt) | 0, me = Math.imul(Oe, tt), X = X + Math.imul(ut, kt) | 0, ce = ce + Math.imul(ut, wt) | 0, ce = ce + Math.imul(ye, kt) | 0, me = me + Math.imul(ye, wt) | 0, X = X + Math.imul(Ge, tr) | 0, ce = ce + Math.imul(Ge, St) | 0, ce = ce + Math.imul(ze, tr) | 0, me = me + Math.imul(ze, St) | 0, X = X + Math.imul(zt, rr) | 0, ce = ce + Math.imul(zt, Le) | 0, ce = ce + Math.imul(bt, rr) | 0, me = me + Math.imul(bt, Le) | 0, X = X + Math.imul(Gt, Ce) | 0, ce = ce + Math.imul(Gt, Ne) | 0, ce = ce + Math.imul(pt, Ce) | 0, me = me + Math.imul(pt, Ne) | 0, X = X + Math.imul(Bt, Re) | 0, ce = ce + Math.imul(Bt, Pe) | 0, ce = ce + Math.imul(mt, Re) | 0, me = me + Math.imul(mt, Pe) | 0, X = X + Math.imul(dt, be) | 0, ce = ce + Math.imul(dt, Fe) | 0, ce = ce + Math.imul(lt, be) | 0, me = me + Math.imul(lt, Fe) | 0, X = X + Math.imul(Ve, st) | 0, ce = ce + Math.imul(Ve, rt) | 0, ce = ce + Math.imul(ke, st) | 0, me = me + Math.imul(ke, rt) | 0, X = X + Math.imul(De, Lt) | 0, ce = ce + Math.imul(De, It) | 0, ce = ce + Math.imul(Ue, Lt) | 0, me = me + Math.imul(Ue, It) | 0; var Qt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, X = Math.imul(Ee, kt), ce = Math.imul(Ee, wt), ce = ce + Math.imul(Oe, kt) | 0, me = Math.imul(Oe, wt), X = X + Math.imul(ut, tr) | 0, ce = ce + Math.imul(ut, St) | 0, ce = ce + Math.imul(ye, tr) | 0, me = me + Math.imul(ye, St) | 0, X = X + Math.imul(Ge, rr) | 0, ce = ce + Math.imul(Ge, Le) | 0, ce = ce + Math.imul(ze, rr) | 0, me = me + Math.imul(ze, Le) | 0, X = X + Math.imul(zt, Ce) | 0, ce = ce + Math.imul(zt, Ne) | 0, ce = ce + Math.imul(bt, Ce) | 0, me = me + Math.imul(bt, Ne) | 0, X = X + Math.imul(Gt, Re) | 0, ce = ce + Math.imul(Gt, Pe) | 0, ce = ce + Math.imul(pt, Re) | 0, me = me + Math.imul(pt, Pe) | 0, X = X + Math.imul(Bt, be) | 0, ce = ce + Math.imul(Bt, Fe) | 0, ce = ce + Math.imul(mt, be) | 0, me = me + Math.imul(mt, Fe) | 0, X = X + Math.imul(dt, st) | 0, ce = ce + Math.imul(dt, rt) | 0, ce = ce + Math.imul(lt, st) | 0, me = me + Math.imul(lt, rt) | 0, X = X + Math.imul(Ve, Lt) | 0, ce = ce + Math.imul(Ve, It) | 0, ce = ce + Math.imul(ke, Lt) | 0, me = me + Math.imul(ke, It) | 0; var $t = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, X = Math.imul(Ee, tr), ce = Math.imul(Ee, St), ce = ce + Math.imul(Oe, tr) | 0, me = Math.imul(Oe, St), X = X + Math.imul(ut, rr) | 0, ce = ce + Math.imul(ut, Le) | 0, ce = ce + Math.imul(ye, rr) | 0, me = me + Math.imul(ye, Le) | 0, X = X + Math.imul(Ge, Ce) | 0, ce = ce + Math.imul(Ge, Ne) | 0, ce = ce + Math.imul(ze, Ce) | 0, me = me + Math.imul(ze, Ne) | 0, X = X + Math.imul(zt, Re) | 0, ce = ce + Math.imul(zt, Pe) | 0, ce = ce + Math.imul(bt, Re) | 0, me = me + Math.imul(bt, Pe) | 0, X = X + Math.imul(Gt, be) | 0, ce = ce + Math.imul(Gt, Fe) | 0, ce = ce + Math.imul(pt, be) | 0, me = me + Math.imul(pt, Fe) | 0, X = X + Math.imul(Bt, st) | 0, ce = ce + Math.imul(Bt, rt) | 0, ce = ce + Math.imul(mt, st) | 0, me = me + Math.imul(mt, rt) | 0, X = X + Math.imul(dt, Lt) | 0, ce = ce + Math.imul(dt, It) | 0, ce = ce + Math.imul(lt, Lt) | 0, me = me + Math.imul(lt, It) | 0; var Yt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, X = Math.imul(Ee, rr), ce = Math.imul(Ee, Le), ce = ce + Math.imul(Oe, rr) | 0, me = Math.imul(Oe, Le), X = X + Math.imul(ut, Ce) | 0, ce = ce + Math.imul(ut, Ne) | 0, ce = ce + Math.imul(ye, Ce) | 0, me = me + Math.imul(ye, Ne) | 0, X = X + Math.imul(Ge, Re) | 0, ce = ce + Math.imul(Ge, Pe) | 0, ce = ce + Math.imul(ze, Re) | 0, me = me + Math.imul(ze, Pe) | 0, X = X + Math.imul(zt, be) | 0, ce = ce + Math.imul(zt, Fe) | 0, ce = ce + Math.imul(bt, be) | 0, me = me + Math.imul(bt, Fe) | 0, X = X + Math.imul(Gt, st) | 0, ce = ce + Math.imul(Gt, rt) | 0, ce = ce + Math.imul(pt, st) | 0, me = me + Math.imul(pt, rt) | 0, X = X + Math.imul(Bt, Lt) | 0, ce = ce + Math.imul(Bt, It) | 0, ce = ce + Math.imul(mt, Lt) | 0, me = me + Math.imul(mt, It) | 0; var Xt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, X = Math.imul(Ee, Ce), ce = Math.imul(Ee, Ne), ce = ce + Math.imul(Oe, Ce) | 0, me = Math.imul(Oe, Ne), X = X + Math.imul(ut, Re) | 0, ce = ce + Math.imul(ut, Pe) | 0, ce = ce + Math.imul(ye, Re) | 0, me = me + Math.imul(ye, Pe) | 0, X = X + Math.imul(Ge, be) | 0, ce = ce + Math.imul(Ge, Fe) | 0, ce = ce + Math.imul(ze, be) | 0, me = me + Math.imul(ze, Fe) | 0, X = X + Math.imul(zt, st) | 0, ce = ce + Math.imul(zt, rt) | 0, ce = ce + Math.imul(bt, st) | 0, me = me + Math.imul(bt, rt) | 0, X = X + Math.imul(Gt, Lt) | 0, ce = ce + Math.imul(Gt, It) | 0, ce = ce + Math.imul(pt, Lt) | 0, me = me + Math.imul(pt, It) | 0; var Nt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, X = Math.imul(Ee, Re), ce = Math.imul(Ee, Pe), ce = ce + Math.imul(Oe, Re) | 0, me = Math.imul(Oe, Pe), X = X + Math.imul(ut, be) | 0, ce = ce + Math.imul(ut, Fe) | 0, ce = ce + Math.imul(ye, be) | 0, me = me + Math.imul(ye, Fe) | 0, X = X + Math.imul(Ge, st) | 0, ce = ce + Math.imul(Ge, rt) | 0, ce = ce + Math.imul(ze, st) | 0, me = me + Math.imul(ze, rt) | 0, X = X + Math.imul(zt, Lt) | 0, ce = ce + Math.imul(zt, It) | 0, ce = ce + Math.imul(bt, Lt) | 0, me = me + Math.imul(bt, It) | 0; var Et = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, X = Math.imul(Ee, be), ce = Math.imul(Ee, Fe), ce = ce + Math.imul(Oe, be) | 0, me = Math.imul(Oe, Fe), X = X + Math.imul(ut, st) | 0, ce = ce + Math.imul(ut, rt) | 0, ce = ce + Math.imul(ye, st) | 0, me = me + Math.imul(ye, rt) | 0, X = X + Math.imul(Ge, Lt) | 0, ce = ce + Math.imul(Ge, It) | 0, ce = ce + Math.imul(ze, Lt) | 0, me = me + Math.imul(ze, It) | 0; var At = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, X = Math.imul(Ee, st), ce = Math.imul(Ee, rt), ce = ce + Math.imul(Oe, st) | 0, me = Math.imul(Oe, rt), X = X + Math.imul(ut, Lt) | 0, ce = ce + Math.imul(ut, It) | 0, ce = ce + Math.imul(ye, Lt) | 0, me = me + Math.imul(ye, It) | 0; var qt = (y + X | 0) + ((ce & 8191) << 13) | 0; y = (me + (ce >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, X = Math.imul(Ee, Lt), ce = Math.imul(Ee, It), ce = ce + Math.imul(Oe, Lt) | 0, me = Math.imul(Oe, It); var Ot = (y + X | 0) + ((ce & 8191) << 13) | 0; return y = (me + (ce >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, G[0] = lr, G[1] = jt, G[2] = Ft, G[3] = er, G[4] = ar, G[5] = nr, G[6] = ir, G[7] = Ht, G[8] = sr, G[9] = Kt, G[10] = Qt, G[11] = $t, G[12] = Yt, G[13] = Xt, G[14] = Nt, G[15] = Et, G[16] = At, G[17] = qt, G[18] = Ot, y !== 0 && (G[19] = y, Y.length++), Y }; Math.imul || (se = ae); function le(P, U, K) { K.negative = U.negative ^ P.negative, K.length = P.length + U.length; for (var Y = 0, te = 0, ee = 0; ee < K.length - 1; ee++) { var G = te; te = 0; for (var y = Y & 67108863, X = Math.min(ee, U.length - 1), ce = Math.max(0, ee - P.length + 1); ce <= X; ce++) { var me = ee - ce, Ae = P.words[me] | 0, Ie = U.words[ce] | 0, Be = Ae * Ie, Me = Be & 67108863; G = G + (Be / 67108864 | 0) | 0, Me = Me + y | 0, y = Me & 67108863, G = G + (Me >>> 26) | 0, te += G >>> 26, G &= 67108863 } K.words[ee] = y, Y = G, G = te } return Y !== 0 ? K.words[ee] = Y : K.length--, K._strip() } function ue(P, U, K) { return le(P, U, K) } d.prototype.mulTo = function (U, K) { var Y, te = this.length + U.length; return this.length === 10 && U.length === 10 ? Y = se(this, U, K) : te < 63 ? Y = ae(this, U, K) : te < 1024 ? Y = le(this, U, K) : Y = ue(this, U, K), Y }, d.prototype.mul = function (U) { var K = new d(null); return K.words = new Array(this.length + U.length), this.mulTo(U, K) }, d.prototype.mulf = function (U) { var K = new d(null); return K.words = new Array(this.length + U.length), ue(this, U, K) }, d.prototype.imul = function (U) { return this.clone().mulTo(U, this) }, d.prototype.imuln = function (U) { var K = U < 0; K && (U = -U), f(typeof U == "number"), f(U < 67108864); for (var Y = 0, te = 0; te < this.length; te++) { var ee = (this.words[te] | 0) * U, G = (ee & 67108863) + (Y & 67108863); Y >>= 26, Y += ee / 67108864 | 0, Y += G >>> 26, this.words[te] = G & 67108863 } return Y !== 0 && (this.words[te] = Y, this.length++), K ? this.ineg() : this }, d.prototype.muln = function (U) { return this.clone().imuln(U) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (U) { var K = oe(U); if (K.length === 0) return new d(1); for (var Y = this, te = 0; te < K.length && K[te] === 0; te++, Y = Y.sqr()); if (++te < K.length) for (var ee = Y.sqr(); te < K.length; te++, ee = ee.sqr())K[te] !== 0 && (Y = Y.mul(ee)); return Y }, d.prototype.iushln = function (U) { f(typeof U == "number" && U >= 0); var K = U % 26, Y = (U - K) / 26, te = 67108863 >>> 26 - K << 26 - K, ee; if (K !== 0) { var G = 0; for (ee = 0; ee < this.length; ee++) { var y = this.words[ee] & te, X = (this.words[ee] | 0) - y << K; this.words[ee] = X | G, G = y >>> 26 - K } G && (this.words[ee] = G, this.length++) } if (Y !== 0) { for (ee = this.length - 1; ee >= 0; ee--)this.words[ee + Y] = this.words[ee]; for (ee = 0; ee < Y; ee++)this.words[ee] = 0; this.length += Y } return this._strip() }, d.prototype.ishln = function (U) { return f(this.negative === 0), this.iushln(U) }, d.prototype.iushrn = function (U, K, Y) { f(typeof U == "number" && U >= 0); var te; K ? te = (K - K % 26) / 26 : te = 0; var ee = U % 26, G = Math.min((U - ee) / 26, this.length), y = 67108863 ^ 67108863 >>> ee << ee, X = Y; if (te -= G, te = Math.max(0, te), X) { for (var ce = 0; ce < G; ce++)X.words[ce] = this.words[ce]; X.length = G } if (G !== 0) if (this.length > G) for (this.length -= G, ce = 0; ce < this.length; ce++)this.words[ce] = this.words[ce + G]; else this.words[0] = 0, this.length = 1; var me = 0; for (ce = this.length - 1; ce >= 0 && (me !== 0 || ce >= te); ce--) { var Ae = this.words[ce] | 0; this.words[ce] = me << 26 - ee | Ae >>> ee, me = Ae & y } return X && me !== 0 && (X.words[X.length++] = me), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip() }, d.prototype.ishrn = function (U, K, Y) { return f(this.negative === 0), this.iushrn(U, K, Y) }, d.prototype.shln = function (U) { return this.clone().ishln(U) }, d.prototype.ushln = function (U) { return this.clone().iushln(U) }, d.prototype.shrn = function (U) { return this.clone().ishrn(U) }, d.prototype.ushrn = function (U) { return this.clone().iushrn(U) }, d.prototype.testn = function (U) { f(typeof U == "number" && U >= 0); var K = U % 26, Y = (U - K) / 26, te = 1 << K; if (this.length <= Y) return !1; var ee = this.words[Y]; return !!(ee & te) }, d.prototype.imaskn = function (U) { f(typeof U == "number" && U >= 0); var K = U % 26, Y = (U - K) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Y) return this; if (K !== 0 && Y++, this.length = Math.min(Y, this.length), K !== 0) { var te = 67108863 ^ 67108863 >>> K << K; this.words[this.length - 1] &= te } return this._strip() }, d.prototype.maskn = function (U) { return this.clone().imaskn(U) }, d.prototype.iaddn = function (U) { return f(typeof U == "number"), f(U < 67108864), U < 0 ? this.isubn(-U) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= U ? (this.words[0] = U - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(U), this.negative = 1, this) : this._iaddn(U) }, d.prototype._iaddn = function (U) { this.words[0] += U; for (var K = 0; K < this.length && this.words[K] >= 67108864; K++)this.words[K] -= 67108864, K === this.length - 1 ? this.words[K + 1] = 1 : this.words[K + 1]++; return this.length = Math.max(this.length, K + 1), this }, d.prototype.isubn = function (U) { if (f(typeof U == "number"), f(U < 67108864), U < 0) return this.iaddn(-U); if (this.negative !== 0) return this.negative = 0, this.iaddn(U), this.negative = 1, this; if (this.words[0] -= U, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var K = 0; K < this.length && this.words[K] < 0; K++)this.words[K] += 67108864, this.words[K + 1] -= 1; return this._strip() }, d.prototype.addn = function (U) { return this.clone().iaddn(U) }, d.prototype.subn = function (U) { return this.clone().isubn(U) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (U, K, Y) { var te = U.length + Y, ee; this._expand(te); var G, y = 0; for (ee = 0; ee < U.length; ee++) { G = (this.words[ee + Y] | 0) + y; var X = (U.words[ee] | 0) * K; G -= X & 67108863, y = (G >> 26) - (X / 67108864 | 0), this.words[ee + Y] = G & 67108863 } for (; ee < this.length - Y; ee++)G = (this.words[ee + Y] | 0) + y, y = G >> 26, this.words[ee + Y] = G & 67108863; if (y === 0) return this._strip(); for (f(y === -1), y = 0, ee = 0; ee < this.length; ee++)G = -(this.words[ee] | 0) + y, y = G >> 26, this.words[ee] = G & 67108863; return this.negative = 1, this._strip() }, d.prototype._wordDiv = function (U, K) { var Y = this.length - U.length, te = this.clone(), ee = U, G = ee.words[ee.length - 1] | 0, y = this._countBits(G); Y = 26 - y, Y !== 0 && (ee = ee.ushln(Y), te.iushln(Y), G = ee.words[ee.length - 1] | 0); var X = te.length - ee.length, ce; if (K !== "mod") { ce = new d(null), ce.length = X + 1, ce.words = new Array(ce.length); for (var me = 0; me < ce.length; me++)ce.words[me] = 0 } var Ae = te.clone()._ishlnsubmul(ee, 1, X); Ae.negative === 0 && (te = Ae, ce && (ce.words[X] = 1)); for (var Ie = X - 1; Ie >= 0; Ie--) { var Be = (te.words[ee.length + Ie] | 0) * 67108864 + (te.words[ee.length + Ie - 1] | 0); for (Be = Math.min(Be / G | 0, 67108863), te._ishlnsubmul(ee, Be, Ie); te.negative !== 0;)Be--, te.negative = 0, te._ishlnsubmul(ee, 1, Ie), te.isZero() || (te.negative ^= 1); ce && (ce.words[Ie] = Be) } return ce && ce._strip(), te._strip(), K !== "div" && Y !== 0 && te.iushrn(Y), { div: ce || null, mod: te } }, d.prototype.divmod = function (U, K, Y) { if (f(!U.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var te, ee, G; return this.negative !== 0 && U.negative === 0 ? (G = this.neg().divmod(U, K), K !== "mod" && (te = G.div.neg()), K !== "div" && (ee = G.mod.neg(), Y && ee.negative !== 0 && ee.iadd(U)), { div: te, mod: ee }) : this.negative === 0 && U.negative !== 0 ? (G = this.divmod(U.neg(), K), K !== "mod" && (te = G.div.neg()), { div: te, mod: G.mod }) : (this.negative & U.negative) !== 0 ? (G = this.neg().divmod(U.neg(), K), K !== "div" && (ee = G.mod.neg(), Y && ee.negative !== 0 && ee.isub(U)), { div: G.div, mod: ee }) : U.length > this.length || this.cmp(U) < 0 ? { div: new d(0), mod: this } : U.length === 1 ? K === "div" ? { div: this.divn(U.words[0]), mod: null } : K === "mod" ? { div: null, mod: new d(this.modrn(U.words[0])) } : { div: this.divn(U.words[0]), mod: new d(this.modrn(U.words[0])) } : this._wordDiv(U, K) }, d.prototype.div = function (U) { return this.divmod(U, "div", !1).div }, d.prototype.mod = function (U) { return this.divmod(U, "mod", !1).mod }, d.prototype.umod = function (U) { return this.divmod(U, "mod", !0).mod }, d.prototype.divRound = function (U) { var K = this.divmod(U); if (K.mod.isZero()) return K.div; var Y = K.div.negative !== 0 ? K.mod.isub(U) : K.mod, te = U.ushrn(1), ee = U.andln(1), G = Y.cmp(te); return G < 0 || ee === 1 && G === 0 ? K.div : K.div.negative !== 0 ? K.div.isubn(1) : K.div.iaddn(1) }, d.prototype.modrn = function (U) { var K = U < 0; K && (U = -U), f(U <= 67108863); for (var Y = (1 << 26) % U, te = 0, ee = this.length - 1; ee >= 0; ee--)te = (Y * te + (this.words[ee] | 0)) % U; return K ? -te : te }, d.prototype.modn = function (U) { return this.modrn(U) }, d.prototype.idivn = function (U) { var K = U < 0; K && (U = -U), f(U <= 67108863); for (var Y = 0, te = this.length - 1; te >= 0; te--) { var ee = (this.words[te] | 0) + Y * 67108864; this.words[te] = ee / U | 0, Y = ee % U } return this._strip(), K ? this.ineg() : this }, d.prototype.divn = function (U) { return this.clone().idivn(U) }, d.prototype.egcd = function (U) { f(U.negative === 0), f(!U.isZero()); var K = this, Y = U.clone(); K.negative !== 0 ? K = K.umod(U) : K = K.clone(); for (var te = new d(1), ee = new d(0), G = new d(0), y = new d(1), X = 0; K.isEven() && Y.isEven();)K.iushrn(1), Y.iushrn(1), ++X; for (var ce = Y.clone(), me = K.clone(); !K.isZero();) { for (var Ae = 0, Ie = 1; (K.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (K.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(ce), ee.isub(me)), te.iushrn(1), ee.iushrn(1); for (var Be = 0, Me = 1; (Y.words[0] & Me) === 0 && Be < 26; ++Be, Me <<= 1); if (Be > 0) for (Y.iushrn(Be); Be-- > 0;)(G.isOdd() || y.isOdd()) && (G.iadd(ce), y.isub(me)), G.iushrn(1), y.iushrn(1); K.cmp(Y) >= 0 ? (K.isub(Y), te.isub(G), ee.isub(y)) : (Y.isub(K), G.isub(te), y.isub(ee)) } return { a: G, b: y, gcd: Y.iushln(X) } }, d.prototype._invmp = function (U) { f(U.negative === 0), f(!U.isZero()); var K = this, Y = U.clone(); K.negative !== 0 ? K = K.umod(U) : K = K.clone(); for (var te = new d(1), ee = new d(0), G = Y.clone(); K.cmpn(1) > 0 && Y.cmpn(1) > 0;) { for (var y = 0, X = 1; (K.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (K.iushrn(y); y-- > 0;)te.isOdd() && te.iadd(G), te.iushrn(1); for (var ce = 0, me = 1; (Y.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (Y.iushrn(ce); ce-- > 0;)ee.isOdd() && ee.iadd(G), ee.iushrn(1); K.cmp(Y) >= 0 ? (K.isub(Y), te.isub(ee)) : (Y.isub(K), ee.isub(te)) } var Ae; return K.cmpn(1) === 0 ? Ae = te : Ae = ee, Ae.cmpn(0) < 0 && Ae.iadd(U), Ae }, d.prototype.gcd = function (U) { if (this.isZero()) return U.abs(); if (U.isZero()) return this.abs(); var K = this.clone(), Y = U.clone(); K.negative = 0, Y.negative = 0; for (var te = 0; K.isEven() && Y.isEven(); te++)K.iushrn(1), Y.iushrn(1); do { for (; K.isEven();)K.iushrn(1); for (; Y.isEven();)Y.iushrn(1); var ee = K.cmp(Y); if (ee < 0) { var G = K; K = Y, Y = G } else if (ee === 0 || Y.cmpn(1) === 0) break; K.isub(Y) } while (!0); return Y.iushln(te) }, d.prototype.invm = function (U) { return this.egcd(U).a.umod(U) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (U) { return this.words[0] & U }, d.prototype.bincn = function (U) { f(typeof U == "number"); var K = U % 26, Y = (U - K) / 26, te = 1 << K; if (this.length <= Y) return this._expand(Y + 1), this.words[Y] |= te, this; for (var ee = te, G = Y; ee !== 0 && G < this.length; G++) { var y = this.words[G] | 0; y += ee, ee = y >>> 26, y &= 67108863, this.words[G] = y } return ee !== 0 && (this.words[G] = ee, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (U) { var K = U < 0; if (this.negative !== 0 && !K) return -1; if (this.negative === 0 && K) return 1; this._strip(); var Y; if (this.length > 1) Y = 1; else { K && (U = -U), f(U <= 67108863, "Number is too big"); var te = this.words[0] | 0; Y = te === U ? 0 : te < U ? -1 : 1 } return this.negative !== 0 ? -Y | 0 : Y }, d.prototype.cmp = function (U) { if (this.negative !== 0 && U.negative === 0) return -1; if (this.negative === 0 && U.negative !== 0) return 1; var K = this.ucmp(U); return this.negative !== 0 ? -K | 0 : K }, d.prototype.ucmp = function (U) { if (this.length > U.length) return 1; if (this.length < U.length) return -1; for (var K = 0, Y = this.length - 1; Y >= 0; Y--) { var te = this.words[Y] | 0, ee = U.words[Y] | 0; if (te !== ee) { te < ee ? K = -1 : te > ee && (K = 1); break } } return K }, d.prototype.gtn = function (U) { return this.cmpn(U) === 1 }, d.prototype.gt = function (U) { return this.cmp(U) === 1 }, d.prototype.gten = function (U) { return this.cmpn(U) >= 0 }, d.prototype.gte = function (U) { return this.cmp(U) >= 0 }, d.prototype.ltn = function (U) { return this.cmpn(U) === -1 }, d.prototype.lt = function (U) { return this.cmp(U) === -1 }, d.prototype.lten = function (U) { return this.cmpn(U) <= 0 }, d.prototype.lte = function (U) { return this.cmp(U) <= 0 }, d.prototype.eqn = function (U) { return this.cmpn(U) === 0 }, d.prototype.eq = function (U) { return this.cmp(U) === 0 }, d.red = function (U) { return new ie(U) }, d.prototype.toRed = function (U) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), U.convertTo(this)._forceRed(U) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (U) { return this.red = U, this }, d.prototype.forceRed = function (U) { return f(!this.red, "Already a number in reduction context"), this._forceRed(U) }, d.prototype.redAdd = function (U) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, U) }, d.prototype.redIAdd = function (U) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, U) }, d.prototype.redSub = function (U) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, U) }, d.prototype.redISub = function (U) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, U) }, d.prototype.redShl = function (U) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, U) }, d.prototype.redMul = function (U) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, U), this.red.mul(this, U) }, d.prototype.redIMul = function (U) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, U), this.red.imul(this, U) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (U) { return f(this.red && !U.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, U) }; var he = { k256: null, p224: null, p192: null, p25519: null }; function pe(P, U) { this.name = P, this.p = new d(U, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } pe.prototype._tmp = function () { var U = new d(null); return U.words = new Array(Math.ceil(this.n / 13)), U }, pe.prototype.ireduce = function (U) { var K = U, Y; do this.split(K, this.tmp), K = this.imulK(K), K = K.iadd(this.tmp), Y = K.bitLength(); while (Y > this.n); var te = Y < this.n ? -1 : K.ucmp(this.p); return te === 0 ? (K.words[0] = 0, K.length = 1) : te > 0 ? K.isub(this.p) : K.strip !== void 0 ? K.strip() : K._strip(), K }, pe.prototype.split = function (U, K) { U.iushrn(this.n, 0, K) }, pe.prototype.imulK = function (U) { return U.imul(this.k) }; function ve() { pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(ve, pe), ve.prototype.split = function (U, K) { for (var Y = 4194303, te = Math.min(U.length, 9), ee = 0; ee < te; ee++)K.words[ee] = U.words[ee]; if (K.length = te, U.length <= 9) { U.words[0] = 0, U.length = 1; return } var G = U.words[9]; for (K.words[K.length++] = G & Y, ee = 10; ee < U.length; ee++) { var y = U.words[ee] | 0; U.words[ee - 10] = (y & Y) << 4 | G >>> 22, G = y } G >>>= 22, U.words[ee - 10] = G, G === 0 && U.length > 10 ? U.length -= 10 : U.length -= 9 }, ve.prototype.imulK = function (U) { U.words[U.length] = 0, U.words[U.length + 1] = 0, U.length += 2; for (var K = 0, Y = 0; Y < U.length; Y++) { var te = U.words[Y] | 0; K += te * 977, U.words[Y] = K & 67108863, K = te * 64 + (K / 67108864 | 0) } return U.words[U.length - 1] === 0 && (U.length--, U.words[U.length - 1] === 0 && U.length--), U }; function _e() { pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(_e, pe); function Se() { pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(Se, pe); function $e() { pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p($e, pe), $e.prototype.imulK = function (U) { for (var K = 0, Y = 0; Y < U.length; Y++) { var te = (U.words[Y] | 0) * 19 + K, ee = te & 67108863; te >>>= 26, U.words[Y] = ee, K = te } return K !== 0 && (U.words[U.length++] = K), U }, d._prime = function (U) { if (he[U]) return he[U]; var K; if (U === "k256") K = new ve; else if (U === "p224") K = new _e; else if (U === "p192") K = new Se; else if (U === "p25519") K = new $e; else throw new Error("Unknown prime " + U); return he[U] = K, K }; function ie(P) { if (typeof P == "string") { var U = d._prime(P); this.m = U.p, this.prime = U } else f(P.gtn(1), "modulus must be greater than 1"), this.m = P, this.prime = null } ie.prototype._verify1 = function (U) { f(U.negative === 0, "red works only with positives"), f(U.red, "red works only with red numbers") }, ie.prototype._verify2 = function (U, K) { f((U.negative | K.negative) === 0, "red works only with positives"), f(U.red && U.red === K.red, "red works only with red numbers") }, ie.prototype.imod = function (U) { return this.prime ? this.prime.ireduce(U)._forceRed(this) : (B(U, U.umod(this.m)._forceRed(this)), U) }, ie.prototype.neg = function (U) { return U.isZero() ? U.clone() : this.m.sub(U)._forceRed(this) }, ie.prototype.add = function (U, K) { this._verify2(U, K); var Y = U.add(K); return Y.cmp(this.m) >= 0 && Y.isub(this.m), Y._forceRed(this) }, ie.prototype.iadd = function (U, K) { this._verify2(U, K); var Y = U.iadd(K); return Y.cmp(this.m) >= 0 && Y.isub(this.m), Y }, ie.prototype.sub = function (U, K) { this._verify2(U, K); var Y = U.sub(K); return Y.cmpn(0) < 0 && Y.iadd(this.m), Y._forceRed(this) }, ie.prototype.isub = function (U, K) { this._verify2(U, K); var Y = U.isub(K); return Y.cmpn(0) < 0 && Y.iadd(this.m), Y }, ie.prototype.shl = function (U, K) { return this._verify1(U), this.imod(U.ushln(K)) }, ie.prototype.imul = function (U, K) { return this._verify2(U, K), this.imod(U.imul(K)) }, ie.prototype.mul = function (U, K) { return this._verify2(U, K), this.imod(U.mul(K)) }, ie.prototype.isqr = function (U) { return this.imul(U, U.clone()) }, ie.prototype.sqr = function (U) { return this.mul(U, U) }, ie.prototype.sqrt = function (U) { if (U.isZero()) return U.clone(); var K = this.m.andln(3); if (f(K % 2 === 1), K === 3) { var Y = this.m.add(new d(1)).iushrn(2); return this.pow(U, Y) } for (var te = this.m.subn(1), ee = 0; !te.isZero() && te.andln(1) === 0;)ee++, te.iushrn(1); f(!te.isZero()); var G = new d(1).toRed(this), y = G.redNeg(), X = this.m.subn(1).iushrn(1), ce = this.m.bitLength(); for (ce = new d(2 * ce * ce).toRed(this); this.pow(ce, X).cmp(y) !== 0;)ce.redIAdd(y); for (var me = this.pow(ce, te), Ae = this.pow(U, te.addn(1).iushrn(1)), Ie = this.pow(U, te), Be = ee; Ie.cmp(G) !== 0;) { for (var Me = Ie, De = 0; Me.cmp(G) !== 0; De++)Me = Me.redSqr(); f(De < Be); var Ue = this.pow(me, new d(1).iushln(Be - De - 1)); Ae = Ae.redMul(Ue), me = Ue.redSqr(), Ie = Ie.redMul(me), Be = De } return Ae }, ie.prototype.invm = function (U) { var K = U._invmp(this.m); return K.negative !== 0 ? (K.negative = 0, this.imod(K).redNeg()) : this.imod(K) }, ie.prototype.pow = function (U, K) { if (K.isZero()) return new d(1).toRed(this); if (K.cmpn(1) === 0) return U.clone(); var Y = 4, te = new Array(1 << Y); te[0] = new d(1).toRed(this), te[1] = U; for (var ee = 2; ee < te.length; ee++)te[ee] = this.mul(te[ee - 1], U); var G = te[0], y = 0, X = 0, ce = K.bitLength() % 26; for (ce === 0 && (ce = 26), ee = K.length - 1; ee >= 0; ee--) { for (var me = K.words[ee], Ae = ce - 1; Ae >= 0; Ae--) { var Ie = me >> Ae & 1; if (G !== te[0] && (G = this.sqr(G)), Ie === 0 && y === 0) { X = 0; continue } y <<= 1, y |= Ie, X++, !(X !== Y && (ee !== 0 || Ae !== 0)) && (G = this.mul(G, te[y]), X = 0, y = 0) } ce = 26 } return G }, ie.prototype.convertTo = function (U) { var K = U.umod(this.m); return K === U ? K.clone() : K }, ie.prototype.convertFrom = function (U) { var K = U.clone(); return K.red = null, K }, d.mont = function (U) { return new g(U) }; function g(P) { ie.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p(g, ie), g.prototype.convertTo = function (U) { return this.imod(U.ushln(this.shift)) }, g.prototype.convertFrom = function (U) { var K = this.imod(U.mul(this.rinv)); return K.red = null, K }, g.prototype.imul = function (U, K) { if (U.isZero() || K.isZero()) return U.words[0] = 0, U.length = 1, U; var Y = U.imul(K), te = Y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ee = Y.isub(te).iushrn(this.shift), G = ee; return ee.cmp(this.m) >= 0 ? G = ee.isub(this.m) : ee.cmpn(0) < 0 && (G = ee.iadd(this.m)), G._forceRed(this) }, g.prototype.mul = function (U, K) { if (U.isZero() || K.isZero()) return new d(0)._forceRed(this); var Y = U.mul(K), te = Y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ee = Y.isub(te).iushrn(this.shift), G = ee; return ee.cmp(this.m) >= 0 ? G = ee.isub(this.m) : ee.cmpn(0) < 0 && (G = ee.iadd(this.m)), G._forceRed(this) }, g.prototype.invm = function (U) { var K = this.imod(U._invmp(this.m).mul(this.r2)); return K._forceRed(this) } })(o, bn$8) }(bn$9)), bn$9.exports } var browserifyRsa, hasRequiredBrowserifyRsa; function requireBrowserifyRsa() { if (hasRequiredBrowserifyRsa) return browserifyRsa; hasRequiredBrowserifyRsa = 1; var o = requireBn$4(), l = requireBrowser$b(); function u(d) { var m = f(d), v = m.toRed(o.mont(d.modulus)).redPow(new o(d.publicExponent)).fromRed(); return { blinder: v, unblinder: m.invm(d.modulus) } } function f(d) { var m = d.modulus.byteLength(), v; do v = new o(l(m)); while (v.cmp(d.modulus) >= 0 || !v.umod(d.prime1) || !v.umod(d.prime2)); return v } function p(d, m) { var v = u(m), I = m.modulus.byteLength(), F = new o(d).mul(v.blinder).umod(m.modulus), B = F.toRed(o.mont(m.prime1)), W = F.toRed(o.mont(m.prime2)), Z = m.coefficient, Q = m.prime1, re = m.prime2, ne = B.redPow(m.exponent1).fromRed(), oe = W.redPow(m.exponent2).fromRed(), ae = ne.isub(oe).imul(Z).umod(Q).imul(re); return oe.iadd(ae).imul(v.unblinder).umod(m.modulus).toArrayLike(Buffer, "be", I) } return p.getr = f, browserifyRsa = p, browserifyRsa } var elliptic = {}; const version = "6.6.1", require$$0 = { version }; var utils$2 = {}, bn$7 = { exports: {} }, bn$6 = bn$7.exports, hasRequiredBn$3; function requireBn$3() { return hasRequiredBn$3 || (hasRequiredBn$3 = 1, function (o) { (function (l, u) { function f(ie, g) { if (!ie) throw new Error(g || "Assertion failed") } function p(ie, g) { ie.super_ = g; var P = function () { }; P.prototype = g.prototype, ie.prototype = new P, ie.prototype.constructor = ie } function d(ie, g, P) { if (d.isBN(ie)) return ie; this.negative = 0, this.words = null, this.length = 0, this.red = null, ie !== null && ((g === "le" || g === "be") && (P = g, g = 10), this._init(ie || 0, g || 10, P || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (g) { return g instanceof d ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === d.wordSize && Array.isArray(g.words) }, d.max = function (g, P) { return g.cmp(P) > 0 ? g : P }, d.min = function (g, P) { return g.cmp(P) < 0 ? g : P }, d.prototype._init = function (g, P, U) { if (typeof g == "number") return this._initNumber(g, P, U); if (typeof g == "object") return this._initArray(g, P, U); P === "hex" && (P = 16), f(P === (P | 0) && P >= 2 && P <= 36), g = g.toString().replace(/\s+/g, ""); var K = 0; g[0] === "-" && (K++, this.negative = 1), K < g.length && (P === 16 ? this._parseHex(g, K, U) : (this._parseBase(g, P, K), U === "le" && this._initArray(this.toArray(), P, U))) }, d.prototype._initNumber = function (g, P, U) { g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [g & 67108863, g / 67108864 & 67108863], this.length = 2) : (f(g < 9007199254740992), this.words = [g & 67108863, g / 67108864 & 67108863, 1], this.length = 3), U === "le" && this._initArray(this.toArray(), P, U) }, d.prototype._initArray = function (g, P, U) { if (f(typeof g.length == "number"), g.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(g.length / 3), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y, te, ee = 0; if (U === "be") for (K = g.length - 1, Y = 0; K >= 0; K -= 3)te = g[K] | g[K - 1] << 8 | g[K - 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); else if (U === "le") for (K = 0, Y = 0; K < g.length; K += 3)te = g[K] | g[K + 1] << 8 | g[K + 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); return this.strip() }; function v(ie, g) { var P = ie.charCodeAt(g); return P >= 65 && P <= 70 ? P - 55 : P >= 97 && P <= 102 ? P - 87 : P - 48 & 15 } function I(ie, g, P) { var U = v(ie, P); return P - 1 >= g && (U |= v(ie, P - 1) << 4), U } d.prototype._parseHex = function (g, P, U) { this.length = Math.ceil((g.length - P) / 6), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y = 0, te = 0, ee; if (U === "be") for (K = g.length - 1; K >= P; K -= 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8; else { var G = g.length - P; for (K = G % 2 === 0 ? P + 1 : P; K < g.length; K += 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8 } this.strip() }; function F(ie, g, P, U) { for (var K = 0, Y = Math.min(ie.length, P), te = g; te < Y; te++) { var ee = ie.charCodeAt(te) - 48; K *= U, ee >= 49 ? K += ee - 49 + 10 : ee >= 17 ? K += ee - 17 + 10 : K += ee } return K } d.prototype._parseBase = function (g, P, U) { this.words = [0], this.length = 1; for (var K = 0, Y = 1; Y <= 67108863; Y *= P)K++; K--, Y = Y / P | 0; for (var te = g.length - U, ee = te % K, G = Math.min(te, te - ee) + U, y = 0, X = U; X < G; X += K)y = F(g, X, X + K, P), this.imuln(Y), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y); if (ee !== 0) { var ce = 1; for (y = F(g, X, g.length, P), X = 0; X < ee; X++)ce *= P; this.imuln(ce), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y) } this.strip() }, d.prototype.copy = function (g) { g.words = new Array(this.length); for (var P = 0; P < this.length; P++)g.words[P] = this.words[P]; g.length = this.length, g.negative = this.negative, g.red = this.red }, d.prototype.clone = function () { var g = new d(null); return this.copy(g), g }, d.prototype._expand = function (g) { for (; this.length < g;)this.words[this.length++] = 0; return this }, d.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, d.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var B = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], W = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (g, P) { g = g || 10, P = P | 0 || 1; var U; if (g === 16 || g === "hex") { U = ""; for (var K = 0, Y = 0, te = 0; te < this.length; te++) { var ee = this.words[te], G = ((ee << K | Y) & 16777215).toString(16); Y = ee >>> 24 - K & 16777215, Y !== 0 || te !== this.length - 1 ? U = B[6 - G.length] + G + U : U = G + U, K += 2, K >= 26 && (K -= 26, te--) } for (Y !== 0 && (U = Y.toString(16) + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } if (g === (g | 0) && g >= 2 && g <= 36) { var y = W[g], X = Z[g]; U = ""; var ce = this.clone(); for (ce.negative = 0; !ce.isZero();) { var me = ce.modn(X).toString(g); ce = ce.idivn(X), ce.isZero() ? U = me + U : U = B[y - me.length] + me + U } for (this.isZero() && (U = "0" + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var g = this.words[0]; return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g }, d.prototype.toJSON = function () { return this.toString(16) }, d.prototype.toBuffer = function (g, P) { return f(typeof m < "u"), this.toArrayLike(m, g, P) }, d.prototype.toArray = function (g, P) { return this.toArrayLike(Array, g, P) }, d.prototype.toArrayLike = function (g, P, U) { var K = this.byteLength(), Y = U || Math.max(1, K); f(K <= Y, "byte array longer than desired length"), f(Y > 0, "Requested array length <= 0"), this.strip(); var te = P === "le", ee = new g(Y), G, y, X = this.clone(); if (te) { for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[y] = G; for (; y < Y; y++)ee[y] = 0 } else { for (y = 0; y < Y - K; y++)ee[y] = 0; for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[Y - y - 1] = G } return ee }, Math.clz32 ? d.prototype._countBits = function (g) { return 32 - Math.clz32(g) } : d.prototype._countBits = function (g) { var P = g, U = 0; return P >= 4096 && (U += 13, P >>>= 13), P >= 64 && (U += 7, P >>>= 7), P >= 8 && (U += 4, P >>>= 4), P >= 2 && (U += 2, P >>>= 2), U + P }, d.prototype._zeroBits = function (g) { if (g === 0) return 26; var P = g, U = 0; return (P & 8191) === 0 && (U += 13, P >>>= 13), (P & 127) === 0 && (U += 7, P >>>= 7), (P & 15) === 0 && (U += 4, P >>>= 4), (P & 3) === 0 && (U += 2, P >>>= 2), (P & 1) === 0 && U++, U }, d.prototype.bitLength = function () { var g = this.words[this.length - 1], P = this._countBits(g); return (this.length - 1) * 26 + P }; function Q(ie) { for (var g = new Array(ie.bitLength()), P = 0; P < g.length; P++) { var U = P / 26 | 0, K = P % 26; g[P] = (ie.words[U] & 1 << K) >>> K } return g } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var g = 0, P = 0; P < this.length; P++) { var U = this._zeroBits(this.words[P]); if (g += U, U !== 26) break } return g }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (g) { return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (g) { return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (g) { for (; this.length < g.length;)this.words[this.length++] = 0; for (var P = 0; P < g.length; P++)this.words[P] = this.words[P] | g.words[P]; return this.strip() }, d.prototype.ior = function (g) { return f((this.negative | g.negative) === 0), this.iuor(g) }, d.prototype.or = function (g) { return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this) }, d.prototype.uor = function (g) { return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this) }, d.prototype.iuand = function (g) { var P; this.length > g.length ? P = g : P = this; for (var U = 0; U < P.length; U++)this.words[U] = this.words[U] & g.words[U]; return this.length = P.length, this.strip() }, d.prototype.iand = function (g) { return f((this.negative | g.negative) === 0), this.iuand(g) }, d.prototype.and = function (g) { return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this) }, d.prototype.uand = function (g) { return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this) }, d.prototype.iuxor = function (g) { var P, U; this.length > g.length ? (P = this, U = g) : (P = g, U = this); for (var K = 0; K < U.length; K++)this.words[K] = P.words[K] ^ U.words[K]; if (this !== P) for (; K < P.length; K++)this.words[K] = P.words[K]; return this.length = P.length, this.strip() }, d.prototype.ixor = function (g) { return f((this.negative | g.negative) === 0), this.iuxor(g) }, d.prototype.xor = function (g) { return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this) }, d.prototype.uxor = function (g) { return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this) }, d.prototype.inotn = function (g) { f(typeof g == "number" && g >= 0); var P = Math.ceil(g / 26) | 0, U = g % 26; this._expand(P), U > 0 && P--; for (var K = 0; K < P; K++)this.words[K] = ~this.words[K] & 67108863; return U > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - U), this.strip() }, d.prototype.notn = function (g) { return this.clone().inotn(g) }, d.prototype.setn = function (g, P) { f(typeof g == "number" && g >= 0); var U = g / 26 | 0, K = g % 26; return this._expand(U + 1), P ? this.words[U] = this.words[U] | 1 << K : this.words[U] = this.words[U] & ~(1 << K), this.strip() }, d.prototype.iadd = function (g) { var P; if (this.negative !== 0 && g.negative === 0) return this.negative = 0, P = this.isub(g), this.negative ^= 1, this._normSign(); if (this.negative === 0 && g.negative !== 0) return g.negative = 0, P = this.isub(g), g.negative = 1, P._normSign(); var U, K; this.length > g.length ? (U = this, K = g) : (U = g, K = this); for (var Y = 0, te = 0; te < K.length; te++)P = (U.words[te] | 0) + (K.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; for (; Y !== 0 && te < U.length; te++)P = (U.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; if (this.length = U.length, Y !== 0) this.words[this.length] = Y, this.length++; else if (U !== this) for (; te < U.length; te++)this.words[te] = U.words[te]; return this }, d.prototype.add = function (g) { var P; return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, P = this.sub(g), g.negative ^= 1, P) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = g.sub(this), this.negative = 1, P) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this) }, d.prototype.isub = function (g) { if (g.negative !== 0) { g.negative = 0; var P = this.iadd(g); return g.negative = 1, P._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign(); var U = this.cmp(g); if (U === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var K, Y; U > 0 ? (K = this, Y = g) : (K = g, Y = this); for (var te = 0, ee = 0; ee < Y.length; ee++)P = (K.words[ee] | 0) - (Y.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; for (; te !== 0 && ee < K.length; ee++)P = (K.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; if (te === 0 && ee < K.length && K !== this) for (; ee < K.length; ee++)this.words[ee] = K.words[ee]; return this.length = Math.max(this.length, ee), K !== this && (this.negative = 1), this.strip() }, d.prototype.sub = function (g) { return this.clone().isub(g) }; function re(ie, g, P) { P.negative = g.negative ^ ie.negative; var U = ie.length + g.length | 0; P.length = U, U = U - 1 | 0; var K = ie.words[0] | 0, Y = g.words[0] | 0, te = K * Y, ee = te & 67108863, G = te / 67108864 | 0; P.words[0] = ee; for (var y = 1; y < U; y++) { for (var X = G >>> 26, ce = G & 67108863, me = Math.min(y, g.length - 1), Ae = Math.max(0, y - ie.length + 1); Ae <= me; Ae++) { var Ie = y - Ae | 0; K = ie.words[Ie] | 0, Y = g.words[Ae] | 0, te = K * Y + ce, X += te / 67108864 | 0, ce = te & 67108863 } P.words[y] = ce | 0, G = X | 0 } return G !== 0 ? P.words[y] = G | 0 : P.length--, P.strip() } var ne = function (g, P, U) { var K = g.words, Y = P.words, te = U.words, ee = 0, G, y, X, ce = K[0] | 0, me = ce & 8191, Ae = ce >>> 13, Ie = K[1] | 0, Be = Ie & 8191, Me = Ie >>> 13, De = K[2] | 0, Ue = De & 8191, Ke = De >>> 13, Ve = K[3] | 0, ke = Ve & 8191, Je = Ve >>> 13, dt = K[4] | 0, lt = dt & 8191, ht = dt >>> 13, Bt = K[5] | 0, mt = Bt & 8191, et = Bt >>> 13, Gt = K[6] | 0, pt = Gt & 8191, _t = Gt >>> 13, zt = K[7] | 0, bt = zt & 8191, We = zt >>> 13, Ge = K[8] | 0, ze = Ge & 8191, Ze = Ge >>> 13, ut = K[9] | 0, ye = ut & 8191, ge = ut >>> 13, Ee = Y[0] | 0, Oe = Ee & 8191, je = Ee >>> 13, nt = Y[1] | 0, Xe = nt & 8191, it = nt >>> 13, Tt = Y[2] | 0, tt = Tt & 8191, yt = Tt >>> 13, kt = Y[3] | 0, wt = kt & 8191, Mt = kt >>> 13, tr = Y[4] | 0, St = tr & 8191, gt = tr >>> 13, rr = Y[5] | 0, Le = rr & 8191, xe = rr >>> 13, Ce = Y[6] | 0, Ne = Ce & 8191, Ye = Ce >>> 13, Re = Y[7] | 0, Pe = Re & 8191, qe = Re >>> 13, be = Y[8] | 0, Fe = be & 8191, Qe = be >>> 13, st = Y[9] | 0, rt = st & 8191, ct = st >>> 13; U.negative = g.negative ^ P.negative, U.length = 19, G = Math.imul(me, Oe), y = Math.imul(me, je), y = y + Math.imul(Ae, Oe) | 0, X = Math.imul(Ae, je); var Lt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(Be, Oe), y = Math.imul(Be, je), y = y + Math.imul(Me, Oe) | 0, X = Math.imul(Me, je), G = G + Math.imul(me, Xe) | 0, y = y + Math.imul(me, it) | 0, y = y + Math.imul(Ae, Xe) | 0, X = X + Math.imul(Ae, it) | 0; var It = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(Ue, Oe), y = Math.imul(Ue, je), y = y + Math.imul(Ke, Oe) | 0, X = Math.imul(Ke, je), G = G + Math.imul(Be, Xe) | 0, y = y + Math.imul(Be, it) | 0, y = y + Math.imul(Me, Xe) | 0, X = X + Math.imul(Me, it) | 0, G = G + Math.imul(me, tt) | 0, y = y + Math.imul(me, yt) | 0, y = y + Math.imul(Ae, tt) | 0, X = X + Math.imul(Ae, yt) | 0; var lr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, G = Math.imul(ke, Oe), y = Math.imul(ke, je), y = y + Math.imul(Je, Oe) | 0, X = Math.imul(Je, je), G = G + Math.imul(Ue, Xe) | 0, y = y + Math.imul(Ue, it) | 0, y = y + Math.imul(Ke, Xe) | 0, X = X + Math.imul(Ke, it) | 0, G = G + Math.imul(Be, tt) | 0, y = y + Math.imul(Be, yt) | 0, y = y + Math.imul(Me, tt) | 0, X = X + Math.imul(Me, yt) | 0, G = G + Math.imul(me, wt) | 0, y = y + Math.imul(me, Mt) | 0, y = y + Math.imul(Ae, wt) | 0, X = X + Math.imul(Ae, Mt) | 0; var jt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(lt, Oe), y = Math.imul(lt, je), y = y + Math.imul(ht, Oe) | 0, X = Math.imul(ht, je), G = G + Math.imul(ke, Xe) | 0, y = y + Math.imul(ke, it) | 0, y = y + Math.imul(Je, Xe) | 0, X = X + Math.imul(Je, it) | 0, G = G + Math.imul(Ue, tt) | 0, y = y + Math.imul(Ue, yt) | 0, y = y + Math.imul(Ke, tt) | 0, X = X + Math.imul(Ke, yt) | 0, G = G + Math.imul(Be, wt) | 0, y = y + Math.imul(Be, Mt) | 0, y = y + Math.imul(Me, wt) | 0, X = X + Math.imul(Me, Mt) | 0, G = G + Math.imul(me, St) | 0, y = y + Math.imul(me, gt) | 0, y = y + Math.imul(Ae, St) | 0, X = X + Math.imul(Ae, gt) | 0; var Ft = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(mt, Oe), y = Math.imul(mt, je), y = y + Math.imul(et, Oe) | 0, X = Math.imul(et, je), G = G + Math.imul(lt, Xe) | 0, y = y + Math.imul(lt, it) | 0, y = y + Math.imul(ht, Xe) | 0, X = X + Math.imul(ht, it) | 0, G = G + Math.imul(ke, tt) | 0, y = y + Math.imul(ke, yt) | 0, y = y + Math.imul(Je, tt) | 0, X = X + Math.imul(Je, yt) | 0, G = G + Math.imul(Ue, wt) | 0, y = y + Math.imul(Ue, Mt) | 0, y = y + Math.imul(Ke, wt) | 0, X = X + Math.imul(Ke, Mt) | 0, G = G + Math.imul(Be, St) | 0, y = y + Math.imul(Be, gt) | 0, y = y + Math.imul(Me, St) | 0, X = X + Math.imul(Me, gt) | 0, G = G + Math.imul(me, Le) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(Ae, Le) | 0, X = X + Math.imul(Ae, xe) | 0; var er = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, G = Math.imul(pt, Oe), y = Math.imul(pt, je), y = y + Math.imul(_t, Oe) | 0, X = Math.imul(_t, je), G = G + Math.imul(mt, Xe) | 0, y = y + Math.imul(mt, it) | 0, y = y + Math.imul(et, Xe) | 0, X = X + Math.imul(et, it) | 0, G = G + Math.imul(lt, tt) | 0, y = y + Math.imul(lt, yt) | 0, y = y + Math.imul(ht, tt) | 0, X = X + Math.imul(ht, yt) | 0, G = G + Math.imul(ke, wt) | 0, y = y + Math.imul(ke, Mt) | 0, y = y + Math.imul(Je, wt) | 0, X = X + Math.imul(Je, Mt) | 0, G = G + Math.imul(Ue, St) | 0, y = y + Math.imul(Ue, gt) | 0, y = y + Math.imul(Ke, St) | 0, X = X + Math.imul(Ke, gt) | 0, G = G + Math.imul(Be, Le) | 0, y = y + Math.imul(Be, xe) | 0, y = y + Math.imul(Me, Le) | 0, X = X + Math.imul(Me, xe) | 0, G = G + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Ye) | 0, y = y + Math.imul(Ae, Ne) | 0, X = X + Math.imul(Ae, Ye) | 0; var ar = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, G = Math.imul(bt, Oe), y = Math.imul(bt, je), y = y + Math.imul(We, Oe) | 0, X = Math.imul(We, je), G = G + Math.imul(pt, Xe) | 0, y = y + Math.imul(pt, it) | 0, y = y + Math.imul(_t, Xe) | 0, X = X + Math.imul(_t, it) | 0, G = G + Math.imul(mt, tt) | 0, y = y + Math.imul(mt, yt) | 0, y = y + Math.imul(et, tt) | 0, X = X + Math.imul(et, yt) | 0, G = G + Math.imul(lt, wt) | 0, y = y + Math.imul(lt, Mt) | 0, y = y + Math.imul(ht, wt) | 0, X = X + Math.imul(ht, Mt) | 0, G = G + Math.imul(ke, St) | 0, y = y + Math.imul(ke, gt) | 0, y = y + Math.imul(Je, St) | 0, X = X + Math.imul(Je, gt) | 0, G = G + Math.imul(Ue, Le) | 0, y = y + Math.imul(Ue, xe) | 0, y = y + Math.imul(Ke, Le) | 0, X = X + Math.imul(Ke, xe) | 0, G = G + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, Ye) | 0, y = y + Math.imul(Me, Ne) | 0, X = X + Math.imul(Me, Ye) | 0, G = G + Math.imul(me, Pe) | 0, y = y + Math.imul(me, qe) | 0, y = y + Math.imul(Ae, Pe) | 0, X = X + Math.imul(Ae, qe) | 0; var nr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, G = Math.imul(ze, Oe), y = Math.imul(ze, je), y = y + Math.imul(Ze, Oe) | 0, X = Math.imul(Ze, je), G = G + Math.imul(bt, Xe) | 0, y = y + Math.imul(bt, it) | 0, y = y + Math.imul(We, Xe) | 0, X = X + Math.imul(We, it) | 0, G = G + Math.imul(pt, tt) | 0, y = y + Math.imul(pt, yt) | 0, y = y + Math.imul(_t, tt) | 0, X = X + Math.imul(_t, yt) | 0, G = G + Math.imul(mt, wt) | 0, y = y + Math.imul(mt, Mt) | 0, y = y + Math.imul(et, wt) | 0, X = X + Math.imul(et, Mt) | 0, G = G + Math.imul(lt, St) | 0, y = y + Math.imul(lt, gt) | 0, y = y + Math.imul(ht, St) | 0, X = X + Math.imul(ht, gt) | 0, G = G + Math.imul(ke, Le) | 0, y = y + Math.imul(ke, xe) | 0, y = y + Math.imul(Je, Le) | 0, X = X + Math.imul(Je, xe) | 0, G = G + Math.imul(Ue, Ne) | 0, y = y + Math.imul(Ue, Ye) | 0, y = y + Math.imul(Ke, Ne) | 0, X = X + Math.imul(Ke, Ye) | 0, G = G + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, qe) | 0, y = y + Math.imul(Me, Pe) | 0, X = X + Math.imul(Me, qe) | 0, G = G + Math.imul(me, Fe) | 0, y = y + Math.imul(me, Qe) | 0, y = y + Math.imul(Ae, Fe) | 0, X = X + Math.imul(Ae, Qe) | 0; var ir = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, G = Math.imul(ye, Oe), y = Math.imul(ye, je), y = y + Math.imul(ge, Oe) | 0, X = Math.imul(ge, je), G = G + Math.imul(ze, Xe) | 0, y = y + Math.imul(ze, it) | 0, y = y + Math.imul(Ze, Xe) | 0, X = X + Math.imul(Ze, it) | 0, G = G + Math.imul(bt, tt) | 0, y = y + Math.imul(bt, yt) | 0, y = y + Math.imul(We, tt) | 0, X = X + Math.imul(We, yt) | 0, G = G + Math.imul(pt, wt) | 0, y = y + Math.imul(pt, Mt) | 0, y = y + Math.imul(_t, wt) | 0, X = X + Math.imul(_t, Mt) | 0, G = G + Math.imul(mt, St) | 0, y = y + Math.imul(mt, gt) | 0, y = y + Math.imul(et, St) | 0, X = X + Math.imul(et, gt) | 0, G = G + Math.imul(lt, Le) | 0, y = y + Math.imul(lt, xe) | 0, y = y + Math.imul(ht, Le) | 0, X = X + Math.imul(ht, xe) | 0, G = G + Math.imul(ke, Ne) | 0, y = y + Math.imul(ke, Ye) | 0, y = y + Math.imul(Je, Ne) | 0, X = X + Math.imul(Je, Ye) | 0, G = G + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, qe) | 0, y = y + Math.imul(Ke, Pe) | 0, X = X + Math.imul(Ke, qe) | 0, G = G + Math.imul(Be, Fe) | 0, y = y + Math.imul(Be, Qe) | 0, y = y + Math.imul(Me, Fe) | 0, X = X + Math.imul(Me, Qe) | 0, G = G + Math.imul(me, rt) | 0, y = y + Math.imul(me, ct) | 0, y = y + Math.imul(Ae, rt) | 0, X = X + Math.imul(Ae, ct) | 0; var Ht = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(ye, Xe), y = Math.imul(ye, it), y = y + Math.imul(ge, Xe) | 0, X = Math.imul(ge, it), G = G + Math.imul(ze, tt) | 0, y = y + Math.imul(ze, yt) | 0, y = y + Math.imul(Ze, tt) | 0, X = X + Math.imul(Ze, yt) | 0, G = G + Math.imul(bt, wt) | 0, y = y + Math.imul(bt, Mt) | 0, y = y + Math.imul(We, wt) | 0, X = X + Math.imul(We, Mt) | 0, G = G + Math.imul(pt, St) | 0, y = y + Math.imul(pt, gt) | 0, y = y + Math.imul(_t, St) | 0, X = X + Math.imul(_t, gt) | 0, G = G + Math.imul(mt, Le) | 0, y = y + Math.imul(mt, xe) | 0, y = y + Math.imul(et, Le) | 0, X = X + Math.imul(et, xe) | 0, G = G + Math.imul(lt, Ne) | 0, y = y + Math.imul(lt, Ye) | 0, y = y + Math.imul(ht, Ne) | 0, X = X + Math.imul(ht, Ye) | 0, G = G + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, qe) | 0, y = y + Math.imul(Je, Pe) | 0, X = X + Math.imul(Je, qe) | 0, G = G + Math.imul(Ue, Fe) | 0, y = y + Math.imul(Ue, Qe) | 0, y = y + Math.imul(Ke, Fe) | 0, X = X + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, ct) | 0, y = y + Math.imul(Me, rt) | 0, X = X + Math.imul(Me, ct) | 0; var sr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, G = Math.imul(ye, tt), y = Math.imul(ye, yt), y = y + Math.imul(ge, tt) | 0, X = Math.imul(ge, yt), G = G + Math.imul(ze, wt) | 0, y = y + Math.imul(ze, Mt) | 0, y = y + Math.imul(Ze, wt) | 0, X = X + Math.imul(Ze, Mt) | 0, G = G + Math.imul(bt, St) | 0, y = y + Math.imul(bt, gt) | 0, y = y + Math.imul(We, St) | 0, X = X + Math.imul(We, gt) | 0, G = G + Math.imul(pt, Le) | 0, y = y + Math.imul(pt, xe) | 0, y = y + Math.imul(_t, Le) | 0, X = X + Math.imul(_t, xe) | 0, G = G + Math.imul(mt, Ne) | 0, y = y + Math.imul(mt, Ye) | 0, y = y + Math.imul(et, Ne) | 0, X = X + Math.imul(et, Ye) | 0, G = G + Math.imul(lt, Pe) | 0, y = y + Math.imul(lt, qe) | 0, y = y + Math.imul(ht, Pe) | 0, X = X + Math.imul(ht, qe) | 0, G = G + Math.imul(ke, Fe) | 0, y = y + Math.imul(ke, Qe) | 0, y = y + Math.imul(Je, Fe) | 0, X = X + Math.imul(Je, Qe) | 0, G = G + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ke, rt) | 0, X = X + Math.imul(Ke, ct) | 0; var Kt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, G = Math.imul(ye, wt), y = Math.imul(ye, Mt), y = y + Math.imul(ge, wt) | 0, X = Math.imul(ge, Mt), G = G + Math.imul(ze, St) | 0, y = y + Math.imul(ze, gt) | 0, y = y + Math.imul(Ze, St) | 0, X = X + Math.imul(Ze, gt) | 0, G = G + Math.imul(bt, Le) | 0, y = y + Math.imul(bt, xe) | 0, y = y + Math.imul(We, Le) | 0, X = X + Math.imul(We, xe) | 0, G = G + Math.imul(pt, Ne) | 0, y = y + Math.imul(pt, Ye) | 0, y = y + Math.imul(_t, Ne) | 0, X = X + Math.imul(_t, Ye) | 0, G = G + Math.imul(mt, Pe) | 0, y = y + Math.imul(mt, qe) | 0, y = y + Math.imul(et, Pe) | 0, X = X + Math.imul(et, qe) | 0, G = G + Math.imul(lt, Fe) | 0, y = y + Math.imul(lt, Qe) | 0, y = y + Math.imul(ht, Fe) | 0, X = X + Math.imul(ht, Qe) | 0, G = G + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, ct) | 0, y = y + Math.imul(Je, rt) | 0, X = X + Math.imul(Je, ct) | 0; var Qt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, G = Math.imul(ye, St), y = Math.imul(ye, gt), y = y + Math.imul(ge, St) | 0, X = Math.imul(ge, gt), G = G + Math.imul(ze, Le) | 0, y = y + Math.imul(ze, xe) | 0, y = y + Math.imul(Ze, Le) | 0, X = X + Math.imul(Ze, xe) | 0, G = G + Math.imul(bt, Ne) | 0, y = y + Math.imul(bt, Ye) | 0, y = y + Math.imul(We, Ne) | 0, X = X + Math.imul(We, Ye) | 0, G = G + Math.imul(pt, Pe) | 0, y = y + Math.imul(pt, qe) | 0, y = y + Math.imul(_t, Pe) | 0, X = X + Math.imul(_t, qe) | 0, G = G + Math.imul(mt, Fe) | 0, y = y + Math.imul(mt, Qe) | 0, y = y + Math.imul(et, Fe) | 0, X = X + Math.imul(et, Qe) | 0, G = G + Math.imul(lt, rt) | 0, y = y + Math.imul(lt, ct) | 0, y = y + Math.imul(ht, rt) | 0, X = X + Math.imul(ht, ct) | 0; var $t = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, G = Math.imul(ye, Le), y = Math.imul(ye, xe), y = y + Math.imul(ge, Le) | 0, X = Math.imul(ge, xe), G = G + Math.imul(ze, Ne) | 0, y = y + Math.imul(ze, Ye) | 0, y = y + Math.imul(Ze, Ne) | 0, X = X + Math.imul(Ze, Ye) | 0, G = G + Math.imul(bt, Pe) | 0, y = y + Math.imul(bt, qe) | 0, y = y + Math.imul(We, Pe) | 0, X = X + Math.imul(We, qe) | 0, G = G + Math.imul(pt, Fe) | 0, y = y + Math.imul(pt, Qe) | 0, y = y + Math.imul(_t, Fe) | 0, X = X + Math.imul(_t, Qe) | 0, G = G + Math.imul(mt, rt) | 0, y = y + Math.imul(mt, ct) | 0, y = y + Math.imul(et, rt) | 0, X = X + Math.imul(et, ct) | 0; var Yt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, G = Math.imul(ye, Ne), y = Math.imul(ye, Ye), y = y + Math.imul(ge, Ne) | 0, X = Math.imul(ge, Ye), G = G + Math.imul(ze, Pe) | 0, y = y + Math.imul(ze, qe) | 0, y = y + Math.imul(Ze, Pe) | 0, X = X + Math.imul(Ze, qe) | 0, G = G + Math.imul(bt, Fe) | 0, y = y + Math.imul(bt, Qe) | 0, y = y + Math.imul(We, Fe) | 0, X = X + Math.imul(We, Qe) | 0, G = G + Math.imul(pt, rt) | 0, y = y + Math.imul(pt, ct) | 0, y = y + Math.imul(_t, rt) | 0, X = X + Math.imul(_t, ct) | 0; var Xt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, G = Math.imul(ye, Pe), y = Math.imul(ye, qe), y = y + Math.imul(ge, Pe) | 0, X = Math.imul(ge, qe), G = G + Math.imul(ze, Fe) | 0, y = y + Math.imul(ze, Qe) | 0, y = y + Math.imul(Ze, Fe) | 0, X = X + Math.imul(Ze, Qe) | 0, G = G + Math.imul(bt, rt) | 0, y = y + Math.imul(bt, ct) | 0, y = y + Math.imul(We, rt) | 0, X = X + Math.imul(We, ct) | 0; var Nt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ye, Fe), y = Math.imul(ye, Qe), y = y + Math.imul(ge, Fe) | 0, X = Math.imul(ge, Qe), G = G + Math.imul(ze, rt) | 0, y = y + Math.imul(ze, ct) | 0, y = y + Math.imul(Ze, rt) | 0, X = X + Math.imul(Ze, ct) | 0; var Et = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, G = Math.imul(ye, rt), y = Math.imul(ye, ct), y = y + Math.imul(ge, rt) | 0, X = Math.imul(ge, ct); var At = (ee + G | 0) + ((y & 8191) << 13) | 0; return ee = (X + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, te[0] = Lt, te[1] = It, te[2] = lr, te[3] = jt, te[4] = Ft, te[5] = er, te[6] = ar, te[7] = nr, te[8] = ir, te[9] = Ht, te[10] = sr, te[11] = Kt, te[12] = Qt, te[13] = $t, te[14] = Yt, te[15] = Xt, te[16] = Nt, te[17] = Et, te[18] = At, ee !== 0 && (te[19] = ee, U.length++), U }; Math.imul || (ne = re); function oe(ie, g, P) { P.negative = g.negative ^ ie.negative, P.length = ie.length + g.length; for (var U = 0, K = 0, Y = 0; Y < P.length - 1; Y++) { var te = K; K = 0; for (var ee = U & 67108863, G = Math.min(Y, g.length - 1), y = Math.max(0, Y - ie.length + 1); y <= G; y++) { var X = Y - y, ce = ie.words[X] | 0, me = g.words[y] | 0, Ae = ce * me, Ie = Ae & 67108863; te = te + (Ae / 67108864 | 0) | 0, Ie = Ie + ee | 0, ee = Ie & 67108863, te = te + (Ie >>> 26) | 0, K += te >>> 26, te &= 67108863 } P.words[Y] = ee, U = te, te = K } return U !== 0 ? P.words[Y] = U : P.length--, P.strip() } function ae(ie, g, P) { var U = new se; return U.mulp(ie, g, P) } d.prototype.mulTo = function (g, P) { var U, K = this.length + g.length; return this.length === 10 && g.length === 10 ? U = ne(this, g, P) : K < 63 ? U = re(this, g, P) : K < 1024 ? U = oe(this, g, P) : U = ae(this, g, P), U }; function se(ie, g) { this.x = ie, this.y = g } se.prototype.makeRBT = function (g) { for (var P = new Array(g), U = d.prototype._countBits(g) - 1, K = 0; K < g; K++)P[K] = this.revBin(K, U, g); return P }, se.prototype.revBin = function (g, P, U) { if (g === 0 || g === U - 1) return g; for (var K = 0, Y = 0; Y < P; Y++)K |= (g & 1) << P - Y - 1, g >>= 1; return K }, se.prototype.permute = function (g, P, U, K, Y, te) { for (var ee = 0; ee < te; ee++)K[ee] = P[g[ee]], Y[ee] = U[g[ee]] }, se.prototype.transform = function (g, P, U, K, Y, te) { this.permute(te, g, P, U, K, Y); for (var ee = 1; ee < Y; ee <<= 1)for (var G = ee << 1, y = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), ce = 0; ce < Y; ce += G)for (var me = y, Ae = X, Ie = 0; Ie < ee; Ie++) { var Be = U[ce + Ie], Me = K[ce + Ie], De = U[ce + Ie + ee], Ue = K[ce + Ie + ee], Ke = me * De - Ae * Ue; Ue = me * Ue + Ae * De, De = Ke, U[ce + Ie] = Be + De, K[ce + Ie] = Me + Ue, U[ce + Ie + ee] = Be - De, K[ce + Ie + ee] = Me - Ue, Ie !== G && (Ke = y * me - X * Ae, Ae = y * Ae + X * me, me = Ke) } }, se.prototype.guessLen13b = function (g, P) { var U = Math.max(P, g) | 1, K = U & 1, Y = 0; for (U = U / 2 | 0; U; U = U >>> 1)Y++; return 1 << Y + 1 + K }, se.prototype.conjugate = function (g, P, U) { if (!(U <= 1)) for (var K = 0; K < U / 2; K++) { var Y = g[K]; g[K] = g[U - K - 1], g[U - K - 1] = Y, Y = P[K], P[K] = -P[U - K - 1], P[U - K - 1] = -Y } }, se.prototype.normalize13b = function (g, P) { for (var U = 0, K = 0; K < P / 2; K++) { var Y = Math.round(g[2 * K + 1] / P) * 8192 + Math.round(g[2 * K] / P) + U; g[K] = Y & 67108863, Y < 67108864 ? U = 0 : U = Y / 67108864 | 0 } return g }, se.prototype.convert13b = function (g, P, U, K) { for (var Y = 0, te = 0; te < P; te++)Y = Y + (g[te] | 0), U[2 * te] = Y & 8191, Y = Y >>> 13, U[2 * te + 1] = Y & 8191, Y = Y >>> 13; for (te = 2 * P; te < K; ++te)U[te] = 0; f(Y === 0), f((Y & -8192) === 0) }, se.prototype.stub = function (g) { for (var P = new Array(g), U = 0; U < g; U++)P[U] = 0; return P }, se.prototype.mulp = function (g, P, U) { var K = 2 * this.guessLen13b(g.length, P.length), Y = this.makeRBT(K), te = this.stub(K), ee = new Array(K), G = new Array(K), y = new Array(K), X = new Array(K), ce = new Array(K), me = new Array(K), Ae = U.words; Ae.length = K, this.convert13b(g.words, g.length, ee, K), this.convert13b(P.words, P.length, X, K), this.transform(ee, te, G, y, K, Y), this.transform(X, te, ce, me, K, Y); for (var Ie = 0; Ie < K; Ie++) { var Be = G[Ie] * ce[Ie] - y[Ie] * me[Ie]; y[Ie] = G[Ie] * me[Ie] + y[Ie] * ce[Ie], G[Ie] = Be } return this.conjugate(G, y, K), this.transform(G, y, Ae, te, K, Y), this.conjugate(Ae, te, K), this.normalize13b(Ae, K), U.negative = g.negative ^ P.negative, U.length = g.length + P.length, U.strip() }, d.prototype.mul = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), this.mulTo(g, P) }, d.prototype.mulf = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), ae(this, g, P) }, d.prototype.imul = function (g) { return this.clone().mulTo(g, this) }, d.prototype.imuln = function (g) { f(typeof g == "number"), f(g < 67108864); for (var P = 0, U = 0; U < this.length; U++) { var K = (this.words[U] | 0) * g, Y = (K & 67108863) + (P & 67108863); P >>= 26, P += K / 67108864 | 0, P += Y >>> 26, this.words[U] = Y & 67108863 } return P !== 0 && (this.words[U] = P, this.length++), this }, d.prototype.muln = function (g) { return this.clone().imuln(g) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (g) { var P = Q(g); if (P.length === 0) return new d(1); for (var U = this, K = 0; K < P.length && P[K] === 0; K++, U = U.sqr()); if (++K < P.length) for (var Y = U.sqr(); K < P.length; K++, Y = Y.sqr())P[K] !== 0 && (U = U.mul(Y)); return U }, d.prototype.iushln = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 67108863 >>> 26 - P << 26 - P, Y; if (P !== 0) { var te = 0; for (Y = 0; Y < this.length; Y++) { var ee = this.words[Y] & K, G = (this.words[Y] | 0) - ee << P; this.words[Y] = G | te, te = ee >>> 26 - P } te && (this.words[Y] = te, this.length++) } if (U !== 0) { for (Y = this.length - 1; Y >= 0; Y--)this.words[Y + U] = this.words[Y]; for (Y = 0; Y < U; Y++)this.words[Y] = 0; this.length += U } return this.strip() }, d.prototype.ishln = function (g) { return f(this.negative === 0), this.iushln(g) }, d.prototype.iushrn = function (g, P, U) { f(typeof g == "number" && g >= 0); var K; P ? K = (P - P % 26) / 26 : K = 0; var Y = g % 26, te = Math.min((g - Y) / 26, this.length), ee = 67108863 ^ 67108863 >>> Y << Y, G = U; if (K -= te, K = Math.max(0, K), G) { for (var y = 0; y < te; y++)G.words[y] = this.words[y]; G.length = te } if (te !== 0) if (this.length > te) for (this.length -= te, y = 0; y < this.length; y++)this.words[y] = this.words[y + te]; else this.words[0] = 0, this.length = 1; var X = 0; for (y = this.length - 1; y >= 0 && (X !== 0 || y >= K); y--) { var ce = this.words[y] | 0; this.words[y] = X << 26 - Y | ce >>> Y, X = ce & ee } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, d.prototype.ishrn = function (g, P, U) { return f(this.negative === 0), this.iushrn(g, P, U) }, d.prototype.shln = function (g) { return this.clone().ishln(g) }, d.prototype.ushln = function (g) { return this.clone().iushln(g) }, d.prototype.shrn = function (g) { return this.clone().ishrn(g) }, d.prototype.ushrn = function (g) { return this.clone().iushrn(g) }, d.prototype.testn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return !1; var Y = this.words[U]; return !!(Y & K) }, d.prototype.imaskn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U) return this; if (P !== 0 && U++, this.length = Math.min(U, this.length), P !== 0) { var K = 67108863 ^ 67108863 >>> P << P; this.words[this.length - 1] &= K } return this.strip() }, d.prototype.maskn = function (g) { return this.clone().imaskn(g) }, d.prototype.iaddn = function (g) { return f(typeof g == "number"), f(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g) }, d.prototype._iaddn = function (g) { this.words[0] += g; for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++; return this.length = Math.max(this.length, P + 1), this }, d.prototype.isubn = function (g) { if (f(typeof g == "number"), f(g < 67108864), g < 0) return this.iaddn(-g); if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this; if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var P = 0; P < this.length && this.words[P] < 0; P++)this.words[P] += 67108864, this.words[P + 1] -= 1; return this.strip() }, d.prototype.addn = function (g) { return this.clone().iaddn(g) }, d.prototype.subn = function (g) { return this.clone().isubn(g) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (g, P, U) { var K = g.length + U, Y; this._expand(K); var te, ee = 0; for (Y = 0; Y < g.length; Y++) { te = (this.words[Y + U] | 0) + ee; var G = (g.words[Y] | 0) * P; te -= G & 67108863, ee = (te >> 26) - (G / 67108864 | 0), this.words[Y + U] = te & 67108863 } for (; Y < this.length - U; Y++)te = (this.words[Y + U] | 0) + ee, ee = te >> 26, this.words[Y + U] = te & 67108863; if (ee === 0) return this.strip(); for (f(ee === -1), ee = 0, Y = 0; Y < this.length; Y++)te = -(this.words[Y] | 0) + ee, ee = te >> 26, this.words[Y] = te & 67108863; return this.negative = 1, this.strip() }, d.prototype._wordDiv = function (g, P) { var U = this.length - g.length, K = this.clone(), Y = g, te = Y.words[Y.length - 1] | 0, ee = this._countBits(te); U = 26 - ee, U !== 0 && (Y = Y.ushln(U), K.iushln(U), te = Y.words[Y.length - 1] | 0); var G = K.length - Y.length, y; if (P !== "mod") { y = new d(null), y.length = G + 1, y.words = new Array(y.length); for (var X = 0; X < y.length; X++)y.words[X] = 0 } var ce = K.clone()._ishlnsubmul(Y, 1, G); ce.negative === 0 && (K = ce, y && (y.words[G] = 1)); for (var me = G - 1; me >= 0; me--) { var Ae = (K.words[Y.length + me] | 0) * 67108864 + (K.words[Y.length + me - 1] | 0); for (Ae = Math.min(Ae / te | 0, 67108863), K._ishlnsubmul(Y, Ae, me); K.negative !== 0;)Ae--, K.negative = 0, K._ishlnsubmul(Y, 1, me), K.isZero() || (K.negative ^= 1); y && (y.words[me] = Ae) } return y && y.strip(), K.strip(), P !== "div" && U !== 0 && K.iushrn(U), { div: y || null, mod: K } }, d.prototype.divmod = function (g, P, U) { if (f(!g.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var K, Y, te; return this.negative !== 0 && g.negative === 0 ? (te = this.neg().divmod(g, P), P !== "mod" && (K = te.div.neg()), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.iadd(g)), { div: K, mod: Y }) : this.negative === 0 && g.negative !== 0 ? (te = this.divmod(g.neg(), P), P !== "mod" && (K = te.div.neg()), { div: K, mod: te.mod }) : (this.negative & g.negative) !== 0 ? (te = this.neg().divmod(g.neg(), P), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.isub(g)), { div: te.div, mod: Y }) : g.length > this.length || this.cmp(g) < 0 ? { div: new d(0), mod: this } : g.length === 1 ? P === "div" ? { div: this.divn(g.words[0]), mod: null } : P === "mod" ? { div: null, mod: new d(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new d(this.modn(g.words[0])) } : this._wordDiv(g, P) }, d.prototype.div = function (g) { return this.divmod(g, "div", !1).div }, d.prototype.mod = function (g) { return this.divmod(g, "mod", !1).mod }, d.prototype.umod = function (g) { return this.divmod(g, "mod", !0).mod }, d.prototype.divRound = function (g) { var P = this.divmod(g); if (P.mod.isZero()) return P.div; var U = P.div.negative !== 0 ? P.mod.isub(g) : P.mod, K = g.ushrn(1), Y = g.andln(1), te = U.cmp(K); return te < 0 || Y === 1 && te === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1) }, d.prototype.modn = function (g) { f(g <= 67108863); for (var P = (1 << 26) % g, U = 0, K = this.length - 1; K >= 0; K--)U = (P * U + (this.words[K] | 0)) % g; return U }, d.prototype.idivn = function (g) { f(g <= 67108863); for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = (this.words[U] | 0) + P * 67108864; this.words[U] = K / g | 0, P = K % g } return this.strip() }, d.prototype.divn = function (g) { return this.clone().idivn(g) }, d.prototype.egcd = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = new d(0), ee = new d(1), G = 0; P.isEven() && U.isEven();)P.iushrn(1), U.iushrn(1), ++G; for (var y = U.clone(), X = P.clone(); !P.isZero();) { for (var ce = 0, me = 1; (P.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (P.iushrn(ce); ce-- > 0;)(K.isOdd() || Y.isOdd()) && (K.iadd(y), Y.isub(X)), K.iushrn(1), Y.iushrn(1); for (var Ae = 0, Ie = 1; (U.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (U.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(y), ee.isub(X)), te.iushrn(1), ee.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(te), Y.isub(ee)) : (U.isub(P), te.isub(K), ee.isub(Y)) } return { a: te, b: ee, gcd: U.iushln(G) } }, d.prototype._invmp = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = U.clone(); P.cmpn(1) > 0 && U.cmpn(1) > 0;) { for (var ee = 0, G = 1; (P.words[0] & G) === 0 && ee < 26; ++ee, G <<= 1); if (ee > 0) for (P.iushrn(ee); ee-- > 0;)K.isOdd() && K.iadd(te), K.iushrn(1); for (var y = 0, X = 1; (U.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (U.iushrn(y); y-- > 0;)Y.isOdd() && Y.iadd(te), Y.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(Y)) : (U.isub(P), Y.isub(K)) } var ce; return P.cmpn(1) === 0 ? ce = K : ce = Y, ce.cmpn(0) < 0 && ce.iadd(g), ce }, d.prototype.gcd = function (g) { if (this.isZero()) return g.abs(); if (g.isZero()) return this.abs(); var P = this.clone(), U = g.clone(); P.negative = 0, U.negative = 0; for (var K = 0; P.isEven() && U.isEven(); K++)P.iushrn(1), U.iushrn(1); do { for (; P.isEven();)P.iushrn(1); for (; U.isEven();)U.iushrn(1); var Y = P.cmp(U); if (Y < 0) { var te = P; P = U, U = te } else if (Y === 0 || U.cmpn(1) === 0) break; P.isub(U) } while (!0); return U.iushln(K) }, d.prototype.invm = function (g) { return this.egcd(g).a.umod(g) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (g) { return this.words[0] & g }, d.prototype.bincn = function (g) { f(typeof g == "number"); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return this._expand(U + 1), this.words[U] |= K, this; for (var Y = K, te = U; Y !== 0 && te < this.length; te++) { var ee = this.words[te] | 0; ee += Y, Y = ee >>> 26, ee &= 67108863, this.words[te] = ee } return Y !== 0 && (this.words[te] = Y, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (g) { var P = g < 0; if (this.negative !== 0 && !P) return -1; if (this.negative === 0 && P) return 1; this.strip(); var U; if (this.length > 1) U = 1; else { P && (g = -g), f(g <= 67108863, "Number is too big"); var K = this.words[0] | 0; U = K === g ? 0 : K < g ? -1 : 1 } return this.negative !== 0 ? -U | 0 : U }, d.prototype.cmp = function (g) { if (this.negative !== 0 && g.negative === 0) return -1; if (this.negative === 0 && g.negative !== 0) return 1; var P = this.ucmp(g); return this.negative !== 0 ? -P | 0 : P }, d.prototype.ucmp = function (g) { if (this.length > g.length) return 1; if (this.length < g.length) return -1; for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = this.words[U] | 0, Y = g.words[U] | 0; if (K !== Y) { K < Y ? P = -1 : K > Y && (P = 1); break } } return P }, d.prototype.gtn = function (g) { return this.cmpn(g) === 1 }, d.prototype.gt = function (g) { return this.cmp(g) === 1 }, d.prototype.gten = function (g) { return this.cmpn(g) >= 0 }, d.prototype.gte = function (g) { return this.cmp(g) >= 0 }, d.prototype.ltn = function (g) { return this.cmpn(g) === -1 }, d.prototype.lt = function (g) { return this.cmp(g) === -1 }, d.prototype.lten = function (g) { return this.cmpn(g) <= 0 }, d.prototype.lte = function (g) { return this.cmp(g) <= 0 }, d.prototype.eqn = function (g) { return this.cmpn(g) === 0 }, d.prototype.eq = function (g) { return this.cmp(g) === 0 }, d.red = function (g) { return new Se(g) }, d.prototype.toRed = function (g) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (g) { return this.red = g, this }, d.prototype.forceRed = function (g) { return f(!this.red, "Already a number in reduction context"), this._forceRed(g) }, d.prototype.redAdd = function (g) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, g) }, d.prototype.redIAdd = function (g) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g) }, d.prototype.redSub = function (g) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, g) }, d.prototype.redISub = function (g) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, g) }, d.prototype.redShl = function (g) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, g) }, d.prototype.redMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g) }, d.prototype.redIMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (g) { return f(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g) }; var le = { k256: null, p224: null, p192: null, p25519: null }; function ue(ie, g) { this.name = ie, this.p = new d(g, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } ue.prototype._tmp = function () { var g = new d(null); return g.words = new Array(Math.ceil(this.n / 13)), g }, ue.prototype.ireduce = function (g) { var P = g, U; do this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), U = P.bitLength(); while (U > this.n); var K = U < this.n ? -1 : P.ucmp(this.p); return K === 0 ? (P.words[0] = 0, P.length = 1) : K > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P }, ue.prototype.split = function (g, P) { g.iushrn(this.n, 0, P) }, ue.prototype.imulK = function (g) { return g.imul(this.k) }; function he() { ue.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(he, ue), he.prototype.split = function (g, P) { for (var U = 4194303, K = Math.min(g.length, 9), Y = 0; Y < K; Y++)P.words[Y] = g.words[Y]; if (P.length = K, g.length <= 9) { g.words[0] = 0, g.length = 1; return } var te = g.words[9]; for (P.words[P.length++] = te & U, Y = 10; Y < g.length; Y++) { var ee = g.words[Y] | 0; g.words[Y - 10] = (ee & U) << 4 | te >>> 22, te = ee } te >>>= 22, g.words[Y - 10] = te, te === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9 }, he.prototype.imulK = function (g) { g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2; for (var P = 0, U = 0; U < g.length; U++) { var K = g.words[U] | 0; P += K * 977, g.words[U] = P & 67108863, P = K * 64 + (P / 67108864 | 0) } return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g }; function pe() { ue.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(pe, ue); function ve() { ue.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(ve, ue); function _e() { ue.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p(_e, ue), _e.prototype.imulK = function (g) { for (var P = 0, U = 0; U < g.length; U++) { var K = (g.words[U] | 0) * 19 + P, Y = K & 67108863; K >>>= 26, g.words[U] = Y, P = K } return P !== 0 && (g.words[g.length++] = P), g }, d._prime = function (g) { if (le[g]) return le[g]; var P; if (g === "k256") P = new he; else if (g === "p224") P = new pe; else if (g === "p192") P = new ve; else if (g === "p25519") P = new _e; else throw new Error("Unknown prime " + g); return le[g] = P, P }; function Se(ie) { if (typeof ie == "string") { var g = d._prime(ie); this.m = g.p, this.prime = g } else f(ie.gtn(1), "modulus must be greater than 1"), this.m = ie, this.prime = null } Se.prototype._verify1 = function (g) { f(g.negative === 0, "red works only with positives"), f(g.red, "red works only with red numbers") }, Se.prototype._verify2 = function (g, P) { f((g.negative | P.negative) === 0, "red works only with positives"), f(g.red && g.red === P.red, "red works only with red numbers") }, Se.prototype.imod = function (g) { return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this) }, Se.prototype.neg = function (g) { return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this) }, Se.prototype.add = function (g, P) { this._verify2(g, P); var U = g.add(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this) }, Se.prototype.iadd = function (g, P) { this._verify2(g, P); var U = g.iadd(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U }, Se.prototype.sub = function (g, P) { this._verify2(g, P); var U = g.sub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this) }, Se.prototype.isub = function (g, P) { this._verify2(g, P); var U = g.isub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U }, Se.prototype.shl = function (g, P) { return this._verify1(g), this.imod(g.ushln(P)) }, Se.prototype.imul = function (g, P) { return this._verify2(g, P), this.imod(g.imul(P)) }, Se.prototype.mul = function (g, P) { return this._verify2(g, P), this.imod(g.mul(P)) }, Se.prototype.isqr = function (g) { return this.imul(g, g.clone()) }, Se.prototype.sqr = function (g) { return this.mul(g, g) }, Se.prototype.sqrt = function (g) { if (g.isZero()) return g.clone(); var P = this.m.andln(3); if (f(P % 2 === 1), P === 3) { var U = this.m.add(new d(1)).iushrn(2); return this.pow(g, U) } for (var K = this.m.subn(1), Y = 0; !K.isZero() && K.andln(1) === 0;)Y++, K.iushrn(1); f(!K.isZero()); var te = new d(1).toRed(this), ee = te.redNeg(), G = this.m.subn(1).iushrn(1), y = this.m.bitLength(); for (y = new d(2 * y * y).toRed(this); this.pow(y, G).cmp(ee) !== 0;)y.redIAdd(ee); for (var X = this.pow(y, K), ce = this.pow(g, K.addn(1).iushrn(1)), me = this.pow(g, K), Ae = Y; me.cmp(te) !== 0;) { for (var Ie = me, Be = 0; Ie.cmp(te) !== 0; Be++)Ie = Ie.redSqr(); f(Be < Ae); var Me = this.pow(X, new d(1).iushln(Ae - Be - 1)); ce = ce.redMul(Me), X = Me.redSqr(), me = me.redMul(X), Ae = Be } return ce }, Se.prototype.invm = function (g) { var P = g._invmp(this.m); return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P) }, Se.prototype.pow = function (g, P) { if (P.isZero()) return new d(1).toRed(this); if (P.cmpn(1) === 0) return g.clone(); var U = 4, K = new Array(1 << U); K[0] = new d(1).toRed(this), K[1] = g; for (var Y = 2; Y < K.length; Y++)K[Y] = this.mul(K[Y - 1], g); var te = K[0], ee = 0, G = 0, y = P.bitLength() % 26; for (y === 0 && (y = 26), Y = P.length - 1; Y >= 0; Y--) { for (var X = P.words[Y], ce = y - 1; ce >= 0; ce--) { var me = X >> ce & 1; if (te !== K[0] && (te = this.sqr(te)), me === 0 && ee === 0) { G = 0; continue } ee <<= 1, ee |= me, G++, !(G !== U && (Y !== 0 || ce !== 0)) && (te = this.mul(te, K[ee]), G = 0, ee = 0) } y = 26 } return te }, Se.prototype.convertTo = function (g) { var P = g.umod(this.m); return P === g ? P.clone() : P }, Se.prototype.convertFrom = function (g) { var P = g.clone(); return P.red = null, P }, d.mont = function (g) { return new $e(g) }; function $e(ie) { Se.call(this, ie), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p($e, Se), $e.prototype.convertTo = function (g) { return this.imod(g.ushln(this.shift)) }, $e.prototype.convertFrom = function (g) { var P = this.imod(g.mul(this.rinv)); return P.red = null, P }, $e.prototype.imul = function (g, P) { if (g.isZero() || P.isZero()) return g.words[0] = 0, g.length = 1, g; var U = g.imul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.mul = function (g, P) { if (g.isZero() || P.isZero()) return new d(0)._forceRed(this); var U = g.mul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.invm = function (g) { var P = this.imod(g._invmp(this.m).mul(this.r2)); return P._forceRed(this) } })(o, bn$6) }(bn$7)), bn$7.exports } var utils$1 = {}, hasRequiredUtils$2; function requireUtils$2() { return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function (o) { var l = o; function u(d, m) { if (Array.isArray(d)) return d.slice(); if (!d) return []; var v = []; if (typeof d != "string") { for (var I = 0; I < d.length; I++)v[I] = d[I] | 0; return v } if (m === "hex") { d = d.replace(/[^a-z0-9]+/ig, ""), d.length % 2 !== 0 && (d = "0" + d); for (var I = 0; I < d.length; I += 2)v.push(parseInt(d[I] + d[I + 1], 16)) } else for (var I = 0; I < d.length; I++) { var F = d.charCodeAt(I), B = F >> 8, W = F & 255; B ? v.push(B, W) : v.push(W) } return v } l.toArray = u; function f(d) { return d.length === 1 ? "0" + d : d } l.zero2 = f; function p(d) { for (var m = "", v = 0; v < d.length; v++)m += f(d[v].toString(16)); return m } l.toHex = p, l.encode = function (m, v) { return v === "hex" ? p(m) : m } }(utils$1)), utils$1 } var hasRequiredUtils$1; function requireUtils$1() { return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function (o) { var l = o, u = requireBn$3(), f = requireMinimalisticAssert(), p = requireUtils$2(); l.assert = f, l.toArray = p.toArray, l.zero2 = p.zero2, l.toHex = p.toHex, l.encode = p.encode; function d(B, W, Z) { var Q = new Array(Math.max(B.bitLength(), Z) + 1), re; for (re = 0; re < Q.length; re += 1)Q[re] = 0; var ne = 1 << W + 1, oe = B.clone(); for (re = 0; re < Q.length; re++) { var ae, se = oe.andln(ne - 1); oe.isOdd() ? (se > (ne >> 1) - 1 ? ae = (ne >> 1) - se : ae = se, oe.isubn(ae)) : ae = 0, Q[re] = ae, oe.iushrn(1) } return Q } l.getNAF = d; function m(B, W) { var Z = [[], []]; B = B.clone(), W = W.clone(); for (var Q = 0, re = 0, ne; B.cmpn(-Q) > 0 || W.cmpn(-re) > 0;) { var oe = B.andln(3) + Q & 3, ae = W.andln(3) + re & 3; oe === 3 && (oe = -1), ae === 3 && (ae = -1); var se; (oe & 1) === 0 ? se = 0 : (ne = B.andln(7) + Q & 7, (ne === 3 || ne === 5) && ae === 2 ? se = -oe : se = oe), Z[0].push(se); var le; (ae & 1) === 0 ? le = 0 : (ne = W.andln(7) + re & 7, (ne === 3 || ne === 5) && oe === 2 ? le = -ae : le = ae), Z[1].push(le), 2 * Q === se + 1 && (Q = 1 - Q), 2 * re === le + 1 && (re = 1 - re), B.iushrn(1), W.iushrn(1) } return Z } l.getJSF = m; function v(B, W, Z) { var Q = "_" + W; B.prototype[W] = function () { return this[Q] !== void 0 ? this[Q] : this[Q] = Z.call(this) } } l.cachedProperty = v; function I(B) { return typeof B == "string" ? l.toArray(B, "hex") : B } l.parseBytes = I; function F(B) { return new u(B, "hex", "le") } l.intFromLE = F }(utils$2)), utils$2 } var curve = {}, base$1, hasRequiredBase$1; function requireBase$1() { if (hasRequiredBase$1) return base$1; hasRequiredBase$1 = 1; var o = requireBn$3(), l = requireUtils$1(), u = l.getNAF, f = l.getJSF, p = l.assert; function d(v, I) { this.type = v, this.p = new o(I.p, 16), this.red = I.prime ? o.red(I.prime) : o.mont(this.p), this.zero = new o(0).toRed(this.red), this.one = new o(1).toRed(this.red), this.two = new o(2).toRed(this.red), this.n = I.n && new o(I.n, 16), this.g = I.g && this.pointFromJSON(I.g, I.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0; var F = this.n && this.p.div(this.n); !F || F.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red)) } base$1 = d, d.prototype.point = function () { throw new Error("Not implemented") }, d.prototype.validate = function () { throw new Error("Not implemented") }, d.prototype._fixedNafMul = function (I, F) { p(I.precomputed); var B = I._getDoubles(), W = u(F, 1, this._bitLength), Z = (1 << B.step + 1) - (B.step % 2 === 0 ? 2 : 1); Z /= 3; var Q = [], re, ne; for (re = 0; re < W.length; re += B.step) { ne = 0; for (var oe = re + B.step - 1; oe >= re; oe--)ne = (ne << 1) + W[oe]; Q.push(ne) } for (var ae = this.jpoint(null, null, null), se = this.jpoint(null, null, null), le = Z; le > 0; le--) { for (re = 0; re < Q.length; re++)ne = Q[re], ne === le ? se = se.mixedAdd(B.points[re]) : ne === -le && (se = se.mixedAdd(B.points[re].neg())); ae = ae.add(se) } return ae.toP() }, d.prototype._wnafMul = function (I, F) { var B = 4, W = I._getNAFPoints(B); B = W.wnd; for (var Z = W.points, Q = u(F, B, this._bitLength), re = this.jpoint(null, null, null), ne = Q.length - 1; ne >= 0; ne--) { for (var oe = 0; ne >= 0 && Q[ne] === 0; ne--)oe++; if (ne >= 0 && oe++, re = re.dblp(oe), ne < 0) break; var ae = Q[ne]; p(ae !== 0), I.type === "affine" ? ae > 0 ? re = re.mixedAdd(Z[ae - 1 >> 1]) : re = re.mixedAdd(Z[-ae - 1 >> 1].neg()) : ae > 0 ? re = re.add(Z[ae - 1 >> 1]) : re = re.add(Z[-ae - 1 >> 1].neg()) } return I.type === "affine" ? re.toP() : re }, d.prototype._wnafMulAdd = function (I, F, B, W, Z) { var Q = this._wnafT1, re = this._wnafT2, ne = this._wnafT3, oe = 0, ae, se, le; for (ae = 0; ae < W; ae++) { le = F[ae]; var ue = le._getNAFPoints(I); Q[ae] = ue.wnd, re[ae] = ue.points } for (ae = W - 1; ae >= 1; ae -= 2) { var he = ae - 1, pe = ae; if (Q[he] !== 1 || Q[pe] !== 1) { ne[he] = u(B[he], Q[he], this._bitLength), ne[pe] = u(B[pe], Q[pe], this._bitLength), oe = Math.max(ne[he].length, oe), oe = Math.max(ne[pe].length, oe); continue } var ve = [F[he], null, null, F[pe]]; F[he].y.cmp(F[pe].y) === 0 ? (ve[1] = F[he].add(F[pe]), ve[2] = F[he].toJ().mixedAdd(F[pe].neg())) : F[he].y.cmp(F[pe].y.redNeg()) === 0 ? (ve[1] = F[he].toJ().mixedAdd(F[pe]), ve[2] = F[he].add(F[pe].neg())) : (ve[1] = F[he].toJ().mixedAdd(F[pe]), ve[2] = F[he].toJ().mixedAdd(F[pe].neg())); var _e = [-3, -1, -5, -7, 0, 7, 5, 1, 3], Se = f(B[he], B[pe]); for (oe = Math.max(Se[0].length, oe), ne[he] = new Array(oe), ne[pe] = new Array(oe), se = 0; se < oe; se++) { var $e = Se[0][se] | 0, ie = Se[1][se] | 0; ne[he][se] = _e[($e + 1) * 3 + (ie + 1)], ne[pe][se] = 0, re[he] = ve } } var g = this.jpoint(null, null, null), P = this._wnafT4; for (ae = oe; ae >= 0; ae--) { for (var U = 0; ae >= 0;) { var K = !0; for (se = 0; se < W; se++)P[se] = ne[se][ae] | 0, P[se] !== 0 && (K = !1); if (!K) break; U++, ae-- } if (ae >= 0 && U++, g = g.dblp(U), ae < 0) break; for (se = 0; se < W; se++) { var Y = P[se]; Y !== 0 && (Y > 0 ? le = re[se][Y - 1 >> 1] : Y < 0 && (le = re[se][-Y - 1 >> 1].neg()), le.type === "affine" ? g = g.mixedAdd(le) : g = g.add(le)) } } for (ae = 0; ae < W; ae++)re[ae] = null; return Z ? g : g.toP() }; function m(v, I) { this.curve = v, this.type = I, this.precomputed = null } return d.BasePoint = m, m.prototype.eq = function () { throw new Error("Not implemented") }, m.prototype.validate = function () { return this.curve.validate(this) }, d.prototype.decodePoint = function (I, F) { I = l.toArray(I, F); var B = this.p.byteLength(); if ((I[0] === 4 || I[0] === 6 || I[0] === 7) && I.length - 1 === 2 * B) { I[0] === 6 ? p(I[I.length - 1] % 2 === 0) : I[0] === 7 && p(I[I.length - 1] % 2 === 1); var W = this.point(I.slice(1, 1 + B), I.slice(1 + B, 1 + 2 * B)); return W } else if ((I[0] === 2 || I[0] === 3) && I.length - 1 === B) return this.pointFromX(I.slice(1, 1 + B), I[0] === 3); throw new Error("Unknown point format") }, m.prototype.encodeCompressed = function (I) { return this.encode(I, !0) }, m.prototype._encode = function (I) { var F = this.curve.p.byteLength(), B = this.getX().toArray("be", F); return I ? [this.getY().isEven() ? 2 : 3].concat(B) : [4].concat(B, this.getY().toArray("be", F)) }, m.prototype.encode = function (I, F) { return l.encode(this._encode(F), I) }, m.prototype.precompute = function (I) { if (this.precomputed) return this; var F = { doubles: null, naf: null, beta: null }; return F.naf = this._getNAFPoints(8), F.doubles = this._getDoubles(4, I), F.beta = this._getBeta(), this.precomputed = F, this }, m.prototype._hasDoubles = function (I) { if (!this.precomputed) return !1; var F = this.precomputed.doubles; return F ? F.points.length >= Math.ceil((I.bitLength() + 1) / F.step) : !1 }, m.prototype._getDoubles = function (I, F) { if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles; for (var B = [this], W = this, Z = 0; Z < F; Z += I) { for (var Q = 0; Q < I; Q++)W = W.dbl(); B.push(W) } return { step: I, points: B } }, m.prototype._getNAFPoints = function (I) { if (this.precomputed && this.precomputed.naf) return this.precomputed.naf; for (var F = [this], B = (1 << I) - 1, W = B === 1 ? null : this.dbl(), Z = 1; Z < B; Z++)F[Z] = F[Z - 1].add(W); return { wnd: I, points: F } }, m.prototype._getBeta = function () { return null }, m.prototype.dblp = function (I) { for (var F = this, B = 0; B < I; B++)F = F.dbl(); return F }, base$1 } var short, hasRequiredShort; function requireShort() { if (hasRequiredShort) return short; hasRequiredShort = 1; var o = requireUtils$1(), l = requireBn$3(), u = requireInherits_browser(), f = requireBase$1(), p = o.assert; function d(I) { f.call(this, "short", I), this.a = new l(I.a, 16).toRed(this.red), this.b = new l(I.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(I), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4) } u(d, f), short = d, d.prototype._getEndomorphism = function (F) { if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) { var B, W; if (F.beta) B = new l(F.beta, 16).toRed(this.red); else { var Z = this._getEndoRoots(this.p); B = Z[0].cmp(Z[1]) < 0 ? Z[0] : Z[1], B = B.toRed(this.red) } if (F.lambda) W = new l(F.lambda, 16); else { var Q = this._getEndoRoots(this.n); this.g.mul(Q[0]).x.cmp(this.g.x.redMul(B)) === 0 ? W = Q[0] : (W = Q[1], p(this.g.mul(W).x.cmp(this.g.x.redMul(B)) === 0)) } var re; return F.basis ? re = F.basis.map(function (ne) { return { a: new l(ne.a, 16), b: new l(ne.b, 16) } }) : re = this._getEndoBasis(W), { beta: B, lambda: W, basis: re } } }, d.prototype._getEndoRoots = function (F) { var B = F === this.p ? this.red : l.mont(F), W = new l(2).toRed(B).redInvm(), Z = W.redNeg(), Q = new l(3).toRed(B).redNeg().redSqrt().redMul(W), re = Z.redAdd(Q).fromRed(), ne = Z.redSub(Q).fromRed(); return [re, ne] }, d.prototype._getEndoBasis = function (F) { for (var B = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), W = F, Z = this.n.clone(), Q = new l(1), re = new l(0), ne = new l(0), oe = new l(1), ae, se, le, ue, he, pe, ve, _e = 0, Se, $e; W.cmpn(0) !== 0;) { var ie = Z.div(W); Se = Z.sub(ie.mul(W)), $e = ne.sub(ie.mul(Q)); var g = oe.sub(ie.mul(re)); if (!le && Se.cmp(B) < 0) ae = ve.neg(), se = Q, le = Se.neg(), ue = $e; else if (le && ++_e === 2) break; ve = Se, Z = W, W = Se, ne = Q, Q = $e, oe = re, re = g } he = Se.neg(), pe = $e; var P = le.sqr().add(ue.sqr()), U = he.sqr().add(pe.sqr()); return U.cmp(P) >= 0 && (he = ae, pe = se), le.negative && (le = le.neg(), ue = ue.neg()), he.negative && (he = he.neg(), pe = pe.neg()), [{ a: le, b: ue }, { a: he, b: pe }] }, d.prototype._endoSplit = function (F) { var B = this.endo.basis, W = B[0], Z = B[1], Q = Z.b.mul(F).divRound(this.n), re = W.b.neg().mul(F).divRound(this.n), ne = Q.mul(W.a), oe = re.mul(Z.a), ae = Q.mul(W.b), se = re.mul(Z.b), le = F.sub(ne).sub(oe), ue = ae.add(se).neg(); return { k1: le, k2: ue } }, d.prototype.pointFromX = function (F, B) { F = new l(F, 16), F.red || (F = F.toRed(this.red)); var W = F.redSqr().redMul(F).redIAdd(F.redMul(this.a)).redIAdd(this.b), Z = W.redSqrt(); if (Z.redSqr().redSub(W).cmp(this.zero) !== 0) throw new Error("invalid point"); var Q = Z.fromRed().isOdd(); return (B && !Q || !B && Q) && (Z = Z.redNeg()), this.point(F, Z) }, d.prototype.validate = function (F) { if (F.inf) return !0; var B = F.x, W = F.y, Z = this.a.redMul(B), Q = B.redSqr().redMul(B).redIAdd(Z).redIAdd(this.b); return W.redSqr().redISub(Q).cmpn(0) === 0 }, d.prototype._endoWnafMulAdd = function (F, B, W) { for (var Z = this._endoWnafT1, Q = this._endoWnafT2, re = 0; re < F.length; re++) { var ne = this._endoSplit(B[re]), oe = F[re], ae = oe._getBeta(); ne.k1.negative && (ne.k1.ineg(), oe = oe.neg(!0)), ne.k2.negative && (ne.k2.ineg(), ae = ae.neg(!0)), Z[re * 2] = oe, Z[re * 2 + 1] = ae, Q[re * 2] = ne.k1, Q[re * 2 + 1] = ne.k2 } for (var se = this._wnafMulAdd(1, Z, Q, re * 2, W), le = 0; le < re * 2; le++)Z[le] = null, Q[le] = null; return se }; function m(I, F, B, W) { f.BasePoint.call(this, I, "affine"), F === null && B === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new l(F, 16), this.y = new l(B, 16), W && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1) } u(m, f.BasePoint), d.prototype.point = function (F, B, W) { return new m(this, F, B, W) }, d.prototype.pointFromJSON = function (F, B) { return m.fromJSON(this, F, B) }, m.prototype._getBeta = function () { if (this.curve.endo) { var F = this.precomputed; if (F && F.beta) return F.beta; var B = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y); if (F) { var W = this.curve, Z = function (Q) { return W.point(Q.x.redMul(W.endo.beta), Q.y) }; F.beta = B, B.precomputed = { beta: null, naf: F.naf && { wnd: F.naf.wnd, points: F.naf.points.map(Z) }, doubles: F.doubles && { step: F.doubles.step, points: F.doubles.points.map(Z) } } } return B } }, m.prototype.toJSON = function () { return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y] }, m.fromJSON = function (F, B, W) { typeof B == "string" && (B = JSON.parse(B)); var Z = F.point(B[0], B[1], W); if (!B[2]) return Z; function Q(ne) { return F.point(ne[0], ne[1], W) } var re = B[2]; return Z.precomputed = { beta: null, doubles: re.doubles && { step: re.doubles.step, points: [Z].concat(re.doubles.points.map(Q)) }, naf: re.naf && { wnd: re.naf.wnd, points: [Z].concat(re.naf.points.map(Q)) } }, Z }, m.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">" }, m.prototype.isInfinity = function () { return this.inf }, m.prototype.add = function (F) { if (this.inf) return F; if (F.inf) return this; if (this.eq(F)) return this.dbl(); if (this.neg().eq(F)) return this.curve.point(null, null); if (this.x.cmp(F.x) === 0) return this.curve.point(null, null); var B = this.y.redSub(F.y); B.cmpn(0) !== 0 && (B = B.redMul(this.x.redSub(F.x).redInvm())); var W = B.redSqr().redISub(this.x).redISub(F.x), Z = B.redMul(this.x.redSub(W)).redISub(this.y); return this.curve.point(W, Z) }, m.prototype.dbl = function () { if (this.inf) return this; var F = this.y.redAdd(this.y); if (F.cmpn(0) === 0) return this.curve.point(null, null); var B = this.curve.a, W = this.x.redSqr(), Z = F.redInvm(), Q = W.redAdd(W).redIAdd(W).redIAdd(B).redMul(Z), re = Q.redSqr().redISub(this.x.redAdd(this.x)), ne = Q.redMul(this.x.redSub(re)).redISub(this.y); return this.curve.point(re, ne) }, m.prototype.getX = function () { return this.x.fromRed() }, m.prototype.getY = function () { return this.y.fromRed() }, m.prototype.mul = function (F) { return F = new l(F, 16), this.isInfinity() ? this : this._hasDoubles(F) ? this.curve._fixedNafMul(this, F) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [F]) : this.curve._wnafMul(this, F) }, m.prototype.mulAdd = function (F, B, W) { var Z = [this, B], Q = [F, W]; return this.curve.endo ? this.curve._endoWnafMulAdd(Z, Q) : this.curve._wnafMulAdd(1, Z, Q, 2) }, m.prototype.jmulAdd = function (F, B, W) { var Z = [this, B], Q = [F, W]; return this.curve.endo ? this.curve._endoWnafMulAdd(Z, Q, !0) : this.curve._wnafMulAdd(1, Z, Q, 2, !0) }, m.prototype.eq = function (F) { return this === F || this.inf === F.inf && (this.inf || this.x.cmp(F.x) === 0 && this.y.cmp(F.y) === 0) }, m.prototype.neg = function (F) { if (this.inf) return this; var B = this.curve.point(this.x, this.y.redNeg()); if (F && this.precomputed) { var W = this.precomputed, Z = function (Q) { return Q.neg() }; B.precomputed = { naf: W.naf && { wnd: W.naf.wnd, points: W.naf.points.map(Z) }, doubles: W.doubles && { step: W.doubles.step, points: W.doubles.points.map(Z) } } } return B }, m.prototype.toJ = function () { if (this.inf) return this.curve.jpoint(null, null, null); var F = this.curve.jpoint(this.x, this.y, this.curve.one); return F }; function v(I, F, B, W) { f.BasePoint.call(this, I, "jacobian"), F === null && B === null && W === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new l(0)) : (this.x = new l(F, 16), this.y = new l(B, 16), this.z = new l(W, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one } return u(v, f.BasePoint), d.prototype.jpoint = function (F, B, W) { return new v(this, F, B, W) }, v.prototype.toP = function () { if (this.isInfinity()) return this.curve.point(null, null); var F = this.z.redInvm(), B = F.redSqr(), W = this.x.redMul(B), Z = this.y.redMul(B).redMul(F); return this.curve.point(W, Z) }, v.prototype.neg = function () { return this.curve.jpoint(this.x, this.y.redNeg(), this.z) }, v.prototype.add = function (F) { if (this.isInfinity()) return F; if (F.isInfinity()) return this; var B = F.z.redSqr(), W = this.z.redSqr(), Z = this.x.redMul(B), Q = F.x.redMul(W), re = this.y.redMul(B.redMul(F.z)), ne = F.y.redMul(W.redMul(this.z)), oe = Z.redSub(Q), ae = re.redSub(ne); if (oe.cmpn(0) === 0) return ae.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); var se = oe.redSqr(), le = se.redMul(oe), ue = Z.redMul(se), he = ae.redSqr().redIAdd(le).redISub(ue).redISub(ue), pe = ae.redMul(ue.redISub(he)).redISub(re.redMul(le)), ve = this.z.redMul(F.z).redMul(oe); return this.curve.jpoint(he, pe, ve) }, v.prototype.mixedAdd = function (F) { if (this.isInfinity()) return F.toJ(); if (F.isInfinity()) return this; var B = this.z.redSqr(), W = this.x, Z = F.x.redMul(B), Q = this.y, re = F.y.redMul(B).redMul(this.z), ne = W.redSub(Z), oe = Q.redSub(re); if (ne.cmpn(0) === 0) return oe.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); var ae = ne.redSqr(), se = ae.redMul(ne), le = W.redMul(ae), ue = oe.redSqr().redIAdd(se).redISub(le).redISub(le), he = oe.redMul(le.redISub(ue)).redISub(Q.redMul(se)), pe = this.z.redMul(ne); return this.curve.jpoint(ue, he, pe) }, v.prototype.dblp = function (F) { if (F === 0) return this; if (this.isInfinity()) return this; if (!F) return this.dbl(); var B; if (this.curve.zeroA || this.curve.threeA) { var W = this; for (B = 0; B < F; B++)W = W.dbl(); return W } var Z = this.curve.a, Q = this.curve.tinv, re = this.x, ne = this.y, oe = this.z, ae = oe.redSqr().redSqr(), se = ne.redAdd(ne); for (B = 0; B < F; B++) { var le = re.redSqr(), ue = se.redSqr(), he = ue.redSqr(), pe = le.redAdd(le).redIAdd(le).redIAdd(Z.redMul(ae)), ve = re.redMul(ue), _e = pe.redSqr().redISub(ve.redAdd(ve)), Se = ve.redISub(_e), $e = pe.redMul(Se); $e = $e.redIAdd($e).redISub(he); var ie = se.redMul(oe); B + 1 < F && (ae = ae.redMul(he)), re = _e, oe = ie, se = $e } return this.curve.jpoint(re, se.redMul(Q), oe) }, v.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl() }, v.prototype._zeroDbl = function () { var F, B, W; if (this.zOne) { var Z = this.x.redSqr(), Q = this.y.redSqr(), re = Q.redSqr(), ne = this.x.redAdd(Q).redSqr().redISub(Z).redISub(re); ne = ne.redIAdd(ne); var oe = Z.redAdd(Z).redIAdd(Z), ae = oe.redSqr().redISub(ne).redISub(ne), se = re.redIAdd(re); se = se.redIAdd(se), se = se.redIAdd(se), F = ae, B = oe.redMul(ne.redISub(ae)).redISub(se), W = this.y.redAdd(this.y) } else { var le = this.x.redSqr(), ue = this.y.redSqr(), he = ue.redSqr(), pe = this.x.redAdd(ue).redSqr().redISub(le).redISub(he); pe = pe.redIAdd(pe); var ve = le.redAdd(le).redIAdd(le), _e = ve.redSqr(), Se = he.redIAdd(he); Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), F = _e.redISub(pe).redISub(pe), B = ve.redMul(pe.redISub(F)).redISub(Se), W = this.y.redMul(this.z), W = W.redIAdd(W) } return this.curve.jpoint(F, B, W) }, v.prototype._threeDbl = function () { var F, B, W; if (this.zOne) { var Z = this.x.redSqr(), Q = this.y.redSqr(), re = Q.redSqr(), ne = this.x.redAdd(Q).redSqr().redISub(Z).redISub(re); ne = ne.redIAdd(ne); var oe = Z.redAdd(Z).redIAdd(Z).redIAdd(this.curve.a), ae = oe.redSqr().redISub(ne).redISub(ne); F = ae; var se = re.redIAdd(re); se = se.redIAdd(se), se = se.redIAdd(se), B = oe.redMul(ne.redISub(ae)).redISub(se), W = this.y.redAdd(this.y) } else { var le = this.z.redSqr(), ue = this.y.redSqr(), he = this.x.redMul(ue), pe = this.x.redSub(le).redMul(this.x.redAdd(le)); pe = pe.redAdd(pe).redIAdd(pe); var ve = he.redIAdd(he); ve = ve.redIAdd(ve); var _e = ve.redAdd(ve); F = pe.redSqr().redISub(_e), W = this.y.redAdd(this.z).redSqr().redISub(ue).redISub(le); var Se = ue.redSqr(); Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), Se = Se.redIAdd(Se), B = pe.redMul(ve.redISub(F)).redISub(Se) } return this.curve.jpoint(F, B, W) }, v.prototype._dbl = function () { var F = this.curve.a, B = this.x, W = this.y, Z = this.z, Q = Z.redSqr().redSqr(), re = B.redSqr(), ne = W.redSqr(), oe = re.redAdd(re).redIAdd(re).redIAdd(F.redMul(Q)), ae = B.redAdd(B); ae = ae.redIAdd(ae); var se = ae.redMul(ne), le = oe.redSqr().redISub(se.redAdd(se)), ue = se.redISub(le), he = ne.redSqr(); he = he.redIAdd(he), he = he.redIAdd(he), he = he.redIAdd(he); var pe = oe.redMul(ue).redISub(he), ve = W.redAdd(W).redMul(Z); return this.curve.jpoint(le, pe, ve) }, v.prototype.trpl = function () { if (!this.curve.zeroA) return this.dbl().add(this); var F = this.x.redSqr(), B = this.y.redSqr(), W = this.z.redSqr(), Z = B.redSqr(), Q = F.redAdd(F).redIAdd(F), re = Q.redSqr(), ne = this.x.redAdd(B).redSqr().redISub(F).redISub(Z); ne = ne.redIAdd(ne), ne = ne.redAdd(ne).redIAdd(ne), ne = ne.redISub(re); var oe = ne.redSqr(), ae = Z.redIAdd(Z); ae = ae.redIAdd(ae), ae = ae.redIAdd(ae), ae = ae.redIAdd(ae); var se = Q.redIAdd(ne).redSqr().redISub(re).redISub(oe).redISub(ae), le = B.redMul(se); le = le.redIAdd(le), le = le.redIAdd(le); var ue = this.x.redMul(oe).redISub(le); ue = ue.redIAdd(ue), ue = ue.redIAdd(ue); var he = this.y.redMul(se.redMul(ae.redISub(se)).redISub(ne.redMul(oe))); he = he.redIAdd(he), he = he.redIAdd(he), he = he.redIAdd(he); var pe = this.z.redAdd(ne).redSqr().redISub(W).redISub(oe); return this.curve.jpoint(ue, he, pe) }, v.prototype.mul = function (F, B) { return F = new l(F, B), this.curve._wnafMul(this, F) }, v.prototype.eq = function (F) { if (F.type === "affine") return this.eq(F.toJ()); if (this === F) return !0; var B = this.z.redSqr(), W = F.z.redSqr(); if (this.x.redMul(W).redISub(F.x.redMul(B)).cmpn(0) !== 0) return !1; var Z = B.redMul(this.z), Q = W.redMul(F.z); return this.y.redMul(Q).redISub(F.y.redMul(Z)).cmpn(0) === 0 }, v.prototype.eqXToP = function (F) { var B = this.z.redSqr(), W = F.toRed(this.curve.red).redMul(B); if (this.x.cmp(W) === 0) return !0; for (var Z = F.clone(), Q = this.curve.redN.redMul(B); ;) { if (Z.iadd(this.curve.n), Z.cmp(this.curve.p) >= 0) return !1; if (W.redIAdd(Q), this.x.cmp(W) === 0) return !0 } }, v.prototype.inspect = function () { return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">" }, v.prototype.isInfinity = function () { return this.z.cmpn(0) === 0 }, short } var mont, hasRequiredMont; function requireMont() { if (hasRequiredMont) return mont; hasRequiredMont = 1; var o = requireBn$3(), l = requireInherits_browser(), u = requireBase$1(), f = requireUtils$1(); function p(m) { u.call(this, "mont", m), this.a = new o(m.a, 16).toRed(this.red), this.b = new o(m.b, 16).toRed(this.red), this.i4 = new o(4).toRed(this.red).redInvm(), this.two = new o(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two)) } l(p, u), mont = p, p.prototype.validate = function (v) { var I = v.normalize().x, F = I.redSqr(), B = F.redMul(I).redAdd(F.redMul(this.a)).redAdd(I), W = B.redSqrt(); return W.redSqr().cmp(B) === 0 }; function d(m, v, I) { u.BasePoint.call(this, m, "projective"), v === null && I === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new o(v, 16), this.z = new o(I, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red))) } return l(d, u.BasePoint), p.prototype.decodePoint = function (v, I) { return this.point(f.toArray(v, I), 1) }, p.prototype.point = function (v, I) { return new d(this, v, I) }, p.prototype.pointFromJSON = function (v) { return d.fromJSON(this, v) }, d.prototype.precompute = function () { }, d.prototype._encode = function () { return this.getX().toArray("be", this.curve.p.byteLength()) }, d.fromJSON = function (v, I) { return new d(v, I[0], I[1] || v.one) }, d.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">" }, d.prototype.isInfinity = function () { return this.z.cmpn(0) === 0 }, d.prototype.dbl = function () { var v = this.x.redAdd(this.z), I = v.redSqr(), F = this.x.redSub(this.z), B = F.redSqr(), W = I.redSub(B), Z = I.redMul(B), Q = W.redMul(B.redAdd(this.curve.a24.redMul(W))); return this.curve.point(Z, Q) }, d.prototype.add = function () { throw new Error("Not supported on Montgomery curve") }, d.prototype.diffAdd = function (v, I) { var F = this.x.redAdd(this.z), B = this.x.redSub(this.z), W = v.x.redAdd(v.z), Z = v.x.redSub(v.z), Q = Z.redMul(F), re = W.redMul(B), ne = I.z.redMul(Q.redAdd(re).redSqr()), oe = I.x.redMul(Q.redISub(re).redSqr()); return this.curve.point(ne, oe) }, d.prototype.mul = function (v) { for (var I = v.clone(), F = this, B = this.curve.point(null, null), W = this, Z = []; I.cmpn(0) !== 0; I.iushrn(1))Z.push(I.andln(1)); for (var Q = Z.length - 1; Q >= 0; Q--)Z[Q] === 0 ? (F = F.diffAdd(B, W), B = B.dbl()) : (B = F.diffAdd(B, W), F = F.dbl()); return B }, d.prototype.mulAdd = function () { throw new Error("Not supported on Montgomery curve") }, d.prototype.jumlAdd = function () { throw new Error("Not supported on Montgomery curve") }, d.prototype.eq = function (v) { return this.getX().cmp(v.getX()) === 0 }, d.prototype.normalize = function () { return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this }, d.prototype.getX = function () { return this.normalize(), this.x.fromRed() }, mont } var edwards, hasRequiredEdwards; function requireEdwards() { if (hasRequiredEdwards) return edwards; hasRequiredEdwards = 1; var o = requireUtils$1(), l = requireBn$3(), u = requireInherits_browser(), f = requireBase$1(), p = o.assert; function d(v) { this.twisted = (v.a | 0) !== 1, this.mOneA = this.twisted && (v.a | 0) === -1, this.extended = this.mOneA, f.call(this, "edwards", v), this.a = new l(v.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new l(v.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new l(v.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), p(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (v.c | 0) === 1 } u(d, f), edwards = d, d.prototype._mulA = function (I) { return this.mOneA ? I.redNeg() : this.a.redMul(I) }, d.prototype._mulC = function (I) { return this.oneC ? I : this.c.redMul(I) }, d.prototype.jpoint = function (I, F, B, W) { return this.point(I, F, B, W) }, d.prototype.pointFromX = function (I, F) { I = new l(I, 16), I.red || (I = I.toRed(this.red)); var B = I.redSqr(), W = this.c2.redSub(this.a.redMul(B)), Z = this.one.redSub(this.c2.redMul(this.d).redMul(B)), Q = W.redMul(Z.redInvm()), re = Q.redSqrt(); if (re.redSqr().redSub(Q).cmp(this.zero) !== 0) throw new Error("invalid point"); var ne = re.fromRed().isOdd(); return (F && !ne || !F && ne) && (re = re.redNeg()), this.point(I, re) }, d.prototype.pointFromY = function (I, F) { I = new l(I, 16), I.red || (I = I.toRed(this.red)); var B = I.redSqr(), W = B.redSub(this.c2), Z = B.redMul(this.d).redMul(this.c2).redSub(this.a), Q = W.redMul(Z.redInvm()); if (Q.cmp(this.zero) === 0) { if (F) throw new Error("invalid point"); return this.point(this.zero, I) } var re = Q.redSqrt(); if (re.redSqr().redSub(Q).cmp(this.zero) !== 0) throw new Error("invalid point"); return re.fromRed().isOdd() !== F && (re = re.redNeg()), this.point(re, I) }, d.prototype.validate = function (I) { if (I.isInfinity()) return !0; I.normalize(); var F = I.x.redSqr(), B = I.y.redSqr(), W = F.redMul(this.a).redAdd(B), Z = this.c2.redMul(this.one.redAdd(this.d.redMul(F).redMul(B))); return W.cmp(Z) === 0 }; function m(v, I, F, B, W) { f.BasePoint.call(this, v, "projective"), I === null && F === null && B === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new l(I, 16), this.y = new l(F, 16), this.z = B ? new l(B, 16) : this.curve.one, this.t = W && new l(W, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm())))) } return u(m, f.BasePoint), d.prototype.pointFromJSON = function (I) { return m.fromJSON(this, I) }, d.prototype.point = function (I, F, B, W) { return new m(this, I, F, B, W) }, m.fromJSON = function (I, F) { return new m(I, F[0], F[1], F[2]) }, m.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">" }, m.prototype.isInfinity = function () { return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0) }, m.prototype._extDbl = function () { var I = this.x.redSqr(), F = this.y.redSqr(), B = this.z.redSqr(); B = B.redIAdd(B); var W = this.curve._mulA(I), Z = this.x.redAdd(this.y).redSqr().redISub(I).redISub(F), Q = W.redAdd(F), re = Q.redSub(B), ne = W.redSub(F), oe = Z.redMul(re), ae = Q.redMul(ne), se = Z.redMul(ne), le = re.redMul(Q); return this.curve.point(oe, ae, le, se) }, m.prototype._projDbl = function () { var I = this.x.redAdd(this.y).redSqr(), F = this.x.redSqr(), B = this.y.redSqr(), W, Z, Q, re, ne, oe; if (this.curve.twisted) { re = this.curve._mulA(F); var ae = re.redAdd(B); this.zOne ? (W = I.redSub(F).redSub(B).redMul(ae.redSub(this.curve.two)), Z = ae.redMul(re.redSub(B)), Q = ae.redSqr().redSub(ae).redSub(ae)) : (ne = this.z.redSqr(), oe = ae.redSub(ne).redISub(ne), W = I.redSub(F).redISub(B).redMul(oe), Z = ae.redMul(re.redSub(B)), Q = ae.redMul(oe)) } else re = F.redAdd(B), ne = this.curve._mulC(this.z).redSqr(), oe = re.redSub(ne).redSub(ne), W = this.curve._mulC(I.redISub(re)).redMul(oe), Z = this.curve._mulC(re).redMul(F.redISub(B)), Q = re.redMul(oe); return this.curve.point(W, Z, Q) }, m.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl() }, m.prototype._extAdd = function (I) { var F = this.y.redSub(this.x).redMul(I.y.redSub(I.x)), B = this.y.redAdd(this.x).redMul(I.y.redAdd(I.x)), W = this.t.redMul(this.curve.dd).redMul(I.t), Z = this.z.redMul(I.z.redAdd(I.z)), Q = B.redSub(F), re = Z.redSub(W), ne = Z.redAdd(W), oe = B.redAdd(F), ae = Q.redMul(re), se = ne.redMul(oe), le = Q.redMul(oe), ue = re.redMul(ne); return this.curve.point(ae, se, ue, le) }, m.prototype._projAdd = function (I) { var F = this.z.redMul(I.z), B = F.redSqr(), W = this.x.redMul(I.x), Z = this.y.redMul(I.y), Q = this.curve.d.redMul(W).redMul(Z), re = B.redSub(Q), ne = B.redAdd(Q), oe = this.x.redAdd(this.y).redMul(I.x.redAdd(I.y)).redISub(W).redISub(Z), ae = F.redMul(re).redMul(oe), se, le; return this.curve.twisted ? (se = F.redMul(ne).redMul(Z.redSub(this.curve._mulA(W))), le = re.redMul(ne)) : (se = F.redMul(ne).redMul(Z.redSub(W)), le = this.curve._mulC(re).redMul(ne)), this.curve.point(ae, se, le) }, m.prototype.add = function (I) { return this.isInfinity() ? I : I.isInfinity() ? this : this.curve.extended ? this._extAdd(I) : this._projAdd(I) }, m.prototype.mul = function (I) { return this._hasDoubles(I) ? this.curve._fixedNafMul(this, I) : this.curve._wnafMul(this, I) }, m.prototype.mulAdd = function (I, F, B) { return this.curve._wnafMulAdd(1, [this, F], [I, B], 2, !1) }, m.prototype.jmulAdd = function (I, F, B) { return this.curve._wnafMulAdd(1, [this, F], [I, B], 2, !0) }, m.prototype.normalize = function () { if (this.zOne) return this; var I = this.z.redInvm(); return this.x = this.x.redMul(I), this.y = this.y.redMul(I), this.t && (this.t = this.t.redMul(I)), this.z = this.curve.one, this.zOne = !0, this }, m.prototype.neg = function () { return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg()) }, m.prototype.getX = function () { return this.normalize(), this.x.fromRed() }, m.prototype.getY = function () { return this.normalize(), this.y.fromRed() }, m.prototype.eq = function (I) { return this === I || this.getX().cmp(I.getX()) === 0 && this.getY().cmp(I.getY()) === 0 }, m.prototype.eqXToP = function (I) { var F = I.toRed(this.curve.red).redMul(this.z); if (this.x.cmp(F) === 0) return !0; for (var B = I.clone(), W = this.curve.redN.redMul(this.z); ;) { if (B.iadd(this.curve.n), B.cmp(this.curve.p) >= 0) return !1; if (F.redIAdd(W), this.x.cmp(F) === 0) return !0 } }, m.prototype.toP = m.prototype.normalize, m.prototype.mixedAdd = m.prototype.add, edwards } var hasRequiredCurve; function requireCurve() { return hasRequiredCurve || (hasRequiredCurve = 1, function (o) { var l = o; l.base = requireBase$1(), l.short = requireShort(), l.mont = requireMont(), l.edwards = requireEdwards() }(curve)), curve } var curves = {}, hash = {}, utils = {}, hasRequiredUtils; function requireUtils() { if (hasRequiredUtils) return utils; hasRequiredUtils = 1; var o = requireMinimalisticAssert(), l = requireInherits_browser(); utils.inherits = l; function u(g, P) { return (g.charCodeAt(P) & 64512) !== 55296 || P < 0 || P + 1 >= g.length ? !1 : (g.charCodeAt(P + 1) & 64512) === 56320 } function f(g, P) { if (Array.isArray(g)) return g.slice(); if (!g) return []; var U = []; if (typeof g == "string") if (P) { if (P === "hex") for (g = g.replace(/[^a-z0-9]+/ig, ""), g.length % 2 !== 0 && (g = "0" + g), Y = 0; Y < g.length; Y += 2)U.push(parseInt(g[Y] + g[Y + 1], 16)) } else for (var K = 0, Y = 0; Y < g.length; Y++) { var te = g.charCodeAt(Y); te < 128 ? U[K++] = te : te < 2048 ? (U[K++] = te >> 6 | 192, U[K++] = te & 63 | 128) : u(g, Y) ? (te = 65536 + ((te & 1023) << 10) + (g.charCodeAt(++Y) & 1023), U[K++] = te >> 18 | 240, U[K++] = te >> 12 & 63 | 128, U[K++] = te >> 6 & 63 | 128, U[K++] = te & 63 | 128) : (U[K++] = te >> 12 | 224, U[K++] = te >> 6 & 63 | 128, U[K++] = te & 63 | 128) } else for (Y = 0; Y < g.length; Y++)U[Y] = g[Y] | 0; return U } utils.toArray = f; function p(g) { for (var P = "", U = 0; U < g.length; U++)P += v(g[U].toString(16)); return P } utils.toHex = p; function d(g) { var P = g >>> 24 | g >>> 8 & 65280 | g << 8 & 16711680 | (g & 255) << 24; return P >>> 0 } utils.htonl = d; function m(g, P) { for (var U = "", K = 0; K < g.length; K++) { var Y = g[K]; P === "little" && (Y = d(Y)), U += I(Y.toString(16)) } return U } utils.toHex32 = m; function v(g) { return g.length === 1 ? "0" + g : g } utils.zero2 = v; function I(g) { return g.length === 7 ? "0" + g : g.length === 6 ? "00" + g : g.length === 5 ? "000" + g : g.length === 4 ? "0000" + g : g.length === 3 ? "00000" + g : g.length === 2 ? "000000" + g : g.length === 1 ? "0000000" + g : g } utils.zero8 = I; function F(g, P, U, K) { var Y = U - P; o(Y % 4 === 0); for (var te = new Array(Y / 4), ee = 0, G = P; ee < te.length; ee++, G += 4) { var y; K === "big" ? y = g[G] << 24 | g[G + 1] << 16 | g[G + 2] << 8 | g[G + 3] : y = g[G + 3] << 24 | g[G + 2] << 16 | g[G + 1] << 8 | g[G], te[ee] = y >>> 0 } return te } utils.join32 = F; function B(g, P) { for (var U = new Array(g.length * 4), K = 0, Y = 0; K < g.length; K++, Y += 4) { var te = g[K]; P === "big" ? (U[Y] = te >>> 24, U[Y + 1] = te >>> 16 & 255, U[Y + 2] = te >>> 8 & 255, U[Y + 3] = te & 255) : (U[Y + 3] = te >>> 24, U[Y + 2] = te >>> 16 & 255, U[Y + 1] = te >>> 8 & 255, U[Y] = te & 255) } return U } utils.split32 = B; function W(g, P) { return g >>> P | g << 32 - P } utils.rotr32 = W; function Z(g, P) { return g << P | g >>> 32 - P } utils.rotl32 = Z; function Q(g, P) { return g + P >>> 0 } utils.sum32 = Q; function re(g, P, U) { return g + P + U >>> 0 } utils.sum32_3 = re; function ne(g, P, U, K) { return g + P + U + K >>> 0 } utils.sum32_4 = ne; function oe(g, P, U, K, Y) { return g + P + U + K + Y >>> 0 } utils.sum32_5 = oe; function ae(g, P, U, K) { var Y = g[P], te = g[P + 1], ee = K + te >>> 0, G = (ee < K ? 1 : 0) + U + Y; g[P] = G >>> 0, g[P + 1] = ee } utils.sum64 = ae; function se(g, P, U, K) { var Y = P + K >>> 0, te = (Y < P ? 1 : 0) + g + U; return te >>> 0 } utils.sum64_hi = se; function le(g, P, U, K) { var Y = P + K; return Y >>> 0 } utils.sum64_lo = le; function ue(g, P, U, K, Y, te, ee, G) { var y = 0, X = P; X = X + K >>> 0, y += X < P ? 1 : 0, X = X + te >>> 0, y += X < te ? 1 : 0, X = X + G >>> 0, y += X < G ? 1 : 0; var ce = g + U + Y + ee + y; return ce >>> 0 } utils.sum64_4_hi = ue; function he(g, P, U, K, Y, te, ee, G) { var y = P + K + te + G; return y >>> 0 } utils.sum64_4_lo = he; function pe(g, P, U, K, Y, te, ee, G, y, X) { var ce = 0, me = P; me = me + K >>> 0, ce += me < P ? 1 : 0, me = me + te >>> 0, ce += me < te ? 1 : 0, me = me + G >>> 0, ce += me < G ? 1 : 0, me = me + X >>> 0, ce += me < X ? 1 : 0; var Ae = g + U + Y + ee + y + ce; return Ae >>> 0 } utils.sum64_5_hi = pe; function ve(g, P, U, K, Y, te, ee, G, y, X) { var ce = P + K + te + G + X; return ce >>> 0 } utils.sum64_5_lo = ve; function _e(g, P, U) { var K = P << 32 - U | g >>> U; return K >>> 0 } utils.rotr64_hi = _e; function Se(g, P, U) { var K = g << 32 - U | P >>> U; return K >>> 0 } utils.rotr64_lo = Se; function $e(g, P, U) { return g >>> U } utils.shr64_hi = $e; function ie(g, P, U) { var K = g << 32 - U | P >>> U; return K >>> 0 } return utils.shr64_lo = ie, utils } var common$1 = {}, hasRequiredCommon$1; function requireCommon$1() { if (hasRequiredCommon$1) return common$1; hasRequiredCommon$1 = 1; var o = requireUtils(), l = requireMinimalisticAssert(); function u() { this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32 } return common$1.BlockHash = u, u.prototype.update = function (p, d) { if (p = o.toArray(p, d), this.pending ? this.pending = this.pending.concat(p) : this.pending = p, this.pendingTotal += p.length, this.pending.length >= this._delta8) { p = this.pending; var m = p.length % this._delta8; this.pending = p.slice(p.length - m, p.length), this.pending.length === 0 && (this.pending = null), p = o.join32(p, 0, p.length - m, this.endian); for (var v = 0; v < p.length; v += this._delta32)this._update(p, v, v + this._delta32) } return this }, u.prototype.digest = function (p) { return this.update(this._pad()), l(this.pending === null), this._digest(p) }, u.prototype._pad = function () { var p = this.pendingTotal, d = this._delta8, m = d - (p + this.padLength) % d, v = new Array(m + this.padLength); v[0] = 128; for (var I = 1; I < m; I++)v[I] = 0; if (p <<= 3, this.endian === "big") { for (var F = 8; F < this.padLength; F++)v[I++] = 0; v[I++] = 0, v[I++] = 0, v[I++] = 0, v[I++] = 0, v[I++] = p >>> 24 & 255, v[I++] = p >>> 16 & 255, v[I++] = p >>> 8 & 255, v[I++] = p & 255 } else for (v[I++] = p & 255, v[I++] = p >>> 8 & 255, v[I++] = p >>> 16 & 255, v[I++] = p >>> 24 & 255, v[I++] = 0, v[I++] = 0, v[I++] = 0, v[I++] = 0, F = 8; F < this.padLength; F++)v[I++] = 0; return v }, common$1 } var sha = {}, common = {}, hasRequiredCommon; function requireCommon() { if (hasRequiredCommon) return common; hasRequiredCommon = 1; var o = requireUtils(), l = o.rotr32; function u(B, W, Z, Q) { if (B === 0) return f(W, Z, Q); if (B === 1 || B === 3) return d(W, Z, Q); if (B === 2) return p(W, Z, Q) } common.ft_1 = u; function f(B, W, Z) { return B & W ^ ~B & Z } common.ch32 = f; function p(B, W, Z) { return B & W ^ B & Z ^ W & Z } common.maj32 = p; function d(B, W, Z) { return B ^ W ^ Z } common.p32 = d; function m(B) { return l(B, 2) ^ l(B, 13) ^ l(B, 22) } common.s0_256 = m; function v(B) { return l(B, 6) ^ l(B, 11) ^ l(B, 25) } common.s1_256 = v; function I(B) { return l(B, 7) ^ l(B, 18) ^ B >>> 3 } common.g0_256 = I; function F(B) { return l(B, 17) ^ l(B, 19) ^ B >>> 10 } return common.g1_256 = F, common } var _1, hasRequired_1; function require_1() { if (hasRequired_1) return _1; hasRequired_1 = 1; var o = requireUtils(), l = requireCommon$1(), u = requireCommon(), f = o.rotl32, p = o.sum32, d = o.sum32_5, m = u.ft_1, v = l.BlockHash, I = [1518500249, 1859775393, 2400959708, 3395469782]; function F() { if (!(this instanceof F)) return new F; v.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80) } return o.inherits(F, v), _1 = F, F.blockSize = 512, F.outSize = 160, F.hmacStrength = 80, F.padLength = 64, F.prototype._update = function (W, Z) { for (var Q = this.W, re = 0; re < 16; re++)Q[re] = W[Z + re]; for (; re < Q.length; re++)Q[re] = f(Q[re - 3] ^ Q[re - 8] ^ Q[re - 14] ^ Q[re - 16], 1); var ne = this.h[0], oe = this.h[1], ae = this.h[2], se = this.h[3], le = this.h[4]; for (re = 0; re < Q.length; re++) { var ue = ~~(re / 20), he = d(f(ne, 5), m(ue, oe, ae, se), le, Q[re], I[ue]); le = se, se = ae, ae = f(oe, 30), oe = ne, ne = he } this.h[0] = p(this.h[0], ne), this.h[1] = p(this.h[1], oe), this.h[2] = p(this.h[2], ae), this.h[3] = p(this.h[3], se), this.h[4] = p(this.h[4], le) }, F.prototype._digest = function (W) { return W === "hex" ? o.toHex32(this.h, "big") : o.split32(this.h, "big") }, _1 } var _256, hasRequired_256; function require_256() { if (hasRequired_256) return _256; hasRequired_256 = 1; var o = requireUtils(), l = requireCommon$1(), u = requireCommon(), f = requireMinimalisticAssert(), p = o.sum32, d = o.sum32_4, m = o.sum32_5, v = u.ch32, I = u.maj32, F = u.s0_256, B = u.s1_256, W = u.g0_256, Z = u.g1_256, Q = l.BlockHash, re = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; function ne() { if (!(this instanceof ne)) return new ne; Q.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = re, this.W = new Array(64) } return o.inherits(ne, Q), _256 = ne, ne.blockSize = 512, ne.outSize = 256, ne.hmacStrength = 192, ne.padLength = 64, ne.prototype._update = function (ae, se) { for (var le = this.W, ue = 0; ue < 16; ue++)le[ue] = ae[se + ue]; for (; ue < le.length; ue++)le[ue] = d(Z(le[ue - 2]), le[ue - 7], W(le[ue - 15]), le[ue - 16]); var he = this.h[0], pe = this.h[1], ve = this.h[2], _e = this.h[3], Se = this.h[4], $e = this.h[5], ie = this.h[6], g = this.h[7]; for (f(this.k.length === le.length), ue = 0; ue < le.length; ue++) { var P = m(g, B(Se), v(Se, $e, ie), this.k[ue], le[ue]), U = p(F(he), I(he, pe, ve)); g = ie, ie = $e, $e = Se, Se = p(_e, P), _e = ve, ve = pe, pe = he, he = p(P, U) } this.h[0] = p(this.h[0], he), this.h[1] = p(this.h[1], pe), this.h[2] = p(this.h[2], ve), this.h[3] = p(this.h[3], _e), this.h[4] = p(this.h[4], Se), this.h[5] = p(this.h[5], $e), this.h[6] = p(this.h[6], ie), this.h[7] = p(this.h[7], g) }, ne.prototype._digest = function (ae) { return ae === "hex" ? o.toHex32(this.h, "big") : o.split32(this.h, "big") }, _256 } var _224, hasRequired_224; function require_224() { if (hasRequired_224) return _224; hasRequired_224 = 1; var o = requireUtils(), l = require_256(); function u() { if (!(this instanceof u)) return new u; l.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428] } return o.inherits(u, l), _224 = u, u.blockSize = 512, u.outSize = 224, u.hmacStrength = 192, u.padLength = 64, u.prototype._digest = function (p) { return p === "hex" ? o.toHex32(this.h.slice(0, 7), "big") : o.split32(this.h.slice(0, 7), "big") }, _224 } var _512, hasRequired_512; function require_512() { if (hasRequired_512) return _512; hasRequired_512 = 1; var o = requireUtils(), l = requireCommon$1(), u = requireMinimalisticAssert(), f = o.rotr64_hi, p = o.rotr64_lo, d = o.shr64_hi, m = o.shr64_lo, v = o.sum64, I = o.sum64_hi, F = o.sum64_lo, B = o.sum64_4_hi, W = o.sum64_4_lo, Z = o.sum64_5_hi, Q = o.sum64_5_lo, re = l.BlockHash, ne = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; function oe() { if (!(this instanceof oe)) return new oe; re.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = ne, this.W = new Array(160) } o.inherits(oe, re), _512 = oe, oe.blockSize = 1024, oe.outSize = 512, oe.hmacStrength = 192, oe.padLength = 128, oe.prototype._prepareBlock = function (U, K) { for (var Y = this.W, te = 0; te < 32; te++)Y[te] = U[K + te]; for (; te < Y.length; te += 2) { var ee = ie(Y[te - 4], Y[te - 3]), G = g(Y[te - 4], Y[te - 3]), y = Y[te - 14], X = Y[te - 13], ce = Se(Y[te - 30], Y[te - 29]), me = $e(Y[te - 30], Y[te - 29]), Ae = Y[te - 32], Ie = Y[te - 31]; Y[te] = B(ee, G, y, X, ce, me, Ae, Ie), Y[te + 1] = W(ee, G, y, X, ce, me, Ae, Ie) } }, oe.prototype._update = function (U, K) { this._prepareBlock(U, K); var Y = this.W, te = this.h[0], ee = this.h[1], G = this.h[2], y = this.h[3], X = this.h[4], ce = this.h[5], me = this.h[6], Ae = this.h[7], Ie = this.h[8], Be = this.h[9], Me = this.h[10], De = this.h[11], Ue = this.h[12], Ke = this.h[13], Ve = this.h[14], ke = this.h[15]; u(this.k.length === Y.length); for (var Je = 0; Je < Y.length; Je += 2) { var dt = Ve, lt = ke, ht = ve(Ie, Be), Bt = _e(Ie, Be), mt = ae(Ie, Be, Me, De, Ue), et = se(Ie, Be, Me, De, Ue, Ke), Gt = this.k[Je], pt = this.k[Je + 1], _t = Y[Je], zt = Y[Je + 1], bt = Z(dt, lt, ht, Bt, mt, et, Gt, pt, _t, zt), We = Q(dt, lt, ht, Bt, mt, et, Gt, pt, _t, zt); dt = he(te, ee), lt = pe(te, ee), ht = le(te, ee, G, y, X), Bt = ue(te, ee, G, y, X, ce); var Ge = I(dt, lt, ht, Bt), ze = F(dt, lt, ht, Bt); Ve = Ue, ke = Ke, Ue = Me, Ke = De, Me = Ie, De = Be, Ie = I(me, Ae, bt, We), Be = F(Ae, Ae, bt, We), me = X, Ae = ce, X = G, ce = y, G = te, y = ee, te = I(bt, We, Ge, ze), ee = F(bt, We, Ge, ze) } v(this.h, 0, te, ee), v(this.h, 2, G, y), v(this.h, 4, X, ce), v(this.h, 6, me, Ae), v(this.h, 8, Ie, Be), v(this.h, 10, Me, De), v(this.h, 12, Ue, Ke), v(this.h, 14, Ve, ke) }, oe.prototype._digest = function (U) { return U === "hex" ? o.toHex32(this.h, "big") : o.split32(this.h, "big") }; function ae(P, U, K, Y, te) { var ee = P & K ^ ~P & te; return ee < 0 && (ee += 4294967296), ee } function se(P, U, K, Y, te, ee) { var G = U & Y ^ ~U & ee; return G < 0 && (G += 4294967296), G } function le(P, U, K, Y, te) { var ee = P & K ^ P & te ^ K & te; return ee < 0 && (ee += 4294967296), ee } function ue(P, U, K, Y, te, ee) { var G = U & Y ^ U & ee ^ Y & ee; return G < 0 && (G += 4294967296), G } function he(P, U) { var K = f(P, U, 28), Y = f(U, P, 2), te = f(U, P, 7), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function pe(P, U) { var K = p(P, U, 28), Y = p(U, P, 2), te = p(U, P, 7), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function ve(P, U) { var K = f(P, U, 14), Y = f(P, U, 18), te = f(U, P, 9), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function _e(P, U) { var K = p(P, U, 14), Y = p(P, U, 18), te = p(U, P, 9), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function Se(P, U) { var K = f(P, U, 1), Y = f(P, U, 8), te = d(P, U, 7), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function $e(P, U) { var K = p(P, U, 1), Y = p(P, U, 8), te = m(P, U, 7), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function ie(P, U) { var K = f(P, U, 19), Y = f(U, P, 29), te = d(P, U, 6), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } function g(P, U) { var K = p(P, U, 19), Y = p(U, P, 29), te = m(P, U, 6), ee = K ^ Y ^ te; return ee < 0 && (ee += 4294967296), ee } return _512 } var _384, hasRequired_384; function require_384() { if (hasRequired_384) return _384; hasRequired_384 = 1; var o = requireUtils(), l = require_512(); function u() { if (!(this instanceof u)) return new u; l.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428] } return o.inherits(u, l), _384 = u, u.blockSize = 1024, u.outSize = 384, u.hmacStrength = 192, u.padLength = 128, u.prototype._digest = function (p) { return p === "hex" ? o.toHex32(this.h.slice(0, 12), "big") : o.split32(this.h.slice(0, 12), "big") }, _384 } var hasRequiredSha; function requireSha() { return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha } var ripemd = {}, hasRequiredRipemd; function requireRipemd() { if (hasRequiredRipemd) return ripemd; hasRequiredRipemd = 1; var o = requireUtils(), l = requireCommon$1(), u = o.rotl32, f = o.sum32, p = o.sum32_3, d = o.sum32_4, m = l.BlockHash; function v() { if (!(this instanceof v)) return new v; m.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little" } o.inherits(v, m), ripemd.ripemd160 = v, v.blockSize = 512, v.outSize = 160, v.hmacStrength = 192, v.padLength = 64, v.prototype._update = function (oe, ae) { for (var se = this.h[0], le = this.h[1], ue = this.h[2], he = this.h[3], pe = this.h[4], ve = se, _e = le, Se = ue, $e = he, ie = pe, g = 0; g < 80; g++) { var P = f(u(d(se, I(g, le, ue, he), oe[W[g] + ae], F(g)), Q[g]), pe); se = pe, pe = he, he = u(ue, 10), ue = le, le = P, P = f(u(d(ve, I(79 - g, _e, Se, $e), oe[Z[g] + ae], B(g)), re[g]), ie), ve = ie, ie = $e, $e = u(Se, 10), Se = _e, _e = P } P = p(this.h[1], ue, $e), this.h[1] = p(this.h[2], he, ie), this.h[2] = p(this.h[3], pe, ve), this.h[3] = p(this.h[4], se, _e), this.h[4] = p(this.h[0], le, Se), this.h[0] = P }, v.prototype._digest = function (oe) { return oe === "hex" ? o.toHex32(this.h, "little") : o.split32(this.h, "little") }; function I(ne, oe, ae, se) { return ne <= 15 ? oe ^ ae ^ se : ne <= 31 ? oe & ae | ~oe & se : ne <= 47 ? (oe | ~ae) ^ se : ne <= 63 ? oe & se | ae & ~se : oe ^ (ae | ~se) } function F(ne) { return ne <= 15 ? 0 : ne <= 31 ? 1518500249 : ne <= 47 ? 1859775393 : ne <= 63 ? 2400959708 : 2840853838 } function B(ne) { return ne <= 15 ? 1352829926 : ne <= 31 ? 1548603684 : ne <= 47 ? 1836072691 : ne <= 63 ? 2053994217 : 0 } var W = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Z = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Q = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], re = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]; return ripemd } var hmac, hasRequiredHmac; function requireHmac() { if (hasRequiredHmac) return hmac; hasRequiredHmac = 1; var o = requireUtils(), l = requireMinimalisticAssert(); function u(f, p, d) { if (!(this instanceof u)) return new u(f, p, d); this.Hash = f, this.blockSize = f.blockSize / 8, this.outSize = f.outSize / 8, this.inner = null, this.outer = null, this._init(o.toArray(p, d)) } return hmac = u, u.prototype._init = function (p) { p.length > this.blockSize && (p = new this.Hash().update(p).digest()), l(p.length <= this.blockSize); for (var d = p.length; d < this.blockSize; d++)p.push(0); for (d = 0; d < p.length; d++)p[d] ^= 54; for (this.inner = new this.Hash().update(p), d = 0; d < p.length; d++)p[d] ^= 106; this.outer = new this.Hash().update(p) }, u.prototype.update = function (p, d) { return this.inner.update(p, d), this }, u.prototype.digest = function (p) { return this.outer.update(this.inner.digest()), this.outer.digest(p) }, hmac } var hasRequiredHash; function requireHash() { return hasRequiredHash || (hasRequiredHash = 1, function (o) { var l = o; l.utils = requireUtils(), l.common = requireCommon$1(), l.sha = requireSha(), l.ripemd = requireRipemd(), l.hmac = requireHmac(), l.sha1 = l.sha.sha1, l.sha256 = l.sha.sha256, l.sha224 = l.sha.sha224, l.sha384 = l.sha.sha384, l.sha512 = l.sha.sha512, l.ripemd160 = l.ripemd.ripemd160 }(hash)), hash } var secp256k1, hasRequiredSecp256k1; function requireSecp256k1() { return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } }), secp256k1 } var hasRequiredCurves; function requireCurves() { return hasRequiredCurves || (hasRequiredCurves = 1, function (o) { var l = o, u = requireHash(), f = requireCurve(), p = requireUtils$1(), d = p.assert; function m(F) { F.type === "short" ? this.curve = new f.short(F) : F.type === "edwards" ? this.curve = new f.edwards(F) : this.curve = new f.mont(F), this.g = this.curve.g, this.n = this.curve.n, this.hash = F.hash, d(this.g.validate(), "Invalid curve"), d(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O") } l.PresetCurve = m; function v(F, B) { Object.defineProperty(l, F, { configurable: !0, enumerable: !0, get: function () { var W = new m(B); return Object.defineProperty(l, F, { configurable: !0, enumerable: !0, value: W }), W } }) } v("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: u.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), v("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: u.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), v("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: u.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), v("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: u.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), v("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: u.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), v("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["9"] }), v("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] }); var I; try { I = requireSecp256k1() } catch { I = void 0 } v("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: u.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", I] }) }(curves)), curves } var hmacDrbg, hasRequiredHmacDrbg; function requireHmacDrbg() { if (hasRequiredHmacDrbg) return hmacDrbg; hasRequiredHmacDrbg = 1; var o = requireHash(), l = requireUtils$2(), u = requireMinimalisticAssert(); function f(p) { if (!(this instanceof f)) return new f(p); this.hash = p.hash, this.predResist = !!p.predResist, this.outLen = this.hash.outSize, this.minEntropy = p.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null; var d = l.toArray(p.entropy, p.entropyEnc || "hex"), m = l.toArray(p.nonce, p.nonceEnc || "hex"), v = l.toArray(p.pers, p.persEnc || "hex"); u(d.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(d, m, v) } return hmacDrbg = f, f.prototype._init = function (d, m, v) { var I = d.concat(m).concat(v); this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8); for (var F = 0; F < this.V.length; F++)this.K[F] = 0, this.V[F] = 1; this._update(I), this._reseed = 1, this.reseedInterval = 281474976710656 }, f.prototype._hmac = function () { return new o.hmac(this.hash, this.K) }, f.prototype._update = function (d) { var m = this._hmac().update(this.V).update([0]); d && (m = m.update(d)), this.K = m.digest(), this.V = this._hmac().update(this.V).digest(), d && (this.K = this._hmac().update(this.V).update([1]).update(d).digest(), this.V = this._hmac().update(this.V).digest()) }, f.prototype.reseed = function (d, m, v, I) { typeof m != "string" && (I = v, v = m, m = null), d = l.toArray(d, m), v = l.toArray(v, I), u(d.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(d.concat(v || [])), this._reseed = 1 }, f.prototype.generate = function (d, m, v, I) { if (this._reseed > this.reseedInterval) throw new Error("Reseed is required"); typeof m != "string" && (I = v, v = m, m = null), v && (v = l.toArray(v, I || "hex"), this._update(v)); for (var F = []; F.length < d;)this.V = this._hmac().update(this.V).digest(), F = F.concat(this.V); var B = F.slice(0, d); return this._update(v), this._reseed++, l.encode(B, m) }, hmacDrbg } var key$3, hasRequiredKey$1; function requireKey$1() { if (hasRequiredKey$1) return key$3; hasRequiredKey$1 = 1; var o = requireBn$3(), l = requireUtils$1(), u = l.assert; function f(p, d) { this.ec = p, this.priv = null, this.pub = null, d.priv && this._importPrivate(d.priv, d.privEnc), d.pub && this._importPublic(d.pub, d.pubEnc) } return key$3 = f, f.fromPublic = function (d, m, v) { return m instanceof f ? m : new f(d, { pub: m, pubEnc: v }) }, f.fromPrivate = function (d, m, v) { return m instanceof f ? m : new f(d, { priv: m, privEnc: v }) }, f.prototype.validate = function () { var d = this.getPublic(); return d.isInfinity() ? { result: !1, reason: "Invalid public key" } : d.validate() ? d.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" } }, f.prototype.getPublic = function (d, m) { return typeof d == "string" && (m = d, d = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), m ? this.pub.encode(m, d) : this.pub }, f.prototype.getPrivate = function (d) { return d === "hex" ? this.priv.toString(16, 2) : this.priv }, f.prototype._importPrivate = function (d, m) { this.priv = new o(d, m || 16), this.priv = this.priv.umod(this.ec.curve.n) }, f.prototype._importPublic = function (d, m) { if (d.x || d.y) { this.ec.curve.type === "mont" ? u(d.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && u(d.x && d.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(d.x, d.y); return } this.pub = this.ec.curve.decodePoint(d, m) }, f.prototype.derive = function (d) { return d.validate() || u(d.validate(), "public point not validated"), d.mul(this.priv).getX() }, f.prototype.sign = function (d, m, v) { return this.ec.sign(d, this, m, v) }, f.prototype.verify = function (d, m, v) { return this.ec.verify(d, m, this, void 0, v) }, f.prototype.inspect = function () { return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >" }, key$3 } var signature$1, hasRequiredSignature$1; function requireSignature$1() { if (hasRequiredSignature$1) return signature$1; hasRequiredSignature$1 = 1; var o = requireBn$3(), l = requireUtils$1(), u = l.assert; function f(I, F) { if (I instanceof f) return I; this._importDER(I, F) || (u(I.r && I.s, "Signature without r or s"), this.r = new o(I.r, 16), this.s = new o(I.s, 16), I.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = I.recoveryParam) } signature$1 = f; function p() { this.place = 0 } function d(I, F) { var B = I[F.place++]; if (!(B & 128)) return B; var W = B & 15; if (W === 0 || W > 4 || I[F.place] === 0) return !1; for (var Z = 0, Q = 0, re = F.place; Q < W; Q++, re++)Z <<= 8, Z |= I[re], Z >>>= 0; return Z <= 127 ? !1 : (F.place = re, Z) } function m(I) { for (var F = 0, B = I.length - 1; !I[F] && !(I[F + 1] & 128) && F < B;)F++; return F === 0 ? I : I.slice(F) } f.prototype._importDER = function (F, B) { F = l.toArray(F, B); var W = new p; if (F[W.place++] !== 48) return !1; var Z = d(F, W); if (Z === !1 || Z + W.place !== F.length || F[W.place++] !== 2) return !1; var Q = d(F, W); if (Q === !1 || (F[W.place] & 128) !== 0) return !1; var re = F.slice(W.place, Q + W.place); if (W.place += Q, F[W.place++] !== 2) return !1; var ne = d(F, W); if (ne === !1 || F.length !== ne + W.place || (F[W.place] & 128) !== 0) return !1; var oe = F.slice(W.place, ne + W.place); if (re[0] === 0) if (re[1] & 128) re = re.slice(1); else return !1; if (oe[0] === 0) if (oe[1] & 128) oe = oe.slice(1); else return !1; return this.r = new o(re), this.s = new o(oe), this.recoveryParam = null, !0 }; function v(I, F) { if (F < 128) { I.push(F); return } var B = 1 + (Math.log(F) / Math.LN2 >>> 3); for (I.push(B | 128); --B;)I.push(F >>> (B << 3) & 255); I.push(F) } return f.prototype.toDER = function (F) { var B = this.r.toArray(), W = this.s.toArray(); for (B[0] & 128 && (B = [0].concat(B)), W[0] & 128 && (W = [0].concat(W)), B = m(B), W = m(W); !W[0] && !(W[1] & 128);)W = W.slice(1); var Z = [2]; v(Z, B.length), Z = Z.concat(B), Z.push(2), v(Z, W.length); var Q = Z.concat(W), re = [48]; return v(re, Q.length), re = re.concat(Q), l.encode(re, F) }, signature$1 } var ec, hasRequiredEc; function requireEc() { if (hasRequiredEc) return ec; hasRequiredEc = 1; var o = requireBn$3(), l = requireHmacDrbg(), u = requireUtils$1(), f = requireCurves(), p = requireBrorand(), d = u.assert, m = requireKey$1(), v = requireSignature$1(); function I(F) { if (!(this instanceof I)) return new I(F); typeof F == "string" && (d(Object.prototype.hasOwnProperty.call(f, F), "Unknown curve " + F), F = f[F]), F instanceof f.PresetCurve && (F = { curve: F }), this.curve = F.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = F.curve.g, this.g.precompute(F.curve.n.bitLength() + 1), this.hash = F.hash || F.curve.hash } return ec = I, I.prototype.keyPair = function (B) { return new m(this, B) }, I.prototype.keyFromPrivate = function (B, W) { return m.fromPrivate(this, B, W) }, I.prototype.keyFromPublic = function (B, W) { return m.fromPublic(this, B, W) }, I.prototype.genKeyPair = function (B) { B || (B = {}); for (var W = new l({ hash: this.hash, pers: B.pers, persEnc: B.persEnc || "utf8", entropy: B.entropy || p(this.hash.hmacStrength), entropyEnc: B.entropy && B.entropyEnc || "utf8", nonce: this.n.toArray() }), Z = this.n.byteLength(), Q = this.n.sub(new o(2)); ;) { var re = new o(W.generate(Z)); if (!(re.cmp(Q) > 0)) return re.iaddn(1), this.keyFromPrivate(re) } }, I.prototype._truncateToN = function (B, W, Z) { var Q; if (o.isBN(B) || typeof B == "number") B = new o(B, 16), Q = B.byteLength(); else if (typeof B == "object") Q = B.length, B = new o(B, 16); else { var re = B.toString(); Q = re.length + 1 >>> 1, B = new o(re, 16) } typeof Z != "number" && (Z = Q * 8); var ne = Z - this.n.bitLength(); return ne > 0 && (B = B.ushrn(ne)), !W && B.cmp(this.n) >= 0 ? B.sub(this.n) : B }, I.prototype.sign = function (B, W, Z, Q) { if (typeof Z == "object" && (Q = Z, Z = null), Q || (Q = {}), typeof B != "string" && typeof B != "number" && !o.isBN(B)) { d(typeof B == "object" && B && typeof B.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), d(B.length >>> 0 === B.length); for (var re = 0; re < B.length; re++)d((B[re] & 255) === B[re]) } W = this.keyFromPrivate(W, Z), B = this._truncateToN(B, !1, Q.msgBitLength), d(!B.isNeg(), "Can not sign a negative message"); var ne = this.n.byteLength(), oe = W.getPrivate().toArray("be", ne), ae = B.toArray("be", ne); d(new o(ae).eq(B), "Can not sign message"); for (var se = new l({ hash: this.hash, entropy: oe, nonce: ae, pers: Q.pers, persEnc: Q.persEnc || "utf8" }), le = this.n.sub(new o(1)), ue = 0; ; ue++) { var he = Q.k ? Q.k(ue) : new o(se.generate(this.n.byteLength())); if (he = this._truncateToN(he, !0), !(he.cmpn(1) <= 0 || he.cmp(le) >= 0)) { var pe = this.g.mul(he); if (!pe.isInfinity()) { var ve = pe.getX(), _e = ve.umod(this.n); if (_e.cmpn(0) !== 0) { var Se = he.invm(this.n).mul(_e.mul(W.getPrivate()).iadd(B)); if (Se = Se.umod(this.n), Se.cmpn(0) !== 0) { var $e = (pe.getY().isOdd() ? 1 : 0) | (ve.cmp(_e) !== 0 ? 2 : 0); return Q.canonical && Se.cmp(this.nh) > 0 && (Se = this.n.sub(Se), $e ^= 1), new v({ r: _e, s: Se, recoveryParam: $e }) } } } } } }, I.prototype.verify = function (B, W, Z, Q, re) { re || (re = {}), B = this._truncateToN(B, !1, re.msgBitLength), Z = this.keyFromPublic(Z, Q), W = new v(W, "hex"); var ne = W.r, oe = W.s; if (ne.cmpn(1) < 0 || ne.cmp(this.n) >= 0 || oe.cmpn(1) < 0 || oe.cmp(this.n) >= 0) return !1; var ae = oe.invm(this.n), se = ae.mul(B).umod(this.n), le = ae.mul(ne).umod(this.n), ue; return this.curve._maxwellTrick ? (ue = this.g.jmulAdd(se, Z.getPublic(), le), ue.isInfinity() ? !1 : ue.eqXToP(ne)) : (ue = this.g.mulAdd(se, Z.getPublic(), le), ue.isInfinity() ? !1 : ue.getX().umod(this.n).cmp(ne) === 0) }, I.prototype.recoverPubKey = function (F, B, W, Z) { d((3 & W) === W, "The recovery param is more than two bits"), B = new v(B, Z); var Q = this.n, re = new o(F), ne = B.r, oe = B.s, ae = W & 1, se = W >> 1; if (ne.cmp(this.curve.p.umod(this.curve.n)) >= 0 && se) throw new Error("Unable to find sencond key candinate"); se ? ne = this.curve.pointFromX(ne.add(this.curve.n), ae) : ne = this.curve.pointFromX(ne, ae); var le = B.r.invm(Q), ue = Q.sub(re).mul(le).umod(Q), he = oe.mul(le).umod(Q); return this.g.mulAdd(ue, ne, he) }, I.prototype.getKeyRecoveryParam = function (F, B, W, Z) { if (B = new v(B, Z), B.recoveryParam !== null) return B.recoveryParam; for (var Q = 0; Q < 4; Q++) { var re; try { re = this.recoverPubKey(F, B, Q) } catch { continue } if (re.eq(W)) return Q } throw new Error("Unable to find valid recovery factor") }, ec } var key$2, hasRequiredKey; function requireKey() { if (hasRequiredKey) return key$2; hasRequiredKey = 1; var o = requireUtils$1(), l = o.assert, u = o.parseBytes, f = o.cachedProperty; function p(d, m) { this.eddsa = d, this._secret = u(m.secret), d.isPoint(m.pub) ? this._pub = m.pub : this._pubBytes = u(m.pub) } return p.fromPublic = function (m, v) { return v instanceof p ? v : new p(m, { pub: v }) }, p.fromSecret = function (m, v) { return v instanceof p ? v : new p(m, { secret: v }) }, p.prototype.secret = function () { return this._secret }, f(p, "pubBytes", function () { return this.eddsa.encodePoint(this.pub()) }), f(p, "pub", function () { return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv()) }), f(p, "privBytes", function () { var m = this.eddsa, v = this.hash(), I = m.encodingLength - 1, F = v.slice(0, m.encodingLength); return F[0] &= 248, F[I] &= 127, F[I] |= 64, F }), f(p, "priv", function () { return this.eddsa.decodeInt(this.privBytes()) }), f(p, "hash", function () { return this.eddsa.hash().update(this.secret()).digest() }), f(p, "messagePrefix", function () { return this.hash().slice(this.eddsa.encodingLength) }), p.prototype.sign = function (m) { return l(this._secret, "KeyPair can only verify"), this.eddsa.sign(m, this) }, p.prototype.verify = function (m, v) { return this.eddsa.verify(m, v, this) }, p.prototype.getSecret = function (m) { return l(this._secret, "KeyPair is public only"), o.encode(this.secret(), m) }, p.prototype.getPublic = function (m) { return o.encode(this.pubBytes(), m) }, key$2 = p, key$2 } var signature, hasRequiredSignature; function requireSignature() { if (hasRequiredSignature) return signature; hasRequiredSignature = 1; var o = requireBn$3(), l = requireUtils$1(), u = l.assert, f = l.cachedProperty, p = l.parseBytes; function d(m, v) { this.eddsa = m, typeof v != "object" && (v = p(v)), Array.isArray(v) && (u(v.length === m.encodingLength * 2, "Signature has invalid size"), v = { R: v.slice(0, m.encodingLength), S: v.slice(m.encodingLength) }), u(v.R && v.S, "Signature without R or S"), m.isPoint(v.R) && (this._R = v.R), v.S instanceof o && (this._S = v.S), this._Rencoded = Array.isArray(v.R) ? v.R : v.Rencoded, this._Sencoded = Array.isArray(v.S) ? v.S : v.Sencoded } return f(d, "S", function () { return this.eddsa.decodeInt(this.Sencoded()) }), f(d, "R", function () { return this.eddsa.decodePoint(this.Rencoded()) }), f(d, "Rencoded", function () { return this.eddsa.encodePoint(this.R()) }), f(d, "Sencoded", function () { return this.eddsa.encodeInt(this.S()) }), d.prototype.toBytes = function () { return this.Rencoded().concat(this.Sencoded()) }, d.prototype.toHex = function () { return l.encode(this.toBytes(), "hex").toUpperCase() }, signature = d, signature } var eddsa, hasRequiredEddsa; function requireEddsa() { if (hasRequiredEddsa) return eddsa; hasRequiredEddsa = 1; var o = requireHash(), l = requireCurves(), u = requireUtils$1(), f = u.assert, p = u.parseBytes, d = requireKey(), m = requireSignature(); function v(I) { if (f(I === "ed25519", "only tested with ed25519 so far"), !(this instanceof v)) return new v(I); I = l[I].curve, this.curve = I, this.g = I.g, this.g.precompute(I.n.bitLength() + 1), this.pointClass = I.point().constructor, this.encodingLength = Math.ceil(I.n.bitLength() / 8), this.hash = o.sha512 } return eddsa = v, v.prototype.sign = function (F, B) { F = p(F); var W = this.keyFromSecret(B), Z = this.hashInt(W.messagePrefix(), F), Q = this.g.mul(Z), re = this.encodePoint(Q), ne = this.hashInt(re, W.pubBytes(), F).mul(W.priv()), oe = Z.add(ne).umod(this.curve.n); return this.makeSignature({ R: Q, S: oe, Rencoded: re }) }, v.prototype.verify = function (F, B, W) { if (F = p(F), B = this.makeSignature(B), B.S().gte(B.eddsa.curve.n) || B.S().isNeg()) return !1; var Z = this.keyFromPublic(W), Q = this.hashInt(B.Rencoded(), Z.pubBytes(), F), re = this.g.mul(B.S()), ne = B.R().add(Z.pub().mul(Q)); return ne.eq(re) }, v.prototype.hashInt = function () { for (var F = this.hash(), B = 0; B < arguments.length; B++)F.update(arguments[B]); return u.intFromLE(F.digest()).umod(this.curve.n) }, v.prototype.keyFromPublic = function (F) { return d.fromPublic(this, F) }, v.prototype.keyFromSecret = function (F) { return d.fromSecret(this, F) }, v.prototype.makeSignature = function (F) { return F instanceof m ? F : new m(this, F) }, v.prototype.encodePoint = function (F) { var B = F.getY().toArray("le", this.encodingLength); return B[this.encodingLength - 1] |= F.getX().isOdd() ? 128 : 0, B }, v.prototype.decodePoint = function (F) { F = u.parseBytes(F); var B = F.length - 1, W = F.slice(0, B).concat(F[B] & -129), Z = (F[B] & 128) !== 0, Q = u.intFromLE(W); return this.curve.pointFromY(Q, Z) }, v.prototype.encodeInt = function (F) { return F.toArray("le", this.encodingLength) }, v.prototype.decodeInt = function (F) { return u.intFromLE(F) }, v.prototype.isPoint = function (F) { return F instanceof this.pointClass }, eddsa } var hasRequiredElliptic; function requireElliptic() { return hasRequiredElliptic || (hasRequiredElliptic = 1, function (o) { var l = o; l.version = require$$0.version, l.utils = requireUtils$1(), l.rand = requireBrorand(), l.curve = requireCurve(), l.curves = requireCurves(), l.ec = requireEc(), l.eddsa = requireEddsa() }(elliptic)), elliptic } var asn1$1 = {}, asn1 = {}, bn$5 = { exports: {} }, bn$4 = bn$5.exports, hasRequiredBn$2; function requireBn$2() { return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function (o) { (function (l, u) { function f(ie, g) { if (!ie) throw new Error(g || "Assertion failed") } function p(ie, g) { ie.super_ = g; var P = function () { }; P.prototype = g.prototype, ie.prototype = new P, ie.prototype.constructor = ie } function d(ie, g, P) { if (d.isBN(ie)) return ie; this.negative = 0, this.words = null, this.length = 0, this.red = null, ie !== null && ((g === "le" || g === "be") && (P = g, g = 10), this._init(ie || 0, g || 10, P || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (g) { return g instanceof d ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === d.wordSize && Array.isArray(g.words) }, d.max = function (g, P) { return g.cmp(P) > 0 ? g : P }, d.min = function (g, P) { return g.cmp(P) < 0 ? g : P }, d.prototype._init = function (g, P, U) { if (typeof g == "number") return this._initNumber(g, P, U); if (typeof g == "object") return this._initArray(g, P, U); P === "hex" && (P = 16), f(P === (P | 0) && P >= 2 && P <= 36), g = g.toString().replace(/\s+/g, ""); var K = 0; g[0] === "-" && (K++, this.negative = 1), K < g.length && (P === 16 ? this._parseHex(g, K, U) : (this._parseBase(g, P, K), U === "le" && this._initArray(this.toArray(), P, U))) }, d.prototype._initNumber = function (g, P, U) { g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [g & 67108863, g / 67108864 & 67108863], this.length = 2) : (f(g < 9007199254740992), this.words = [g & 67108863, g / 67108864 & 67108863, 1], this.length = 3), U === "le" && this._initArray(this.toArray(), P, U) }, d.prototype._initArray = function (g, P, U) { if (f(typeof g.length == "number"), g.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(g.length / 3), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y, te, ee = 0; if (U === "be") for (K = g.length - 1, Y = 0; K >= 0; K -= 3)te = g[K] | g[K - 1] << 8 | g[K - 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); else if (U === "le") for (K = 0, Y = 0; K < g.length; K += 3)te = g[K] | g[K + 1] << 8 | g[K + 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); return this.strip() }; function v(ie, g) { var P = ie.charCodeAt(g); return P >= 65 && P <= 70 ? P - 55 : P >= 97 && P <= 102 ? P - 87 : P - 48 & 15 } function I(ie, g, P) { var U = v(ie, P); return P - 1 >= g && (U |= v(ie, P - 1) << 4), U } d.prototype._parseHex = function (g, P, U) { this.length = Math.ceil((g.length - P) / 6), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y = 0, te = 0, ee; if (U === "be") for (K = g.length - 1; K >= P; K -= 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8; else { var G = g.length - P; for (K = G % 2 === 0 ? P + 1 : P; K < g.length; K += 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8 } this.strip() }; function F(ie, g, P, U) { for (var K = 0, Y = Math.min(ie.length, P), te = g; te < Y; te++) { var ee = ie.charCodeAt(te) - 48; K *= U, ee >= 49 ? K += ee - 49 + 10 : ee >= 17 ? K += ee - 17 + 10 : K += ee } return K } d.prototype._parseBase = function (g, P, U) { this.words = [0], this.length = 1; for (var K = 0, Y = 1; Y <= 67108863; Y *= P)K++; K--, Y = Y / P | 0; for (var te = g.length - U, ee = te % K, G = Math.min(te, te - ee) + U, y = 0, X = U; X < G; X += K)y = F(g, X, X + K, P), this.imuln(Y), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y); if (ee !== 0) { var ce = 1; for (y = F(g, X, g.length, P), X = 0; X < ee; X++)ce *= P; this.imuln(ce), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y) } this.strip() }, d.prototype.copy = function (g) { g.words = new Array(this.length); for (var P = 0; P < this.length; P++)g.words[P] = this.words[P]; g.length = this.length, g.negative = this.negative, g.red = this.red }, d.prototype.clone = function () { var g = new d(null); return this.copy(g), g }, d.prototype._expand = function (g) { for (; this.length < g;)this.words[this.length++] = 0; return this }, d.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, d.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var B = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], W = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (g, P) { g = g || 10, P = P | 0 || 1; var U; if (g === 16 || g === "hex") { U = ""; for (var K = 0, Y = 0, te = 0; te < this.length; te++) { var ee = this.words[te], G = ((ee << K | Y) & 16777215).toString(16); Y = ee >>> 24 - K & 16777215, Y !== 0 || te !== this.length - 1 ? U = B[6 - G.length] + G + U : U = G + U, K += 2, K >= 26 && (K -= 26, te--) } for (Y !== 0 && (U = Y.toString(16) + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } if (g === (g | 0) && g >= 2 && g <= 36) { var y = W[g], X = Z[g]; U = ""; var ce = this.clone(); for (ce.negative = 0; !ce.isZero();) { var me = ce.modn(X).toString(g); ce = ce.idivn(X), ce.isZero() ? U = me + U : U = B[y - me.length] + me + U } for (this.isZero() && (U = "0" + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var g = this.words[0]; return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g }, d.prototype.toJSON = function () { return this.toString(16) }, d.prototype.toBuffer = function (g, P) { return f(typeof m < "u"), this.toArrayLike(m, g, P) }, d.prototype.toArray = function (g, P) { return this.toArrayLike(Array, g, P) }, d.prototype.toArrayLike = function (g, P, U) { var K = this.byteLength(), Y = U || Math.max(1, K); f(K <= Y, "byte array longer than desired length"), f(Y > 0, "Requested array length <= 0"), this.strip(); var te = P === "le", ee = new g(Y), G, y, X = this.clone(); if (te) { for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[y] = G; for (; y < Y; y++)ee[y] = 0 } else { for (y = 0; y < Y - K; y++)ee[y] = 0; for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[Y - y - 1] = G } return ee }, Math.clz32 ? d.prototype._countBits = function (g) { return 32 - Math.clz32(g) } : d.prototype._countBits = function (g) { var P = g, U = 0; return P >= 4096 && (U += 13, P >>>= 13), P >= 64 && (U += 7, P >>>= 7), P >= 8 && (U += 4, P >>>= 4), P >= 2 && (U += 2, P >>>= 2), U + P }, d.prototype._zeroBits = function (g) { if (g === 0) return 26; var P = g, U = 0; return (P & 8191) === 0 && (U += 13, P >>>= 13), (P & 127) === 0 && (U += 7, P >>>= 7), (P & 15) === 0 && (U += 4, P >>>= 4), (P & 3) === 0 && (U += 2, P >>>= 2), (P & 1) === 0 && U++, U }, d.prototype.bitLength = function () { var g = this.words[this.length - 1], P = this._countBits(g); return (this.length - 1) * 26 + P }; function Q(ie) { for (var g = new Array(ie.bitLength()), P = 0; P < g.length; P++) { var U = P / 26 | 0, K = P % 26; g[P] = (ie.words[U] & 1 << K) >>> K } return g } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var g = 0, P = 0; P < this.length; P++) { var U = this._zeroBits(this.words[P]); if (g += U, U !== 26) break } return g }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (g) { return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (g) { return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (g) { for (; this.length < g.length;)this.words[this.length++] = 0; for (var P = 0; P < g.length; P++)this.words[P] = this.words[P] | g.words[P]; return this.strip() }, d.prototype.ior = function (g) { return f((this.negative | g.negative) === 0), this.iuor(g) }, d.prototype.or = function (g) { return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this) }, d.prototype.uor = function (g) { return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this) }, d.prototype.iuand = function (g) { var P; this.length > g.length ? P = g : P = this; for (var U = 0; U < P.length; U++)this.words[U] = this.words[U] & g.words[U]; return this.length = P.length, this.strip() }, d.prototype.iand = function (g) { return f((this.negative | g.negative) === 0), this.iuand(g) }, d.prototype.and = function (g) { return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this) }, d.prototype.uand = function (g) { return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this) }, d.prototype.iuxor = function (g) { var P, U; this.length > g.length ? (P = this, U = g) : (P = g, U = this); for (var K = 0; K < U.length; K++)this.words[K] = P.words[K] ^ U.words[K]; if (this !== P) for (; K < P.length; K++)this.words[K] = P.words[K]; return this.length = P.length, this.strip() }, d.prototype.ixor = function (g) { return f((this.negative | g.negative) === 0), this.iuxor(g) }, d.prototype.xor = function (g) { return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this) }, d.prototype.uxor = function (g) { return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this) }, d.prototype.inotn = function (g) { f(typeof g == "number" && g >= 0); var P = Math.ceil(g / 26) | 0, U = g % 26; this._expand(P), U > 0 && P--; for (var K = 0; K < P; K++)this.words[K] = ~this.words[K] & 67108863; return U > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - U), this.strip() }, d.prototype.notn = function (g) { return this.clone().inotn(g) }, d.prototype.setn = function (g, P) { f(typeof g == "number" && g >= 0); var U = g / 26 | 0, K = g % 26; return this._expand(U + 1), P ? this.words[U] = this.words[U] | 1 << K : this.words[U] = this.words[U] & ~(1 << K), this.strip() }, d.prototype.iadd = function (g) { var P; if (this.negative !== 0 && g.negative === 0) return this.negative = 0, P = this.isub(g), this.negative ^= 1, this._normSign(); if (this.negative === 0 && g.negative !== 0) return g.negative = 0, P = this.isub(g), g.negative = 1, P._normSign(); var U, K; this.length > g.length ? (U = this, K = g) : (U = g, K = this); for (var Y = 0, te = 0; te < K.length; te++)P = (U.words[te] | 0) + (K.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; for (; Y !== 0 && te < U.length; te++)P = (U.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; if (this.length = U.length, Y !== 0) this.words[this.length] = Y, this.length++; else if (U !== this) for (; te < U.length; te++)this.words[te] = U.words[te]; return this }, d.prototype.add = function (g) { var P; return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, P = this.sub(g), g.negative ^= 1, P) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = g.sub(this), this.negative = 1, P) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this) }, d.prototype.isub = function (g) { if (g.negative !== 0) { g.negative = 0; var P = this.iadd(g); return g.negative = 1, P._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign(); var U = this.cmp(g); if (U === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var K, Y; U > 0 ? (K = this, Y = g) : (K = g, Y = this); for (var te = 0, ee = 0; ee < Y.length; ee++)P = (K.words[ee] | 0) - (Y.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; for (; te !== 0 && ee < K.length; ee++)P = (K.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; if (te === 0 && ee < K.length && K !== this) for (; ee < K.length; ee++)this.words[ee] = K.words[ee]; return this.length = Math.max(this.length, ee), K !== this && (this.negative = 1), this.strip() }, d.prototype.sub = function (g) { return this.clone().isub(g) }; function re(ie, g, P) { P.negative = g.negative ^ ie.negative; var U = ie.length + g.length | 0; P.length = U, U = U - 1 | 0; var K = ie.words[0] | 0, Y = g.words[0] | 0, te = K * Y, ee = te & 67108863, G = te / 67108864 | 0; P.words[0] = ee; for (var y = 1; y < U; y++) { for (var X = G >>> 26, ce = G & 67108863, me = Math.min(y, g.length - 1), Ae = Math.max(0, y - ie.length + 1); Ae <= me; Ae++) { var Ie = y - Ae | 0; K = ie.words[Ie] | 0, Y = g.words[Ae] | 0, te = K * Y + ce, X += te / 67108864 | 0, ce = te & 67108863 } P.words[y] = ce | 0, G = X | 0 } return G !== 0 ? P.words[y] = G | 0 : P.length--, P.strip() } var ne = function (g, P, U) { var K = g.words, Y = P.words, te = U.words, ee = 0, G, y, X, ce = K[0] | 0, me = ce & 8191, Ae = ce >>> 13, Ie = K[1] | 0, Be = Ie & 8191, Me = Ie >>> 13, De = K[2] | 0, Ue = De & 8191, Ke = De >>> 13, Ve = K[3] | 0, ke = Ve & 8191, Je = Ve >>> 13, dt = K[4] | 0, lt = dt & 8191, ht = dt >>> 13, Bt = K[5] | 0, mt = Bt & 8191, et = Bt >>> 13, Gt = K[6] | 0, pt = Gt & 8191, _t = Gt >>> 13, zt = K[7] | 0, bt = zt & 8191, We = zt >>> 13, Ge = K[8] | 0, ze = Ge & 8191, Ze = Ge >>> 13, ut = K[9] | 0, ye = ut & 8191, ge = ut >>> 13, Ee = Y[0] | 0, Oe = Ee & 8191, je = Ee >>> 13, nt = Y[1] | 0, Xe = nt & 8191, it = nt >>> 13, Tt = Y[2] | 0, tt = Tt & 8191, yt = Tt >>> 13, kt = Y[3] | 0, wt = kt & 8191, Mt = kt >>> 13, tr = Y[4] | 0, St = tr & 8191, gt = tr >>> 13, rr = Y[5] | 0, Le = rr & 8191, xe = rr >>> 13, Ce = Y[6] | 0, Ne = Ce & 8191, Ye = Ce >>> 13, Re = Y[7] | 0, Pe = Re & 8191, qe = Re >>> 13, be = Y[8] | 0, Fe = be & 8191, Qe = be >>> 13, st = Y[9] | 0, rt = st & 8191, ct = st >>> 13; U.negative = g.negative ^ P.negative, U.length = 19, G = Math.imul(me, Oe), y = Math.imul(me, je), y = y + Math.imul(Ae, Oe) | 0, X = Math.imul(Ae, je); var Lt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(Be, Oe), y = Math.imul(Be, je), y = y + Math.imul(Me, Oe) | 0, X = Math.imul(Me, je), G = G + Math.imul(me, Xe) | 0, y = y + Math.imul(me, it) | 0, y = y + Math.imul(Ae, Xe) | 0, X = X + Math.imul(Ae, it) | 0; var It = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(Ue, Oe), y = Math.imul(Ue, je), y = y + Math.imul(Ke, Oe) | 0, X = Math.imul(Ke, je), G = G + Math.imul(Be, Xe) | 0, y = y + Math.imul(Be, it) | 0, y = y + Math.imul(Me, Xe) | 0, X = X + Math.imul(Me, it) | 0, G = G + Math.imul(me, tt) | 0, y = y + Math.imul(me, yt) | 0, y = y + Math.imul(Ae, tt) | 0, X = X + Math.imul(Ae, yt) | 0; var lr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, G = Math.imul(ke, Oe), y = Math.imul(ke, je), y = y + Math.imul(Je, Oe) | 0, X = Math.imul(Je, je), G = G + Math.imul(Ue, Xe) | 0, y = y + Math.imul(Ue, it) | 0, y = y + Math.imul(Ke, Xe) | 0, X = X + Math.imul(Ke, it) | 0, G = G + Math.imul(Be, tt) | 0, y = y + Math.imul(Be, yt) | 0, y = y + Math.imul(Me, tt) | 0, X = X + Math.imul(Me, yt) | 0, G = G + Math.imul(me, wt) | 0, y = y + Math.imul(me, Mt) | 0, y = y + Math.imul(Ae, wt) | 0, X = X + Math.imul(Ae, Mt) | 0; var jt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(lt, Oe), y = Math.imul(lt, je), y = y + Math.imul(ht, Oe) | 0, X = Math.imul(ht, je), G = G + Math.imul(ke, Xe) | 0, y = y + Math.imul(ke, it) | 0, y = y + Math.imul(Je, Xe) | 0, X = X + Math.imul(Je, it) | 0, G = G + Math.imul(Ue, tt) | 0, y = y + Math.imul(Ue, yt) | 0, y = y + Math.imul(Ke, tt) | 0, X = X + Math.imul(Ke, yt) | 0, G = G + Math.imul(Be, wt) | 0, y = y + Math.imul(Be, Mt) | 0, y = y + Math.imul(Me, wt) | 0, X = X + Math.imul(Me, Mt) | 0, G = G + Math.imul(me, St) | 0, y = y + Math.imul(me, gt) | 0, y = y + Math.imul(Ae, St) | 0, X = X + Math.imul(Ae, gt) | 0; var Ft = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(mt, Oe), y = Math.imul(mt, je), y = y + Math.imul(et, Oe) | 0, X = Math.imul(et, je), G = G + Math.imul(lt, Xe) | 0, y = y + Math.imul(lt, it) | 0, y = y + Math.imul(ht, Xe) | 0, X = X + Math.imul(ht, it) | 0, G = G + Math.imul(ke, tt) | 0, y = y + Math.imul(ke, yt) | 0, y = y + Math.imul(Je, tt) | 0, X = X + Math.imul(Je, yt) | 0, G = G + Math.imul(Ue, wt) | 0, y = y + Math.imul(Ue, Mt) | 0, y = y + Math.imul(Ke, wt) | 0, X = X + Math.imul(Ke, Mt) | 0, G = G + Math.imul(Be, St) | 0, y = y + Math.imul(Be, gt) | 0, y = y + Math.imul(Me, St) | 0, X = X + Math.imul(Me, gt) | 0, G = G + Math.imul(me, Le) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(Ae, Le) | 0, X = X + Math.imul(Ae, xe) | 0; var er = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, G = Math.imul(pt, Oe), y = Math.imul(pt, je), y = y + Math.imul(_t, Oe) | 0, X = Math.imul(_t, je), G = G + Math.imul(mt, Xe) | 0, y = y + Math.imul(mt, it) | 0, y = y + Math.imul(et, Xe) | 0, X = X + Math.imul(et, it) | 0, G = G + Math.imul(lt, tt) | 0, y = y + Math.imul(lt, yt) | 0, y = y + Math.imul(ht, tt) | 0, X = X + Math.imul(ht, yt) | 0, G = G + Math.imul(ke, wt) | 0, y = y + Math.imul(ke, Mt) | 0, y = y + Math.imul(Je, wt) | 0, X = X + Math.imul(Je, Mt) | 0, G = G + Math.imul(Ue, St) | 0, y = y + Math.imul(Ue, gt) | 0, y = y + Math.imul(Ke, St) | 0, X = X + Math.imul(Ke, gt) | 0, G = G + Math.imul(Be, Le) | 0, y = y + Math.imul(Be, xe) | 0, y = y + Math.imul(Me, Le) | 0, X = X + Math.imul(Me, xe) | 0, G = G + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Ye) | 0, y = y + Math.imul(Ae, Ne) | 0, X = X + Math.imul(Ae, Ye) | 0; var ar = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, G = Math.imul(bt, Oe), y = Math.imul(bt, je), y = y + Math.imul(We, Oe) | 0, X = Math.imul(We, je), G = G + Math.imul(pt, Xe) | 0, y = y + Math.imul(pt, it) | 0, y = y + Math.imul(_t, Xe) | 0, X = X + Math.imul(_t, it) | 0, G = G + Math.imul(mt, tt) | 0, y = y + Math.imul(mt, yt) | 0, y = y + Math.imul(et, tt) | 0, X = X + Math.imul(et, yt) | 0, G = G + Math.imul(lt, wt) | 0, y = y + Math.imul(lt, Mt) | 0, y = y + Math.imul(ht, wt) | 0, X = X + Math.imul(ht, Mt) | 0, G = G + Math.imul(ke, St) | 0, y = y + Math.imul(ke, gt) | 0, y = y + Math.imul(Je, St) | 0, X = X + Math.imul(Je, gt) | 0, G = G + Math.imul(Ue, Le) | 0, y = y + Math.imul(Ue, xe) | 0, y = y + Math.imul(Ke, Le) | 0, X = X + Math.imul(Ke, xe) | 0, G = G + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, Ye) | 0, y = y + Math.imul(Me, Ne) | 0, X = X + Math.imul(Me, Ye) | 0, G = G + Math.imul(me, Pe) | 0, y = y + Math.imul(me, qe) | 0, y = y + Math.imul(Ae, Pe) | 0, X = X + Math.imul(Ae, qe) | 0; var nr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, G = Math.imul(ze, Oe), y = Math.imul(ze, je), y = y + Math.imul(Ze, Oe) | 0, X = Math.imul(Ze, je), G = G + Math.imul(bt, Xe) | 0, y = y + Math.imul(bt, it) | 0, y = y + Math.imul(We, Xe) | 0, X = X + Math.imul(We, it) | 0, G = G + Math.imul(pt, tt) | 0, y = y + Math.imul(pt, yt) | 0, y = y + Math.imul(_t, tt) | 0, X = X + Math.imul(_t, yt) | 0, G = G + Math.imul(mt, wt) | 0, y = y + Math.imul(mt, Mt) | 0, y = y + Math.imul(et, wt) | 0, X = X + Math.imul(et, Mt) | 0, G = G + Math.imul(lt, St) | 0, y = y + Math.imul(lt, gt) | 0, y = y + Math.imul(ht, St) | 0, X = X + Math.imul(ht, gt) | 0, G = G + Math.imul(ke, Le) | 0, y = y + Math.imul(ke, xe) | 0, y = y + Math.imul(Je, Le) | 0, X = X + Math.imul(Je, xe) | 0, G = G + Math.imul(Ue, Ne) | 0, y = y + Math.imul(Ue, Ye) | 0, y = y + Math.imul(Ke, Ne) | 0, X = X + Math.imul(Ke, Ye) | 0, G = G + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, qe) | 0, y = y + Math.imul(Me, Pe) | 0, X = X + Math.imul(Me, qe) | 0, G = G + Math.imul(me, Fe) | 0, y = y + Math.imul(me, Qe) | 0, y = y + Math.imul(Ae, Fe) | 0, X = X + Math.imul(Ae, Qe) | 0; var ir = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, G = Math.imul(ye, Oe), y = Math.imul(ye, je), y = y + Math.imul(ge, Oe) | 0, X = Math.imul(ge, je), G = G + Math.imul(ze, Xe) | 0, y = y + Math.imul(ze, it) | 0, y = y + Math.imul(Ze, Xe) | 0, X = X + Math.imul(Ze, it) | 0, G = G + Math.imul(bt, tt) | 0, y = y + Math.imul(bt, yt) | 0, y = y + Math.imul(We, tt) | 0, X = X + Math.imul(We, yt) | 0, G = G + Math.imul(pt, wt) | 0, y = y + Math.imul(pt, Mt) | 0, y = y + Math.imul(_t, wt) | 0, X = X + Math.imul(_t, Mt) | 0, G = G + Math.imul(mt, St) | 0, y = y + Math.imul(mt, gt) | 0, y = y + Math.imul(et, St) | 0, X = X + Math.imul(et, gt) | 0, G = G + Math.imul(lt, Le) | 0, y = y + Math.imul(lt, xe) | 0, y = y + Math.imul(ht, Le) | 0, X = X + Math.imul(ht, xe) | 0, G = G + Math.imul(ke, Ne) | 0, y = y + Math.imul(ke, Ye) | 0, y = y + Math.imul(Je, Ne) | 0, X = X + Math.imul(Je, Ye) | 0, G = G + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, qe) | 0, y = y + Math.imul(Ke, Pe) | 0, X = X + Math.imul(Ke, qe) | 0, G = G + Math.imul(Be, Fe) | 0, y = y + Math.imul(Be, Qe) | 0, y = y + Math.imul(Me, Fe) | 0, X = X + Math.imul(Me, Qe) | 0, G = G + Math.imul(me, rt) | 0, y = y + Math.imul(me, ct) | 0, y = y + Math.imul(Ae, rt) | 0, X = X + Math.imul(Ae, ct) | 0; var Ht = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(ye, Xe), y = Math.imul(ye, it), y = y + Math.imul(ge, Xe) | 0, X = Math.imul(ge, it), G = G + Math.imul(ze, tt) | 0, y = y + Math.imul(ze, yt) | 0, y = y + Math.imul(Ze, tt) | 0, X = X + Math.imul(Ze, yt) | 0, G = G + Math.imul(bt, wt) | 0, y = y + Math.imul(bt, Mt) | 0, y = y + Math.imul(We, wt) | 0, X = X + Math.imul(We, Mt) | 0, G = G + Math.imul(pt, St) | 0, y = y + Math.imul(pt, gt) | 0, y = y + Math.imul(_t, St) | 0, X = X + Math.imul(_t, gt) | 0, G = G + Math.imul(mt, Le) | 0, y = y + Math.imul(mt, xe) | 0, y = y + Math.imul(et, Le) | 0, X = X + Math.imul(et, xe) | 0, G = G + Math.imul(lt, Ne) | 0, y = y + Math.imul(lt, Ye) | 0, y = y + Math.imul(ht, Ne) | 0, X = X + Math.imul(ht, Ye) | 0, G = G + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, qe) | 0, y = y + Math.imul(Je, Pe) | 0, X = X + Math.imul(Je, qe) | 0, G = G + Math.imul(Ue, Fe) | 0, y = y + Math.imul(Ue, Qe) | 0, y = y + Math.imul(Ke, Fe) | 0, X = X + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, ct) | 0, y = y + Math.imul(Me, rt) | 0, X = X + Math.imul(Me, ct) | 0; var sr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, G = Math.imul(ye, tt), y = Math.imul(ye, yt), y = y + Math.imul(ge, tt) | 0, X = Math.imul(ge, yt), G = G + Math.imul(ze, wt) | 0, y = y + Math.imul(ze, Mt) | 0, y = y + Math.imul(Ze, wt) | 0, X = X + Math.imul(Ze, Mt) | 0, G = G + Math.imul(bt, St) | 0, y = y + Math.imul(bt, gt) | 0, y = y + Math.imul(We, St) | 0, X = X + Math.imul(We, gt) | 0, G = G + Math.imul(pt, Le) | 0, y = y + Math.imul(pt, xe) | 0, y = y + Math.imul(_t, Le) | 0, X = X + Math.imul(_t, xe) | 0, G = G + Math.imul(mt, Ne) | 0, y = y + Math.imul(mt, Ye) | 0, y = y + Math.imul(et, Ne) | 0, X = X + Math.imul(et, Ye) | 0, G = G + Math.imul(lt, Pe) | 0, y = y + Math.imul(lt, qe) | 0, y = y + Math.imul(ht, Pe) | 0, X = X + Math.imul(ht, qe) | 0, G = G + Math.imul(ke, Fe) | 0, y = y + Math.imul(ke, Qe) | 0, y = y + Math.imul(Je, Fe) | 0, X = X + Math.imul(Je, Qe) | 0, G = G + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ke, rt) | 0, X = X + Math.imul(Ke, ct) | 0; var Kt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, G = Math.imul(ye, wt), y = Math.imul(ye, Mt), y = y + Math.imul(ge, wt) | 0, X = Math.imul(ge, Mt), G = G + Math.imul(ze, St) | 0, y = y + Math.imul(ze, gt) | 0, y = y + Math.imul(Ze, St) | 0, X = X + Math.imul(Ze, gt) | 0, G = G + Math.imul(bt, Le) | 0, y = y + Math.imul(bt, xe) | 0, y = y + Math.imul(We, Le) | 0, X = X + Math.imul(We, xe) | 0, G = G + Math.imul(pt, Ne) | 0, y = y + Math.imul(pt, Ye) | 0, y = y + Math.imul(_t, Ne) | 0, X = X + Math.imul(_t, Ye) | 0, G = G + Math.imul(mt, Pe) | 0, y = y + Math.imul(mt, qe) | 0, y = y + Math.imul(et, Pe) | 0, X = X + Math.imul(et, qe) | 0, G = G + Math.imul(lt, Fe) | 0, y = y + Math.imul(lt, Qe) | 0, y = y + Math.imul(ht, Fe) | 0, X = X + Math.imul(ht, Qe) | 0, G = G + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, ct) | 0, y = y + Math.imul(Je, rt) | 0, X = X + Math.imul(Je, ct) | 0; var Qt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, G = Math.imul(ye, St), y = Math.imul(ye, gt), y = y + Math.imul(ge, St) | 0, X = Math.imul(ge, gt), G = G + Math.imul(ze, Le) | 0, y = y + Math.imul(ze, xe) | 0, y = y + Math.imul(Ze, Le) | 0, X = X + Math.imul(Ze, xe) | 0, G = G + Math.imul(bt, Ne) | 0, y = y + Math.imul(bt, Ye) | 0, y = y + Math.imul(We, Ne) | 0, X = X + Math.imul(We, Ye) | 0, G = G + Math.imul(pt, Pe) | 0, y = y + Math.imul(pt, qe) | 0, y = y + Math.imul(_t, Pe) | 0, X = X + Math.imul(_t, qe) | 0, G = G + Math.imul(mt, Fe) | 0, y = y + Math.imul(mt, Qe) | 0, y = y + Math.imul(et, Fe) | 0, X = X + Math.imul(et, Qe) | 0, G = G + Math.imul(lt, rt) | 0, y = y + Math.imul(lt, ct) | 0, y = y + Math.imul(ht, rt) | 0, X = X + Math.imul(ht, ct) | 0; var $t = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, G = Math.imul(ye, Le), y = Math.imul(ye, xe), y = y + Math.imul(ge, Le) | 0, X = Math.imul(ge, xe), G = G + Math.imul(ze, Ne) | 0, y = y + Math.imul(ze, Ye) | 0, y = y + Math.imul(Ze, Ne) | 0, X = X + Math.imul(Ze, Ye) | 0, G = G + Math.imul(bt, Pe) | 0, y = y + Math.imul(bt, qe) | 0, y = y + Math.imul(We, Pe) | 0, X = X + Math.imul(We, qe) | 0, G = G + Math.imul(pt, Fe) | 0, y = y + Math.imul(pt, Qe) | 0, y = y + Math.imul(_t, Fe) | 0, X = X + Math.imul(_t, Qe) | 0, G = G + Math.imul(mt, rt) | 0, y = y + Math.imul(mt, ct) | 0, y = y + Math.imul(et, rt) | 0, X = X + Math.imul(et, ct) | 0; var Yt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, G = Math.imul(ye, Ne), y = Math.imul(ye, Ye), y = y + Math.imul(ge, Ne) | 0, X = Math.imul(ge, Ye), G = G + Math.imul(ze, Pe) | 0, y = y + Math.imul(ze, qe) | 0, y = y + Math.imul(Ze, Pe) | 0, X = X + Math.imul(Ze, qe) | 0, G = G + Math.imul(bt, Fe) | 0, y = y + Math.imul(bt, Qe) | 0, y = y + Math.imul(We, Fe) | 0, X = X + Math.imul(We, Qe) | 0, G = G + Math.imul(pt, rt) | 0, y = y + Math.imul(pt, ct) | 0, y = y + Math.imul(_t, rt) | 0, X = X + Math.imul(_t, ct) | 0; var Xt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, G = Math.imul(ye, Pe), y = Math.imul(ye, qe), y = y + Math.imul(ge, Pe) | 0, X = Math.imul(ge, qe), G = G + Math.imul(ze, Fe) | 0, y = y + Math.imul(ze, Qe) | 0, y = y + Math.imul(Ze, Fe) | 0, X = X + Math.imul(Ze, Qe) | 0, G = G + Math.imul(bt, rt) | 0, y = y + Math.imul(bt, ct) | 0, y = y + Math.imul(We, rt) | 0, X = X + Math.imul(We, ct) | 0; var Nt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ye, Fe), y = Math.imul(ye, Qe), y = y + Math.imul(ge, Fe) | 0, X = Math.imul(ge, Qe), G = G + Math.imul(ze, rt) | 0, y = y + Math.imul(ze, ct) | 0, y = y + Math.imul(Ze, rt) | 0, X = X + Math.imul(Ze, ct) | 0; var Et = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, G = Math.imul(ye, rt), y = Math.imul(ye, ct), y = y + Math.imul(ge, rt) | 0, X = Math.imul(ge, ct); var At = (ee + G | 0) + ((y & 8191) << 13) | 0; return ee = (X + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, te[0] = Lt, te[1] = It, te[2] = lr, te[3] = jt, te[4] = Ft, te[5] = er, te[6] = ar, te[7] = nr, te[8] = ir, te[9] = Ht, te[10] = sr, te[11] = Kt, te[12] = Qt, te[13] = $t, te[14] = Yt, te[15] = Xt, te[16] = Nt, te[17] = Et, te[18] = At, ee !== 0 && (te[19] = ee, U.length++), U }; Math.imul || (ne = re); function oe(ie, g, P) { P.negative = g.negative ^ ie.negative, P.length = ie.length + g.length; for (var U = 0, K = 0, Y = 0; Y < P.length - 1; Y++) { var te = K; K = 0; for (var ee = U & 67108863, G = Math.min(Y, g.length - 1), y = Math.max(0, Y - ie.length + 1); y <= G; y++) { var X = Y - y, ce = ie.words[X] | 0, me = g.words[y] | 0, Ae = ce * me, Ie = Ae & 67108863; te = te + (Ae / 67108864 | 0) | 0, Ie = Ie + ee | 0, ee = Ie & 67108863, te = te + (Ie >>> 26) | 0, K += te >>> 26, te &= 67108863 } P.words[Y] = ee, U = te, te = K } return U !== 0 ? P.words[Y] = U : P.length--, P.strip() } function ae(ie, g, P) { var U = new se; return U.mulp(ie, g, P) } d.prototype.mulTo = function (g, P) { var U, K = this.length + g.length; return this.length === 10 && g.length === 10 ? U = ne(this, g, P) : K < 63 ? U = re(this, g, P) : K < 1024 ? U = oe(this, g, P) : U = ae(this, g, P), U }; function se(ie, g) { this.x = ie, this.y = g } se.prototype.makeRBT = function (g) { for (var P = new Array(g), U = d.prototype._countBits(g) - 1, K = 0; K < g; K++)P[K] = this.revBin(K, U, g); return P }, se.prototype.revBin = function (g, P, U) { if (g === 0 || g === U - 1) return g; for (var K = 0, Y = 0; Y < P; Y++)K |= (g & 1) << P - Y - 1, g >>= 1; return K }, se.prototype.permute = function (g, P, U, K, Y, te) { for (var ee = 0; ee < te; ee++)K[ee] = P[g[ee]], Y[ee] = U[g[ee]] }, se.prototype.transform = function (g, P, U, K, Y, te) { this.permute(te, g, P, U, K, Y); for (var ee = 1; ee < Y; ee <<= 1)for (var G = ee << 1, y = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), ce = 0; ce < Y; ce += G)for (var me = y, Ae = X, Ie = 0; Ie < ee; Ie++) { var Be = U[ce + Ie], Me = K[ce + Ie], De = U[ce + Ie + ee], Ue = K[ce + Ie + ee], Ke = me * De - Ae * Ue; Ue = me * Ue + Ae * De, De = Ke, U[ce + Ie] = Be + De, K[ce + Ie] = Me + Ue, U[ce + Ie + ee] = Be - De, K[ce + Ie + ee] = Me - Ue, Ie !== G && (Ke = y * me - X * Ae, Ae = y * Ae + X * me, me = Ke) } }, se.prototype.guessLen13b = function (g, P) { var U = Math.max(P, g) | 1, K = U & 1, Y = 0; for (U = U / 2 | 0; U; U = U >>> 1)Y++; return 1 << Y + 1 + K }, se.prototype.conjugate = function (g, P, U) { if (!(U <= 1)) for (var K = 0; K < U / 2; K++) { var Y = g[K]; g[K] = g[U - K - 1], g[U - K - 1] = Y, Y = P[K], P[K] = -P[U - K - 1], P[U - K - 1] = -Y } }, se.prototype.normalize13b = function (g, P) { for (var U = 0, K = 0; K < P / 2; K++) { var Y = Math.round(g[2 * K + 1] / P) * 8192 + Math.round(g[2 * K] / P) + U; g[K] = Y & 67108863, Y < 67108864 ? U = 0 : U = Y / 67108864 | 0 } return g }, se.prototype.convert13b = function (g, P, U, K) { for (var Y = 0, te = 0; te < P; te++)Y = Y + (g[te] | 0), U[2 * te] = Y & 8191, Y = Y >>> 13, U[2 * te + 1] = Y & 8191, Y = Y >>> 13; for (te = 2 * P; te < K; ++te)U[te] = 0; f(Y === 0), f((Y & -8192) === 0) }, se.prototype.stub = function (g) { for (var P = new Array(g), U = 0; U < g; U++)P[U] = 0; return P }, se.prototype.mulp = function (g, P, U) { var K = 2 * this.guessLen13b(g.length, P.length), Y = this.makeRBT(K), te = this.stub(K), ee = new Array(K), G = new Array(K), y = new Array(K), X = new Array(K), ce = new Array(K), me = new Array(K), Ae = U.words; Ae.length = K, this.convert13b(g.words, g.length, ee, K), this.convert13b(P.words, P.length, X, K), this.transform(ee, te, G, y, K, Y), this.transform(X, te, ce, me, K, Y); for (var Ie = 0; Ie < K; Ie++) { var Be = G[Ie] * ce[Ie] - y[Ie] * me[Ie]; y[Ie] = G[Ie] * me[Ie] + y[Ie] * ce[Ie], G[Ie] = Be } return this.conjugate(G, y, K), this.transform(G, y, Ae, te, K, Y), this.conjugate(Ae, te, K), this.normalize13b(Ae, K), U.negative = g.negative ^ P.negative, U.length = g.length + P.length, U.strip() }, d.prototype.mul = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), this.mulTo(g, P) }, d.prototype.mulf = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), ae(this, g, P) }, d.prototype.imul = function (g) { return this.clone().mulTo(g, this) }, d.prototype.imuln = function (g) { f(typeof g == "number"), f(g < 67108864); for (var P = 0, U = 0; U < this.length; U++) { var K = (this.words[U] | 0) * g, Y = (K & 67108863) + (P & 67108863); P >>= 26, P += K / 67108864 | 0, P += Y >>> 26, this.words[U] = Y & 67108863 } return P !== 0 && (this.words[U] = P, this.length++), this }, d.prototype.muln = function (g) { return this.clone().imuln(g) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (g) { var P = Q(g); if (P.length === 0) return new d(1); for (var U = this, K = 0; K < P.length && P[K] === 0; K++, U = U.sqr()); if (++K < P.length) for (var Y = U.sqr(); K < P.length; K++, Y = Y.sqr())P[K] !== 0 && (U = U.mul(Y)); return U }, d.prototype.iushln = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 67108863 >>> 26 - P << 26 - P, Y; if (P !== 0) { var te = 0; for (Y = 0; Y < this.length; Y++) { var ee = this.words[Y] & K, G = (this.words[Y] | 0) - ee << P; this.words[Y] = G | te, te = ee >>> 26 - P } te && (this.words[Y] = te, this.length++) } if (U !== 0) { for (Y = this.length - 1; Y >= 0; Y--)this.words[Y + U] = this.words[Y]; for (Y = 0; Y < U; Y++)this.words[Y] = 0; this.length += U } return this.strip() }, d.prototype.ishln = function (g) { return f(this.negative === 0), this.iushln(g) }, d.prototype.iushrn = function (g, P, U) { f(typeof g == "number" && g >= 0); var K; P ? K = (P - P % 26) / 26 : K = 0; var Y = g % 26, te = Math.min((g - Y) / 26, this.length), ee = 67108863 ^ 67108863 >>> Y << Y, G = U; if (K -= te, K = Math.max(0, K), G) { for (var y = 0; y < te; y++)G.words[y] = this.words[y]; G.length = te } if (te !== 0) if (this.length > te) for (this.length -= te, y = 0; y < this.length; y++)this.words[y] = this.words[y + te]; else this.words[0] = 0, this.length = 1; var X = 0; for (y = this.length - 1; y >= 0 && (X !== 0 || y >= K); y--) { var ce = this.words[y] | 0; this.words[y] = X << 26 - Y | ce >>> Y, X = ce & ee } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, d.prototype.ishrn = function (g, P, U) { return f(this.negative === 0), this.iushrn(g, P, U) }, d.prototype.shln = function (g) { return this.clone().ishln(g) }, d.prototype.ushln = function (g) { return this.clone().iushln(g) }, d.prototype.shrn = function (g) { return this.clone().ishrn(g) }, d.prototype.ushrn = function (g) { return this.clone().iushrn(g) }, d.prototype.testn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return !1; var Y = this.words[U]; return !!(Y & K) }, d.prototype.imaskn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U) return this; if (P !== 0 && U++, this.length = Math.min(U, this.length), P !== 0) { var K = 67108863 ^ 67108863 >>> P << P; this.words[this.length - 1] &= K } return this.strip() }, d.prototype.maskn = function (g) { return this.clone().imaskn(g) }, d.prototype.iaddn = function (g) { return f(typeof g == "number"), f(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g) }, d.prototype._iaddn = function (g) { this.words[0] += g; for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++; return this.length = Math.max(this.length, P + 1), this }, d.prototype.isubn = function (g) { if (f(typeof g == "number"), f(g < 67108864), g < 0) return this.iaddn(-g); if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this; if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var P = 0; P < this.length && this.words[P] < 0; P++)this.words[P] += 67108864, this.words[P + 1] -= 1; return this.strip() }, d.prototype.addn = function (g) { return this.clone().iaddn(g) }, d.prototype.subn = function (g) { return this.clone().isubn(g) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (g, P, U) { var K = g.length + U, Y; this._expand(K); var te, ee = 0; for (Y = 0; Y < g.length; Y++) { te = (this.words[Y + U] | 0) + ee; var G = (g.words[Y] | 0) * P; te -= G & 67108863, ee = (te >> 26) - (G / 67108864 | 0), this.words[Y + U] = te & 67108863 } for (; Y < this.length - U; Y++)te = (this.words[Y + U] | 0) + ee, ee = te >> 26, this.words[Y + U] = te & 67108863; if (ee === 0) return this.strip(); for (f(ee === -1), ee = 0, Y = 0; Y < this.length; Y++)te = -(this.words[Y] | 0) + ee, ee = te >> 26, this.words[Y] = te & 67108863; return this.negative = 1, this.strip() }, d.prototype._wordDiv = function (g, P) { var U = this.length - g.length, K = this.clone(), Y = g, te = Y.words[Y.length - 1] | 0, ee = this._countBits(te); U = 26 - ee, U !== 0 && (Y = Y.ushln(U), K.iushln(U), te = Y.words[Y.length - 1] | 0); var G = K.length - Y.length, y; if (P !== "mod") { y = new d(null), y.length = G + 1, y.words = new Array(y.length); for (var X = 0; X < y.length; X++)y.words[X] = 0 } var ce = K.clone()._ishlnsubmul(Y, 1, G); ce.negative === 0 && (K = ce, y && (y.words[G] = 1)); for (var me = G - 1; me >= 0; me--) { var Ae = (K.words[Y.length + me] | 0) * 67108864 + (K.words[Y.length + me - 1] | 0); for (Ae = Math.min(Ae / te | 0, 67108863), K._ishlnsubmul(Y, Ae, me); K.negative !== 0;)Ae--, K.negative = 0, K._ishlnsubmul(Y, 1, me), K.isZero() || (K.negative ^= 1); y && (y.words[me] = Ae) } return y && y.strip(), K.strip(), P !== "div" && U !== 0 && K.iushrn(U), { div: y || null, mod: K } }, d.prototype.divmod = function (g, P, U) { if (f(!g.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var K, Y, te; return this.negative !== 0 && g.negative === 0 ? (te = this.neg().divmod(g, P), P !== "mod" && (K = te.div.neg()), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.iadd(g)), { div: K, mod: Y }) : this.negative === 0 && g.negative !== 0 ? (te = this.divmod(g.neg(), P), P !== "mod" && (K = te.div.neg()), { div: K, mod: te.mod }) : (this.negative & g.negative) !== 0 ? (te = this.neg().divmod(g.neg(), P), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.isub(g)), { div: te.div, mod: Y }) : g.length > this.length || this.cmp(g) < 0 ? { div: new d(0), mod: this } : g.length === 1 ? P === "div" ? { div: this.divn(g.words[0]), mod: null } : P === "mod" ? { div: null, mod: new d(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new d(this.modn(g.words[0])) } : this._wordDiv(g, P) }, d.prototype.div = function (g) { return this.divmod(g, "div", !1).div }, d.prototype.mod = function (g) { return this.divmod(g, "mod", !1).mod }, d.prototype.umod = function (g) { return this.divmod(g, "mod", !0).mod }, d.prototype.divRound = function (g) { var P = this.divmod(g); if (P.mod.isZero()) return P.div; var U = P.div.negative !== 0 ? P.mod.isub(g) : P.mod, K = g.ushrn(1), Y = g.andln(1), te = U.cmp(K); return te < 0 || Y === 1 && te === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1) }, d.prototype.modn = function (g) { f(g <= 67108863); for (var P = (1 << 26) % g, U = 0, K = this.length - 1; K >= 0; K--)U = (P * U + (this.words[K] | 0)) % g; return U }, d.prototype.idivn = function (g) { f(g <= 67108863); for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = (this.words[U] | 0) + P * 67108864; this.words[U] = K / g | 0, P = K % g } return this.strip() }, d.prototype.divn = function (g) { return this.clone().idivn(g) }, d.prototype.egcd = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = new d(0), ee = new d(1), G = 0; P.isEven() && U.isEven();)P.iushrn(1), U.iushrn(1), ++G; for (var y = U.clone(), X = P.clone(); !P.isZero();) { for (var ce = 0, me = 1; (P.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (P.iushrn(ce); ce-- > 0;)(K.isOdd() || Y.isOdd()) && (K.iadd(y), Y.isub(X)), K.iushrn(1), Y.iushrn(1); for (var Ae = 0, Ie = 1; (U.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (U.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(y), ee.isub(X)), te.iushrn(1), ee.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(te), Y.isub(ee)) : (U.isub(P), te.isub(K), ee.isub(Y)) } return { a: te, b: ee, gcd: U.iushln(G) } }, d.prototype._invmp = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = U.clone(); P.cmpn(1) > 0 && U.cmpn(1) > 0;) { for (var ee = 0, G = 1; (P.words[0] & G) === 0 && ee < 26; ++ee, G <<= 1); if (ee > 0) for (P.iushrn(ee); ee-- > 0;)K.isOdd() && K.iadd(te), K.iushrn(1); for (var y = 0, X = 1; (U.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (U.iushrn(y); y-- > 0;)Y.isOdd() && Y.iadd(te), Y.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(Y)) : (U.isub(P), Y.isub(K)) } var ce; return P.cmpn(1) === 0 ? ce = K : ce = Y, ce.cmpn(0) < 0 && ce.iadd(g), ce }, d.prototype.gcd = function (g) { if (this.isZero()) return g.abs(); if (g.isZero()) return this.abs(); var P = this.clone(), U = g.clone(); P.negative = 0, U.negative = 0; for (var K = 0; P.isEven() && U.isEven(); K++)P.iushrn(1), U.iushrn(1); do { for (; P.isEven();)P.iushrn(1); for (; U.isEven();)U.iushrn(1); var Y = P.cmp(U); if (Y < 0) { var te = P; P = U, U = te } else if (Y === 0 || U.cmpn(1) === 0) break; P.isub(U) } while (!0); return U.iushln(K) }, d.prototype.invm = function (g) { return this.egcd(g).a.umod(g) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (g) { return this.words[0] & g }, d.prototype.bincn = function (g) { f(typeof g == "number"); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return this._expand(U + 1), this.words[U] |= K, this; for (var Y = K, te = U; Y !== 0 && te < this.length; te++) { var ee = this.words[te] | 0; ee += Y, Y = ee >>> 26, ee &= 67108863, this.words[te] = ee } return Y !== 0 && (this.words[te] = Y, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (g) { var P = g < 0; if (this.negative !== 0 && !P) return -1; if (this.negative === 0 && P) return 1; this.strip(); var U; if (this.length > 1) U = 1; else { P && (g = -g), f(g <= 67108863, "Number is too big"); var K = this.words[0] | 0; U = K === g ? 0 : K < g ? -1 : 1 } return this.negative !== 0 ? -U | 0 : U }, d.prototype.cmp = function (g) { if (this.negative !== 0 && g.negative === 0) return -1; if (this.negative === 0 && g.negative !== 0) return 1; var P = this.ucmp(g); return this.negative !== 0 ? -P | 0 : P }, d.prototype.ucmp = function (g) { if (this.length > g.length) return 1; if (this.length < g.length) return -1; for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = this.words[U] | 0, Y = g.words[U] | 0; if (K !== Y) { K < Y ? P = -1 : K > Y && (P = 1); break } } return P }, d.prototype.gtn = function (g) { return this.cmpn(g) === 1 }, d.prototype.gt = function (g) { return this.cmp(g) === 1 }, d.prototype.gten = function (g) { return this.cmpn(g) >= 0 }, d.prototype.gte = function (g) { return this.cmp(g) >= 0 }, d.prototype.ltn = function (g) { return this.cmpn(g) === -1 }, d.prototype.lt = function (g) { return this.cmp(g) === -1 }, d.prototype.lten = function (g) { return this.cmpn(g) <= 0 }, d.prototype.lte = function (g) { return this.cmp(g) <= 0 }, d.prototype.eqn = function (g) { return this.cmpn(g) === 0 }, d.prototype.eq = function (g) { return this.cmp(g) === 0 }, d.red = function (g) { return new Se(g) }, d.prototype.toRed = function (g) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (g) { return this.red = g, this }, d.prototype.forceRed = function (g) { return f(!this.red, "Already a number in reduction context"), this._forceRed(g) }, d.prototype.redAdd = function (g) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, g) }, d.prototype.redIAdd = function (g) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g) }, d.prototype.redSub = function (g) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, g) }, d.prototype.redISub = function (g) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, g) }, d.prototype.redShl = function (g) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, g) }, d.prototype.redMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g) }, d.prototype.redIMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (g) { return f(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g) }; var le = { k256: null, p224: null, p192: null, p25519: null }; function ue(ie, g) { this.name = ie, this.p = new d(g, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } ue.prototype._tmp = function () { var g = new d(null); return g.words = new Array(Math.ceil(this.n / 13)), g }, ue.prototype.ireduce = function (g) { var P = g, U; do this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), U = P.bitLength(); while (U > this.n); var K = U < this.n ? -1 : P.ucmp(this.p); return K === 0 ? (P.words[0] = 0, P.length = 1) : K > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P }, ue.prototype.split = function (g, P) { g.iushrn(this.n, 0, P) }, ue.prototype.imulK = function (g) { return g.imul(this.k) }; function he() { ue.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(he, ue), he.prototype.split = function (g, P) { for (var U = 4194303, K = Math.min(g.length, 9), Y = 0; Y < K; Y++)P.words[Y] = g.words[Y]; if (P.length = K, g.length <= 9) { g.words[0] = 0, g.length = 1; return } var te = g.words[9]; for (P.words[P.length++] = te & U, Y = 10; Y < g.length; Y++) { var ee = g.words[Y] | 0; g.words[Y - 10] = (ee & U) << 4 | te >>> 22, te = ee } te >>>= 22, g.words[Y - 10] = te, te === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9 }, he.prototype.imulK = function (g) { g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2; for (var P = 0, U = 0; U < g.length; U++) { var K = g.words[U] | 0; P += K * 977, g.words[U] = P & 67108863, P = K * 64 + (P / 67108864 | 0) } return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g }; function pe() { ue.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(pe, ue); function ve() { ue.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(ve, ue); function _e() { ue.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p(_e, ue), _e.prototype.imulK = function (g) { for (var P = 0, U = 0; U < g.length; U++) { var K = (g.words[U] | 0) * 19 + P, Y = K & 67108863; K >>>= 26, g.words[U] = Y, P = K } return P !== 0 && (g.words[g.length++] = P), g }, d._prime = function (g) { if (le[g]) return le[g]; var P; if (g === "k256") P = new he; else if (g === "p224") P = new pe; else if (g === "p192") P = new ve; else if (g === "p25519") P = new _e; else throw new Error("Unknown prime " + g); return le[g] = P, P }; function Se(ie) { if (typeof ie == "string") { var g = d._prime(ie); this.m = g.p, this.prime = g } else f(ie.gtn(1), "modulus must be greater than 1"), this.m = ie, this.prime = null } Se.prototype._verify1 = function (g) { f(g.negative === 0, "red works only with positives"), f(g.red, "red works only with red numbers") }, Se.prototype._verify2 = function (g, P) { f((g.negative | P.negative) === 0, "red works only with positives"), f(g.red && g.red === P.red, "red works only with red numbers") }, Se.prototype.imod = function (g) { return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this) }, Se.prototype.neg = function (g) { return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this) }, Se.prototype.add = function (g, P) { this._verify2(g, P); var U = g.add(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this) }, Se.prototype.iadd = function (g, P) { this._verify2(g, P); var U = g.iadd(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U }, Se.prototype.sub = function (g, P) { this._verify2(g, P); var U = g.sub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this) }, Se.prototype.isub = function (g, P) { this._verify2(g, P); var U = g.isub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U }, Se.prototype.shl = function (g, P) { return this._verify1(g), this.imod(g.ushln(P)) }, Se.prototype.imul = function (g, P) { return this._verify2(g, P), this.imod(g.imul(P)) }, Se.prototype.mul = function (g, P) { return this._verify2(g, P), this.imod(g.mul(P)) }, Se.prototype.isqr = function (g) { return this.imul(g, g.clone()) }, Se.prototype.sqr = function (g) { return this.mul(g, g) }, Se.prototype.sqrt = function (g) { if (g.isZero()) return g.clone(); var P = this.m.andln(3); if (f(P % 2 === 1), P === 3) { var U = this.m.add(new d(1)).iushrn(2); return this.pow(g, U) } for (var K = this.m.subn(1), Y = 0; !K.isZero() && K.andln(1) === 0;)Y++, K.iushrn(1); f(!K.isZero()); var te = new d(1).toRed(this), ee = te.redNeg(), G = this.m.subn(1).iushrn(1), y = this.m.bitLength(); for (y = new d(2 * y * y).toRed(this); this.pow(y, G).cmp(ee) !== 0;)y.redIAdd(ee); for (var X = this.pow(y, K), ce = this.pow(g, K.addn(1).iushrn(1)), me = this.pow(g, K), Ae = Y; me.cmp(te) !== 0;) { for (var Ie = me, Be = 0; Ie.cmp(te) !== 0; Be++)Ie = Ie.redSqr(); f(Be < Ae); var Me = this.pow(X, new d(1).iushln(Ae - Be - 1)); ce = ce.redMul(Me), X = Me.redSqr(), me = me.redMul(X), Ae = Be } return ce }, Se.prototype.invm = function (g) { var P = g._invmp(this.m); return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P) }, Se.prototype.pow = function (g, P) { if (P.isZero()) return new d(1).toRed(this); if (P.cmpn(1) === 0) return g.clone(); var U = 4, K = new Array(1 << U); K[0] = new d(1).toRed(this), K[1] = g; for (var Y = 2; Y < K.length; Y++)K[Y] = this.mul(K[Y - 1], g); var te = K[0], ee = 0, G = 0, y = P.bitLength() % 26; for (y === 0 && (y = 26), Y = P.length - 1; Y >= 0; Y--) { for (var X = P.words[Y], ce = y - 1; ce >= 0; ce--) { var me = X >> ce & 1; if (te !== K[0] && (te = this.sqr(te)), me === 0 && ee === 0) { G = 0; continue } ee <<= 1, ee |= me, G++, !(G !== U && (Y !== 0 || ce !== 0)) && (te = this.mul(te, K[ee]), G = 0, ee = 0) } y = 26 } return te }, Se.prototype.convertTo = function (g) { var P = g.umod(this.m); return P === g ? P.clone() : P }, Se.prototype.convertFrom = function (g) { var P = g.clone(); return P.red = null, P }, d.mont = function (g) { return new $e(g) }; function $e(ie) { Se.call(this, ie), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p($e, Se), $e.prototype.convertTo = function (g) { return this.imod(g.ushln(this.shift)) }, $e.prototype.convertFrom = function (g) { var P = this.imod(g.mul(this.rinv)); return P.red = null, P }, $e.prototype.imul = function (g, P) { if (g.isZero() || P.isZero()) return g.words[0] = 0, g.length = 1, g; var U = g.imul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.mul = function (g, P) { if (g.isZero() || P.isZero()) return new d(0)._forceRed(this); var U = g.mul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.invm = function (g) { var P = this.imod(g._invmp(this.m).mul(this.r2)); return P._forceRed(this) } })(o, bn$4) }(bn$5)), bn$5.exports } var api = {}, vmBrowserify = {}, hasRequiredVmBrowserify; function requireVmBrowserify() { return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function (exports) { var indexOf = function (o, l) { if (o.indexOf) return o.indexOf(l); for (var u = 0; u < o.length; u++)if (o[u] === l) return u; return -1 }, Object_keys = function (o) { if (Object.keys) return Object.keys(o); var l = []; for (var u in o) l.push(u); return l }, forEach = function (o, l) { if (o.forEach) return o.forEach(l); for (var u = 0; u < o.length; u++)l(o[u], u, o) }, defineProp = function () { try { return Object.defineProperty({}, "_", {}), function (o, l, u) { Object.defineProperty(o, l, { writable: !0, enumerable: !1, configurable: !0, value: u }) } } catch { return function (l, u, f) { l[u] = f } } }(), globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"]; function Context() { } Context.prototype = {}; var Script = exports.Script = function (l) { if (!(this instanceof Script)) return new Script(l); this.code = l }; Script.prototype.runInContext = function (o) { if (!(o instanceof Context)) throw new TypeError("needs a 'context' argument."); var l = document.createElement("iframe"); l.style || (l.style = {}), l.style.display = "none", document.body.appendChild(l); var u = l.contentWindow, f = u.eval, p = u.execScript; !f && p && (p.call(u, "null"), f = u.eval), forEach(Object_keys(o), function (v) { u[v] = o[v] }), forEach(globals, function (v) { o[v] && (u[v] = o[v]) }); var d = Object_keys(u), m = f.call(u, this.code); return forEach(Object_keys(u), function (v) { (v in o || indexOf(d, v) === -1) && (o[v] = u[v]) }), forEach(globals, function (v) { v in o || defineProp(o, v, u[v]) }), document.body.removeChild(l), m }, Script.prototype.runInThisContext = function () { return eval(this.code) }, Script.prototype.runInNewContext = function (o) { var l = Script.createContext(o), u = this.runInContext(l); return o && forEach(Object_keys(l), function (f) { o[f] = l[f] }), u }, forEach(Object_keys(Script.prototype), function (o) { exports[o] = Script[o] = function (l) { var u = Script(l); return u[o].apply(u, [].slice.call(arguments, 1)) } }), exports.isContext = function (o) { return o instanceof Context }, exports.createScript = function (o) { return exports.Script(o) }, exports.createContext = Script.createContext = function (o) { var l = new Context; return typeof o == "object" && forEach(Object_keys(o), function (u) { l[u] = o[u] }), l } }(vmBrowserify)), vmBrowserify } var hasRequiredApi; function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function (o) {
    var l = requireAsn1$1(), u = requireInherits_browser(), f = o; f.define = function (m, v) { return new p(m, v) }; function p(d, m) { this.name = d, this.body = m, this.decoders = {}, this.encoders = {} } p.prototype._createNamed = function (m) {
      var v; try {
        v = requireVmBrowserify().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`)
      } catch { v = function (F) { this._initNamed(F) } } return u(v, m), v.prototype._initNamed = function (F) { m.call(this, F) }, new v(this)
    }, p.prototype._getDecoder = function (m) { return m = m || "der", this.decoders.hasOwnProperty(m) || (this.decoders[m] = this._createNamed(l.decoders[m])), this.decoders[m] }, p.prototype.decode = function (m, v, I) { return this._getDecoder(v).decode(m, I) }, p.prototype._getEncoder = function (m) { return m = m || "der", this.encoders.hasOwnProperty(m) || (this.encoders[m] = this._createNamed(l.encoders[m])), this.encoders[m] }, p.prototype.encode = function (m, v, I) { return this._getEncoder(v).encode(m, I) }
  }(api)), api
} var base = {}, reporter = {}, hasRequiredReporter; function requireReporter() { if (hasRequiredReporter) return reporter; hasRequiredReporter = 1; var o = requireInherits_browser(); function l(f) { this._reporterState = { obj: null, path: [], options: f || {}, errors: [] } } reporter.Reporter = l, l.prototype.isError = function (p) { return p instanceof u }, l.prototype.save = function () { var p = this._reporterState; return { obj: p.obj, pathLen: p.path.length } }, l.prototype.restore = function (p) { var d = this._reporterState; d.obj = p.obj, d.path = d.path.slice(0, p.pathLen) }, l.prototype.enterKey = function (p) { return this._reporterState.path.push(p) }, l.prototype.exitKey = function (p) { var d = this._reporterState; d.path = d.path.slice(0, p - 1) }, l.prototype.leaveKey = function (p, d, m) { var v = this._reporterState; this.exitKey(p), v.obj !== null && (v.obj[d] = m) }, l.prototype.path = function () { return this._reporterState.path.join("/") }, l.prototype.enterObject = function () { var p = this._reporterState, d = p.obj; return p.obj = {}, d }, l.prototype.leaveObject = function (p) { var d = this._reporterState, m = d.obj; return d.obj = p, m }, l.prototype.error = function (p) { var d, m = this._reporterState, v = p instanceof u; if (v ? d = p : d = new u(m.path.map(function (I) { return "[" + JSON.stringify(I) + "]" }).join(""), p.message || p, p.stack), !m.options.partial) throw d; return v || m.errors.push(d), d }, l.prototype.wrapResult = function (p) { var d = this._reporterState; return d.options.partial ? { result: this.isError(p) ? null : p, errors: d.errors } : p }; function u(f, p) { this.path = f, this.rethrow(p) } return o(u, Error), u.prototype.rethrow = function (p) { if (this.message = p + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, u), !this.stack) try { throw new Error(this.message) } catch (d) { this.stack = d.stack } return this }, reporter } var buffer = {}, hasRequiredBuffer; function requireBuffer() { if (hasRequiredBuffer) return buffer; hasRequiredBuffer = 1; var o = requireInherits_browser(), l = requireBase().Reporter, u = requireDist$2().Buffer; function f(d, m) { if (l.call(this, m), !u.isBuffer(d)) { this.error("Input not Buffer"); return } this.base = d, this.offset = 0, this.length = d.length } o(f, l), buffer.DecoderBuffer = f, f.prototype.save = function () { return { offset: this.offset, reporter: l.prototype.save.call(this) } }, f.prototype.restore = function (m) { var v = new f(this.base); return v.offset = m.offset, v.length = this.offset, this.offset = m.offset, l.prototype.restore.call(this, m.reporter), v }, f.prototype.isEmpty = function () { return this.offset === this.length }, f.prototype.readUInt8 = function (m) { return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(m || "DecoderBuffer overrun") }, f.prototype.skip = function (m, v) { if (!(this.offset + m <= this.length)) return this.error(v || "DecoderBuffer overrun"); var I = new f(this.base); return I._reporterState = this._reporterState, I.offset = this.offset, I.length = this.offset + m, this.offset += m, I }, f.prototype.raw = function (m) { return this.base.slice(m ? m.offset : this.offset, this.length) }; function p(d, m) { if (Array.isArray(d)) this.length = 0, this.value = d.map(function (v) { return v instanceof p || (v = new p(v, m)), this.length += v.length, v }, this); else if (typeof d == "number") { if (!(0 <= d && d <= 255)) return m.error("non-byte EncoderBuffer value"); this.value = d, this.length = 1 } else if (typeof d == "string") this.value = d, this.length = u.byteLength(d); else if (u.isBuffer(d)) this.value = d, this.length = d.length; else return m.error("Unsupported type: " + typeof d) } return buffer.EncoderBuffer = p, p.prototype.join = function (m, v) { return m || (m = new u(this.length)), v || (v = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function (I) { I.join(m, v), v += I.length }) : (typeof this.value == "number" ? m[v] = this.value : typeof this.value == "string" ? m.write(this.value, v) : u.isBuffer(this.value) && this.value.copy(m, v), v += this.length)), m }, buffer } var node, hasRequiredNode; function requireNode() { if (hasRequiredNode) return node; hasRequiredNode = 1; var o = requireBase().Reporter, l = requireBase().EncoderBuffer, u = requireBase().DecoderBuffer, f = requireMinimalisticAssert(), p = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], d = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(p), m = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"]; function v(F, B) { var W = {}; this._baseState = W, W.enc = F, W.parent = B || null, W.children = null, W.tag = null, W.args = null, W.reverseArgs = null, W.choice = null, W.optional = !1, W.any = !1, W.obj = !1, W.use = null, W.useDecoder = null, W.key = null, W.default = null, W.explicit = null, W.implicit = null, W.contains = null, W.parent || (W.children = [], this._wrap()) } node = v; var I = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"]; return v.prototype.clone = function () { var B = this._baseState, W = {}; I.forEach(function (Q) { W[Q] = B[Q] }); var Z = new this.constructor(W.parent); return Z._baseState = W, Z }, v.prototype._wrap = function () { var B = this._baseState; d.forEach(function (W) { this[W] = function () { var Q = new this.constructor(this); return B.children.push(Q), Q[W].apply(Q, arguments) } }, this) }, v.prototype._init = function (B) { var W = this._baseState; f(W.parent === null), B.call(this), W.children = W.children.filter(function (Z) { return Z._baseState.parent === this }, this), f.equal(W.children.length, 1, "Root node can have only one child") }, v.prototype._useArgs = function (B) { var W = this._baseState, Z = B.filter(function (Q) { return Q instanceof this.constructor }, this); B = B.filter(function (Q) { return !(Q instanceof this.constructor) }, this), Z.length !== 0 && (f(W.children === null), W.children = Z, Z.forEach(function (Q) { Q._baseState.parent = this }, this)), B.length !== 0 && (f(W.args === null), W.args = B, W.reverseArgs = B.map(function (Q) { if (typeof Q != "object" || Q.constructor !== Object) return Q; var re = {}; return Object.keys(Q).forEach(function (ne) { ne == (ne | 0) && (ne |= 0); var oe = Q[ne]; re[oe] = ne }), re })) }, m.forEach(function (F) { v.prototype[F] = function () { var W = this._baseState; throw new Error(F + " not implemented for encoding: " + W.enc) } }), p.forEach(function (F) { v.prototype[F] = function () { var W = this._baseState, Z = Array.prototype.slice.call(arguments); return f(W.tag === null), W.tag = F, this._useArgs(Z), this } }), v.prototype.use = function (B) { f(B); var W = this._baseState; return f(W.use === null), W.use = B, this }, v.prototype.optional = function () { var B = this._baseState; return B.optional = !0, this }, v.prototype.def = function (B) { var W = this._baseState; return f(W.default === null), W.default = B, W.optional = !0, this }, v.prototype.explicit = function (B) { var W = this._baseState; return f(W.explicit === null && W.implicit === null), W.explicit = B, this }, v.prototype.implicit = function (B) { var W = this._baseState; return f(W.explicit === null && W.implicit === null), W.implicit = B, this }, v.prototype.obj = function () { var B = this._baseState, W = Array.prototype.slice.call(arguments); return B.obj = !0, W.length !== 0 && this._useArgs(W), this }, v.prototype.key = function (B) { var W = this._baseState; return f(W.key === null), W.key = B, this }, v.prototype.any = function () { var B = this._baseState; return B.any = !0, this }, v.prototype.choice = function (B) { var W = this._baseState; return f(W.choice === null), W.choice = B, this._useArgs(Object.keys(B).map(function (Z) { return B[Z] })), this }, v.prototype.contains = function (B) { var W = this._baseState; return f(W.use === null), W.contains = B, this }, v.prototype._decode = function (B, W) { var Z = this._baseState; if (Z.parent === null) return B.wrapResult(Z.children[0]._decode(B, W)); var Q = Z.default, re = !0, ne = null; if (Z.key !== null && (ne = B.enterKey(Z.key)), Z.optional) { var oe = null; if (Z.explicit !== null ? oe = Z.explicit : Z.implicit !== null ? oe = Z.implicit : Z.tag !== null && (oe = Z.tag), oe === null && !Z.any) { var ae = B.save(); try { Z.choice === null ? this._decodeGeneric(Z.tag, B, W) : this._decodeChoice(B, W), re = !0 } catch { re = !1 } B.restore(ae) } else if (re = this._peekTag(B, oe, Z.any), B.isError(re)) return re } var se; if (Z.obj && re && (se = B.enterObject()), re) { if (Z.explicit !== null) { var le = this._decodeTag(B, Z.explicit); if (B.isError(le)) return le; B = le } var ue = B.offset; if (Z.use === null && Z.choice === null) { if (Z.any) var ae = B.save(); var he = this._decodeTag(B, Z.implicit !== null ? Z.implicit : Z.tag, Z.any); if (B.isError(he)) return he; Z.any ? Q = B.raw(ae) : B = he } if (W && W.track && Z.tag !== null && W.track(B.path(), ue, B.length, "tagged"), W && W.track && Z.tag !== null && W.track(B.path(), B.offset, B.length, "content"), Z.any ? Q = Q : Z.choice === null ? Q = this._decodeGeneric(Z.tag, B, W) : Q = this._decodeChoice(B, W), B.isError(Q)) return Q; if (!Z.any && Z.choice === null && Z.children !== null && Z.children.forEach(function (_e) { _e._decode(B, W) }), Z.contains && (Z.tag === "octstr" || Z.tag === "bitstr")) { var pe = new u(Q); Q = this._getUse(Z.contains, B._reporterState.obj)._decode(pe, W) } } return Z.obj && re && (Q = B.leaveObject(se)), Z.key !== null && (Q !== null || re === !0) ? B.leaveKey(ne, Z.key, Q) : ne !== null && B.exitKey(ne), Q }, v.prototype._decodeGeneric = function (B, W, Z) { var Q = this._baseState; return B === "seq" || B === "set" ? null : B === "seqof" || B === "setof" ? this._decodeList(W, B, Q.args[0], Z) : /str$/.test(B) ? this._decodeStr(W, B, Z) : B === "objid" && Q.args ? this._decodeObjid(W, Q.args[0], Q.args[1], Z) : B === "objid" ? this._decodeObjid(W, null, null, Z) : B === "gentime" || B === "utctime" ? this._decodeTime(W, B, Z) : B === "null_" ? this._decodeNull(W, Z) : B === "bool" ? this._decodeBool(W, Z) : B === "objDesc" ? this._decodeStr(W, B, Z) : B === "int" || B === "enum" ? this._decodeInt(W, Q.args && Q.args[0], Z) : Q.use !== null ? this._getUse(Q.use, W._reporterState.obj)._decode(W, Z) : W.error("unknown tag: " + B) }, v.prototype._getUse = function (B, W) { var Z = this._baseState; return Z.useDecoder = this._use(B, W), f(Z.useDecoder._baseState.parent === null), Z.useDecoder = Z.useDecoder._baseState.children[0], Z.implicit !== Z.useDecoder._baseState.implicit && (Z.useDecoder = Z.useDecoder.clone(), Z.useDecoder._baseState.implicit = Z.implicit), Z.useDecoder }, v.prototype._decodeChoice = function (B, W) { var Z = this._baseState, Q = null, re = !1; return Object.keys(Z.choice).some(function (ne) { var oe = B.save(), ae = Z.choice[ne]; try { var se = ae._decode(B, W); if (B.isError(se)) return !1; Q = { type: ne, value: se }, re = !0 } catch { return B.restore(oe), !1 } return !0 }, this), re ? Q : B.error("Choice not matched") }, v.prototype._createEncoderBuffer = function (B) { return new l(B, this.reporter) }, v.prototype._encode = function (B, W, Z) { var Q = this._baseState; if (!(Q.default !== null && Q.default === B)) { var re = this._encodeValue(B, W, Z); if (re !== void 0 && !this._skipDefault(re, W, Z)) return re } }, v.prototype._encodeValue = function (B, W, Z) { var Q = this._baseState; if (Q.parent === null) return Q.children[0]._encode(B, W || new o); var ae = null; if (this.reporter = W, Q.optional && B === void 0) if (Q.default !== null) B = Q.default; else return; var re = null, ne = !1; if (Q.any) ae = this._createEncoderBuffer(B); else if (Q.choice) ae = this._encodeChoice(B, W); else if (Q.contains) re = this._getUse(Q.contains, Z)._encode(B, W), ne = !0; else if (Q.children) re = Q.children.map(function (ue) { if (ue._baseState.tag === "null_") return ue._encode(null, W, B); if (ue._baseState.key === null) return W.error("Child should have a key"); var he = W.enterKey(ue._baseState.key); if (typeof B != "object") return W.error("Child expected, but input is not object"); var pe = ue._encode(B[ue._baseState.key], W, B); return W.leaveKey(he), pe }, this).filter(function (ue) { return ue }), re = this._createEncoderBuffer(re); else if (Q.tag === "seqof" || Q.tag === "setof") { if (!(Q.args && Q.args.length === 1)) return W.error("Too many args for : " + Q.tag); if (!Array.isArray(B)) return W.error("seqof/setof, but data is not Array"); var oe = this.clone(); oe._baseState.implicit = null, re = this._createEncoderBuffer(B.map(function (ue) { var he = this._baseState; return this._getUse(he.args[0], B)._encode(ue, W) }, oe)) } else Q.use !== null ? ae = this._getUse(Q.use, Z)._encode(B, W) : (re = this._encodePrimitive(Q.tag, B), ne = !0); var ae; if (!Q.any && Q.choice === null) { var se = Q.implicit !== null ? Q.implicit : Q.tag, le = Q.implicit === null ? "universal" : "context"; se === null ? Q.use === null && W.error("Tag could be omitted only for .use()") : Q.use === null && (ae = this._encodeComposite(se, ne, le, re)) } return Q.explicit !== null && (ae = this._encodeComposite(Q.explicit, !1, "context", ae)), ae }, v.prototype._encodeChoice = function (B, W) { var Z = this._baseState, Q = Z.choice[B.type]; return Q || f(!1, B.type + " not found in " + JSON.stringify(Object.keys(Z.choice))), Q._encode(B.value, W) }, v.prototype._encodePrimitive = function (B, W) { var Z = this._baseState; if (/str$/.test(B)) return this._encodeStr(W, B); if (B === "objid" && Z.args) return this._encodeObjid(W, Z.reverseArgs[0], Z.args[1]); if (B === "objid") return this._encodeObjid(W, null, null); if (B === "gentime" || B === "utctime") return this._encodeTime(W, B); if (B === "null_") return this._encodeNull(); if (B === "int" || B === "enum") return this._encodeInt(W, Z.args && Z.reverseArgs[0]); if (B === "bool") return this._encodeBool(W); if (B === "objDesc") return this._encodeStr(W, B); throw new Error("Unsupported tag: " + B) }, v.prototype._isNumstr = function (B) { return /^[0-9 ]*$/.test(B) }, v.prototype._isPrintstr = function (B) { return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(B) }, node } var hasRequiredBase; function requireBase() { return hasRequiredBase || (hasRequiredBase = 1, function (o) { var l = o; l.Reporter = requireReporter().Reporter, l.DecoderBuffer = requireBuffer().DecoderBuffer, l.EncoderBuffer = requireBuffer().EncoderBuffer, l.Node = requireNode() }(base)), base } var constants = {}, der = {}, hasRequiredDer$2; function requireDer$2() { return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function (o) { var l = requireConstants(); o.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, o.tagClassByName = l._reverse(o.tagClass), o.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, o.tagByName = l._reverse(o.tag) }(der)), der } var hasRequiredConstants; function requireConstants() { return hasRequiredConstants || (hasRequiredConstants = 1, function (o) { var l = o; l._reverse = function (f) { var p = {}; return Object.keys(f).forEach(function (d) { (d | 0) == d && (d = d | 0); var m = f[d]; p[m] = d }), p }, l.der = requireDer$2() }(constants)), constants } var decoders = {}, der_1$1, hasRequiredDer$1; function requireDer$1() { if (hasRequiredDer$1) return der_1$1; hasRequiredDer$1 = 1; var o = requireInherits_browser(), l = requireAsn1$1(), u = l.base, f = l.bignum, p = l.constants.der; function d(F) { this.enc = "der", this.name = F.name, this.entity = F, this.tree = new m, this.tree._init(F.body) } der_1$1 = d, d.prototype.decode = function (B, W) { return B instanceof u.DecoderBuffer || (B = new u.DecoderBuffer(B, W)), this.tree._decode(B, W) }; function m(F) { u.Node.call(this, "der", F) } o(m, u.Node), m.prototype._peekTag = function (B, W, Z) { if (B.isEmpty()) return !1; var Q = B.save(), re = v(B, 'Failed to peek tag: "' + W + '"'); return B.isError(re) ? re : (B.restore(Q), re.tag === W || re.tagStr === W || re.tagStr + "of" === W || Z) }, m.prototype._decodeTag = function (B, W, Z) { var Q = v(B, 'Failed to decode tag of "' + W + '"'); if (B.isError(Q)) return Q; var re = I(B, Q.primitive, 'Failed to get length of "' + W + '"'); if (B.isError(re)) return re; if (!Z && Q.tag !== W && Q.tagStr !== W && Q.tagStr + "of" !== W) return B.error('Failed to match tag: "' + W + '"'); if (Q.primitive || re !== null) return B.skip(re, 'Failed to match body of: "' + W + '"'); var ne = B.save(), oe = this._skipUntilEnd(B, 'Failed to skip indefinite length body: "' + this.tag + '"'); return B.isError(oe) ? oe : (re = B.offset - ne.offset, B.restore(ne), B.skip(re, 'Failed to match body of: "' + W + '"')) }, m.prototype._skipUntilEnd = function (B, W) { for (; ;) { var Z = v(B, W); if (B.isError(Z)) return Z; var Q = I(B, Z.primitive, W); if (B.isError(Q)) return Q; var re; if (Z.primitive || Q !== null ? re = B.skip(Q) : re = this._skipUntilEnd(B, W), B.isError(re)) return re; if (Z.tagStr === "end") break } }, m.prototype._decodeList = function (B, W, Z, Q) { for (var re = []; !B.isEmpty();) { var ne = this._peekTag(B, "end"); if (B.isError(ne)) return ne; var oe = Z.decode(B, "der", Q); if (B.isError(oe) && ne) break; re.push(oe) } return re }, m.prototype._decodeStr = function (B, W) { if (W === "bitstr") { var Z = B.readUInt8(); return B.isError(Z) ? Z : { unused: Z, data: B.raw() } } else if (W === "bmpstr") { var Q = B.raw(); if (Q.length % 2 === 1) return B.error("Decoding of string type: bmpstr length mismatch"); for (var re = "", ne = 0; ne < Q.length / 2; ne++)re += String.fromCharCode(Q.readUInt16BE(ne * 2)); return re } else if (W === "numstr") { var oe = B.raw().toString("ascii"); return this._isNumstr(oe) ? oe : B.error("Decoding of string type: numstr unsupported characters") } else { if (W === "octstr") return B.raw(); if (W === "objDesc") return B.raw(); if (W === "printstr") { var ae = B.raw().toString("ascii"); return this._isPrintstr(ae) ? ae : B.error("Decoding of string type: printstr unsupported characters") } else return /str$/.test(W) ? B.raw().toString() : B.error("Decoding of string type: " + W + " unsupported") } }, m.prototype._decodeObjid = function (B, W, Z) { for (var Q, re = [], ne = 0; !B.isEmpty();) { var oe = B.readUInt8(); ne <<= 7, ne |= oe & 127, (oe & 128) === 0 && (re.push(ne), ne = 0) } oe & 128 && re.push(ne); var ae = re[0] / 40 | 0, se = re[0] % 40; if (Z ? Q = re : Q = [ae, se].concat(re.slice(1)), W) { var le = W[Q.join(" ")]; le === void 0 && (le = W[Q.join(".")]), le !== void 0 && (Q = le) } return Q }, m.prototype._decodeTime = function (B, W) { var Z = B.raw().toString(); if (W === "gentime") var Q = Z.slice(0, 4) | 0, re = Z.slice(4, 6) | 0, ne = Z.slice(6, 8) | 0, oe = Z.slice(8, 10) | 0, ae = Z.slice(10, 12) | 0, se = Z.slice(12, 14) | 0; else if (W === "utctime") { var Q = Z.slice(0, 2) | 0, re = Z.slice(2, 4) | 0, ne = Z.slice(4, 6) | 0, oe = Z.slice(6, 8) | 0, ae = Z.slice(8, 10) | 0, se = Z.slice(10, 12) | 0; Q < 70 ? Q = 2e3 + Q : Q = 1900 + Q } else return B.error("Decoding " + W + " time is not supported yet"); return Date.UTC(Q, re - 1, ne, oe, ae, se, 0) }, m.prototype._decodeNull = function (B) { return null }, m.prototype._decodeBool = function (B) { var W = B.readUInt8(); return B.isError(W) ? W : W !== 0 }, m.prototype._decodeInt = function (B, W) { var Z = B.raw(), Q = new f(Z); return W && (Q = W[Q.toString(10)] || Q), Q }, m.prototype._use = function (B, W) { return typeof B == "function" && (B = B(W)), B._getDecoder("der").tree }; function v(F, B) { var W = F.readUInt8(B); if (F.isError(W)) return W; var Z = p.tagClass[W >> 6], Q = (W & 32) === 0; if ((W & 31) === 31) { var re = W; for (W = 0; (re & 128) === 128;) { if (re = F.readUInt8(B), F.isError(re)) return re; W <<= 7, W |= re & 127 } } else W &= 31; var ne = p.tag[W]; return { cls: Z, primitive: Q, tag: W, tagStr: ne } } function I(F, B, W) { var Z = F.readUInt8(W); if (F.isError(Z)) return Z; if (!B && Z === 128) return null; if ((Z & 128) === 0) return Z; var Q = Z & 127; if (Q > 4) return F.error("length octect is too long"); Z = 0; for (var re = 0; re < Q; re++) { Z <<= 8; var ne = F.readUInt8(W); if (F.isError(ne)) return ne; Z |= ne } return Z } return der_1$1 } var pem$1, hasRequiredPem$1; function requirePem$1() { if (hasRequiredPem$1) return pem$1; hasRequiredPem$1 = 1; var o = requireInherits_browser(), l = requireDist$2().Buffer, u = requireDer$1(); function f(p) { u.call(this, p), this.enc = "pem" } return o(f, u), pem$1 = f, f.prototype.decode = function (d, m) { for (var v = d.toString().split(/[\r\n]+/g), I = m.label.toUpperCase(), F = /^-----(BEGIN|END) ([^-]+)-----$/, B = -1, W = -1, Z = 0; Z < v.length; Z++) { var Q = v[Z].match(F); if (Q !== null && Q[2] === I) if (B === -1) { if (Q[1] !== "BEGIN") break; B = Z } else { if (Q[1] !== "END") break; W = Z; break } } if (B === -1 || W === -1) throw new Error("PEM section not found for: " + I); var re = v.slice(B + 1, W).join(""); re.replace(/[^a-z0-9\+\/=]+/gi, ""); var ne = new l(re, "base64"); return u.prototype.decode.call(this, ne, m) }, pem$1 } var hasRequiredDecoders; function requireDecoders() { return hasRequiredDecoders || (hasRequiredDecoders = 1, function (o) { var l = o; l.der = requireDer$1(), l.pem = requirePem$1() }(decoders)), decoders } var encoders = {}, der_1, hasRequiredDer; function requireDer() { if (hasRequiredDer) return der_1; hasRequiredDer = 1; var o = requireInherits_browser(), l = requireDist$2().Buffer, u = requireAsn1$1(), f = u.base, p = u.constants.der; function d(F) { this.enc = "der", this.name = F.name, this.entity = F, this.tree = new m, this.tree._init(F.body) } der_1 = d, d.prototype.encode = function (B, W) { return this.tree._encode(B, W).join() }; function m(F) { f.Node.call(this, "der", F) } o(m, f.Node), m.prototype._encodeComposite = function (B, W, Z, Q) { var re = I(B, W, Z, this.reporter); if (Q.length < 128) { var ae = new l(2); return ae[0] = re, ae[1] = Q.length, this._createEncoderBuffer([ae, Q]) } for (var ne = 1, oe = Q.length; oe >= 256; oe >>= 8)ne++; var ae = new l(2 + ne); ae[0] = re, ae[1] = 128 | ne; for (var oe = 1 + ne, se = Q.length; se > 0; oe--, se >>= 8)ae[oe] = se & 255; return this._createEncoderBuffer([ae, Q]) }, m.prototype._encodeStr = function (B, W) { if (W === "bitstr") return this._createEncoderBuffer([B.unused | 0, B.data]); if (W === "bmpstr") { for (var Z = new l(B.length * 2), Q = 0; Q < B.length; Q++)Z.writeUInt16BE(B.charCodeAt(Q), Q * 2); return this._createEncoderBuffer(Z) } else return W === "numstr" ? this._isNumstr(B) ? this._createEncoderBuffer(B) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : W === "printstr" ? this._isPrintstr(B) ? this._createEncoderBuffer(B) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(W) ? this._createEncoderBuffer(B) : W === "objDesc" ? this._createEncoderBuffer(B) : this.reporter.error("Encoding of string type: " + W + " unsupported") }, m.prototype._encodeObjid = function (B, W, Z) { if (typeof B == "string") { if (!W) return this.reporter.error("string objid given, but no values map found"); if (!W.hasOwnProperty(B)) return this.reporter.error("objid not found in values map"); B = W[B].split(/[\s\.]+/g); for (var Q = 0; Q < B.length; Q++)B[Q] |= 0 } else if (Array.isArray(B)) { B = B.slice(); for (var Q = 0; Q < B.length; Q++)B[Q] |= 0 } if (!Array.isArray(B)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(B)); if (!Z) { if (B[1] >= 40) return this.reporter.error("Second objid identifier OOB"); B.splice(0, 2, B[0] * 40 + B[1]) } for (var re = 0, Q = 0; Q < B.length; Q++) { var ne = B[Q]; for (re++; ne >= 128; ne >>= 7)re++ } for (var oe = new l(re), ae = oe.length - 1, Q = B.length - 1; Q >= 0; Q--) { var ne = B[Q]; for (oe[ae--] = ne & 127; (ne >>= 7) > 0;)oe[ae--] = 128 | ne & 127 } return this._createEncoderBuffer(oe) }; function v(F) { return F < 10 ? "0" + F : F } m.prototype._encodeTime = function (B, W) { var Z, Q = new Date(B); return W === "gentime" ? Z = [v(Q.getFullYear()), v(Q.getUTCMonth() + 1), v(Q.getUTCDate()), v(Q.getUTCHours()), v(Q.getUTCMinutes()), v(Q.getUTCSeconds()), "Z"].join("") : W === "utctime" ? Z = [v(Q.getFullYear() % 100), v(Q.getUTCMonth() + 1), v(Q.getUTCDate()), v(Q.getUTCHours()), v(Q.getUTCMinutes()), v(Q.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + W + " time is not supported yet"), this._encodeStr(Z, "octstr") }, m.prototype._encodeNull = function () { return this._createEncoderBuffer("") }, m.prototype._encodeInt = function (B, W) { if (typeof B == "string") { if (!W) return this.reporter.error("String int or enum given, but no values map"); if (!W.hasOwnProperty(B)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(B)); B = W[B] } if (typeof B != "number" && !l.isBuffer(B)) { var Z = B.toArray(); !B.sign && Z[0] & 128 && Z.unshift(0), B = new l(Z) } if (l.isBuffer(B)) { var Q = B.length; B.length === 0 && Q++; var ne = new l(Q); return B.copy(ne), B.length === 0 && (ne[0] = 0), this._createEncoderBuffer(ne) } if (B < 128) return this._createEncoderBuffer(B); if (B < 256) return this._createEncoderBuffer([0, B]); for (var Q = 1, re = B; re >= 256; re >>= 8)Q++; for (var ne = new Array(Q), re = ne.length - 1; re >= 0; re--)ne[re] = B & 255, B >>= 8; return ne[0] & 128 && ne.unshift(0), this._createEncoderBuffer(new l(ne)) }, m.prototype._encodeBool = function (B) { return this._createEncoderBuffer(B ? 255 : 0) }, m.prototype._use = function (B, W) { return typeof B == "function" && (B = B(W)), B._getEncoder("der").tree }, m.prototype._skipDefault = function (B, W, Z) { var Q = this._baseState, re; if (Q.default === null) return !1; var ne = B.join(); if (Q.defaultBuffer === void 0 && (Q.defaultBuffer = this._encodeValue(Q.default, W, Z).join()), ne.length !== Q.defaultBuffer.length) return !1; for (re = 0; re < ne.length; re++)if (ne[re] !== Q.defaultBuffer[re]) return !1; return !0 }; function I(F, B, W, Z) { var Q; if (F === "seqof" ? F = "seq" : F === "setof" && (F = "set"), p.tagByName.hasOwnProperty(F)) Q = p.tagByName[F]; else if (typeof F == "number" && (F | 0) === F) Q = F; else return Z.error("Unknown tag: " + F); return Q >= 31 ? Z.error("Multi-octet tag encoding unsupported") : (B || (Q |= 32), Q |= p.tagClassByName[W || "universal"] << 6, Q) } return der_1 } var pem, hasRequiredPem; function requirePem() {
  if (hasRequiredPem) return pem; hasRequiredPem = 1; var o = requireInherits_browser(), l = requireDer(); function u(f) { l.call(this, f), this.enc = "pem" } return o(u, l), pem = u, u.prototype.encode = function (p, d) {
    for (var m = l.prototype.encode.call(this, p), v = m.toString("base64"), I = ["-----BEGIN " + d.label + "-----"], F = 0; F < v.length; F += 64)I.push(v.slice(F, F + 64)); return I.push("-----END " + d.label + "-----"), I.join(`
`)
  }, pem
} var hasRequiredEncoders; function requireEncoders() { return hasRequiredEncoders || (hasRequiredEncoders = 1, function (o) { var l = o; l.der = requireDer(), l.pem = requirePem() }(encoders)), encoders } var hasRequiredAsn1$1; function requireAsn1$1() { return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function (o) { var l = o; l.bignum = requireBn$2(), l.define = requireApi().define, l.base = requireBase(), l.constants = requireConstants(), l.decoders = requireDecoders(), l.encoders = requireEncoders() }(asn1)), asn1 } var certificate, hasRequiredCertificate; function requireCertificate() { if (hasRequiredCertificate) return certificate; hasRequiredCertificate = 1; var o = requireAsn1$1(), l = o.define("Time", function () { this.choice({ utcTime: this.utctime(), generalTime: this.gentime() }) }), u = o.define("AttributeTypeValue", function () { this.seq().obj(this.key("type").objid(), this.key("value").any()) }), f = o.define("AlgorithmIdentifier", function () { this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional()) }), p = o.define("SubjectPublicKeyInfo", function () { this.seq().obj(this.key("algorithm").use(f), this.key("subjectPublicKey").bitstr()) }), d = o.define("RelativeDistinguishedName", function () { this.setof(u) }), m = o.define("RDNSequence", function () { this.seqof(d) }), v = o.define("Name", function () { this.choice({ rdnSequence: this.use(m) }) }), I = o.define("Validity", function () { this.seq().obj(this.key("notBefore").use(l), this.key("notAfter").use(l)) }), F = o.define("Extension", function () { this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr()) }), B = o.define("TBSCertificate", function () { this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(f), this.key("issuer").use(v), this.key("validity").use(I), this.key("subject").use(v), this.key("subjectPublicKeyInfo").use(p), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(F).optional()) }), W = o.define("X509Certificate", function () { this.seq().obj(this.key("tbsCertificate").use(B), this.key("signatureAlgorithm").use(f), this.key("signatureValue").bitstr()) }); return certificate = W, certificate } var hasRequiredAsn1; function requireAsn1() { if (hasRequiredAsn1) return asn1$1; hasRequiredAsn1 = 1; var o = requireAsn1$1(); asn1$1.certificate = requireCertificate(); var l = o.define("RSAPrivateKey", function () { this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int()) }); asn1$1.RSAPrivateKey = l; var u = o.define("RSAPublicKey", function () { this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int()) }); asn1$1.RSAPublicKey = u; var f = o.define("AlgorithmIdentifier", function () { this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional()) }), p = o.define("SubjectPublicKeyInfo", function () { this.seq().obj(this.key("algorithm").use(f), this.key("subjectPublicKey").bitstr()) }); asn1$1.PublicKey = p; var d = o.define("PrivateKeyInfo", function () { this.seq().obj(this.key("version").int(), this.key("algorithm").use(f), this.key("subjectPrivateKey").octstr()) }); asn1$1.PrivateKey = d; var m = o.define("EncryptedPrivateKeyInfo", function () { this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr()) }); asn1$1.EncryptedPrivateKey = m; var v = o.define("DSAPrivateKey", function () { this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int()) }); asn1$1.DSAPrivateKey = v, asn1$1.DSAparam = o.define("DSAparam", function () { this.int() }); var I = o.define("ECParameters", function () { this.choice({ namedCurve: this.objid() }) }), F = o.define("ECPrivateKey", function () { this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(I), this.key("publicKey").optional().explicit(1).bitstr()) }); return asn1$1.ECPrivateKey = F, asn1$1.signature = o.define("signature", function () { this.seq().obj(this.key("r").int(), this.key("s").int()) }), asn1$1 } const require$$1 = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" }; var fixProc, hasRequiredFixProc; function requireFixProc() { if (hasRequiredFixProc) return fixProc; hasRequiredFixProc = 1; var o = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, l = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, u = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, f = requireEvp_bytestokey(), p = requireBrowser$6(), d = requireSafeBuffer$1().Buffer; return fixProc = function (m, v) { var I = m.toString(), F = I.match(o), B; if (F) { var Z = "aes" + F[1], Q = d.from(F[2], "hex"), re = d.from(F[3].replace(/[\r\n]/g, ""), "base64"), ne = f(v, Q.slice(0, 8), parseInt(F[1], 10)).key, oe = [], ae = p.createDecipheriv(Z, ne, Q); oe.push(ae.update(re)), oe.push(ae.final()), B = d.concat(oe) } else { var W = I.match(u); B = d.from(W[2].replace(/[\r\n]/g, ""), "base64") } var se = I.match(l)[1]; return { tag: se, data: B } }, fixProc } var parseAsn1, hasRequiredParseAsn1; function requireParseAsn1() { if (hasRequiredParseAsn1) return parseAsn1; hasRequiredParseAsn1 = 1; var o = requireAsn1(), l = require$$1, u = requireFixProc(), f = requireBrowser$6(), p = requireBrowser$7(), d = requireSafeBuffer$1().Buffer; function m(I, F) { var B = I.algorithm.decrypt.kde.kdeparams.salt, W = parseInt(I.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), Z = l[I.algorithm.decrypt.cipher.algo.join(".")], Q = I.algorithm.decrypt.cipher.iv, re = I.subjectPrivateKey, ne = parseInt(Z.split("-")[1], 10) / 8, oe = p.pbkdf2Sync(F, B, W, ne, "sha1"), ae = f.createDecipheriv(Z, oe, Q), se = []; return se.push(ae.update(re)), se.push(ae.final()), d.concat(se) } function v(I) { var F; typeof I == "object" && !d.isBuffer(I) && (F = I.passphrase, I = I.key), typeof I == "string" && (I = d.from(I)); var B = u(I, F), W = B.tag, Z = B.data, Q, re; switch (W) { case "CERTIFICATE": re = o.certificate.decode(Z, "der").tbsCertificate.subjectPublicKeyInfo; case "PUBLIC KEY": switch (re || (re = o.PublicKey.decode(Z, "der")), Q = re.algorithm.algorithm.join("."), Q) { case "1.2.840.113549.1.1.1": return o.RSAPublicKey.decode(re.subjectPublicKey.data, "der"); case "1.2.840.10045.2.1": return re.subjectPrivateKey = re.subjectPublicKey, { type: "ec", data: re }; case "1.2.840.10040.4.1": return re.algorithm.params.pub_key = o.DSAparam.decode(re.subjectPublicKey.data, "der"), { type: "dsa", data: re.algorithm.params }; default: throw new Error("unknown key id " + Q) }case "ENCRYPTED PRIVATE KEY": Z = o.EncryptedPrivateKey.decode(Z, "der"), Z = m(Z, F); case "PRIVATE KEY": switch (re = o.PrivateKey.decode(Z, "der"), Q = re.algorithm.algorithm.join("."), Q) { case "1.2.840.113549.1.1.1": return o.RSAPrivateKey.decode(re.subjectPrivateKey, "der"); case "1.2.840.10045.2.1": return { curve: re.algorithm.curve, privateKey: o.ECPrivateKey.decode(re.subjectPrivateKey, "der").privateKey }; case "1.2.840.10040.4.1": return re.algorithm.params.priv_key = o.DSAparam.decode(re.subjectPrivateKey, "der"), { type: "dsa", params: re.algorithm.params }; default: throw new Error("unknown key id " + Q) }case "RSA PUBLIC KEY": return o.RSAPublicKey.decode(Z, "der"); case "RSA PRIVATE KEY": return o.RSAPrivateKey.decode(Z, "der"); case "DSA PRIVATE KEY": return { type: "dsa", params: o.DSAPrivateKey.decode(Z, "der") }; case "EC PRIVATE KEY": return Z = o.ECPrivateKey.decode(Z, "der"), { curve: Z.parameters.value, privateKey: Z.privateKey }; default: throw new Error("unknown key type " + W) } } return v.signature = o.signature, parseAsn1 = v, parseAsn1 } const require$$4 = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" }; var hasRequiredSign; function requireSign() { if (hasRequiredSign) return sign.exports; hasRequiredSign = 1; var o = requireSafeBuffer$1().Buffer, l = requireBrowser$8(), u = requireBrowserifyRsa(), f = requireElliptic().ec, p = requireBn$4(), d = requireParseAsn1(), m = require$$4, v = 1; function I(ae, se, le, ue, he) { var pe = d(se); if (pe.curve) { if (ue !== "ecdsa" && ue !== "ecdsa/rsa") throw new Error("wrong private key type"); return F(ae, pe) } else if (pe.type === "dsa") { if (ue !== "dsa") throw new Error("wrong private key type"); return B(ae, pe, le) } if (ue !== "rsa" && ue !== "ecdsa/rsa") throw new Error("wrong private key type"); if (se.padding !== void 0 && se.padding !== v) throw new Error("illegal or unsupported padding mode"); ae = o.concat([he, ae]); for (var ve = pe.modulus.byteLength(), _e = [0, 1]; ae.length + _e.length + 1 < ve;)_e.push(255); _e.push(0); for (var Se = -1; ++Se < ae.length;)_e.push(ae[Se]); var $e = u(_e, pe); return $e } function F(ae, se) { var le = m[se.curve.join(".")]; if (!le) throw new Error("unknown curve " + se.curve.join(".")); var ue = new f(le), he = ue.keyFromPrivate(se.privateKey), pe = he.sign(ae); return o.from(pe.toDER()) } function B(ae, se, le) { for (var ue = se.params.priv_key, he = se.params.p, pe = se.params.q, ve = se.params.g, _e = new p(0), Se, $e = Q(ae, pe).mod(pe), ie = !1, g = Z(ue, pe, ae, le); ie === !1;)Se = ne(pe, g, le), _e = oe(ve, Se, he, pe), ie = Se.invm(pe).imul($e.add(ue.mul(_e))).mod(pe), ie.cmpn(0) === 0 && (ie = !1, _e = new p(0)); return W(_e, ie) } function W(ae, se) { ae = ae.toArray(), se = se.toArray(), ae[0] & 128 && (ae = [0].concat(ae)), se[0] & 128 && (se = [0].concat(se)); var le = ae.length + se.length + 4, ue = [48, le, 2, ae.length]; return ue = ue.concat(ae, [2, se.length], se), o.from(ue) } function Z(ae, se, le, ue) { if (ae = o.from(ae.toArray()), ae.length < se.byteLength()) { var he = o.alloc(se.byteLength() - ae.length); ae = o.concat([he, ae]) } var pe = le.length, ve = re(le, se), _e = o.alloc(pe); _e.fill(1); var Se = o.alloc(pe); return Se = l(ue, Se).update(_e).update(o.from([0])).update(ae).update(ve).digest(), _e = l(ue, Se).update(_e).digest(), Se = l(ue, Se).update(_e).update(o.from([1])).update(ae).update(ve).digest(), _e = l(ue, Se).update(_e).digest(), { k: Se, v: _e } } function Q(ae, se) { var le = new p(ae), ue = (ae.length << 3) - se.bitLength(); return ue > 0 && le.ishrn(ue), le } function re(ae, se) { ae = Q(ae, se), ae = ae.mod(se); var le = o.from(ae.toArray()); if (le.length < se.byteLength()) { var ue = o.alloc(se.byteLength() - le.length); le = o.concat([ue, le]) } return le } function ne(ae, se, le) { var ue, he; do { for (ue = o.alloc(0); ue.length * 8 < ae.bitLength();)se.v = l(le, se.k).update(se.v).digest(), ue = o.concat([ue, se.v]); he = Q(ue, ae), se.k = l(le, se.k).update(se.v).update(o.from([0])).digest(), se.v = l(le, se.k).update(se.v).digest() } while (he.cmp(ae) !== -1); return he } function oe(ae, se, le, ue) { return ae.toRed(p.mont(le)).redPow(se).fromRed().mod(ue) } return sign.exports = I, sign.exports.getKey = Z, sign.exports.makeKey = ne, sign.exports } var verify_1, hasRequiredVerify; function requireVerify() { if (hasRequiredVerify) return verify_1; hasRequiredVerify = 1; var o = requireSafeBuffer$1().Buffer, l = requireBn$4(), u = requireElliptic().ec, f = requireParseAsn1(), p = require$$4; function d(F, B, W, Z, Q) { var re = f(W); if (re.type === "ec") { if (Z !== "ecdsa" && Z !== "ecdsa/rsa") throw new Error("wrong public key type"); return m(F, B, re) } else if (re.type === "dsa") { if (Z !== "dsa") throw new Error("wrong public key type"); return v(F, B, re) } if (Z !== "rsa" && Z !== "ecdsa/rsa") throw new Error("wrong public key type"); B = o.concat([Q, B]); for (var ne = re.modulus.byteLength(), oe = [1], ae = 0; B.length + oe.length + 2 < ne;)oe.push(255), ae += 1; oe.push(0); for (var se = -1; ++se < B.length;)oe.push(B[se]); oe = o.from(oe); var le = l.mont(re.modulus); F = new l(F).toRed(le), F = F.redPow(new l(re.publicExponent)), F = o.from(F.fromRed().toArray()); var ue = ae < 8 ? 1 : 0; for (ne = Math.min(F.length, oe.length), F.length !== oe.length && (ue = 1), se = -1; ++se < ne;)ue |= F[se] ^ oe[se]; return ue === 0 } function m(F, B, W) { var Z = p[W.data.algorithm.curve.join(".")]; if (!Z) throw new Error("unknown curve " + W.data.algorithm.curve.join(".")); var Q = new u(Z), re = W.data.subjectPrivateKey.data; return Q.verify(B, F, re) } function v(F, B, W) { var Z = W.data.p, Q = W.data.q, re = W.data.g, ne = W.data.pub_key, oe = f.signature.decode(F, "der"), ae = oe.s, se = oe.r; I(ae, Q), I(se, Q); var le = l.mont(Z), ue = ae.invm(Q), he = re.toRed(le).redPow(new l(B).mul(ue).mod(Q)).fromRed().mul(ne.toRed(le).redPow(se.mul(ue).mod(Q)).fromRed()).mod(Z).mod(Q); return he.cmp(se) === 0 } function I(F, B) { if (F.cmpn(0) <= 0) throw new Error("invalid sig"); if (F.cmp(B) >= 0) throw new Error("invalid sig") } return verify_1 = d, verify_1 } var browser$4, hasRequiredBrowser$3; function requireBrowser$3() { if (hasRequiredBrowser$3) return browser$4; hasRequiredBrowser$3 = 1; var o = requireSafeBuffer$1().Buffer, l = requireBrowser$9(), u = requireReadableBrowser(), f = requireInherits_browser(), p = requireSign(), d = requireVerify(), m = require$$6; Object.keys(m).forEach(function (W) { m[W].id = o.from(m[W].id, "hex"), m[W.toLowerCase()] = m[W] }); function v(W) { u.Writable.call(this); var Z = m[W]; if (!Z) throw new Error("Unknown message digest"); this._hashType = Z.hash, this._hash = l(Z.hash), this._tag = Z.id, this._signType = Z.sign } f(v, u.Writable), v.prototype._write = function (Z, Q, re) { this._hash.update(Z), re() }, v.prototype.update = function (Z, Q) { return this._hash.update(typeof Z == "string" ? o.from(Z, Q) : Z), this }, v.prototype.sign = function (Z, Q) { this.end(); var re = this._hash.digest(), ne = p(re, Z, this._hashType, this._signType, this._tag); return Q ? ne.toString(Q) : ne }; function I(W) { u.Writable.call(this); var Z = m[W]; if (!Z) throw new Error("Unknown message digest"); this._hash = l(Z.hash), this._tag = Z.id, this._signType = Z.sign } f(I, u.Writable), I.prototype._write = function (Z, Q, re) { this._hash.update(Z), re() }, I.prototype.update = function (Z, Q) { return this._hash.update(typeof Z == "string" ? o.from(Z, Q) : Z), this }, I.prototype.verify = function (Z, Q, re) { var ne = typeof Q == "string" ? o.from(Q, re) : Q; this.end(); var oe = this._hash.digest(); return d(ne, oe, Z, this._signType, this._tag) }; function F(W) { return new v(W) } function B(W) { return new I(W) } return browser$4 = { Sign: F, Verify: B, createSign: F, createVerify: B }, browser$4 } var bn$3 = { exports: {} }, bn$2 = bn$3.exports, hasRequiredBn$1; function requireBn$1() { return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function (o) { (function (l, u) { function f(ie, g) { if (!ie) throw new Error(g || "Assertion failed") } function p(ie, g) { ie.super_ = g; var P = function () { }; P.prototype = g.prototype, ie.prototype = new P, ie.prototype.constructor = ie } function d(ie, g, P) { if (d.isBN(ie)) return ie; this.negative = 0, this.words = null, this.length = 0, this.red = null, ie !== null && ((g === "le" || g === "be") && (P = g, g = 10), this._init(ie || 0, g || 10, P || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (g) { return g instanceof d ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === d.wordSize && Array.isArray(g.words) }, d.max = function (g, P) { return g.cmp(P) > 0 ? g : P }, d.min = function (g, P) { return g.cmp(P) < 0 ? g : P }, d.prototype._init = function (g, P, U) { if (typeof g == "number") return this._initNumber(g, P, U); if (typeof g == "object") return this._initArray(g, P, U); P === "hex" && (P = 16), f(P === (P | 0) && P >= 2 && P <= 36), g = g.toString().replace(/\s+/g, ""); var K = 0; g[0] === "-" && (K++, this.negative = 1), K < g.length && (P === 16 ? this._parseHex(g, K, U) : (this._parseBase(g, P, K), U === "le" && this._initArray(this.toArray(), P, U))) }, d.prototype._initNumber = function (g, P, U) { g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [g & 67108863, g / 67108864 & 67108863], this.length = 2) : (f(g < 9007199254740992), this.words = [g & 67108863, g / 67108864 & 67108863, 1], this.length = 3), U === "le" && this._initArray(this.toArray(), P, U) }, d.prototype._initArray = function (g, P, U) { if (f(typeof g.length == "number"), g.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(g.length / 3), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y, te, ee = 0; if (U === "be") for (K = g.length - 1, Y = 0; K >= 0; K -= 3)te = g[K] | g[K - 1] << 8 | g[K - 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); else if (U === "le") for (K = 0, Y = 0; K < g.length; K += 3)te = g[K] | g[K + 1] << 8 | g[K + 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); return this.strip() }; function v(ie, g) { var P = ie.charCodeAt(g); return P >= 65 && P <= 70 ? P - 55 : P >= 97 && P <= 102 ? P - 87 : P - 48 & 15 } function I(ie, g, P) { var U = v(ie, P); return P - 1 >= g && (U |= v(ie, P - 1) << 4), U } d.prototype._parseHex = function (g, P, U) { this.length = Math.ceil((g.length - P) / 6), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y = 0, te = 0, ee; if (U === "be") for (K = g.length - 1; K >= P; K -= 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8; else { var G = g.length - P; for (K = G % 2 === 0 ? P + 1 : P; K < g.length; K += 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8 } this.strip() }; function F(ie, g, P, U) { for (var K = 0, Y = Math.min(ie.length, P), te = g; te < Y; te++) { var ee = ie.charCodeAt(te) - 48; K *= U, ee >= 49 ? K += ee - 49 + 10 : ee >= 17 ? K += ee - 17 + 10 : K += ee } return K } d.prototype._parseBase = function (g, P, U) { this.words = [0], this.length = 1; for (var K = 0, Y = 1; Y <= 67108863; Y *= P)K++; K--, Y = Y / P | 0; for (var te = g.length - U, ee = te % K, G = Math.min(te, te - ee) + U, y = 0, X = U; X < G; X += K)y = F(g, X, X + K, P), this.imuln(Y), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y); if (ee !== 0) { var ce = 1; for (y = F(g, X, g.length, P), X = 0; X < ee; X++)ce *= P; this.imuln(ce), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y) } this.strip() }, d.prototype.copy = function (g) { g.words = new Array(this.length); for (var P = 0; P < this.length; P++)g.words[P] = this.words[P]; g.length = this.length, g.negative = this.negative, g.red = this.red }, d.prototype.clone = function () { var g = new d(null); return this.copy(g), g }, d.prototype._expand = function (g) { for (; this.length < g;)this.words[this.length++] = 0; return this }, d.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, d.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var B = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], W = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (g, P) { g = g || 10, P = P | 0 || 1; var U; if (g === 16 || g === "hex") { U = ""; for (var K = 0, Y = 0, te = 0; te < this.length; te++) { var ee = this.words[te], G = ((ee << K | Y) & 16777215).toString(16); Y = ee >>> 24 - K & 16777215, Y !== 0 || te !== this.length - 1 ? U = B[6 - G.length] + G + U : U = G + U, K += 2, K >= 26 && (K -= 26, te--) } for (Y !== 0 && (U = Y.toString(16) + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } if (g === (g | 0) && g >= 2 && g <= 36) { var y = W[g], X = Z[g]; U = ""; var ce = this.clone(); for (ce.negative = 0; !ce.isZero();) { var me = ce.modn(X).toString(g); ce = ce.idivn(X), ce.isZero() ? U = me + U : U = B[y - me.length] + me + U } for (this.isZero() && (U = "0" + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var g = this.words[0]; return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g }, d.prototype.toJSON = function () { return this.toString(16) }, d.prototype.toBuffer = function (g, P) { return f(typeof m < "u"), this.toArrayLike(m, g, P) }, d.prototype.toArray = function (g, P) { return this.toArrayLike(Array, g, P) }, d.prototype.toArrayLike = function (g, P, U) { var K = this.byteLength(), Y = U || Math.max(1, K); f(K <= Y, "byte array longer than desired length"), f(Y > 0, "Requested array length <= 0"), this.strip(); var te = P === "le", ee = new g(Y), G, y, X = this.clone(); if (te) { for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[y] = G; for (; y < Y; y++)ee[y] = 0 } else { for (y = 0; y < Y - K; y++)ee[y] = 0; for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[Y - y - 1] = G } return ee }, Math.clz32 ? d.prototype._countBits = function (g) { return 32 - Math.clz32(g) } : d.prototype._countBits = function (g) { var P = g, U = 0; return P >= 4096 && (U += 13, P >>>= 13), P >= 64 && (U += 7, P >>>= 7), P >= 8 && (U += 4, P >>>= 4), P >= 2 && (U += 2, P >>>= 2), U + P }, d.prototype._zeroBits = function (g) { if (g === 0) return 26; var P = g, U = 0; return (P & 8191) === 0 && (U += 13, P >>>= 13), (P & 127) === 0 && (U += 7, P >>>= 7), (P & 15) === 0 && (U += 4, P >>>= 4), (P & 3) === 0 && (U += 2, P >>>= 2), (P & 1) === 0 && U++, U }, d.prototype.bitLength = function () { var g = this.words[this.length - 1], P = this._countBits(g); return (this.length - 1) * 26 + P }; function Q(ie) { for (var g = new Array(ie.bitLength()), P = 0; P < g.length; P++) { var U = P / 26 | 0, K = P % 26; g[P] = (ie.words[U] & 1 << K) >>> K } return g } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var g = 0, P = 0; P < this.length; P++) { var U = this._zeroBits(this.words[P]); if (g += U, U !== 26) break } return g }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (g) { return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (g) { return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (g) { for (; this.length < g.length;)this.words[this.length++] = 0; for (var P = 0; P < g.length; P++)this.words[P] = this.words[P] | g.words[P]; return this.strip() }, d.prototype.ior = function (g) { return f((this.negative | g.negative) === 0), this.iuor(g) }, d.prototype.or = function (g) { return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this) }, d.prototype.uor = function (g) { return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this) }, d.prototype.iuand = function (g) { var P; this.length > g.length ? P = g : P = this; for (var U = 0; U < P.length; U++)this.words[U] = this.words[U] & g.words[U]; return this.length = P.length, this.strip() }, d.prototype.iand = function (g) { return f((this.negative | g.negative) === 0), this.iuand(g) }, d.prototype.and = function (g) { return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this) }, d.prototype.uand = function (g) { return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this) }, d.prototype.iuxor = function (g) { var P, U; this.length > g.length ? (P = this, U = g) : (P = g, U = this); for (var K = 0; K < U.length; K++)this.words[K] = P.words[K] ^ U.words[K]; if (this !== P) for (; K < P.length; K++)this.words[K] = P.words[K]; return this.length = P.length, this.strip() }, d.prototype.ixor = function (g) { return f((this.negative | g.negative) === 0), this.iuxor(g) }, d.prototype.xor = function (g) { return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this) }, d.prototype.uxor = function (g) { return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this) }, d.prototype.inotn = function (g) { f(typeof g == "number" && g >= 0); var P = Math.ceil(g / 26) | 0, U = g % 26; this._expand(P), U > 0 && P--; for (var K = 0; K < P; K++)this.words[K] = ~this.words[K] & 67108863; return U > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - U), this.strip() }, d.prototype.notn = function (g) { return this.clone().inotn(g) }, d.prototype.setn = function (g, P) { f(typeof g == "number" && g >= 0); var U = g / 26 | 0, K = g % 26; return this._expand(U + 1), P ? this.words[U] = this.words[U] | 1 << K : this.words[U] = this.words[U] & ~(1 << K), this.strip() }, d.prototype.iadd = function (g) { var P; if (this.negative !== 0 && g.negative === 0) return this.negative = 0, P = this.isub(g), this.negative ^= 1, this._normSign(); if (this.negative === 0 && g.negative !== 0) return g.negative = 0, P = this.isub(g), g.negative = 1, P._normSign(); var U, K; this.length > g.length ? (U = this, K = g) : (U = g, K = this); for (var Y = 0, te = 0; te < K.length; te++)P = (U.words[te] | 0) + (K.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; for (; Y !== 0 && te < U.length; te++)P = (U.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; if (this.length = U.length, Y !== 0) this.words[this.length] = Y, this.length++; else if (U !== this) for (; te < U.length; te++)this.words[te] = U.words[te]; return this }, d.prototype.add = function (g) { var P; return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, P = this.sub(g), g.negative ^= 1, P) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = g.sub(this), this.negative = 1, P) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this) }, d.prototype.isub = function (g) { if (g.negative !== 0) { g.negative = 0; var P = this.iadd(g); return g.negative = 1, P._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign(); var U = this.cmp(g); if (U === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var K, Y; U > 0 ? (K = this, Y = g) : (K = g, Y = this); for (var te = 0, ee = 0; ee < Y.length; ee++)P = (K.words[ee] | 0) - (Y.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; for (; te !== 0 && ee < K.length; ee++)P = (K.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; if (te === 0 && ee < K.length && K !== this) for (; ee < K.length; ee++)this.words[ee] = K.words[ee]; return this.length = Math.max(this.length, ee), K !== this && (this.negative = 1), this.strip() }, d.prototype.sub = function (g) { return this.clone().isub(g) }; function re(ie, g, P) { P.negative = g.negative ^ ie.negative; var U = ie.length + g.length | 0; P.length = U, U = U - 1 | 0; var K = ie.words[0] | 0, Y = g.words[0] | 0, te = K * Y, ee = te & 67108863, G = te / 67108864 | 0; P.words[0] = ee; for (var y = 1; y < U; y++) { for (var X = G >>> 26, ce = G & 67108863, me = Math.min(y, g.length - 1), Ae = Math.max(0, y - ie.length + 1); Ae <= me; Ae++) { var Ie = y - Ae | 0; K = ie.words[Ie] | 0, Y = g.words[Ae] | 0, te = K * Y + ce, X += te / 67108864 | 0, ce = te & 67108863 } P.words[y] = ce | 0, G = X | 0 } return G !== 0 ? P.words[y] = G | 0 : P.length--, P.strip() } var ne = function (g, P, U) { var K = g.words, Y = P.words, te = U.words, ee = 0, G, y, X, ce = K[0] | 0, me = ce & 8191, Ae = ce >>> 13, Ie = K[1] | 0, Be = Ie & 8191, Me = Ie >>> 13, De = K[2] | 0, Ue = De & 8191, Ke = De >>> 13, Ve = K[3] | 0, ke = Ve & 8191, Je = Ve >>> 13, dt = K[4] | 0, lt = dt & 8191, ht = dt >>> 13, Bt = K[5] | 0, mt = Bt & 8191, et = Bt >>> 13, Gt = K[6] | 0, pt = Gt & 8191, _t = Gt >>> 13, zt = K[7] | 0, bt = zt & 8191, We = zt >>> 13, Ge = K[8] | 0, ze = Ge & 8191, Ze = Ge >>> 13, ut = K[9] | 0, ye = ut & 8191, ge = ut >>> 13, Ee = Y[0] | 0, Oe = Ee & 8191, je = Ee >>> 13, nt = Y[1] | 0, Xe = nt & 8191, it = nt >>> 13, Tt = Y[2] | 0, tt = Tt & 8191, yt = Tt >>> 13, kt = Y[3] | 0, wt = kt & 8191, Mt = kt >>> 13, tr = Y[4] | 0, St = tr & 8191, gt = tr >>> 13, rr = Y[5] | 0, Le = rr & 8191, xe = rr >>> 13, Ce = Y[6] | 0, Ne = Ce & 8191, Ye = Ce >>> 13, Re = Y[7] | 0, Pe = Re & 8191, qe = Re >>> 13, be = Y[8] | 0, Fe = be & 8191, Qe = be >>> 13, st = Y[9] | 0, rt = st & 8191, ct = st >>> 13; U.negative = g.negative ^ P.negative, U.length = 19, G = Math.imul(me, Oe), y = Math.imul(me, je), y = y + Math.imul(Ae, Oe) | 0, X = Math.imul(Ae, je); var Lt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(Be, Oe), y = Math.imul(Be, je), y = y + Math.imul(Me, Oe) | 0, X = Math.imul(Me, je), G = G + Math.imul(me, Xe) | 0, y = y + Math.imul(me, it) | 0, y = y + Math.imul(Ae, Xe) | 0, X = X + Math.imul(Ae, it) | 0; var It = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(Ue, Oe), y = Math.imul(Ue, je), y = y + Math.imul(Ke, Oe) | 0, X = Math.imul(Ke, je), G = G + Math.imul(Be, Xe) | 0, y = y + Math.imul(Be, it) | 0, y = y + Math.imul(Me, Xe) | 0, X = X + Math.imul(Me, it) | 0, G = G + Math.imul(me, tt) | 0, y = y + Math.imul(me, yt) | 0, y = y + Math.imul(Ae, tt) | 0, X = X + Math.imul(Ae, yt) | 0; var lr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, G = Math.imul(ke, Oe), y = Math.imul(ke, je), y = y + Math.imul(Je, Oe) | 0, X = Math.imul(Je, je), G = G + Math.imul(Ue, Xe) | 0, y = y + Math.imul(Ue, it) | 0, y = y + Math.imul(Ke, Xe) | 0, X = X + Math.imul(Ke, it) | 0, G = G + Math.imul(Be, tt) | 0, y = y + Math.imul(Be, yt) | 0, y = y + Math.imul(Me, tt) | 0, X = X + Math.imul(Me, yt) | 0, G = G + Math.imul(me, wt) | 0, y = y + Math.imul(me, Mt) | 0, y = y + Math.imul(Ae, wt) | 0, X = X + Math.imul(Ae, Mt) | 0; var jt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(lt, Oe), y = Math.imul(lt, je), y = y + Math.imul(ht, Oe) | 0, X = Math.imul(ht, je), G = G + Math.imul(ke, Xe) | 0, y = y + Math.imul(ke, it) | 0, y = y + Math.imul(Je, Xe) | 0, X = X + Math.imul(Je, it) | 0, G = G + Math.imul(Ue, tt) | 0, y = y + Math.imul(Ue, yt) | 0, y = y + Math.imul(Ke, tt) | 0, X = X + Math.imul(Ke, yt) | 0, G = G + Math.imul(Be, wt) | 0, y = y + Math.imul(Be, Mt) | 0, y = y + Math.imul(Me, wt) | 0, X = X + Math.imul(Me, Mt) | 0, G = G + Math.imul(me, St) | 0, y = y + Math.imul(me, gt) | 0, y = y + Math.imul(Ae, St) | 0, X = X + Math.imul(Ae, gt) | 0; var Ft = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(mt, Oe), y = Math.imul(mt, je), y = y + Math.imul(et, Oe) | 0, X = Math.imul(et, je), G = G + Math.imul(lt, Xe) | 0, y = y + Math.imul(lt, it) | 0, y = y + Math.imul(ht, Xe) | 0, X = X + Math.imul(ht, it) | 0, G = G + Math.imul(ke, tt) | 0, y = y + Math.imul(ke, yt) | 0, y = y + Math.imul(Je, tt) | 0, X = X + Math.imul(Je, yt) | 0, G = G + Math.imul(Ue, wt) | 0, y = y + Math.imul(Ue, Mt) | 0, y = y + Math.imul(Ke, wt) | 0, X = X + Math.imul(Ke, Mt) | 0, G = G + Math.imul(Be, St) | 0, y = y + Math.imul(Be, gt) | 0, y = y + Math.imul(Me, St) | 0, X = X + Math.imul(Me, gt) | 0, G = G + Math.imul(me, Le) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(Ae, Le) | 0, X = X + Math.imul(Ae, xe) | 0; var er = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, G = Math.imul(pt, Oe), y = Math.imul(pt, je), y = y + Math.imul(_t, Oe) | 0, X = Math.imul(_t, je), G = G + Math.imul(mt, Xe) | 0, y = y + Math.imul(mt, it) | 0, y = y + Math.imul(et, Xe) | 0, X = X + Math.imul(et, it) | 0, G = G + Math.imul(lt, tt) | 0, y = y + Math.imul(lt, yt) | 0, y = y + Math.imul(ht, tt) | 0, X = X + Math.imul(ht, yt) | 0, G = G + Math.imul(ke, wt) | 0, y = y + Math.imul(ke, Mt) | 0, y = y + Math.imul(Je, wt) | 0, X = X + Math.imul(Je, Mt) | 0, G = G + Math.imul(Ue, St) | 0, y = y + Math.imul(Ue, gt) | 0, y = y + Math.imul(Ke, St) | 0, X = X + Math.imul(Ke, gt) | 0, G = G + Math.imul(Be, Le) | 0, y = y + Math.imul(Be, xe) | 0, y = y + Math.imul(Me, Le) | 0, X = X + Math.imul(Me, xe) | 0, G = G + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Ye) | 0, y = y + Math.imul(Ae, Ne) | 0, X = X + Math.imul(Ae, Ye) | 0; var ar = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, G = Math.imul(bt, Oe), y = Math.imul(bt, je), y = y + Math.imul(We, Oe) | 0, X = Math.imul(We, je), G = G + Math.imul(pt, Xe) | 0, y = y + Math.imul(pt, it) | 0, y = y + Math.imul(_t, Xe) | 0, X = X + Math.imul(_t, it) | 0, G = G + Math.imul(mt, tt) | 0, y = y + Math.imul(mt, yt) | 0, y = y + Math.imul(et, tt) | 0, X = X + Math.imul(et, yt) | 0, G = G + Math.imul(lt, wt) | 0, y = y + Math.imul(lt, Mt) | 0, y = y + Math.imul(ht, wt) | 0, X = X + Math.imul(ht, Mt) | 0, G = G + Math.imul(ke, St) | 0, y = y + Math.imul(ke, gt) | 0, y = y + Math.imul(Je, St) | 0, X = X + Math.imul(Je, gt) | 0, G = G + Math.imul(Ue, Le) | 0, y = y + Math.imul(Ue, xe) | 0, y = y + Math.imul(Ke, Le) | 0, X = X + Math.imul(Ke, xe) | 0, G = G + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, Ye) | 0, y = y + Math.imul(Me, Ne) | 0, X = X + Math.imul(Me, Ye) | 0, G = G + Math.imul(me, Pe) | 0, y = y + Math.imul(me, qe) | 0, y = y + Math.imul(Ae, Pe) | 0, X = X + Math.imul(Ae, qe) | 0; var nr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, G = Math.imul(ze, Oe), y = Math.imul(ze, je), y = y + Math.imul(Ze, Oe) | 0, X = Math.imul(Ze, je), G = G + Math.imul(bt, Xe) | 0, y = y + Math.imul(bt, it) | 0, y = y + Math.imul(We, Xe) | 0, X = X + Math.imul(We, it) | 0, G = G + Math.imul(pt, tt) | 0, y = y + Math.imul(pt, yt) | 0, y = y + Math.imul(_t, tt) | 0, X = X + Math.imul(_t, yt) | 0, G = G + Math.imul(mt, wt) | 0, y = y + Math.imul(mt, Mt) | 0, y = y + Math.imul(et, wt) | 0, X = X + Math.imul(et, Mt) | 0, G = G + Math.imul(lt, St) | 0, y = y + Math.imul(lt, gt) | 0, y = y + Math.imul(ht, St) | 0, X = X + Math.imul(ht, gt) | 0, G = G + Math.imul(ke, Le) | 0, y = y + Math.imul(ke, xe) | 0, y = y + Math.imul(Je, Le) | 0, X = X + Math.imul(Je, xe) | 0, G = G + Math.imul(Ue, Ne) | 0, y = y + Math.imul(Ue, Ye) | 0, y = y + Math.imul(Ke, Ne) | 0, X = X + Math.imul(Ke, Ye) | 0, G = G + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, qe) | 0, y = y + Math.imul(Me, Pe) | 0, X = X + Math.imul(Me, qe) | 0, G = G + Math.imul(me, Fe) | 0, y = y + Math.imul(me, Qe) | 0, y = y + Math.imul(Ae, Fe) | 0, X = X + Math.imul(Ae, Qe) | 0; var ir = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, G = Math.imul(ye, Oe), y = Math.imul(ye, je), y = y + Math.imul(ge, Oe) | 0, X = Math.imul(ge, je), G = G + Math.imul(ze, Xe) | 0, y = y + Math.imul(ze, it) | 0, y = y + Math.imul(Ze, Xe) | 0, X = X + Math.imul(Ze, it) | 0, G = G + Math.imul(bt, tt) | 0, y = y + Math.imul(bt, yt) | 0, y = y + Math.imul(We, tt) | 0, X = X + Math.imul(We, yt) | 0, G = G + Math.imul(pt, wt) | 0, y = y + Math.imul(pt, Mt) | 0, y = y + Math.imul(_t, wt) | 0, X = X + Math.imul(_t, Mt) | 0, G = G + Math.imul(mt, St) | 0, y = y + Math.imul(mt, gt) | 0, y = y + Math.imul(et, St) | 0, X = X + Math.imul(et, gt) | 0, G = G + Math.imul(lt, Le) | 0, y = y + Math.imul(lt, xe) | 0, y = y + Math.imul(ht, Le) | 0, X = X + Math.imul(ht, xe) | 0, G = G + Math.imul(ke, Ne) | 0, y = y + Math.imul(ke, Ye) | 0, y = y + Math.imul(Je, Ne) | 0, X = X + Math.imul(Je, Ye) | 0, G = G + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, qe) | 0, y = y + Math.imul(Ke, Pe) | 0, X = X + Math.imul(Ke, qe) | 0, G = G + Math.imul(Be, Fe) | 0, y = y + Math.imul(Be, Qe) | 0, y = y + Math.imul(Me, Fe) | 0, X = X + Math.imul(Me, Qe) | 0, G = G + Math.imul(me, rt) | 0, y = y + Math.imul(me, ct) | 0, y = y + Math.imul(Ae, rt) | 0, X = X + Math.imul(Ae, ct) | 0; var Ht = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(ye, Xe), y = Math.imul(ye, it), y = y + Math.imul(ge, Xe) | 0, X = Math.imul(ge, it), G = G + Math.imul(ze, tt) | 0, y = y + Math.imul(ze, yt) | 0, y = y + Math.imul(Ze, tt) | 0, X = X + Math.imul(Ze, yt) | 0, G = G + Math.imul(bt, wt) | 0, y = y + Math.imul(bt, Mt) | 0, y = y + Math.imul(We, wt) | 0, X = X + Math.imul(We, Mt) | 0, G = G + Math.imul(pt, St) | 0, y = y + Math.imul(pt, gt) | 0, y = y + Math.imul(_t, St) | 0, X = X + Math.imul(_t, gt) | 0, G = G + Math.imul(mt, Le) | 0, y = y + Math.imul(mt, xe) | 0, y = y + Math.imul(et, Le) | 0, X = X + Math.imul(et, xe) | 0, G = G + Math.imul(lt, Ne) | 0, y = y + Math.imul(lt, Ye) | 0, y = y + Math.imul(ht, Ne) | 0, X = X + Math.imul(ht, Ye) | 0, G = G + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, qe) | 0, y = y + Math.imul(Je, Pe) | 0, X = X + Math.imul(Je, qe) | 0, G = G + Math.imul(Ue, Fe) | 0, y = y + Math.imul(Ue, Qe) | 0, y = y + Math.imul(Ke, Fe) | 0, X = X + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, ct) | 0, y = y + Math.imul(Me, rt) | 0, X = X + Math.imul(Me, ct) | 0; var sr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, G = Math.imul(ye, tt), y = Math.imul(ye, yt), y = y + Math.imul(ge, tt) | 0, X = Math.imul(ge, yt), G = G + Math.imul(ze, wt) | 0, y = y + Math.imul(ze, Mt) | 0, y = y + Math.imul(Ze, wt) | 0, X = X + Math.imul(Ze, Mt) | 0, G = G + Math.imul(bt, St) | 0, y = y + Math.imul(bt, gt) | 0, y = y + Math.imul(We, St) | 0, X = X + Math.imul(We, gt) | 0, G = G + Math.imul(pt, Le) | 0, y = y + Math.imul(pt, xe) | 0, y = y + Math.imul(_t, Le) | 0, X = X + Math.imul(_t, xe) | 0, G = G + Math.imul(mt, Ne) | 0, y = y + Math.imul(mt, Ye) | 0, y = y + Math.imul(et, Ne) | 0, X = X + Math.imul(et, Ye) | 0, G = G + Math.imul(lt, Pe) | 0, y = y + Math.imul(lt, qe) | 0, y = y + Math.imul(ht, Pe) | 0, X = X + Math.imul(ht, qe) | 0, G = G + Math.imul(ke, Fe) | 0, y = y + Math.imul(ke, Qe) | 0, y = y + Math.imul(Je, Fe) | 0, X = X + Math.imul(Je, Qe) | 0, G = G + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ke, rt) | 0, X = X + Math.imul(Ke, ct) | 0; var Kt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, G = Math.imul(ye, wt), y = Math.imul(ye, Mt), y = y + Math.imul(ge, wt) | 0, X = Math.imul(ge, Mt), G = G + Math.imul(ze, St) | 0, y = y + Math.imul(ze, gt) | 0, y = y + Math.imul(Ze, St) | 0, X = X + Math.imul(Ze, gt) | 0, G = G + Math.imul(bt, Le) | 0, y = y + Math.imul(bt, xe) | 0, y = y + Math.imul(We, Le) | 0, X = X + Math.imul(We, xe) | 0, G = G + Math.imul(pt, Ne) | 0, y = y + Math.imul(pt, Ye) | 0, y = y + Math.imul(_t, Ne) | 0, X = X + Math.imul(_t, Ye) | 0, G = G + Math.imul(mt, Pe) | 0, y = y + Math.imul(mt, qe) | 0, y = y + Math.imul(et, Pe) | 0, X = X + Math.imul(et, qe) | 0, G = G + Math.imul(lt, Fe) | 0, y = y + Math.imul(lt, Qe) | 0, y = y + Math.imul(ht, Fe) | 0, X = X + Math.imul(ht, Qe) | 0, G = G + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, ct) | 0, y = y + Math.imul(Je, rt) | 0, X = X + Math.imul(Je, ct) | 0; var Qt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, G = Math.imul(ye, St), y = Math.imul(ye, gt), y = y + Math.imul(ge, St) | 0, X = Math.imul(ge, gt), G = G + Math.imul(ze, Le) | 0, y = y + Math.imul(ze, xe) | 0, y = y + Math.imul(Ze, Le) | 0, X = X + Math.imul(Ze, xe) | 0, G = G + Math.imul(bt, Ne) | 0, y = y + Math.imul(bt, Ye) | 0, y = y + Math.imul(We, Ne) | 0, X = X + Math.imul(We, Ye) | 0, G = G + Math.imul(pt, Pe) | 0, y = y + Math.imul(pt, qe) | 0, y = y + Math.imul(_t, Pe) | 0, X = X + Math.imul(_t, qe) | 0, G = G + Math.imul(mt, Fe) | 0, y = y + Math.imul(mt, Qe) | 0, y = y + Math.imul(et, Fe) | 0, X = X + Math.imul(et, Qe) | 0, G = G + Math.imul(lt, rt) | 0, y = y + Math.imul(lt, ct) | 0, y = y + Math.imul(ht, rt) | 0, X = X + Math.imul(ht, ct) | 0; var $t = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, G = Math.imul(ye, Le), y = Math.imul(ye, xe), y = y + Math.imul(ge, Le) | 0, X = Math.imul(ge, xe), G = G + Math.imul(ze, Ne) | 0, y = y + Math.imul(ze, Ye) | 0, y = y + Math.imul(Ze, Ne) | 0, X = X + Math.imul(Ze, Ye) | 0, G = G + Math.imul(bt, Pe) | 0, y = y + Math.imul(bt, qe) | 0, y = y + Math.imul(We, Pe) | 0, X = X + Math.imul(We, qe) | 0, G = G + Math.imul(pt, Fe) | 0, y = y + Math.imul(pt, Qe) | 0, y = y + Math.imul(_t, Fe) | 0, X = X + Math.imul(_t, Qe) | 0, G = G + Math.imul(mt, rt) | 0, y = y + Math.imul(mt, ct) | 0, y = y + Math.imul(et, rt) | 0, X = X + Math.imul(et, ct) | 0; var Yt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, G = Math.imul(ye, Ne), y = Math.imul(ye, Ye), y = y + Math.imul(ge, Ne) | 0, X = Math.imul(ge, Ye), G = G + Math.imul(ze, Pe) | 0, y = y + Math.imul(ze, qe) | 0, y = y + Math.imul(Ze, Pe) | 0, X = X + Math.imul(Ze, qe) | 0, G = G + Math.imul(bt, Fe) | 0, y = y + Math.imul(bt, Qe) | 0, y = y + Math.imul(We, Fe) | 0, X = X + Math.imul(We, Qe) | 0, G = G + Math.imul(pt, rt) | 0, y = y + Math.imul(pt, ct) | 0, y = y + Math.imul(_t, rt) | 0, X = X + Math.imul(_t, ct) | 0; var Xt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, G = Math.imul(ye, Pe), y = Math.imul(ye, qe), y = y + Math.imul(ge, Pe) | 0, X = Math.imul(ge, qe), G = G + Math.imul(ze, Fe) | 0, y = y + Math.imul(ze, Qe) | 0, y = y + Math.imul(Ze, Fe) | 0, X = X + Math.imul(Ze, Qe) | 0, G = G + Math.imul(bt, rt) | 0, y = y + Math.imul(bt, ct) | 0, y = y + Math.imul(We, rt) | 0, X = X + Math.imul(We, ct) | 0; var Nt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ye, Fe), y = Math.imul(ye, Qe), y = y + Math.imul(ge, Fe) | 0, X = Math.imul(ge, Qe), G = G + Math.imul(ze, rt) | 0, y = y + Math.imul(ze, ct) | 0, y = y + Math.imul(Ze, rt) | 0, X = X + Math.imul(Ze, ct) | 0; var Et = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, G = Math.imul(ye, rt), y = Math.imul(ye, ct), y = y + Math.imul(ge, rt) | 0, X = Math.imul(ge, ct); var At = (ee + G | 0) + ((y & 8191) << 13) | 0; return ee = (X + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, te[0] = Lt, te[1] = It, te[2] = lr, te[3] = jt, te[4] = Ft, te[5] = er, te[6] = ar, te[7] = nr, te[8] = ir, te[9] = Ht, te[10] = sr, te[11] = Kt, te[12] = Qt, te[13] = $t, te[14] = Yt, te[15] = Xt, te[16] = Nt, te[17] = Et, te[18] = At, ee !== 0 && (te[19] = ee, U.length++), U }; Math.imul || (ne = re); function oe(ie, g, P) { P.negative = g.negative ^ ie.negative, P.length = ie.length + g.length; for (var U = 0, K = 0, Y = 0; Y < P.length - 1; Y++) { var te = K; K = 0; for (var ee = U & 67108863, G = Math.min(Y, g.length - 1), y = Math.max(0, Y - ie.length + 1); y <= G; y++) { var X = Y - y, ce = ie.words[X] | 0, me = g.words[y] | 0, Ae = ce * me, Ie = Ae & 67108863; te = te + (Ae / 67108864 | 0) | 0, Ie = Ie + ee | 0, ee = Ie & 67108863, te = te + (Ie >>> 26) | 0, K += te >>> 26, te &= 67108863 } P.words[Y] = ee, U = te, te = K } return U !== 0 ? P.words[Y] = U : P.length--, P.strip() } function ae(ie, g, P) { var U = new se; return U.mulp(ie, g, P) } d.prototype.mulTo = function (g, P) { var U, K = this.length + g.length; return this.length === 10 && g.length === 10 ? U = ne(this, g, P) : K < 63 ? U = re(this, g, P) : K < 1024 ? U = oe(this, g, P) : U = ae(this, g, P), U }; function se(ie, g) { this.x = ie, this.y = g } se.prototype.makeRBT = function (g) { for (var P = new Array(g), U = d.prototype._countBits(g) - 1, K = 0; K < g; K++)P[K] = this.revBin(K, U, g); return P }, se.prototype.revBin = function (g, P, U) { if (g === 0 || g === U - 1) return g; for (var K = 0, Y = 0; Y < P; Y++)K |= (g & 1) << P - Y - 1, g >>= 1; return K }, se.prototype.permute = function (g, P, U, K, Y, te) { for (var ee = 0; ee < te; ee++)K[ee] = P[g[ee]], Y[ee] = U[g[ee]] }, se.prototype.transform = function (g, P, U, K, Y, te) { this.permute(te, g, P, U, K, Y); for (var ee = 1; ee < Y; ee <<= 1)for (var G = ee << 1, y = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), ce = 0; ce < Y; ce += G)for (var me = y, Ae = X, Ie = 0; Ie < ee; Ie++) { var Be = U[ce + Ie], Me = K[ce + Ie], De = U[ce + Ie + ee], Ue = K[ce + Ie + ee], Ke = me * De - Ae * Ue; Ue = me * Ue + Ae * De, De = Ke, U[ce + Ie] = Be + De, K[ce + Ie] = Me + Ue, U[ce + Ie + ee] = Be - De, K[ce + Ie + ee] = Me - Ue, Ie !== G && (Ke = y * me - X * Ae, Ae = y * Ae + X * me, me = Ke) } }, se.prototype.guessLen13b = function (g, P) { var U = Math.max(P, g) | 1, K = U & 1, Y = 0; for (U = U / 2 | 0; U; U = U >>> 1)Y++; return 1 << Y + 1 + K }, se.prototype.conjugate = function (g, P, U) { if (!(U <= 1)) for (var K = 0; K < U / 2; K++) { var Y = g[K]; g[K] = g[U - K - 1], g[U - K - 1] = Y, Y = P[K], P[K] = -P[U - K - 1], P[U - K - 1] = -Y } }, se.prototype.normalize13b = function (g, P) { for (var U = 0, K = 0; K < P / 2; K++) { var Y = Math.round(g[2 * K + 1] / P) * 8192 + Math.round(g[2 * K] / P) + U; g[K] = Y & 67108863, Y < 67108864 ? U = 0 : U = Y / 67108864 | 0 } return g }, se.prototype.convert13b = function (g, P, U, K) { for (var Y = 0, te = 0; te < P; te++)Y = Y + (g[te] | 0), U[2 * te] = Y & 8191, Y = Y >>> 13, U[2 * te + 1] = Y & 8191, Y = Y >>> 13; for (te = 2 * P; te < K; ++te)U[te] = 0; f(Y === 0), f((Y & -8192) === 0) }, se.prototype.stub = function (g) { for (var P = new Array(g), U = 0; U < g; U++)P[U] = 0; return P }, se.prototype.mulp = function (g, P, U) { var K = 2 * this.guessLen13b(g.length, P.length), Y = this.makeRBT(K), te = this.stub(K), ee = new Array(K), G = new Array(K), y = new Array(K), X = new Array(K), ce = new Array(K), me = new Array(K), Ae = U.words; Ae.length = K, this.convert13b(g.words, g.length, ee, K), this.convert13b(P.words, P.length, X, K), this.transform(ee, te, G, y, K, Y), this.transform(X, te, ce, me, K, Y); for (var Ie = 0; Ie < K; Ie++) { var Be = G[Ie] * ce[Ie] - y[Ie] * me[Ie]; y[Ie] = G[Ie] * me[Ie] + y[Ie] * ce[Ie], G[Ie] = Be } return this.conjugate(G, y, K), this.transform(G, y, Ae, te, K, Y), this.conjugate(Ae, te, K), this.normalize13b(Ae, K), U.negative = g.negative ^ P.negative, U.length = g.length + P.length, U.strip() }, d.prototype.mul = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), this.mulTo(g, P) }, d.prototype.mulf = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), ae(this, g, P) }, d.prototype.imul = function (g) { return this.clone().mulTo(g, this) }, d.prototype.imuln = function (g) { f(typeof g == "number"), f(g < 67108864); for (var P = 0, U = 0; U < this.length; U++) { var K = (this.words[U] | 0) * g, Y = (K & 67108863) + (P & 67108863); P >>= 26, P += K / 67108864 | 0, P += Y >>> 26, this.words[U] = Y & 67108863 } return P !== 0 && (this.words[U] = P, this.length++), this }, d.prototype.muln = function (g) { return this.clone().imuln(g) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (g) { var P = Q(g); if (P.length === 0) return new d(1); for (var U = this, K = 0; K < P.length && P[K] === 0; K++, U = U.sqr()); if (++K < P.length) for (var Y = U.sqr(); K < P.length; K++, Y = Y.sqr())P[K] !== 0 && (U = U.mul(Y)); return U }, d.prototype.iushln = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 67108863 >>> 26 - P << 26 - P, Y; if (P !== 0) { var te = 0; for (Y = 0; Y < this.length; Y++) { var ee = this.words[Y] & K, G = (this.words[Y] | 0) - ee << P; this.words[Y] = G | te, te = ee >>> 26 - P } te && (this.words[Y] = te, this.length++) } if (U !== 0) { for (Y = this.length - 1; Y >= 0; Y--)this.words[Y + U] = this.words[Y]; for (Y = 0; Y < U; Y++)this.words[Y] = 0; this.length += U } return this.strip() }, d.prototype.ishln = function (g) { return f(this.negative === 0), this.iushln(g) }, d.prototype.iushrn = function (g, P, U) { f(typeof g == "number" && g >= 0); var K; P ? K = (P - P % 26) / 26 : K = 0; var Y = g % 26, te = Math.min((g - Y) / 26, this.length), ee = 67108863 ^ 67108863 >>> Y << Y, G = U; if (K -= te, K = Math.max(0, K), G) { for (var y = 0; y < te; y++)G.words[y] = this.words[y]; G.length = te } if (te !== 0) if (this.length > te) for (this.length -= te, y = 0; y < this.length; y++)this.words[y] = this.words[y + te]; else this.words[0] = 0, this.length = 1; var X = 0; for (y = this.length - 1; y >= 0 && (X !== 0 || y >= K); y--) { var ce = this.words[y] | 0; this.words[y] = X << 26 - Y | ce >>> Y, X = ce & ee } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, d.prototype.ishrn = function (g, P, U) { return f(this.negative === 0), this.iushrn(g, P, U) }, d.prototype.shln = function (g) { return this.clone().ishln(g) }, d.prototype.ushln = function (g) { return this.clone().iushln(g) }, d.prototype.shrn = function (g) { return this.clone().ishrn(g) }, d.prototype.ushrn = function (g) { return this.clone().iushrn(g) }, d.prototype.testn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return !1; var Y = this.words[U]; return !!(Y & K) }, d.prototype.imaskn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U) return this; if (P !== 0 && U++, this.length = Math.min(U, this.length), P !== 0) { var K = 67108863 ^ 67108863 >>> P << P; this.words[this.length - 1] &= K } return this.strip() }, d.prototype.maskn = function (g) { return this.clone().imaskn(g) }, d.prototype.iaddn = function (g) { return f(typeof g == "number"), f(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g) }, d.prototype._iaddn = function (g) { this.words[0] += g; for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++; return this.length = Math.max(this.length, P + 1), this }, d.prototype.isubn = function (g) { if (f(typeof g == "number"), f(g < 67108864), g < 0) return this.iaddn(-g); if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this; if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var P = 0; P < this.length && this.words[P] < 0; P++)this.words[P] += 67108864, this.words[P + 1] -= 1; return this.strip() }, d.prototype.addn = function (g) { return this.clone().iaddn(g) }, d.prototype.subn = function (g) { return this.clone().isubn(g) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (g, P, U) { var K = g.length + U, Y; this._expand(K); var te, ee = 0; for (Y = 0; Y < g.length; Y++) { te = (this.words[Y + U] | 0) + ee; var G = (g.words[Y] | 0) * P; te -= G & 67108863, ee = (te >> 26) - (G / 67108864 | 0), this.words[Y + U] = te & 67108863 } for (; Y < this.length - U; Y++)te = (this.words[Y + U] | 0) + ee, ee = te >> 26, this.words[Y + U] = te & 67108863; if (ee === 0) return this.strip(); for (f(ee === -1), ee = 0, Y = 0; Y < this.length; Y++)te = -(this.words[Y] | 0) + ee, ee = te >> 26, this.words[Y] = te & 67108863; return this.negative = 1, this.strip() }, d.prototype._wordDiv = function (g, P) { var U = this.length - g.length, K = this.clone(), Y = g, te = Y.words[Y.length - 1] | 0, ee = this._countBits(te); U = 26 - ee, U !== 0 && (Y = Y.ushln(U), K.iushln(U), te = Y.words[Y.length - 1] | 0); var G = K.length - Y.length, y; if (P !== "mod") { y = new d(null), y.length = G + 1, y.words = new Array(y.length); for (var X = 0; X < y.length; X++)y.words[X] = 0 } var ce = K.clone()._ishlnsubmul(Y, 1, G); ce.negative === 0 && (K = ce, y && (y.words[G] = 1)); for (var me = G - 1; me >= 0; me--) { var Ae = (K.words[Y.length + me] | 0) * 67108864 + (K.words[Y.length + me - 1] | 0); for (Ae = Math.min(Ae / te | 0, 67108863), K._ishlnsubmul(Y, Ae, me); K.negative !== 0;)Ae--, K.negative = 0, K._ishlnsubmul(Y, 1, me), K.isZero() || (K.negative ^= 1); y && (y.words[me] = Ae) } return y && y.strip(), K.strip(), P !== "div" && U !== 0 && K.iushrn(U), { div: y || null, mod: K } }, d.prototype.divmod = function (g, P, U) { if (f(!g.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var K, Y, te; return this.negative !== 0 && g.negative === 0 ? (te = this.neg().divmod(g, P), P !== "mod" && (K = te.div.neg()), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.iadd(g)), { div: K, mod: Y }) : this.negative === 0 && g.negative !== 0 ? (te = this.divmod(g.neg(), P), P !== "mod" && (K = te.div.neg()), { div: K, mod: te.mod }) : (this.negative & g.negative) !== 0 ? (te = this.neg().divmod(g.neg(), P), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.isub(g)), { div: te.div, mod: Y }) : g.length > this.length || this.cmp(g) < 0 ? { div: new d(0), mod: this } : g.length === 1 ? P === "div" ? { div: this.divn(g.words[0]), mod: null } : P === "mod" ? { div: null, mod: new d(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new d(this.modn(g.words[0])) } : this._wordDiv(g, P) }, d.prototype.div = function (g) { return this.divmod(g, "div", !1).div }, d.prototype.mod = function (g) { return this.divmod(g, "mod", !1).mod }, d.prototype.umod = function (g) { return this.divmod(g, "mod", !0).mod }, d.prototype.divRound = function (g) { var P = this.divmod(g); if (P.mod.isZero()) return P.div; var U = P.div.negative !== 0 ? P.mod.isub(g) : P.mod, K = g.ushrn(1), Y = g.andln(1), te = U.cmp(K); return te < 0 || Y === 1 && te === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1) }, d.prototype.modn = function (g) { f(g <= 67108863); for (var P = (1 << 26) % g, U = 0, K = this.length - 1; K >= 0; K--)U = (P * U + (this.words[K] | 0)) % g; return U }, d.prototype.idivn = function (g) { f(g <= 67108863); for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = (this.words[U] | 0) + P * 67108864; this.words[U] = K / g | 0, P = K % g } return this.strip() }, d.prototype.divn = function (g) { return this.clone().idivn(g) }, d.prototype.egcd = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = new d(0), ee = new d(1), G = 0; P.isEven() && U.isEven();)P.iushrn(1), U.iushrn(1), ++G; for (var y = U.clone(), X = P.clone(); !P.isZero();) { for (var ce = 0, me = 1; (P.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (P.iushrn(ce); ce-- > 0;)(K.isOdd() || Y.isOdd()) && (K.iadd(y), Y.isub(X)), K.iushrn(1), Y.iushrn(1); for (var Ae = 0, Ie = 1; (U.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (U.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(y), ee.isub(X)), te.iushrn(1), ee.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(te), Y.isub(ee)) : (U.isub(P), te.isub(K), ee.isub(Y)) } return { a: te, b: ee, gcd: U.iushln(G) } }, d.prototype._invmp = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = U.clone(); P.cmpn(1) > 0 && U.cmpn(1) > 0;) { for (var ee = 0, G = 1; (P.words[0] & G) === 0 && ee < 26; ++ee, G <<= 1); if (ee > 0) for (P.iushrn(ee); ee-- > 0;)K.isOdd() && K.iadd(te), K.iushrn(1); for (var y = 0, X = 1; (U.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (U.iushrn(y); y-- > 0;)Y.isOdd() && Y.iadd(te), Y.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(Y)) : (U.isub(P), Y.isub(K)) } var ce; return P.cmpn(1) === 0 ? ce = K : ce = Y, ce.cmpn(0) < 0 && ce.iadd(g), ce }, d.prototype.gcd = function (g) { if (this.isZero()) return g.abs(); if (g.isZero()) return this.abs(); var P = this.clone(), U = g.clone(); P.negative = 0, U.negative = 0; for (var K = 0; P.isEven() && U.isEven(); K++)P.iushrn(1), U.iushrn(1); do { for (; P.isEven();)P.iushrn(1); for (; U.isEven();)U.iushrn(1); var Y = P.cmp(U); if (Y < 0) { var te = P; P = U, U = te } else if (Y === 0 || U.cmpn(1) === 0) break; P.isub(U) } while (!0); return U.iushln(K) }, d.prototype.invm = function (g) { return this.egcd(g).a.umod(g) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (g) { return this.words[0] & g }, d.prototype.bincn = function (g) { f(typeof g == "number"); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return this._expand(U + 1), this.words[U] |= K, this; for (var Y = K, te = U; Y !== 0 && te < this.length; te++) { var ee = this.words[te] | 0; ee += Y, Y = ee >>> 26, ee &= 67108863, this.words[te] = ee } return Y !== 0 && (this.words[te] = Y, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (g) { var P = g < 0; if (this.negative !== 0 && !P) return -1; if (this.negative === 0 && P) return 1; this.strip(); var U; if (this.length > 1) U = 1; else { P && (g = -g), f(g <= 67108863, "Number is too big"); var K = this.words[0] | 0; U = K === g ? 0 : K < g ? -1 : 1 } return this.negative !== 0 ? -U | 0 : U }, d.prototype.cmp = function (g) { if (this.negative !== 0 && g.negative === 0) return -1; if (this.negative === 0 && g.negative !== 0) return 1; var P = this.ucmp(g); return this.negative !== 0 ? -P | 0 : P }, d.prototype.ucmp = function (g) { if (this.length > g.length) return 1; if (this.length < g.length) return -1; for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = this.words[U] | 0, Y = g.words[U] | 0; if (K !== Y) { K < Y ? P = -1 : K > Y && (P = 1); break } } return P }, d.prototype.gtn = function (g) { return this.cmpn(g) === 1 }, d.prototype.gt = function (g) { return this.cmp(g) === 1 }, d.prototype.gten = function (g) { return this.cmpn(g) >= 0 }, d.prototype.gte = function (g) { return this.cmp(g) >= 0 }, d.prototype.ltn = function (g) { return this.cmpn(g) === -1 }, d.prototype.lt = function (g) { return this.cmp(g) === -1 }, d.prototype.lten = function (g) { return this.cmpn(g) <= 0 }, d.prototype.lte = function (g) { return this.cmp(g) <= 0 }, d.prototype.eqn = function (g) { return this.cmpn(g) === 0 }, d.prototype.eq = function (g) { return this.cmp(g) === 0 }, d.red = function (g) { return new Se(g) }, d.prototype.toRed = function (g) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (g) { return this.red = g, this }, d.prototype.forceRed = function (g) { return f(!this.red, "Already a number in reduction context"), this._forceRed(g) }, d.prototype.redAdd = function (g) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, g) }, d.prototype.redIAdd = function (g) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g) }, d.prototype.redSub = function (g) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, g) }, d.prototype.redISub = function (g) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, g) }, d.prototype.redShl = function (g) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, g) }, d.prototype.redMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g) }, d.prototype.redIMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (g) { return f(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g) }; var le = { k256: null, p224: null, p192: null, p25519: null }; function ue(ie, g) { this.name = ie, this.p = new d(g, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } ue.prototype._tmp = function () { var g = new d(null); return g.words = new Array(Math.ceil(this.n / 13)), g }, ue.prototype.ireduce = function (g) { var P = g, U; do this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), U = P.bitLength(); while (U > this.n); var K = U < this.n ? -1 : P.ucmp(this.p); return K === 0 ? (P.words[0] = 0, P.length = 1) : K > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P }, ue.prototype.split = function (g, P) { g.iushrn(this.n, 0, P) }, ue.prototype.imulK = function (g) { return g.imul(this.k) }; function he() { ue.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(he, ue), he.prototype.split = function (g, P) { for (var U = 4194303, K = Math.min(g.length, 9), Y = 0; Y < K; Y++)P.words[Y] = g.words[Y]; if (P.length = K, g.length <= 9) { g.words[0] = 0, g.length = 1; return } var te = g.words[9]; for (P.words[P.length++] = te & U, Y = 10; Y < g.length; Y++) { var ee = g.words[Y] | 0; g.words[Y - 10] = (ee & U) << 4 | te >>> 22, te = ee } te >>>= 22, g.words[Y - 10] = te, te === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9 }, he.prototype.imulK = function (g) { g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2; for (var P = 0, U = 0; U < g.length; U++) { var K = g.words[U] | 0; P += K * 977, g.words[U] = P & 67108863, P = K * 64 + (P / 67108864 | 0) } return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g }; function pe() { ue.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(pe, ue); function ve() { ue.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(ve, ue); function _e() { ue.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p(_e, ue), _e.prototype.imulK = function (g) { for (var P = 0, U = 0; U < g.length; U++) { var K = (g.words[U] | 0) * 19 + P, Y = K & 67108863; K >>>= 26, g.words[U] = Y, P = K } return P !== 0 && (g.words[g.length++] = P), g }, d._prime = function (g) { if (le[g]) return le[g]; var P; if (g === "k256") P = new he; else if (g === "p224") P = new pe; else if (g === "p192") P = new ve; else if (g === "p25519") P = new _e; else throw new Error("Unknown prime " + g); return le[g] = P, P }; function Se(ie) { if (typeof ie == "string") { var g = d._prime(ie); this.m = g.p, this.prime = g } else f(ie.gtn(1), "modulus must be greater than 1"), this.m = ie, this.prime = null } Se.prototype._verify1 = function (g) { f(g.negative === 0, "red works only with positives"), f(g.red, "red works only with red numbers") }, Se.prototype._verify2 = function (g, P) { f((g.negative | P.negative) === 0, "red works only with positives"), f(g.red && g.red === P.red, "red works only with red numbers") }, Se.prototype.imod = function (g) { return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this) }, Se.prototype.neg = function (g) { return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this) }, Se.prototype.add = function (g, P) { this._verify2(g, P); var U = g.add(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this) }, Se.prototype.iadd = function (g, P) { this._verify2(g, P); var U = g.iadd(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U }, Se.prototype.sub = function (g, P) { this._verify2(g, P); var U = g.sub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this) }, Se.prototype.isub = function (g, P) { this._verify2(g, P); var U = g.isub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U }, Se.prototype.shl = function (g, P) { return this._verify1(g), this.imod(g.ushln(P)) }, Se.prototype.imul = function (g, P) { return this._verify2(g, P), this.imod(g.imul(P)) }, Se.prototype.mul = function (g, P) { return this._verify2(g, P), this.imod(g.mul(P)) }, Se.prototype.isqr = function (g) { return this.imul(g, g.clone()) }, Se.prototype.sqr = function (g) { return this.mul(g, g) }, Se.prototype.sqrt = function (g) { if (g.isZero()) return g.clone(); var P = this.m.andln(3); if (f(P % 2 === 1), P === 3) { var U = this.m.add(new d(1)).iushrn(2); return this.pow(g, U) } for (var K = this.m.subn(1), Y = 0; !K.isZero() && K.andln(1) === 0;)Y++, K.iushrn(1); f(!K.isZero()); var te = new d(1).toRed(this), ee = te.redNeg(), G = this.m.subn(1).iushrn(1), y = this.m.bitLength(); for (y = new d(2 * y * y).toRed(this); this.pow(y, G).cmp(ee) !== 0;)y.redIAdd(ee); for (var X = this.pow(y, K), ce = this.pow(g, K.addn(1).iushrn(1)), me = this.pow(g, K), Ae = Y; me.cmp(te) !== 0;) { for (var Ie = me, Be = 0; Ie.cmp(te) !== 0; Be++)Ie = Ie.redSqr(); f(Be < Ae); var Me = this.pow(X, new d(1).iushln(Ae - Be - 1)); ce = ce.redMul(Me), X = Me.redSqr(), me = me.redMul(X), Ae = Be } return ce }, Se.prototype.invm = function (g) { var P = g._invmp(this.m); return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P) }, Se.prototype.pow = function (g, P) { if (P.isZero()) return new d(1).toRed(this); if (P.cmpn(1) === 0) return g.clone(); var U = 4, K = new Array(1 << U); K[0] = new d(1).toRed(this), K[1] = g; for (var Y = 2; Y < K.length; Y++)K[Y] = this.mul(K[Y - 1], g); var te = K[0], ee = 0, G = 0, y = P.bitLength() % 26; for (y === 0 && (y = 26), Y = P.length - 1; Y >= 0; Y--) { for (var X = P.words[Y], ce = y - 1; ce >= 0; ce--) { var me = X >> ce & 1; if (te !== K[0] && (te = this.sqr(te)), me === 0 && ee === 0) { G = 0; continue } ee <<= 1, ee |= me, G++, !(G !== U && (Y !== 0 || ce !== 0)) && (te = this.mul(te, K[ee]), G = 0, ee = 0) } y = 26 } return te }, Se.prototype.convertTo = function (g) { var P = g.umod(this.m); return P === g ? P.clone() : P }, Se.prototype.convertFrom = function (g) { var P = g.clone(); return P.red = null, P }, d.mont = function (g) { return new $e(g) }; function $e(ie) { Se.call(this, ie), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p($e, Se), $e.prototype.convertTo = function (g) { return this.imod(g.ushln(this.shift)) }, $e.prototype.convertFrom = function (g) { var P = this.imod(g.mul(this.rinv)); return P.red = null, P }, $e.prototype.imul = function (g, P) { if (g.isZero() || P.isZero()) return g.words[0] = 0, g.length = 1, g; var U = g.imul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.mul = function (g, P) { if (g.isZero() || P.isZero()) return new d(0)._forceRed(this); var U = g.mul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.invm = function (g) { var P = this.imod(g._invmp(this.m).mul(this.r2)); return P._forceRed(this) } })(o, bn$2) }(bn$3)), bn$3.exports } var browser$3, hasRequiredBrowser$2; function requireBrowser$2() { if (hasRequiredBrowser$2) return browser$3; hasRequiredBrowser$2 = 1; var o = requireElliptic(), l = requireBn$1(); browser$3 = function (m) { return new f(m) }; var u = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } }; u.p224 = u.secp224r1, u.p256 = u.secp256r1 = u.prime256v1, u.p192 = u.secp192r1 = u.prime192v1, u.p384 = u.secp384r1, u.p521 = u.secp521r1; function f(d) { this.curveType = u[d], this.curveType || (this.curveType = { name: d }), this.curve = new o.ec(this.curveType.name), this.keys = void 0 } f.prototype.generateKeys = function (d, m) { return this.keys = this.curve.genKeyPair(), this.getPublicKey(d, m) }, f.prototype.computeSecret = function (d, m, v) { m = m || "utf8", Buffer.isBuffer(d) || (d = new Buffer(d, m)); var I = this.curve.keyFromPublic(d).getPublic(), F = I.mul(this.keys.getPrivate()).getX(); return p(F, v, this.curveType.byteLength) }, f.prototype.getPublicKey = function (d, m) { var v = this.keys.getPublic(m === "compressed", !0); return m === "hybrid" && (v[v.length - 1] % 2 ? v[0] = 7 : v[0] = 6), p(v, d) }, f.prototype.getPrivateKey = function (d) { return p(this.keys.getPrivate(), d) }, f.prototype.setPublicKey = function (d, m) { return m = m || "utf8", Buffer.isBuffer(d) || (d = new Buffer(d, m)), this.keys._importPublic(d), this }, f.prototype.setPrivateKey = function (d, m) { m = m || "utf8", Buffer.isBuffer(d) || (d = new Buffer(d, m)); var v = new l(d); return v = v.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(v), this }; function p(d, m, v) { Array.isArray(d) || (d = d.toArray()); var I = new Buffer(d); if (v && I.length < v) { var F = new Buffer(v - I.length); F.fill(0), I = Buffer.concat([F, I]) } return m ? I.toString(m) : I } return browser$3 } var browser$2 = {}, mgf, hasRequiredMgf; function requireMgf() { if (hasRequiredMgf) return mgf; hasRequiredMgf = 1; var o = requireBrowser$9(), l = requireSafeBuffer$1().Buffer; mgf = function (f, p) { for (var d = l.alloc(0), m = 0, v; d.length < p;)v = u(m++), d = l.concat([d, o("sha1").update(f).update(v).digest()]); return d.slice(0, p) }; function u(f) { var p = l.allocUnsafe(4); return p.writeUInt32BE(f, 0), p } return mgf } var xor, hasRequiredXor; function requireXor() { return hasRequiredXor || (hasRequiredXor = 1, xor = function (l, u) { for (var f = l.length, p = -1; ++p < f;)l[p] ^= u[p]; return l }), xor } var bn$1 = { exports: {} }, bn = bn$1.exports, hasRequiredBn; function requireBn() { return hasRequiredBn || (hasRequiredBn = 1, function (o) { (function (l, u) { function f(ie, g) { if (!ie) throw new Error(g || "Assertion failed") } function p(ie, g) { ie.super_ = g; var P = function () { }; P.prototype = g.prototype, ie.prototype = new P, ie.prototype.constructor = ie } function d(ie, g, P) { if (d.isBN(ie)) return ie; this.negative = 0, this.words = null, this.length = 0, this.red = null, ie !== null && ((g === "le" || g === "be") && (P = g, g = 10), this._init(ie || 0, g || 10, P || "be")) } typeof l == "object" ? l.exports = d : u.BN = d, d.BN = d, d.wordSize = 26; var m; try { typeof window < "u" && typeof window.Buffer < "u" ? m = window.Buffer : m = requireDist$2().Buffer } catch { } d.isBN = function (g) { return g instanceof d ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === d.wordSize && Array.isArray(g.words) }, d.max = function (g, P) { return g.cmp(P) > 0 ? g : P }, d.min = function (g, P) { return g.cmp(P) < 0 ? g : P }, d.prototype._init = function (g, P, U) { if (typeof g == "number") return this._initNumber(g, P, U); if (typeof g == "object") return this._initArray(g, P, U); P === "hex" && (P = 16), f(P === (P | 0) && P >= 2 && P <= 36), g = g.toString().replace(/\s+/g, ""); var K = 0; g[0] === "-" && (K++, this.negative = 1), K < g.length && (P === 16 ? this._parseHex(g, K, U) : (this._parseBase(g, P, K), U === "le" && this._initArray(this.toArray(), P, U))) }, d.prototype._initNumber = function (g, P, U) { g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [g & 67108863], this.length = 1) : g < 4503599627370496 ? (this.words = [g & 67108863, g / 67108864 & 67108863], this.length = 2) : (f(g < 9007199254740992), this.words = [g & 67108863, g / 67108864 & 67108863, 1], this.length = 3), U === "le" && this._initArray(this.toArray(), P, U) }, d.prototype._initArray = function (g, P, U) { if (f(typeof g.length == "number"), g.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(g.length / 3), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y, te, ee = 0; if (U === "be") for (K = g.length - 1, Y = 0; K >= 0; K -= 3)te = g[K] | g[K - 1] << 8 | g[K - 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); else if (U === "le") for (K = 0, Y = 0; K < g.length; K += 3)te = g[K] | g[K + 1] << 8 | g[K + 2] << 16, this.words[Y] |= te << ee & 67108863, this.words[Y + 1] = te >>> 26 - ee & 67108863, ee += 24, ee >= 26 && (ee -= 26, Y++); return this.strip() }; function v(ie, g) { var P = ie.charCodeAt(g); return P >= 65 && P <= 70 ? P - 55 : P >= 97 && P <= 102 ? P - 87 : P - 48 & 15 } function I(ie, g, P) { var U = v(ie, P); return P - 1 >= g && (U |= v(ie, P - 1) << 4), U } d.prototype._parseHex = function (g, P, U) { this.length = Math.ceil((g.length - P) / 6), this.words = new Array(this.length); for (var K = 0; K < this.length; K++)this.words[K] = 0; var Y = 0, te = 0, ee; if (U === "be") for (K = g.length - 1; K >= P; K -= 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8; else { var G = g.length - P; for (K = G % 2 === 0 ? P + 1 : P; K < g.length; K += 2)ee = I(g, P, K) << Y, this.words[te] |= ee & 67108863, Y >= 18 ? (Y -= 18, te += 1, this.words[te] |= ee >>> 26) : Y += 8 } this.strip() }; function F(ie, g, P, U) { for (var K = 0, Y = Math.min(ie.length, P), te = g; te < Y; te++) { var ee = ie.charCodeAt(te) - 48; K *= U, ee >= 49 ? K += ee - 49 + 10 : ee >= 17 ? K += ee - 17 + 10 : K += ee } return K } d.prototype._parseBase = function (g, P, U) { this.words = [0], this.length = 1; for (var K = 0, Y = 1; Y <= 67108863; Y *= P)K++; K--, Y = Y / P | 0; for (var te = g.length - U, ee = te % K, G = Math.min(te, te - ee) + U, y = 0, X = U; X < G; X += K)y = F(g, X, X + K, P), this.imuln(Y), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y); if (ee !== 0) { var ce = 1; for (y = F(g, X, g.length, P), X = 0; X < ee; X++)ce *= P; this.imuln(ce), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y) } this.strip() }, d.prototype.copy = function (g) { g.words = new Array(this.length); for (var P = 0; P < this.length; P++)g.words[P] = this.words[P]; g.length = this.length, g.negative = this.negative, g.red = this.red }, d.prototype.clone = function () { var g = new d(null); return this.copy(g), g }, d.prototype._expand = function (g) { for (; this.length < g;)this.words[this.length++] = 0; return this }, d.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, d.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, d.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var B = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], W = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; d.prototype.toString = function (g, P) { g = g || 10, P = P | 0 || 1; var U; if (g === 16 || g === "hex") { U = ""; for (var K = 0, Y = 0, te = 0; te < this.length; te++) { var ee = this.words[te], G = ((ee << K | Y) & 16777215).toString(16); Y = ee >>> 24 - K & 16777215, Y !== 0 || te !== this.length - 1 ? U = B[6 - G.length] + G + U : U = G + U, K += 2, K >= 26 && (K -= 26, te--) } for (Y !== 0 && (U = Y.toString(16) + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } if (g === (g | 0) && g >= 2 && g <= 36) { var y = W[g], X = Z[g]; U = ""; var ce = this.clone(); for (ce.negative = 0; !ce.isZero();) { var me = ce.modn(X).toString(g); ce = ce.idivn(X), ce.isZero() ? U = me + U : U = B[y - me.length] + me + U } for (this.isZero() && (U = "0" + U); U.length % P !== 0;)U = "0" + U; return this.negative !== 0 && (U = "-" + U), U } f(!1, "Base should be between 2 and 36") }, d.prototype.toNumber = function () { var g = this.words[0]; return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && f(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g }, d.prototype.toJSON = function () { return this.toString(16) }, d.prototype.toBuffer = function (g, P) { return f(typeof m < "u"), this.toArrayLike(m, g, P) }, d.prototype.toArray = function (g, P) { return this.toArrayLike(Array, g, P) }, d.prototype.toArrayLike = function (g, P, U) { var K = this.byteLength(), Y = U || Math.max(1, K); f(K <= Y, "byte array longer than desired length"), f(Y > 0, "Requested array length <= 0"), this.strip(); var te = P === "le", ee = new g(Y), G, y, X = this.clone(); if (te) { for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[y] = G; for (; y < Y; y++)ee[y] = 0 } else { for (y = 0; y < Y - K; y++)ee[y] = 0; for (y = 0; !X.isZero(); y++)G = X.andln(255), X.iushrn(8), ee[Y - y - 1] = G } return ee }, Math.clz32 ? d.prototype._countBits = function (g) { return 32 - Math.clz32(g) } : d.prototype._countBits = function (g) { var P = g, U = 0; return P >= 4096 && (U += 13, P >>>= 13), P >= 64 && (U += 7, P >>>= 7), P >= 8 && (U += 4, P >>>= 4), P >= 2 && (U += 2, P >>>= 2), U + P }, d.prototype._zeroBits = function (g) { if (g === 0) return 26; var P = g, U = 0; return (P & 8191) === 0 && (U += 13, P >>>= 13), (P & 127) === 0 && (U += 7, P >>>= 7), (P & 15) === 0 && (U += 4, P >>>= 4), (P & 3) === 0 && (U += 2, P >>>= 2), (P & 1) === 0 && U++, U }, d.prototype.bitLength = function () { var g = this.words[this.length - 1], P = this._countBits(g); return (this.length - 1) * 26 + P }; function Q(ie) { for (var g = new Array(ie.bitLength()), P = 0; P < g.length; P++) { var U = P / 26 | 0, K = P % 26; g[P] = (ie.words[U] & 1 << K) >>> K } return g } d.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var g = 0, P = 0; P < this.length; P++) { var U = this._zeroBits(this.words[P]); if (g += U, U !== 26) break } return g }, d.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, d.prototype.toTwos = function (g) { return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone() }, d.prototype.fromTwos = function (g) { return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone() }, d.prototype.isNeg = function () { return this.negative !== 0 }, d.prototype.neg = function () { return this.clone().ineg() }, d.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, d.prototype.iuor = function (g) { for (; this.length < g.length;)this.words[this.length++] = 0; for (var P = 0; P < g.length; P++)this.words[P] = this.words[P] | g.words[P]; return this.strip() }, d.prototype.ior = function (g) { return f((this.negative | g.negative) === 0), this.iuor(g) }, d.prototype.or = function (g) { return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this) }, d.prototype.uor = function (g) { return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this) }, d.prototype.iuand = function (g) { var P; this.length > g.length ? P = g : P = this; for (var U = 0; U < P.length; U++)this.words[U] = this.words[U] & g.words[U]; return this.length = P.length, this.strip() }, d.prototype.iand = function (g) { return f((this.negative | g.negative) === 0), this.iuand(g) }, d.prototype.and = function (g) { return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this) }, d.prototype.uand = function (g) { return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this) }, d.prototype.iuxor = function (g) { var P, U; this.length > g.length ? (P = this, U = g) : (P = g, U = this); for (var K = 0; K < U.length; K++)this.words[K] = P.words[K] ^ U.words[K]; if (this !== P) for (; K < P.length; K++)this.words[K] = P.words[K]; return this.length = P.length, this.strip() }, d.prototype.ixor = function (g) { return f((this.negative | g.negative) === 0), this.iuxor(g) }, d.prototype.xor = function (g) { return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this) }, d.prototype.uxor = function (g) { return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this) }, d.prototype.inotn = function (g) { f(typeof g == "number" && g >= 0); var P = Math.ceil(g / 26) | 0, U = g % 26; this._expand(P), U > 0 && P--; for (var K = 0; K < P; K++)this.words[K] = ~this.words[K] & 67108863; return U > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - U), this.strip() }, d.prototype.notn = function (g) { return this.clone().inotn(g) }, d.prototype.setn = function (g, P) { f(typeof g == "number" && g >= 0); var U = g / 26 | 0, K = g % 26; return this._expand(U + 1), P ? this.words[U] = this.words[U] | 1 << K : this.words[U] = this.words[U] & ~(1 << K), this.strip() }, d.prototype.iadd = function (g) { var P; if (this.negative !== 0 && g.negative === 0) return this.negative = 0, P = this.isub(g), this.negative ^= 1, this._normSign(); if (this.negative === 0 && g.negative !== 0) return g.negative = 0, P = this.isub(g), g.negative = 1, P._normSign(); var U, K; this.length > g.length ? (U = this, K = g) : (U = g, K = this); for (var Y = 0, te = 0; te < K.length; te++)P = (U.words[te] | 0) + (K.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; for (; Y !== 0 && te < U.length; te++)P = (U.words[te] | 0) + Y, this.words[te] = P & 67108863, Y = P >>> 26; if (this.length = U.length, Y !== 0) this.words[this.length] = Y, this.length++; else if (U !== this) for (; te < U.length; te++)this.words[te] = U.words[te]; return this }, d.prototype.add = function (g) { var P; return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, P = this.sub(g), g.negative ^= 1, P) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = g.sub(this), this.negative = 1, P) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this) }, d.prototype.isub = function (g) { if (g.negative !== 0) { g.negative = 0; var P = this.iadd(g); return g.negative = 1, P._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign(); var U = this.cmp(g); if (U === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var K, Y; U > 0 ? (K = this, Y = g) : (K = g, Y = this); for (var te = 0, ee = 0; ee < Y.length; ee++)P = (K.words[ee] | 0) - (Y.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; for (; te !== 0 && ee < K.length; ee++)P = (K.words[ee] | 0) + te, te = P >> 26, this.words[ee] = P & 67108863; if (te === 0 && ee < K.length && K !== this) for (; ee < K.length; ee++)this.words[ee] = K.words[ee]; return this.length = Math.max(this.length, ee), K !== this && (this.negative = 1), this.strip() }, d.prototype.sub = function (g) { return this.clone().isub(g) }; function re(ie, g, P) { P.negative = g.negative ^ ie.negative; var U = ie.length + g.length | 0; P.length = U, U = U - 1 | 0; var K = ie.words[0] | 0, Y = g.words[0] | 0, te = K * Y, ee = te & 67108863, G = te / 67108864 | 0; P.words[0] = ee; for (var y = 1; y < U; y++) { for (var X = G >>> 26, ce = G & 67108863, me = Math.min(y, g.length - 1), Ae = Math.max(0, y - ie.length + 1); Ae <= me; Ae++) { var Ie = y - Ae | 0; K = ie.words[Ie] | 0, Y = g.words[Ae] | 0, te = K * Y + ce, X += te / 67108864 | 0, ce = te & 67108863 } P.words[y] = ce | 0, G = X | 0 } return G !== 0 ? P.words[y] = G | 0 : P.length--, P.strip() } var ne = function (g, P, U) { var K = g.words, Y = P.words, te = U.words, ee = 0, G, y, X, ce = K[0] | 0, me = ce & 8191, Ae = ce >>> 13, Ie = K[1] | 0, Be = Ie & 8191, Me = Ie >>> 13, De = K[2] | 0, Ue = De & 8191, Ke = De >>> 13, Ve = K[3] | 0, ke = Ve & 8191, Je = Ve >>> 13, dt = K[4] | 0, lt = dt & 8191, ht = dt >>> 13, Bt = K[5] | 0, mt = Bt & 8191, et = Bt >>> 13, Gt = K[6] | 0, pt = Gt & 8191, _t = Gt >>> 13, zt = K[7] | 0, bt = zt & 8191, We = zt >>> 13, Ge = K[8] | 0, ze = Ge & 8191, Ze = Ge >>> 13, ut = K[9] | 0, ye = ut & 8191, ge = ut >>> 13, Ee = Y[0] | 0, Oe = Ee & 8191, je = Ee >>> 13, nt = Y[1] | 0, Xe = nt & 8191, it = nt >>> 13, Tt = Y[2] | 0, tt = Tt & 8191, yt = Tt >>> 13, kt = Y[3] | 0, wt = kt & 8191, Mt = kt >>> 13, tr = Y[4] | 0, St = tr & 8191, gt = tr >>> 13, rr = Y[5] | 0, Le = rr & 8191, xe = rr >>> 13, Ce = Y[6] | 0, Ne = Ce & 8191, Ye = Ce >>> 13, Re = Y[7] | 0, Pe = Re & 8191, qe = Re >>> 13, be = Y[8] | 0, Fe = be & 8191, Qe = be >>> 13, st = Y[9] | 0, rt = st & 8191, ct = st >>> 13; U.negative = g.negative ^ P.negative, U.length = 19, G = Math.imul(me, Oe), y = Math.imul(me, je), y = y + Math.imul(Ae, Oe) | 0, X = Math.imul(Ae, je); var Lt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(Be, Oe), y = Math.imul(Be, je), y = y + Math.imul(Me, Oe) | 0, X = Math.imul(Me, je), G = G + Math.imul(me, Xe) | 0, y = y + Math.imul(me, it) | 0, y = y + Math.imul(Ae, Xe) | 0, X = X + Math.imul(Ae, it) | 0; var It = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(Ue, Oe), y = Math.imul(Ue, je), y = y + Math.imul(Ke, Oe) | 0, X = Math.imul(Ke, je), G = G + Math.imul(Be, Xe) | 0, y = y + Math.imul(Be, it) | 0, y = y + Math.imul(Me, Xe) | 0, X = X + Math.imul(Me, it) | 0, G = G + Math.imul(me, tt) | 0, y = y + Math.imul(me, yt) | 0, y = y + Math.imul(Ae, tt) | 0, X = X + Math.imul(Ae, yt) | 0; var lr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, G = Math.imul(ke, Oe), y = Math.imul(ke, je), y = y + Math.imul(Je, Oe) | 0, X = Math.imul(Je, je), G = G + Math.imul(Ue, Xe) | 0, y = y + Math.imul(Ue, it) | 0, y = y + Math.imul(Ke, Xe) | 0, X = X + Math.imul(Ke, it) | 0, G = G + Math.imul(Be, tt) | 0, y = y + Math.imul(Be, yt) | 0, y = y + Math.imul(Me, tt) | 0, X = X + Math.imul(Me, yt) | 0, G = G + Math.imul(me, wt) | 0, y = y + Math.imul(me, Mt) | 0, y = y + Math.imul(Ae, wt) | 0, X = X + Math.imul(Ae, Mt) | 0; var jt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(lt, Oe), y = Math.imul(lt, je), y = y + Math.imul(ht, Oe) | 0, X = Math.imul(ht, je), G = G + Math.imul(ke, Xe) | 0, y = y + Math.imul(ke, it) | 0, y = y + Math.imul(Je, Xe) | 0, X = X + Math.imul(Je, it) | 0, G = G + Math.imul(Ue, tt) | 0, y = y + Math.imul(Ue, yt) | 0, y = y + Math.imul(Ke, tt) | 0, X = X + Math.imul(Ke, yt) | 0, G = G + Math.imul(Be, wt) | 0, y = y + Math.imul(Be, Mt) | 0, y = y + Math.imul(Me, wt) | 0, X = X + Math.imul(Me, Mt) | 0, G = G + Math.imul(me, St) | 0, y = y + Math.imul(me, gt) | 0, y = y + Math.imul(Ae, St) | 0, X = X + Math.imul(Ae, gt) | 0; var Ft = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(mt, Oe), y = Math.imul(mt, je), y = y + Math.imul(et, Oe) | 0, X = Math.imul(et, je), G = G + Math.imul(lt, Xe) | 0, y = y + Math.imul(lt, it) | 0, y = y + Math.imul(ht, Xe) | 0, X = X + Math.imul(ht, it) | 0, G = G + Math.imul(ke, tt) | 0, y = y + Math.imul(ke, yt) | 0, y = y + Math.imul(Je, tt) | 0, X = X + Math.imul(Je, yt) | 0, G = G + Math.imul(Ue, wt) | 0, y = y + Math.imul(Ue, Mt) | 0, y = y + Math.imul(Ke, wt) | 0, X = X + Math.imul(Ke, Mt) | 0, G = G + Math.imul(Be, St) | 0, y = y + Math.imul(Be, gt) | 0, y = y + Math.imul(Me, St) | 0, X = X + Math.imul(Me, gt) | 0, G = G + Math.imul(me, Le) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(Ae, Le) | 0, X = X + Math.imul(Ae, xe) | 0; var er = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, G = Math.imul(pt, Oe), y = Math.imul(pt, je), y = y + Math.imul(_t, Oe) | 0, X = Math.imul(_t, je), G = G + Math.imul(mt, Xe) | 0, y = y + Math.imul(mt, it) | 0, y = y + Math.imul(et, Xe) | 0, X = X + Math.imul(et, it) | 0, G = G + Math.imul(lt, tt) | 0, y = y + Math.imul(lt, yt) | 0, y = y + Math.imul(ht, tt) | 0, X = X + Math.imul(ht, yt) | 0, G = G + Math.imul(ke, wt) | 0, y = y + Math.imul(ke, Mt) | 0, y = y + Math.imul(Je, wt) | 0, X = X + Math.imul(Je, Mt) | 0, G = G + Math.imul(Ue, St) | 0, y = y + Math.imul(Ue, gt) | 0, y = y + Math.imul(Ke, St) | 0, X = X + Math.imul(Ke, gt) | 0, G = G + Math.imul(Be, Le) | 0, y = y + Math.imul(Be, xe) | 0, y = y + Math.imul(Me, Le) | 0, X = X + Math.imul(Me, xe) | 0, G = G + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Ye) | 0, y = y + Math.imul(Ae, Ne) | 0, X = X + Math.imul(Ae, Ye) | 0; var ar = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, G = Math.imul(bt, Oe), y = Math.imul(bt, je), y = y + Math.imul(We, Oe) | 0, X = Math.imul(We, je), G = G + Math.imul(pt, Xe) | 0, y = y + Math.imul(pt, it) | 0, y = y + Math.imul(_t, Xe) | 0, X = X + Math.imul(_t, it) | 0, G = G + Math.imul(mt, tt) | 0, y = y + Math.imul(mt, yt) | 0, y = y + Math.imul(et, tt) | 0, X = X + Math.imul(et, yt) | 0, G = G + Math.imul(lt, wt) | 0, y = y + Math.imul(lt, Mt) | 0, y = y + Math.imul(ht, wt) | 0, X = X + Math.imul(ht, Mt) | 0, G = G + Math.imul(ke, St) | 0, y = y + Math.imul(ke, gt) | 0, y = y + Math.imul(Je, St) | 0, X = X + Math.imul(Je, gt) | 0, G = G + Math.imul(Ue, Le) | 0, y = y + Math.imul(Ue, xe) | 0, y = y + Math.imul(Ke, Le) | 0, X = X + Math.imul(Ke, xe) | 0, G = G + Math.imul(Be, Ne) | 0, y = y + Math.imul(Be, Ye) | 0, y = y + Math.imul(Me, Ne) | 0, X = X + Math.imul(Me, Ye) | 0, G = G + Math.imul(me, Pe) | 0, y = y + Math.imul(me, qe) | 0, y = y + Math.imul(Ae, Pe) | 0, X = X + Math.imul(Ae, qe) | 0; var nr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, G = Math.imul(ze, Oe), y = Math.imul(ze, je), y = y + Math.imul(Ze, Oe) | 0, X = Math.imul(Ze, je), G = G + Math.imul(bt, Xe) | 0, y = y + Math.imul(bt, it) | 0, y = y + Math.imul(We, Xe) | 0, X = X + Math.imul(We, it) | 0, G = G + Math.imul(pt, tt) | 0, y = y + Math.imul(pt, yt) | 0, y = y + Math.imul(_t, tt) | 0, X = X + Math.imul(_t, yt) | 0, G = G + Math.imul(mt, wt) | 0, y = y + Math.imul(mt, Mt) | 0, y = y + Math.imul(et, wt) | 0, X = X + Math.imul(et, Mt) | 0, G = G + Math.imul(lt, St) | 0, y = y + Math.imul(lt, gt) | 0, y = y + Math.imul(ht, St) | 0, X = X + Math.imul(ht, gt) | 0, G = G + Math.imul(ke, Le) | 0, y = y + Math.imul(ke, xe) | 0, y = y + Math.imul(Je, Le) | 0, X = X + Math.imul(Je, xe) | 0, G = G + Math.imul(Ue, Ne) | 0, y = y + Math.imul(Ue, Ye) | 0, y = y + Math.imul(Ke, Ne) | 0, X = X + Math.imul(Ke, Ye) | 0, G = G + Math.imul(Be, Pe) | 0, y = y + Math.imul(Be, qe) | 0, y = y + Math.imul(Me, Pe) | 0, X = X + Math.imul(Me, qe) | 0, G = G + Math.imul(me, Fe) | 0, y = y + Math.imul(me, Qe) | 0, y = y + Math.imul(Ae, Fe) | 0, X = X + Math.imul(Ae, Qe) | 0; var ir = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, G = Math.imul(ye, Oe), y = Math.imul(ye, je), y = y + Math.imul(ge, Oe) | 0, X = Math.imul(ge, je), G = G + Math.imul(ze, Xe) | 0, y = y + Math.imul(ze, it) | 0, y = y + Math.imul(Ze, Xe) | 0, X = X + Math.imul(Ze, it) | 0, G = G + Math.imul(bt, tt) | 0, y = y + Math.imul(bt, yt) | 0, y = y + Math.imul(We, tt) | 0, X = X + Math.imul(We, yt) | 0, G = G + Math.imul(pt, wt) | 0, y = y + Math.imul(pt, Mt) | 0, y = y + Math.imul(_t, wt) | 0, X = X + Math.imul(_t, Mt) | 0, G = G + Math.imul(mt, St) | 0, y = y + Math.imul(mt, gt) | 0, y = y + Math.imul(et, St) | 0, X = X + Math.imul(et, gt) | 0, G = G + Math.imul(lt, Le) | 0, y = y + Math.imul(lt, xe) | 0, y = y + Math.imul(ht, Le) | 0, X = X + Math.imul(ht, xe) | 0, G = G + Math.imul(ke, Ne) | 0, y = y + Math.imul(ke, Ye) | 0, y = y + Math.imul(Je, Ne) | 0, X = X + Math.imul(Je, Ye) | 0, G = G + Math.imul(Ue, Pe) | 0, y = y + Math.imul(Ue, qe) | 0, y = y + Math.imul(Ke, Pe) | 0, X = X + Math.imul(Ke, qe) | 0, G = G + Math.imul(Be, Fe) | 0, y = y + Math.imul(Be, Qe) | 0, y = y + Math.imul(Me, Fe) | 0, X = X + Math.imul(Me, Qe) | 0, G = G + Math.imul(me, rt) | 0, y = y + Math.imul(me, ct) | 0, y = y + Math.imul(Ae, rt) | 0, X = X + Math.imul(Ae, ct) | 0; var Ht = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(ye, Xe), y = Math.imul(ye, it), y = y + Math.imul(ge, Xe) | 0, X = Math.imul(ge, it), G = G + Math.imul(ze, tt) | 0, y = y + Math.imul(ze, yt) | 0, y = y + Math.imul(Ze, tt) | 0, X = X + Math.imul(Ze, yt) | 0, G = G + Math.imul(bt, wt) | 0, y = y + Math.imul(bt, Mt) | 0, y = y + Math.imul(We, wt) | 0, X = X + Math.imul(We, Mt) | 0, G = G + Math.imul(pt, St) | 0, y = y + Math.imul(pt, gt) | 0, y = y + Math.imul(_t, St) | 0, X = X + Math.imul(_t, gt) | 0, G = G + Math.imul(mt, Le) | 0, y = y + Math.imul(mt, xe) | 0, y = y + Math.imul(et, Le) | 0, X = X + Math.imul(et, xe) | 0, G = G + Math.imul(lt, Ne) | 0, y = y + Math.imul(lt, Ye) | 0, y = y + Math.imul(ht, Ne) | 0, X = X + Math.imul(ht, Ye) | 0, G = G + Math.imul(ke, Pe) | 0, y = y + Math.imul(ke, qe) | 0, y = y + Math.imul(Je, Pe) | 0, X = X + Math.imul(Je, qe) | 0, G = G + Math.imul(Ue, Fe) | 0, y = y + Math.imul(Ue, Qe) | 0, y = y + Math.imul(Ke, Fe) | 0, X = X + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Be, rt) | 0, y = y + Math.imul(Be, ct) | 0, y = y + Math.imul(Me, rt) | 0, X = X + Math.imul(Me, ct) | 0; var sr = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, G = Math.imul(ye, tt), y = Math.imul(ye, yt), y = y + Math.imul(ge, tt) | 0, X = Math.imul(ge, yt), G = G + Math.imul(ze, wt) | 0, y = y + Math.imul(ze, Mt) | 0, y = y + Math.imul(Ze, wt) | 0, X = X + Math.imul(Ze, Mt) | 0, G = G + Math.imul(bt, St) | 0, y = y + Math.imul(bt, gt) | 0, y = y + Math.imul(We, St) | 0, X = X + Math.imul(We, gt) | 0, G = G + Math.imul(pt, Le) | 0, y = y + Math.imul(pt, xe) | 0, y = y + Math.imul(_t, Le) | 0, X = X + Math.imul(_t, xe) | 0, G = G + Math.imul(mt, Ne) | 0, y = y + Math.imul(mt, Ye) | 0, y = y + Math.imul(et, Ne) | 0, X = X + Math.imul(et, Ye) | 0, G = G + Math.imul(lt, Pe) | 0, y = y + Math.imul(lt, qe) | 0, y = y + Math.imul(ht, Pe) | 0, X = X + Math.imul(ht, qe) | 0, G = G + Math.imul(ke, Fe) | 0, y = y + Math.imul(ke, Qe) | 0, y = y + Math.imul(Je, Fe) | 0, X = X + Math.imul(Je, Qe) | 0, G = G + Math.imul(Ue, rt) | 0, y = y + Math.imul(Ue, ct) | 0, y = y + Math.imul(Ke, rt) | 0, X = X + Math.imul(Ke, ct) | 0; var Kt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, G = Math.imul(ye, wt), y = Math.imul(ye, Mt), y = y + Math.imul(ge, wt) | 0, X = Math.imul(ge, Mt), G = G + Math.imul(ze, St) | 0, y = y + Math.imul(ze, gt) | 0, y = y + Math.imul(Ze, St) | 0, X = X + Math.imul(Ze, gt) | 0, G = G + Math.imul(bt, Le) | 0, y = y + Math.imul(bt, xe) | 0, y = y + Math.imul(We, Le) | 0, X = X + Math.imul(We, xe) | 0, G = G + Math.imul(pt, Ne) | 0, y = y + Math.imul(pt, Ye) | 0, y = y + Math.imul(_t, Ne) | 0, X = X + Math.imul(_t, Ye) | 0, G = G + Math.imul(mt, Pe) | 0, y = y + Math.imul(mt, qe) | 0, y = y + Math.imul(et, Pe) | 0, X = X + Math.imul(et, qe) | 0, G = G + Math.imul(lt, Fe) | 0, y = y + Math.imul(lt, Qe) | 0, y = y + Math.imul(ht, Fe) | 0, X = X + Math.imul(ht, Qe) | 0, G = G + Math.imul(ke, rt) | 0, y = y + Math.imul(ke, ct) | 0, y = y + Math.imul(Je, rt) | 0, X = X + Math.imul(Je, ct) | 0; var Qt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, G = Math.imul(ye, St), y = Math.imul(ye, gt), y = y + Math.imul(ge, St) | 0, X = Math.imul(ge, gt), G = G + Math.imul(ze, Le) | 0, y = y + Math.imul(ze, xe) | 0, y = y + Math.imul(Ze, Le) | 0, X = X + Math.imul(Ze, xe) | 0, G = G + Math.imul(bt, Ne) | 0, y = y + Math.imul(bt, Ye) | 0, y = y + Math.imul(We, Ne) | 0, X = X + Math.imul(We, Ye) | 0, G = G + Math.imul(pt, Pe) | 0, y = y + Math.imul(pt, qe) | 0, y = y + Math.imul(_t, Pe) | 0, X = X + Math.imul(_t, qe) | 0, G = G + Math.imul(mt, Fe) | 0, y = y + Math.imul(mt, Qe) | 0, y = y + Math.imul(et, Fe) | 0, X = X + Math.imul(et, Qe) | 0, G = G + Math.imul(lt, rt) | 0, y = y + Math.imul(lt, ct) | 0, y = y + Math.imul(ht, rt) | 0, X = X + Math.imul(ht, ct) | 0; var $t = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, G = Math.imul(ye, Le), y = Math.imul(ye, xe), y = y + Math.imul(ge, Le) | 0, X = Math.imul(ge, xe), G = G + Math.imul(ze, Ne) | 0, y = y + Math.imul(ze, Ye) | 0, y = y + Math.imul(Ze, Ne) | 0, X = X + Math.imul(Ze, Ye) | 0, G = G + Math.imul(bt, Pe) | 0, y = y + Math.imul(bt, qe) | 0, y = y + Math.imul(We, Pe) | 0, X = X + Math.imul(We, qe) | 0, G = G + Math.imul(pt, Fe) | 0, y = y + Math.imul(pt, Qe) | 0, y = y + Math.imul(_t, Fe) | 0, X = X + Math.imul(_t, Qe) | 0, G = G + Math.imul(mt, rt) | 0, y = y + Math.imul(mt, ct) | 0, y = y + Math.imul(et, rt) | 0, X = X + Math.imul(et, ct) | 0; var Yt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, G = Math.imul(ye, Ne), y = Math.imul(ye, Ye), y = y + Math.imul(ge, Ne) | 0, X = Math.imul(ge, Ye), G = G + Math.imul(ze, Pe) | 0, y = y + Math.imul(ze, qe) | 0, y = y + Math.imul(Ze, Pe) | 0, X = X + Math.imul(Ze, qe) | 0, G = G + Math.imul(bt, Fe) | 0, y = y + Math.imul(bt, Qe) | 0, y = y + Math.imul(We, Fe) | 0, X = X + Math.imul(We, Qe) | 0, G = G + Math.imul(pt, rt) | 0, y = y + Math.imul(pt, ct) | 0, y = y + Math.imul(_t, rt) | 0, X = X + Math.imul(_t, ct) | 0; var Xt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, G = Math.imul(ye, Pe), y = Math.imul(ye, qe), y = y + Math.imul(ge, Pe) | 0, X = Math.imul(ge, qe), G = G + Math.imul(ze, Fe) | 0, y = y + Math.imul(ze, Qe) | 0, y = y + Math.imul(Ze, Fe) | 0, X = X + Math.imul(Ze, Qe) | 0, G = G + Math.imul(bt, rt) | 0, y = y + Math.imul(bt, ct) | 0, y = y + Math.imul(We, rt) | 0, X = X + Math.imul(We, ct) | 0; var Nt = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ye, Fe), y = Math.imul(ye, Qe), y = y + Math.imul(ge, Fe) | 0, X = Math.imul(ge, Qe), G = G + Math.imul(ze, rt) | 0, y = y + Math.imul(ze, ct) | 0, y = y + Math.imul(Ze, rt) | 0, X = X + Math.imul(Ze, ct) | 0; var Et = (ee + G | 0) + ((y & 8191) << 13) | 0; ee = (X + (y >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, G = Math.imul(ye, rt), y = Math.imul(ye, ct), y = y + Math.imul(ge, rt) | 0, X = Math.imul(ge, ct); var At = (ee + G | 0) + ((y & 8191) << 13) | 0; return ee = (X + (y >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, te[0] = Lt, te[1] = It, te[2] = lr, te[3] = jt, te[4] = Ft, te[5] = er, te[6] = ar, te[7] = nr, te[8] = ir, te[9] = Ht, te[10] = sr, te[11] = Kt, te[12] = Qt, te[13] = $t, te[14] = Yt, te[15] = Xt, te[16] = Nt, te[17] = Et, te[18] = At, ee !== 0 && (te[19] = ee, U.length++), U }; Math.imul || (ne = re); function oe(ie, g, P) { P.negative = g.negative ^ ie.negative, P.length = ie.length + g.length; for (var U = 0, K = 0, Y = 0; Y < P.length - 1; Y++) { var te = K; K = 0; for (var ee = U & 67108863, G = Math.min(Y, g.length - 1), y = Math.max(0, Y - ie.length + 1); y <= G; y++) { var X = Y - y, ce = ie.words[X] | 0, me = g.words[y] | 0, Ae = ce * me, Ie = Ae & 67108863; te = te + (Ae / 67108864 | 0) | 0, Ie = Ie + ee | 0, ee = Ie & 67108863, te = te + (Ie >>> 26) | 0, K += te >>> 26, te &= 67108863 } P.words[Y] = ee, U = te, te = K } return U !== 0 ? P.words[Y] = U : P.length--, P.strip() } function ae(ie, g, P) { var U = new se; return U.mulp(ie, g, P) } d.prototype.mulTo = function (g, P) { var U, K = this.length + g.length; return this.length === 10 && g.length === 10 ? U = ne(this, g, P) : K < 63 ? U = re(this, g, P) : K < 1024 ? U = oe(this, g, P) : U = ae(this, g, P), U }; function se(ie, g) { this.x = ie, this.y = g } se.prototype.makeRBT = function (g) { for (var P = new Array(g), U = d.prototype._countBits(g) - 1, K = 0; K < g; K++)P[K] = this.revBin(K, U, g); return P }, se.prototype.revBin = function (g, P, U) { if (g === 0 || g === U - 1) return g; for (var K = 0, Y = 0; Y < P; Y++)K |= (g & 1) << P - Y - 1, g >>= 1; return K }, se.prototype.permute = function (g, P, U, K, Y, te) { for (var ee = 0; ee < te; ee++)K[ee] = P[g[ee]], Y[ee] = U[g[ee]] }, se.prototype.transform = function (g, P, U, K, Y, te) { this.permute(te, g, P, U, K, Y); for (var ee = 1; ee < Y; ee <<= 1)for (var G = ee << 1, y = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), ce = 0; ce < Y; ce += G)for (var me = y, Ae = X, Ie = 0; Ie < ee; Ie++) { var Be = U[ce + Ie], Me = K[ce + Ie], De = U[ce + Ie + ee], Ue = K[ce + Ie + ee], Ke = me * De - Ae * Ue; Ue = me * Ue + Ae * De, De = Ke, U[ce + Ie] = Be + De, K[ce + Ie] = Me + Ue, U[ce + Ie + ee] = Be - De, K[ce + Ie + ee] = Me - Ue, Ie !== G && (Ke = y * me - X * Ae, Ae = y * Ae + X * me, me = Ke) } }, se.prototype.guessLen13b = function (g, P) { var U = Math.max(P, g) | 1, K = U & 1, Y = 0; for (U = U / 2 | 0; U; U = U >>> 1)Y++; return 1 << Y + 1 + K }, se.prototype.conjugate = function (g, P, U) { if (!(U <= 1)) for (var K = 0; K < U / 2; K++) { var Y = g[K]; g[K] = g[U - K - 1], g[U - K - 1] = Y, Y = P[K], P[K] = -P[U - K - 1], P[U - K - 1] = -Y } }, se.prototype.normalize13b = function (g, P) { for (var U = 0, K = 0; K < P / 2; K++) { var Y = Math.round(g[2 * K + 1] / P) * 8192 + Math.round(g[2 * K] / P) + U; g[K] = Y & 67108863, Y < 67108864 ? U = 0 : U = Y / 67108864 | 0 } return g }, se.prototype.convert13b = function (g, P, U, K) { for (var Y = 0, te = 0; te < P; te++)Y = Y + (g[te] | 0), U[2 * te] = Y & 8191, Y = Y >>> 13, U[2 * te + 1] = Y & 8191, Y = Y >>> 13; for (te = 2 * P; te < K; ++te)U[te] = 0; f(Y === 0), f((Y & -8192) === 0) }, se.prototype.stub = function (g) { for (var P = new Array(g), U = 0; U < g; U++)P[U] = 0; return P }, se.prototype.mulp = function (g, P, U) { var K = 2 * this.guessLen13b(g.length, P.length), Y = this.makeRBT(K), te = this.stub(K), ee = new Array(K), G = new Array(K), y = new Array(K), X = new Array(K), ce = new Array(K), me = new Array(K), Ae = U.words; Ae.length = K, this.convert13b(g.words, g.length, ee, K), this.convert13b(P.words, P.length, X, K), this.transform(ee, te, G, y, K, Y), this.transform(X, te, ce, me, K, Y); for (var Ie = 0; Ie < K; Ie++) { var Be = G[Ie] * ce[Ie] - y[Ie] * me[Ie]; y[Ie] = G[Ie] * me[Ie] + y[Ie] * ce[Ie], G[Ie] = Be } return this.conjugate(G, y, K), this.transform(G, y, Ae, te, K, Y), this.conjugate(Ae, te, K), this.normalize13b(Ae, K), U.negative = g.negative ^ P.negative, U.length = g.length + P.length, U.strip() }, d.prototype.mul = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), this.mulTo(g, P) }, d.prototype.mulf = function (g) { var P = new d(null); return P.words = new Array(this.length + g.length), ae(this, g, P) }, d.prototype.imul = function (g) { return this.clone().mulTo(g, this) }, d.prototype.imuln = function (g) { f(typeof g == "number"), f(g < 67108864); for (var P = 0, U = 0; U < this.length; U++) { var K = (this.words[U] | 0) * g, Y = (K & 67108863) + (P & 67108863); P >>= 26, P += K / 67108864 | 0, P += Y >>> 26, this.words[U] = Y & 67108863 } return P !== 0 && (this.words[U] = P, this.length++), this }, d.prototype.muln = function (g) { return this.clone().imuln(g) }, d.prototype.sqr = function () { return this.mul(this) }, d.prototype.isqr = function () { return this.imul(this.clone()) }, d.prototype.pow = function (g) { var P = Q(g); if (P.length === 0) return new d(1); for (var U = this, K = 0; K < P.length && P[K] === 0; K++, U = U.sqr()); if (++K < P.length) for (var Y = U.sqr(); K < P.length; K++, Y = Y.sqr())P[K] !== 0 && (U = U.mul(Y)); return U }, d.prototype.iushln = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 67108863 >>> 26 - P << 26 - P, Y; if (P !== 0) { var te = 0; for (Y = 0; Y < this.length; Y++) { var ee = this.words[Y] & K, G = (this.words[Y] | 0) - ee << P; this.words[Y] = G | te, te = ee >>> 26 - P } te && (this.words[Y] = te, this.length++) } if (U !== 0) { for (Y = this.length - 1; Y >= 0; Y--)this.words[Y + U] = this.words[Y]; for (Y = 0; Y < U; Y++)this.words[Y] = 0; this.length += U } return this.strip() }, d.prototype.ishln = function (g) { return f(this.negative === 0), this.iushln(g) }, d.prototype.iushrn = function (g, P, U) { f(typeof g == "number" && g >= 0); var K; P ? K = (P - P % 26) / 26 : K = 0; var Y = g % 26, te = Math.min((g - Y) / 26, this.length), ee = 67108863 ^ 67108863 >>> Y << Y, G = U; if (K -= te, K = Math.max(0, K), G) { for (var y = 0; y < te; y++)G.words[y] = this.words[y]; G.length = te } if (te !== 0) if (this.length > te) for (this.length -= te, y = 0; y < this.length; y++)this.words[y] = this.words[y + te]; else this.words[0] = 0, this.length = 1; var X = 0; for (y = this.length - 1; y >= 0 && (X !== 0 || y >= K); y--) { var ce = this.words[y] | 0; this.words[y] = X << 26 - Y | ce >>> Y, X = ce & ee } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, d.prototype.ishrn = function (g, P, U) { return f(this.negative === 0), this.iushrn(g, P, U) }, d.prototype.shln = function (g) { return this.clone().ishln(g) }, d.prototype.ushln = function (g) { return this.clone().iushln(g) }, d.prototype.shrn = function (g) { return this.clone().ishrn(g) }, d.prototype.ushrn = function (g) { return this.clone().iushrn(g) }, d.prototype.testn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return !1; var Y = this.words[U]; return !!(Y & K) }, d.prototype.imaskn = function (g) { f(typeof g == "number" && g >= 0); var P = g % 26, U = (g - P) / 26; if (f(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U) return this; if (P !== 0 && U++, this.length = Math.min(U, this.length), P !== 0) { var K = 67108863 ^ 67108863 >>> P << P; this.words[this.length - 1] &= K } return this.strip() }, d.prototype.maskn = function (g) { return this.clone().imaskn(g) }, d.prototype.iaddn = function (g) { return f(typeof g == "number"), f(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g) }, d.prototype._iaddn = function (g) { this.words[0] += g; for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++; return this.length = Math.max(this.length, P + 1), this }, d.prototype.isubn = function (g) { if (f(typeof g == "number"), f(g < 67108864), g < 0) return this.iaddn(-g); if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this; if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var P = 0; P < this.length && this.words[P] < 0; P++)this.words[P] += 67108864, this.words[P + 1] -= 1; return this.strip() }, d.prototype.addn = function (g) { return this.clone().iaddn(g) }, d.prototype.subn = function (g) { return this.clone().isubn(g) }, d.prototype.iabs = function () { return this.negative = 0, this }, d.prototype.abs = function () { return this.clone().iabs() }, d.prototype._ishlnsubmul = function (g, P, U) { var K = g.length + U, Y; this._expand(K); var te, ee = 0; for (Y = 0; Y < g.length; Y++) { te = (this.words[Y + U] | 0) + ee; var G = (g.words[Y] | 0) * P; te -= G & 67108863, ee = (te >> 26) - (G / 67108864 | 0), this.words[Y + U] = te & 67108863 } for (; Y < this.length - U; Y++)te = (this.words[Y + U] | 0) + ee, ee = te >> 26, this.words[Y + U] = te & 67108863; if (ee === 0) return this.strip(); for (f(ee === -1), ee = 0, Y = 0; Y < this.length; Y++)te = -(this.words[Y] | 0) + ee, ee = te >> 26, this.words[Y] = te & 67108863; return this.negative = 1, this.strip() }, d.prototype._wordDiv = function (g, P) { var U = this.length - g.length, K = this.clone(), Y = g, te = Y.words[Y.length - 1] | 0, ee = this._countBits(te); U = 26 - ee, U !== 0 && (Y = Y.ushln(U), K.iushln(U), te = Y.words[Y.length - 1] | 0); var G = K.length - Y.length, y; if (P !== "mod") { y = new d(null), y.length = G + 1, y.words = new Array(y.length); for (var X = 0; X < y.length; X++)y.words[X] = 0 } var ce = K.clone()._ishlnsubmul(Y, 1, G); ce.negative === 0 && (K = ce, y && (y.words[G] = 1)); for (var me = G - 1; me >= 0; me--) { var Ae = (K.words[Y.length + me] | 0) * 67108864 + (K.words[Y.length + me - 1] | 0); for (Ae = Math.min(Ae / te | 0, 67108863), K._ishlnsubmul(Y, Ae, me); K.negative !== 0;)Ae--, K.negative = 0, K._ishlnsubmul(Y, 1, me), K.isZero() || (K.negative ^= 1); y && (y.words[me] = Ae) } return y && y.strip(), K.strip(), P !== "div" && U !== 0 && K.iushrn(U), { div: y || null, mod: K } }, d.prototype.divmod = function (g, P, U) { if (f(!g.isZero()), this.isZero()) return { div: new d(0), mod: new d(0) }; var K, Y, te; return this.negative !== 0 && g.negative === 0 ? (te = this.neg().divmod(g, P), P !== "mod" && (K = te.div.neg()), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.iadd(g)), { div: K, mod: Y }) : this.negative === 0 && g.negative !== 0 ? (te = this.divmod(g.neg(), P), P !== "mod" && (K = te.div.neg()), { div: K, mod: te.mod }) : (this.negative & g.negative) !== 0 ? (te = this.neg().divmod(g.neg(), P), P !== "div" && (Y = te.mod.neg(), U && Y.negative !== 0 && Y.isub(g)), { div: te.div, mod: Y }) : g.length > this.length || this.cmp(g) < 0 ? { div: new d(0), mod: this } : g.length === 1 ? P === "div" ? { div: this.divn(g.words[0]), mod: null } : P === "mod" ? { div: null, mod: new d(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new d(this.modn(g.words[0])) } : this._wordDiv(g, P) }, d.prototype.div = function (g) { return this.divmod(g, "div", !1).div }, d.prototype.mod = function (g) { return this.divmod(g, "mod", !1).mod }, d.prototype.umod = function (g) { return this.divmod(g, "mod", !0).mod }, d.prototype.divRound = function (g) { var P = this.divmod(g); if (P.mod.isZero()) return P.div; var U = P.div.negative !== 0 ? P.mod.isub(g) : P.mod, K = g.ushrn(1), Y = g.andln(1), te = U.cmp(K); return te < 0 || Y === 1 && te === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1) }, d.prototype.modn = function (g) { f(g <= 67108863); for (var P = (1 << 26) % g, U = 0, K = this.length - 1; K >= 0; K--)U = (P * U + (this.words[K] | 0)) % g; return U }, d.prototype.idivn = function (g) { f(g <= 67108863); for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = (this.words[U] | 0) + P * 67108864; this.words[U] = K / g | 0, P = K % g } return this.strip() }, d.prototype.divn = function (g) { return this.clone().idivn(g) }, d.prototype.egcd = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = new d(0), ee = new d(1), G = 0; P.isEven() && U.isEven();)P.iushrn(1), U.iushrn(1), ++G; for (var y = U.clone(), X = P.clone(); !P.isZero();) { for (var ce = 0, me = 1; (P.words[0] & me) === 0 && ce < 26; ++ce, me <<= 1); if (ce > 0) for (P.iushrn(ce); ce-- > 0;)(K.isOdd() || Y.isOdd()) && (K.iadd(y), Y.isub(X)), K.iushrn(1), Y.iushrn(1); for (var Ae = 0, Ie = 1; (U.words[0] & Ie) === 0 && Ae < 26; ++Ae, Ie <<= 1); if (Ae > 0) for (U.iushrn(Ae); Ae-- > 0;)(te.isOdd() || ee.isOdd()) && (te.iadd(y), ee.isub(X)), te.iushrn(1), ee.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(te), Y.isub(ee)) : (U.isub(P), te.isub(K), ee.isub(Y)) } return { a: te, b: ee, gcd: U.iushln(G) } }, d.prototype._invmp = function (g) { f(g.negative === 0), f(!g.isZero()); var P = this, U = g.clone(); P.negative !== 0 ? P = P.umod(g) : P = P.clone(); for (var K = new d(1), Y = new d(0), te = U.clone(); P.cmpn(1) > 0 && U.cmpn(1) > 0;) { for (var ee = 0, G = 1; (P.words[0] & G) === 0 && ee < 26; ++ee, G <<= 1); if (ee > 0) for (P.iushrn(ee); ee-- > 0;)K.isOdd() && K.iadd(te), K.iushrn(1); for (var y = 0, X = 1; (U.words[0] & X) === 0 && y < 26; ++y, X <<= 1); if (y > 0) for (U.iushrn(y); y-- > 0;)Y.isOdd() && Y.iadd(te), Y.iushrn(1); P.cmp(U) >= 0 ? (P.isub(U), K.isub(Y)) : (U.isub(P), Y.isub(K)) } var ce; return P.cmpn(1) === 0 ? ce = K : ce = Y, ce.cmpn(0) < 0 && ce.iadd(g), ce }, d.prototype.gcd = function (g) { if (this.isZero()) return g.abs(); if (g.isZero()) return this.abs(); var P = this.clone(), U = g.clone(); P.negative = 0, U.negative = 0; for (var K = 0; P.isEven() && U.isEven(); K++)P.iushrn(1), U.iushrn(1); do { for (; P.isEven();)P.iushrn(1); for (; U.isEven();)U.iushrn(1); var Y = P.cmp(U); if (Y < 0) { var te = P; P = U, U = te } else if (Y === 0 || U.cmpn(1) === 0) break; P.isub(U) } while (!0); return U.iushln(K) }, d.prototype.invm = function (g) { return this.egcd(g).a.umod(g) }, d.prototype.isEven = function () { return (this.words[0] & 1) === 0 }, d.prototype.isOdd = function () { return (this.words[0] & 1) === 1 }, d.prototype.andln = function (g) { return this.words[0] & g }, d.prototype.bincn = function (g) { f(typeof g == "number"); var P = g % 26, U = (g - P) / 26, K = 1 << P; if (this.length <= U) return this._expand(U + 1), this.words[U] |= K, this; for (var Y = K, te = U; Y !== 0 && te < this.length; te++) { var ee = this.words[te] | 0; ee += Y, Y = ee >>> 26, ee &= 67108863, this.words[te] = ee } return Y !== 0 && (this.words[te] = Y, this.length++), this }, d.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, d.prototype.cmpn = function (g) { var P = g < 0; if (this.negative !== 0 && !P) return -1; if (this.negative === 0 && P) return 1; this.strip(); var U; if (this.length > 1) U = 1; else { P && (g = -g), f(g <= 67108863, "Number is too big"); var K = this.words[0] | 0; U = K === g ? 0 : K < g ? -1 : 1 } return this.negative !== 0 ? -U | 0 : U }, d.prototype.cmp = function (g) { if (this.negative !== 0 && g.negative === 0) return -1; if (this.negative === 0 && g.negative !== 0) return 1; var P = this.ucmp(g); return this.negative !== 0 ? -P | 0 : P }, d.prototype.ucmp = function (g) { if (this.length > g.length) return 1; if (this.length < g.length) return -1; for (var P = 0, U = this.length - 1; U >= 0; U--) { var K = this.words[U] | 0, Y = g.words[U] | 0; if (K !== Y) { K < Y ? P = -1 : K > Y && (P = 1); break } } return P }, d.prototype.gtn = function (g) { return this.cmpn(g) === 1 }, d.prototype.gt = function (g) { return this.cmp(g) === 1 }, d.prototype.gten = function (g) { return this.cmpn(g) >= 0 }, d.prototype.gte = function (g) { return this.cmp(g) >= 0 }, d.prototype.ltn = function (g) { return this.cmpn(g) === -1 }, d.prototype.lt = function (g) { return this.cmp(g) === -1 }, d.prototype.lten = function (g) { return this.cmpn(g) <= 0 }, d.prototype.lte = function (g) { return this.cmp(g) <= 0 }, d.prototype.eqn = function (g) { return this.cmpn(g) === 0 }, d.prototype.eq = function (g) { return this.cmp(g) === 0 }, d.red = function (g) { return new Se(g) }, d.prototype.toRed = function (g) { return f(!this.red, "Already a number in reduction context"), f(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g) }, d.prototype.fromRed = function () { return f(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, d.prototype._forceRed = function (g) { return this.red = g, this }, d.prototype.forceRed = function (g) { return f(!this.red, "Already a number in reduction context"), this._forceRed(g) }, d.prototype.redAdd = function (g) { return f(this.red, "redAdd works only with red numbers"), this.red.add(this, g) }, d.prototype.redIAdd = function (g) { return f(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g) }, d.prototype.redSub = function (g) { return f(this.red, "redSub works only with red numbers"), this.red.sub(this, g) }, d.prototype.redISub = function (g) { return f(this.red, "redISub works only with red numbers"), this.red.isub(this, g) }, d.prototype.redShl = function (g) { return f(this.red, "redShl works only with red numbers"), this.red.shl(this, g) }, d.prototype.redMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g) }, d.prototype.redIMul = function (g) { return f(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g) }, d.prototype.redSqr = function () { return f(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, d.prototype.redISqr = function () { return f(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, d.prototype.redSqrt = function () { return f(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, d.prototype.redInvm = function () { return f(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, d.prototype.redNeg = function () { return f(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, d.prototype.redPow = function (g) { return f(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g) }; var le = { k256: null, p224: null, p192: null, p25519: null }; function ue(ie, g) { this.name = ie, this.p = new d(g, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } ue.prototype._tmp = function () { var g = new d(null); return g.words = new Array(Math.ceil(this.n / 13)), g }, ue.prototype.ireduce = function (g) { var P = g, U; do this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), U = P.bitLength(); while (U > this.n); var K = U < this.n ? -1 : P.ucmp(this.p); return K === 0 ? (P.words[0] = 0, P.length = 1) : K > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P }, ue.prototype.split = function (g, P) { g.iushrn(this.n, 0, P) }, ue.prototype.imulK = function (g) { return g.imul(this.k) }; function he() { ue.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } p(he, ue), he.prototype.split = function (g, P) { for (var U = 4194303, K = Math.min(g.length, 9), Y = 0; Y < K; Y++)P.words[Y] = g.words[Y]; if (P.length = K, g.length <= 9) { g.words[0] = 0, g.length = 1; return } var te = g.words[9]; for (P.words[P.length++] = te & U, Y = 10; Y < g.length; Y++) { var ee = g.words[Y] | 0; g.words[Y - 10] = (ee & U) << 4 | te >>> 22, te = ee } te >>>= 22, g.words[Y - 10] = te, te === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9 }, he.prototype.imulK = function (g) { g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2; for (var P = 0, U = 0; U < g.length; U++) { var K = g.words[U] | 0; P += K * 977, g.words[U] = P & 67108863, P = K * 64 + (P / 67108864 | 0) } return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g }; function pe() { ue.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } p(pe, ue); function ve() { ue.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } p(ve, ue); function _e() { ue.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } p(_e, ue), _e.prototype.imulK = function (g) { for (var P = 0, U = 0; U < g.length; U++) { var K = (g.words[U] | 0) * 19 + P, Y = K & 67108863; K >>>= 26, g.words[U] = Y, P = K } return P !== 0 && (g.words[g.length++] = P), g }, d._prime = function (g) { if (le[g]) return le[g]; var P; if (g === "k256") P = new he; else if (g === "p224") P = new pe; else if (g === "p192") P = new ve; else if (g === "p25519") P = new _e; else throw new Error("Unknown prime " + g); return le[g] = P, P }; function Se(ie) { if (typeof ie == "string") { var g = d._prime(ie); this.m = g.p, this.prime = g } else f(ie.gtn(1), "modulus must be greater than 1"), this.m = ie, this.prime = null } Se.prototype._verify1 = function (g) { f(g.negative === 0, "red works only with positives"), f(g.red, "red works only with red numbers") }, Se.prototype._verify2 = function (g, P) { f((g.negative | P.negative) === 0, "red works only with positives"), f(g.red && g.red === P.red, "red works only with red numbers") }, Se.prototype.imod = function (g) { return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this) }, Se.prototype.neg = function (g) { return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this) }, Se.prototype.add = function (g, P) { this._verify2(g, P); var U = g.add(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this) }, Se.prototype.iadd = function (g, P) { this._verify2(g, P); var U = g.iadd(P); return U.cmp(this.m) >= 0 && U.isub(this.m), U }, Se.prototype.sub = function (g, P) { this._verify2(g, P); var U = g.sub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this) }, Se.prototype.isub = function (g, P) { this._verify2(g, P); var U = g.isub(P); return U.cmpn(0) < 0 && U.iadd(this.m), U }, Se.prototype.shl = function (g, P) { return this._verify1(g), this.imod(g.ushln(P)) }, Se.prototype.imul = function (g, P) { return this._verify2(g, P), this.imod(g.imul(P)) }, Se.prototype.mul = function (g, P) { return this._verify2(g, P), this.imod(g.mul(P)) }, Se.prototype.isqr = function (g) { return this.imul(g, g.clone()) }, Se.prototype.sqr = function (g) { return this.mul(g, g) }, Se.prototype.sqrt = function (g) { if (g.isZero()) return g.clone(); var P = this.m.andln(3); if (f(P % 2 === 1), P === 3) { var U = this.m.add(new d(1)).iushrn(2); return this.pow(g, U) } for (var K = this.m.subn(1), Y = 0; !K.isZero() && K.andln(1) === 0;)Y++, K.iushrn(1); f(!K.isZero()); var te = new d(1).toRed(this), ee = te.redNeg(), G = this.m.subn(1).iushrn(1), y = this.m.bitLength(); for (y = new d(2 * y * y).toRed(this); this.pow(y, G).cmp(ee) !== 0;)y.redIAdd(ee); for (var X = this.pow(y, K), ce = this.pow(g, K.addn(1).iushrn(1)), me = this.pow(g, K), Ae = Y; me.cmp(te) !== 0;) { for (var Ie = me, Be = 0; Ie.cmp(te) !== 0; Be++)Ie = Ie.redSqr(); f(Be < Ae); var Me = this.pow(X, new d(1).iushln(Ae - Be - 1)); ce = ce.redMul(Me), X = Me.redSqr(), me = me.redMul(X), Ae = Be } return ce }, Se.prototype.invm = function (g) { var P = g._invmp(this.m); return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P) }, Se.prototype.pow = function (g, P) { if (P.isZero()) return new d(1).toRed(this); if (P.cmpn(1) === 0) return g.clone(); var U = 4, K = new Array(1 << U); K[0] = new d(1).toRed(this), K[1] = g; for (var Y = 2; Y < K.length; Y++)K[Y] = this.mul(K[Y - 1], g); var te = K[0], ee = 0, G = 0, y = P.bitLength() % 26; for (y === 0 && (y = 26), Y = P.length - 1; Y >= 0; Y--) { for (var X = P.words[Y], ce = y - 1; ce >= 0; ce--) { var me = X >> ce & 1; if (te !== K[0] && (te = this.sqr(te)), me === 0 && ee === 0) { G = 0; continue } ee <<= 1, ee |= me, G++, !(G !== U && (Y !== 0 || ce !== 0)) && (te = this.mul(te, K[ee]), G = 0, ee = 0) } y = 26 } return te }, Se.prototype.convertTo = function (g) { var P = g.umod(this.m); return P === g ? P.clone() : P }, Se.prototype.convertFrom = function (g) { var P = g.clone(); return P.red = null, P }, d.mont = function (g) { return new $e(g) }; function $e(ie) { Se.call(this, ie), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } p($e, Se), $e.prototype.convertTo = function (g) { return this.imod(g.ushln(this.shift)) }, $e.prototype.convertFrom = function (g) { var P = this.imod(g.mul(this.rinv)); return P.red = null, P }, $e.prototype.imul = function (g, P) { if (g.isZero() || P.isZero()) return g.words[0] = 0, g.length = 1, g; var U = g.imul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.mul = function (g, P) { if (g.isZero() || P.isZero()) return new d(0)._forceRed(this); var U = g.mul(P), K = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = U.isub(K).iushrn(this.shift), te = Y; return Y.cmp(this.m) >= 0 ? te = Y.isub(this.m) : Y.cmpn(0) < 0 && (te = Y.iadd(this.m)), te._forceRed(this) }, $e.prototype.invm = function (g) { var P = this.imod(g._invmp(this.m).mul(this.r2)); return P._forceRed(this) } })(o, bn) }(bn$1)), bn$1.exports } var withPublic_1, hasRequiredWithPublic; function requireWithPublic() { if (hasRequiredWithPublic) return withPublic_1; hasRequiredWithPublic = 1; var o = requireBn(), l = requireSafeBuffer$1().Buffer; function u(f, p) { return l.from(f.toRed(o.mont(p.modulus)).redPow(new o(p.publicExponent)).fromRed().toArray()) } return withPublic_1 = u, withPublic_1 } var publicEncrypt, hasRequiredPublicEncrypt; function requirePublicEncrypt() { if (hasRequiredPublicEncrypt) return publicEncrypt; hasRequiredPublicEncrypt = 1; var o = requireParseAsn1(), l = requireBrowser$b(), u = requireBrowser$9(), f = requireMgf(), p = requireXor(), d = requireBn(), m = requireWithPublic(), v = requireBrowserifyRsa(), I = requireSafeBuffer$1().Buffer; publicEncrypt = function (Q, re, ne) { var oe; Q.padding ? oe = Q.padding : ne ? oe = 1 : oe = 4; var ae = o(Q), se; if (oe === 4) se = F(ae, re); else if (oe === 1) se = B(ae, re, ne); else if (oe === 3) { if (se = new d(re), se.cmp(ae.modulus) >= 0) throw new Error("data too long for modulus") } else throw new Error("unknown padding"); return ne ? v(se, ae) : m(se, ae) }; function F(Z, Q) { var re = Z.modulus.byteLength(), ne = Q.length, oe = u("sha1").update(I.alloc(0)).digest(), ae = oe.length, se = 2 * ae; if (ne > re - se - 2) throw new Error("message too long"); var le = I.alloc(re - ne - se - 2), ue = re - ae - 1, he = l(ae), pe = p(I.concat([oe, le, I.alloc(1, 1), Q], ue), f(he, ue)), ve = p(he, f(pe, ae)); return new d(I.concat([I.alloc(1), ve, pe], re)) } function B(Z, Q, re) { var ne = Q.length, oe = Z.modulus.byteLength(); if (ne > oe - 11) throw new Error("message too long"); var ae; return re ? ae = I.alloc(oe - ne - 3, 255) : ae = W(oe - ne - 3), new d(I.concat([I.from([0, re ? 1 : 2]), ae, I.alloc(1), Q], oe)) } function W(Z) { for (var Q = I.allocUnsafe(Z), re = 0, ne = l(Z * 2), oe = 0, ae; re < Z;)oe === ne.length && (ne = l(Z * 2), oe = 0), ae = ne[oe++], ae && (Q[re++] = ae); return Q } return publicEncrypt } var privateDecrypt, hasRequiredPrivateDecrypt; function requirePrivateDecrypt() { if (hasRequiredPrivateDecrypt) return privateDecrypt; hasRequiredPrivateDecrypt = 1; var o = requireParseAsn1(), l = requireMgf(), u = requireXor(), f = requireBn(), p = requireBrowserifyRsa(), d = requireBrowser$9(), m = requireWithPublic(), v = requireSafeBuffer$1().Buffer; privateDecrypt = function (Z, Q, re) { var ne; Z.padding ? ne = Z.padding : re ? ne = 1 : ne = 4; var oe = o(Z), ae = oe.modulus.byteLength(); if (Q.length > ae || new f(Q).cmp(oe.modulus) >= 0) throw new Error("decryption error"); var se; re ? se = m(new f(Q), oe) : se = p(Q, oe); var le = v.alloc(ae - se.length); if (se = v.concat([le, se], ae), ne === 4) return I(oe, se); if (ne === 1) return F(oe, se, re); if (ne === 3) return se; throw new Error("unknown padding") }; function I(W, Z) { var Q = W.modulus.byteLength(), re = d("sha1").update(v.alloc(0)).digest(), ne = re.length; if (Z[0] !== 0) throw new Error("decryption error"); var oe = Z.slice(1, ne + 1), ae = Z.slice(ne + 1), se = u(oe, l(ae, ne)), le = u(ae, l(se, Q - ne - 1)); if (B(re, le.slice(0, ne))) throw new Error("decryption error"); for (var ue = ne; le[ue] === 0;)ue++; if (le[ue++] !== 1) throw new Error("decryption error"); return le.slice(ue) } function F(W, Z, Q) { for (var re = Z.slice(0, 2), ne = 2, oe = 0; Z[ne++] !== 0;)if (ne >= Z.length) { oe++; break } var ae = Z.slice(2, ne - 1); if ((re.toString("hex") !== "0002" && !Q || re.toString("hex") !== "0001" && Q) && oe++, ae.length < 8 && oe++, oe) throw new Error("decryption error"); return Z.slice(ne) } function B(W, Z) { W = v.from(W), Z = v.from(Z); var Q = 0, re = W.length; W.length !== Z.length && (Q++, re = Math.min(W.length, Z.length)); for (var ne = -1; ++ne < re;)Q += W[ne] ^ Z[ne]; return Q } return privateDecrypt } var hasRequiredBrowser$1; function requireBrowser$1() { return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function (o) { o.publicEncrypt = requirePublicEncrypt(), o.privateDecrypt = requirePrivateDecrypt(), o.privateEncrypt = function (u, f) { return o.publicEncrypt(u, f, !0) }, o.publicDecrypt = function (u, f) { return o.privateDecrypt(u, f, !0) } }(browser$2)), browser$2 } var browser$1 = {}, hasRequiredBrowser; function requireBrowser() {
  if (hasRequiredBrowser) return browser$1; hasRequiredBrowser = 1; function o() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
  } var l = requireSafeBuffer$1(), u = requireBrowser$b(), f = l.Buffer, p = l.kMaxLength, d = commonjsGlobal.crypto || commonjsGlobal.msCrypto, m = Math.pow(2, 32) - 1; function v(Z, Q) { if (typeof Z != "number" || Z !== Z) throw new TypeError("offset must be a number"); if (Z > m || Z < 0) throw new TypeError("offset must be a uint32"); if (Z > p || Z > Q) throw new RangeError("offset out of range") } function I(Z, Q, re) { if (typeof Z != "number" || Z !== Z) throw new TypeError("size must be a number"); if (Z > m || Z < 0) throw new TypeError("size must be a uint32"); if (Z + Q > re || Z > p) throw new RangeError("buffer too small") } d && d.getRandomValues || !process$1.browser ? (browser$1.randomFill = F, browser$1.randomFillSync = W) : (browser$1.randomFill = o, browser$1.randomFillSync = o); function F(Z, Q, re, ne) { if (!f.isBuffer(Z) && !(Z instanceof commonjsGlobal.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array'); if (typeof Q == "function") ne = Q, Q = 0, re = Z.length; else if (typeof re == "function") ne = re, re = Z.length - Q; else if (typeof ne != "function") throw new TypeError('"cb" argument must be a function'); return v(Q, Z.length), I(re, Q, Z.length), B(Z, Q, re, ne) } function B(Z, Q, re, ne) { if (process$1.browser) { var oe = Z.buffer, ae = new Uint8Array(oe, Q, re); if (d.getRandomValues(ae), ne) { process$1.nextTick(function () { ne(null, Z) }); return } return Z } if (ne) { u(re, function (le, ue) { if (le) return ne(le); ue.copy(Z, Q), ne(null, Z) }); return } var se = u(re); return se.copy(Z, Q), Z } function W(Z, Q, re) { if (typeof Q > "u" && (Q = 0), !f.isBuffer(Z) && !(Z instanceof commonjsGlobal.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array'); return v(Q, Z.length), re === void 0 && (re = Z.length - Q), I(re, Q, Z.length), B(Z, Q, re) } return browser$1
} var hasRequiredCryptoBrowserify; function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify; hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8(); var o = requireAlgos(), l = Object.keys(o), u = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(l); cryptoBrowserify.getHashes = function () { return u }; var f = requireBrowser$7(); cryptoBrowserify.pbkdf2 = f.pbkdf2, cryptoBrowserify.pbkdf2Sync = f.pbkdf2Sync; var p = requireBrowser$5(); cryptoBrowserify.Cipher = p.Cipher, cryptoBrowserify.createCipher = p.createCipher, cryptoBrowserify.Cipheriv = p.Cipheriv, cryptoBrowserify.createCipheriv = p.createCipheriv, cryptoBrowserify.Decipher = p.Decipher, cryptoBrowserify.createDecipher = p.createDecipher, cryptoBrowserify.Decipheriv = p.Decipheriv, cryptoBrowserify.createDecipheriv = p.createDecipheriv, cryptoBrowserify.getCiphers = p.getCiphers, cryptoBrowserify.listCiphers = p.listCiphers; var d = requireBrowser$4(); cryptoBrowserify.DiffieHellmanGroup = d.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = d.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = d.getDiffieHellman, cryptoBrowserify.createDiffieHellman = d.createDiffieHellman, cryptoBrowserify.DiffieHellman = d.DiffieHellman; var m = requireBrowser$3(); cryptoBrowserify.createSign = m.createSign, cryptoBrowserify.Sign = m.Sign, cryptoBrowserify.createVerify = m.createVerify, cryptoBrowserify.Verify = m.Verify, cryptoBrowserify.createECDH = requireBrowser$2(); var v = requireBrowser$1(); cryptoBrowserify.publicEncrypt = v.publicEncrypt, cryptoBrowserify.privateEncrypt = v.privateEncrypt, cryptoBrowserify.publicDecrypt = v.publicDecrypt, cryptoBrowserify.privateDecrypt = v.privateDecrypt; var I = requireBrowser(); return cryptoBrowserify.randomFill = I.randomFill, cryptoBrowserify.randomFillSync = I.randomFillSync, cryptoBrowserify.createCredentials = function () {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`))
  }, cryptoBrowserify.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 }, cryptoBrowserify
} var hasRequiredNaclFast; function requireNaclFast() { return hasRequiredNaclFast || (hasRequiredNaclFast = 1, function (o) { (function (l) { var u = function (Re) { var Pe, qe = new Float64Array(16); if (Re) for (Pe = 0; Pe < Re.length; Pe++)qe[Pe] = Re[Pe]; return qe }, f = function () { throw new Error("no PRNG") }, p = new Uint8Array(16), d = new Uint8Array(32); d[0] = 9; var m = u(), v = u([1]), I = u([56129, 1]), F = u([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), B = u([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), W = u([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Z = u([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), Q = u([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]); function re(Re, Pe, qe, be) { Re[Pe] = qe >> 24 & 255, Re[Pe + 1] = qe >> 16 & 255, Re[Pe + 2] = qe >> 8 & 255, Re[Pe + 3] = qe & 255, Re[Pe + 4] = be >> 24 & 255, Re[Pe + 5] = be >> 16 & 255, Re[Pe + 6] = be >> 8 & 255, Re[Pe + 7] = be & 255 } function ne(Re, Pe, qe, be, Fe) { var Qe, st = 0; for (Qe = 0; Qe < Fe; Qe++)st |= Re[Pe + Qe] ^ qe[be + Qe]; return (1 & st - 1 >>> 8) - 1 } function oe(Re, Pe, qe, be) { return ne(Re, Pe, qe, be, 16) } function ae(Re, Pe, qe, be) { return ne(Re, Pe, qe, be, 32) } function se(Re, Pe, qe, be) { for (var Fe = be[0] & 255 | (be[1] & 255) << 8 | (be[2] & 255) << 16 | (be[3] & 255) << 24, Qe = qe[0] & 255 | (qe[1] & 255) << 8 | (qe[2] & 255) << 16 | (qe[3] & 255) << 24, st = qe[4] & 255 | (qe[5] & 255) << 8 | (qe[6] & 255) << 16 | (qe[7] & 255) << 24, rt = qe[8] & 255 | (qe[9] & 255) << 8 | (qe[10] & 255) << 16 | (qe[11] & 255) << 24, ct = qe[12] & 255 | (qe[13] & 255) << 8 | (qe[14] & 255) << 16 | (qe[15] & 255) << 24, Lt = be[4] & 255 | (be[5] & 255) << 8 | (be[6] & 255) << 16 | (be[7] & 255) << 24, It = Pe[0] & 255 | (Pe[1] & 255) << 8 | (Pe[2] & 255) << 16 | (Pe[3] & 255) << 24, lr = Pe[4] & 255 | (Pe[5] & 255) << 8 | (Pe[6] & 255) << 16 | (Pe[7] & 255) << 24, jt = Pe[8] & 255 | (Pe[9] & 255) << 8 | (Pe[10] & 255) << 16 | (Pe[11] & 255) << 24, Ft = Pe[12] & 255 | (Pe[13] & 255) << 8 | (Pe[14] & 255) << 16 | (Pe[15] & 255) << 24, er = be[8] & 255 | (be[9] & 255) << 8 | (be[10] & 255) << 16 | (be[11] & 255) << 24, ar = qe[16] & 255 | (qe[17] & 255) << 8 | (qe[18] & 255) << 16 | (qe[19] & 255) << 24, nr = qe[20] & 255 | (qe[21] & 255) << 8 | (qe[22] & 255) << 16 | (qe[23] & 255) << 24, ir = qe[24] & 255 | (qe[25] & 255) << 8 | (qe[26] & 255) << 16 | (qe[27] & 255) << 24, Ht = qe[28] & 255 | (qe[29] & 255) << 8 | (qe[30] & 255) << 16 | (qe[31] & 255) << 24, sr = be[12] & 255 | (be[13] & 255) << 8 | (be[14] & 255) << 16 | (be[15] & 255) << 24, Kt = Fe, Qt = Qe, $t = st, Yt = rt, Xt = ct, Nt = Lt, Et = It, At = lr, qt = jt, Ot = Ft, Dt = er, Wt = ar, pr = nr, yr = ir, br = Ht, _r = sr, ft, Sr = 0; Sr < 20; Sr += 2)ft = Kt + pr | 0, Xt ^= ft << 7 | ft >>> 25, ft = Xt + Kt | 0, qt ^= ft << 9 | ft >>> 23, ft = qt + Xt | 0, pr ^= ft << 13 | ft >>> 19, ft = pr + qt | 0, Kt ^= ft << 18 | ft >>> 14, ft = Nt + Qt | 0, Ot ^= ft << 7 | ft >>> 25, ft = Ot + Nt | 0, yr ^= ft << 9 | ft >>> 23, ft = yr + Ot | 0, Qt ^= ft << 13 | ft >>> 19, ft = Qt + yr | 0, Nt ^= ft << 18 | ft >>> 14, ft = Dt + Et | 0, br ^= ft << 7 | ft >>> 25, ft = br + Dt | 0, $t ^= ft << 9 | ft >>> 23, ft = $t + br | 0, Et ^= ft << 13 | ft >>> 19, ft = Et + $t | 0, Dt ^= ft << 18 | ft >>> 14, ft = _r + Wt | 0, Yt ^= ft << 7 | ft >>> 25, ft = Yt + _r | 0, At ^= ft << 9 | ft >>> 23, ft = At + Yt | 0, Wt ^= ft << 13 | ft >>> 19, ft = Wt + At | 0, _r ^= ft << 18 | ft >>> 14, ft = Kt + Yt | 0, Qt ^= ft << 7 | ft >>> 25, ft = Qt + Kt | 0, $t ^= ft << 9 | ft >>> 23, ft = $t + Qt | 0, Yt ^= ft << 13 | ft >>> 19, ft = Yt + $t | 0, Kt ^= ft << 18 | ft >>> 14, ft = Nt + Xt | 0, Et ^= ft << 7 | ft >>> 25, ft = Et + Nt | 0, At ^= ft << 9 | ft >>> 23, ft = At + Et | 0, Xt ^= ft << 13 | ft >>> 19, ft = Xt + At | 0, Nt ^= ft << 18 | ft >>> 14, ft = Dt + Ot | 0, Wt ^= ft << 7 | ft >>> 25, ft = Wt + Dt | 0, qt ^= ft << 9 | ft >>> 23, ft = qt + Wt | 0, Ot ^= ft << 13 | ft >>> 19, ft = Ot + qt | 0, Dt ^= ft << 18 | ft >>> 14, ft = _r + br | 0, pr ^= ft << 7 | ft >>> 25, ft = pr + _r | 0, yr ^= ft << 9 | ft >>> 23, ft = yr + pr | 0, br ^= ft << 13 | ft >>> 19, ft = br + yr | 0, _r ^= ft << 18 | ft >>> 14; Kt = Kt + Fe | 0, Qt = Qt + Qe | 0, $t = $t + st | 0, Yt = Yt + rt | 0, Xt = Xt + ct | 0, Nt = Nt + Lt | 0, Et = Et + It | 0, At = At + lr | 0, qt = qt + jt | 0, Ot = Ot + Ft | 0, Dt = Dt + er | 0, Wt = Wt + ar | 0, pr = pr + nr | 0, yr = yr + ir | 0, br = br + Ht | 0, _r = _r + sr | 0, Re[0] = Kt >>> 0 & 255, Re[1] = Kt >>> 8 & 255, Re[2] = Kt >>> 16 & 255, Re[3] = Kt >>> 24 & 255, Re[4] = Qt >>> 0 & 255, Re[5] = Qt >>> 8 & 255, Re[6] = Qt >>> 16 & 255, Re[7] = Qt >>> 24 & 255, Re[8] = $t >>> 0 & 255, Re[9] = $t >>> 8 & 255, Re[10] = $t >>> 16 & 255, Re[11] = $t >>> 24 & 255, Re[12] = Yt >>> 0 & 255, Re[13] = Yt >>> 8 & 255, Re[14] = Yt >>> 16 & 255, Re[15] = Yt >>> 24 & 255, Re[16] = Xt >>> 0 & 255, Re[17] = Xt >>> 8 & 255, Re[18] = Xt >>> 16 & 255, Re[19] = Xt >>> 24 & 255, Re[20] = Nt >>> 0 & 255, Re[21] = Nt >>> 8 & 255, Re[22] = Nt >>> 16 & 255, Re[23] = Nt >>> 24 & 255, Re[24] = Et >>> 0 & 255, Re[25] = Et >>> 8 & 255, Re[26] = Et >>> 16 & 255, Re[27] = Et >>> 24 & 255, Re[28] = At >>> 0 & 255, Re[29] = At >>> 8 & 255, Re[30] = At >>> 16 & 255, Re[31] = At >>> 24 & 255, Re[32] = qt >>> 0 & 255, Re[33] = qt >>> 8 & 255, Re[34] = qt >>> 16 & 255, Re[35] = qt >>> 24 & 255, Re[36] = Ot >>> 0 & 255, Re[37] = Ot >>> 8 & 255, Re[38] = Ot >>> 16 & 255, Re[39] = Ot >>> 24 & 255, Re[40] = Dt >>> 0 & 255, Re[41] = Dt >>> 8 & 255, Re[42] = Dt >>> 16 & 255, Re[43] = Dt >>> 24 & 255, Re[44] = Wt >>> 0 & 255, Re[45] = Wt >>> 8 & 255, Re[46] = Wt >>> 16 & 255, Re[47] = Wt >>> 24 & 255, Re[48] = pr >>> 0 & 255, Re[49] = pr >>> 8 & 255, Re[50] = pr >>> 16 & 255, Re[51] = pr >>> 24 & 255, Re[52] = yr >>> 0 & 255, Re[53] = yr >>> 8 & 255, Re[54] = yr >>> 16 & 255, Re[55] = yr >>> 24 & 255, Re[56] = br >>> 0 & 255, Re[57] = br >>> 8 & 255, Re[58] = br >>> 16 & 255, Re[59] = br >>> 24 & 255, Re[60] = _r >>> 0 & 255, Re[61] = _r >>> 8 & 255, Re[62] = _r >>> 16 & 255, Re[63] = _r >>> 24 & 255 } function le(Re, Pe, qe, be) { for (var Fe = be[0] & 255 | (be[1] & 255) << 8 | (be[2] & 255) << 16 | (be[3] & 255) << 24, Qe = qe[0] & 255 | (qe[1] & 255) << 8 | (qe[2] & 255) << 16 | (qe[3] & 255) << 24, st = qe[4] & 255 | (qe[5] & 255) << 8 | (qe[6] & 255) << 16 | (qe[7] & 255) << 24, rt = qe[8] & 255 | (qe[9] & 255) << 8 | (qe[10] & 255) << 16 | (qe[11] & 255) << 24, ct = qe[12] & 255 | (qe[13] & 255) << 8 | (qe[14] & 255) << 16 | (qe[15] & 255) << 24, Lt = be[4] & 255 | (be[5] & 255) << 8 | (be[6] & 255) << 16 | (be[7] & 255) << 24, It = Pe[0] & 255 | (Pe[1] & 255) << 8 | (Pe[2] & 255) << 16 | (Pe[3] & 255) << 24, lr = Pe[4] & 255 | (Pe[5] & 255) << 8 | (Pe[6] & 255) << 16 | (Pe[7] & 255) << 24, jt = Pe[8] & 255 | (Pe[9] & 255) << 8 | (Pe[10] & 255) << 16 | (Pe[11] & 255) << 24, Ft = Pe[12] & 255 | (Pe[13] & 255) << 8 | (Pe[14] & 255) << 16 | (Pe[15] & 255) << 24, er = be[8] & 255 | (be[9] & 255) << 8 | (be[10] & 255) << 16 | (be[11] & 255) << 24, ar = qe[16] & 255 | (qe[17] & 255) << 8 | (qe[18] & 255) << 16 | (qe[19] & 255) << 24, nr = qe[20] & 255 | (qe[21] & 255) << 8 | (qe[22] & 255) << 16 | (qe[23] & 255) << 24, ir = qe[24] & 255 | (qe[25] & 255) << 8 | (qe[26] & 255) << 16 | (qe[27] & 255) << 24, Ht = qe[28] & 255 | (qe[29] & 255) << 8 | (qe[30] & 255) << 16 | (qe[31] & 255) << 24, sr = be[12] & 255 | (be[13] & 255) << 8 | (be[14] & 255) << 16 | (be[15] & 255) << 24, Kt = Fe, Qt = Qe, $t = st, Yt = rt, Xt = ct, Nt = Lt, Et = It, At = lr, qt = jt, Ot = Ft, Dt = er, Wt = ar, pr = nr, yr = ir, br = Ht, _r = sr, ft, Sr = 0; Sr < 20; Sr += 2)ft = Kt + pr | 0, Xt ^= ft << 7 | ft >>> 25, ft = Xt + Kt | 0, qt ^= ft << 9 | ft >>> 23, ft = qt + Xt | 0, pr ^= ft << 13 | ft >>> 19, ft = pr + qt | 0, Kt ^= ft << 18 | ft >>> 14, ft = Nt + Qt | 0, Ot ^= ft << 7 | ft >>> 25, ft = Ot + Nt | 0, yr ^= ft << 9 | ft >>> 23, ft = yr + Ot | 0, Qt ^= ft << 13 | ft >>> 19, ft = Qt + yr | 0, Nt ^= ft << 18 | ft >>> 14, ft = Dt + Et | 0, br ^= ft << 7 | ft >>> 25, ft = br + Dt | 0, $t ^= ft << 9 | ft >>> 23, ft = $t + br | 0, Et ^= ft << 13 | ft >>> 19, ft = Et + $t | 0, Dt ^= ft << 18 | ft >>> 14, ft = _r + Wt | 0, Yt ^= ft << 7 | ft >>> 25, ft = Yt + _r | 0, At ^= ft << 9 | ft >>> 23, ft = At + Yt | 0, Wt ^= ft << 13 | ft >>> 19, ft = Wt + At | 0, _r ^= ft << 18 | ft >>> 14, ft = Kt + Yt | 0, Qt ^= ft << 7 | ft >>> 25, ft = Qt + Kt | 0, $t ^= ft << 9 | ft >>> 23, ft = $t + Qt | 0, Yt ^= ft << 13 | ft >>> 19, ft = Yt + $t | 0, Kt ^= ft << 18 | ft >>> 14, ft = Nt + Xt | 0, Et ^= ft << 7 | ft >>> 25, ft = Et + Nt | 0, At ^= ft << 9 | ft >>> 23, ft = At + Et | 0, Xt ^= ft << 13 | ft >>> 19, ft = Xt + At | 0, Nt ^= ft << 18 | ft >>> 14, ft = Dt + Ot | 0, Wt ^= ft << 7 | ft >>> 25, ft = Wt + Dt | 0, qt ^= ft << 9 | ft >>> 23, ft = qt + Wt | 0, Ot ^= ft << 13 | ft >>> 19, ft = Ot + qt | 0, Dt ^= ft << 18 | ft >>> 14, ft = _r + br | 0, pr ^= ft << 7 | ft >>> 25, ft = pr + _r | 0, yr ^= ft << 9 | ft >>> 23, ft = yr + pr | 0, br ^= ft << 13 | ft >>> 19, ft = br + yr | 0, _r ^= ft << 18 | ft >>> 14; Re[0] = Kt >>> 0 & 255, Re[1] = Kt >>> 8 & 255, Re[2] = Kt >>> 16 & 255, Re[3] = Kt >>> 24 & 255, Re[4] = Nt >>> 0 & 255, Re[5] = Nt >>> 8 & 255, Re[6] = Nt >>> 16 & 255, Re[7] = Nt >>> 24 & 255, Re[8] = Dt >>> 0 & 255, Re[9] = Dt >>> 8 & 255, Re[10] = Dt >>> 16 & 255, Re[11] = Dt >>> 24 & 255, Re[12] = _r >>> 0 & 255, Re[13] = _r >>> 8 & 255, Re[14] = _r >>> 16 & 255, Re[15] = _r >>> 24 & 255, Re[16] = Et >>> 0 & 255, Re[17] = Et >>> 8 & 255, Re[18] = Et >>> 16 & 255, Re[19] = Et >>> 24 & 255, Re[20] = At >>> 0 & 255, Re[21] = At >>> 8 & 255, Re[22] = At >>> 16 & 255, Re[23] = At >>> 24 & 255, Re[24] = qt >>> 0 & 255, Re[25] = qt >>> 8 & 255, Re[26] = qt >>> 16 & 255, Re[27] = qt >>> 24 & 255, Re[28] = Ot >>> 0 & 255, Re[29] = Ot >>> 8 & 255, Re[30] = Ot >>> 16 & 255, Re[31] = Ot >>> 24 & 255 } function ue(Re, Pe, qe, be) { se(Re, Pe, qe, be) } function he(Re, Pe, qe, be) { le(Re, Pe, qe, be) } var pe = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]); function ve(Re, Pe, qe, be, Fe, Qe, st) { var rt = new Uint8Array(16), ct = new Uint8Array(64), Lt, It; for (It = 0; It < 16; It++)rt[It] = 0; for (It = 0; It < 8; It++)rt[It] = Qe[It]; for (; Fe >= 64;) { for (ue(ct, rt, st, pe), It = 0; It < 64; It++)Re[Pe + It] = qe[be + It] ^ ct[It]; for (Lt = 1, It = 8; It < 16; It++)Lt = Lt + (rt[It] & 255) | 0, rt[It] = Lt & 255, Lt >>>= 8; Fe -= 64, Pe += 64, be += 64 } if (Fe > 0) for (ue(ct, rt, st, pe), It = 0; It < Fe; It++)Re[Pe + It] = qe[be + It] ^ ct[It]; return 0 } function _e(Re, Pe, qe, be, Fe) { var Qe = new Uint8Array(16), st = new Uint8Array(64), rt, ct; for (ct = 0; ct < 16; ct++)Qe[ct] = 0; for (ct = 0; ct < 8; ct++)Qe[ct] = be[ct]; for (; qe >= 64;) { for (ue(st, Qe, Fe, pe), ct = 0; ct < 64; ct++)Re[Pe + ct] = st[ct]; for (rt = 1, ct = 8; ct < 16; ct++)rt = rt + (Qe[ct] & 255) | 0, Qe[ct] = rt & 255, rt >>>= 8; qe -= 64, Pe += 64 } if (qe > 0) for (ue(st, Qe, Fe, pe), ct = 0; ct < qe; ct++)Re[Pe + ct] = st[ct]; return 0 } function Se(Re, Pe, qe, be, Fe) { var Qe = new Uint8Array(32); he(Qe, be, Fe, pe); for (var st = new Uint8Array(8), rt = 0; rt < 8; rt++)st[rt] = be[rt + 16]; return _e(Re, Pe, qe, st, Qe) } function $e(Re, Pe, qe, be, Fe, Qe, st) { var rt = new Uint8Array(32); he(rt, Qe, st, pe); for (var ct = new Uint8Array(8), Lt = 0; Lt < 8; Lt++)ct[Lt] = Qe[Lt + 16]; return ve(Re, Pe, qe, be, Fe, ct, rt) } var ie = function (Re) { this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0; var Pe, qe, be, Fe, Qe, st, rt, ct; Pe = Re[0] & 255 | (Re[1] & 255) << 8, this.r[0] = Pe & 8191, qe = Re[2] & 255 | (Re[3] & 255) << 8, this.r[1] = (Pe >>> 13 | qe << 3) & 8191, be = Re[4] & 255 | (Re[5] & 255) << 8, this.r[2] = (qe >>> 10 | be << 6) & 7939, Fe = Re[6] & 255 | (Re[7] & 255) << 8, this.r[3] = (be >>> 7 | Fe << 9) & 8191, Qe = Re[8] & 255 | (Re[9] & 255) << 8, this.r[4] = (Fe >>> 4 | Qe << 12) & 255, this.r[5] = Qe >>> 1 & 8190, st = Re[10] & 255 | (Re[11] & 255) << 8, this.r[6] = (Qe >>> 14 | st << 2) & 8191, rt = Re[12] & 255 | (Re[13] & 255) << 8, this.r[7] = (st >>> 11 | rt << 5) & 8065, ct = Re[14] & 255 | (Re[15] & 255) << 8, this.r[8] = (rt >>> 8 | ct << 8) & 8191, this.r[9] = ct >>> 5 & 127, this.pad[0] = Re[16] & 255 | (Re[17] & 255) << 8, this.pad[1] = Re[18] & 255 | (Re[19] & 255) << 8, this.pad[2] = Re[20] & 255 | (Re[21] & 255) << 8, this.pad[3] = Re[22] & 255 | (Re[23] & 255) << 8, this.pad[4] = Re[24] & 255 | (Re[25] & 255) << 8, this.pad[5] = Re[26] & 255 | (Re[27] & 255) << 8, this.pad[6] = Re[28] & 255 | (Re[29] & 255) << 8, this.pad[7] = Re[30] & 255 | (Re[31] & 255) << 8 }; ie.prototype.blocks = function (Re, Pe, qe) { for (var be = this.fin ? 0 : 2048, Fe, Qe, st, rt, ct, Lt, It, lr, jt, Ft, er, ar, nr, ir, Ht, sr, Kt, Qt, $t, Yt = this.h[0], Xt = this.h[1], Nt = this.h[2], Et = this.h[3], At = this.h[4], qt = this.h[5], Ot = this.h[6], Dt = this.h[7], Wt = this.h[8], pr = this.h[9], yr = this.r[0], br = this.r[1], _r = this.r[2], ft = this.r[3], Sr = this.r[4], Mr = this.r[5], Ar = this.r[6], xr = this.r[7], Er = this.r[8], Rr = this.r[9]; qe >= 16;)Fe = Re[Pe + 0] & 255 | (Re[Pe + 1] & 255) << 8, Yt += Fe & 8191, Qe = Re[Pe + 2] & 255 | (Re[Pe + 3] & 255) << 8, Xt += (Fe >>> 13 | Qe << 3) & 8191, st = Re[Pe + 4] & 255 | (Re[Pe + 5] & 255) << 8, Nt += (Qe >>> 10 | st << 6) & 8191, rt = Re[Pe + 6] & 255 | (Re[Pe + 7] & 255) << 8, Et += (st >>> 7 | rt << 9) & 8191, ct = Re[Pe + 8] & 255 | (Re[Pe + 9] & 255) << 8, At += (rt >>> 4 | ct << 12) & 8191, qt += ct >>> 1 & 8191, Lt = Re[Pe + 10] & 255 | (Re[Pe + 11] & 255) << 8, Ot += (ct >>> 14 | Lt << 2) & 8191, It = Re[Pe + 12] & 255 | (Re[Pe + 13] & 255) << 8, Dt += (Lt >>> 11 | It << 5) & 8191, lr = Re[Pe + 14] & 255 | (Re[Pe + 15] & 255) << 8, Wt += (It >>> 8 | lr << 8) & 8191, pr += lr >>> 5 | be, jt = 0, Ft = jt, Ft += Yt * yr, Ft += Xt * (5 * Rr), Ft += Nt * (5 * Er), Ft += Et * (5 * xr), Ft += At * (5 * Ar), jt = Ft >>> 13, Ft &= 8191, Ft += qt * (5 * Mr), Ft += Ot * (5 * Sr), Ft += Dt * (5 * ft), Ft += Wt * (5 * _r), Ft += pr * (5 * br), jt += Ft >>> 13, Ft &= 8191, er = jt, er += Yt * br, er += Xt * yr, er += Nt * (5 * Rr), er += Et * (5 * Er), er += At * (5 * xr), jt = er >>> 13, er &= 8191, er += qt * (5 * Ar), er += Ot * (5 * Mr), er += Dt * (5 * Sr), er += Wt * (5 * ft), er += pr * (5 * _r), jt += er >>> 13, er &= 8191, ar = jt, ar += Yt * _r, ar += Xt * br, ar += Nt * yr, ar += Et * (5 * Rr), ar += At * (5 * Er), jt = ar >>> 13, ar &= 8191, ar += qt * (5 * xr), ar += Ot * (5 * Ar), ar += Dt * (5 * Mr), ar += Wt * (5 * Sr), ar += pr * (5 * ft), jt += ar >>> 13, ar &= 8191, nr = jt, nr += Yt * ft, nr += Xt * _r, nr += Nt * br, nr += Et * yr, nr += At * (5 * Rr), jt = nr >>> 13, nr &= 8191, nr += qt * (5 * Er), nr += Ot * (5 * xr), nr += Dt * (5 * Ar), nr += Wt * (5 * Mr), nr += pr * (5 * Sr), jt += nr >>> 13, nr &= 8191, ir = jt, ir += Yt * Sr, ir += Xt * ft, ir += Nt * _r, ir += Et * br, ir += At * yr, jt = ir >>> 13, ir &= 8191, ir += qt * (5 * Rr), ir += Ot * (5 * Er), ir += Dt * (5 * xr), ir += Wt * (5 * Ar), ir += pr * (5 * Mr), jt += ir >>> 13, ir &= 8191, Ht = jt, Ht += Yt * Mr, Ht += Xt * Sr, Ht += Nt * ft, Ht += Et * _r, Ht += At * br, jt = Ht >>> 13, Ht &= 8191, Ht += qt * yr, Ht += Ot * (5 * Rr), Ht += Dt * (5 * Er), Ht += Wt * (5 * xr), Ht += pr * (5 * Ar), jt += Ht >>> 13, Ht &= 8191, sr = jt, sr += Yt * Ar, sr += Xt * Mr, sr += Nt * Sr, sr += Et * ft, sr += At * _r, jt = sr >>> 13, sr &= 8191, sr += qt * br, sr += Ot * yr, sr += Dt * (5 * Rr), sr += Wt * (5 * Er), sr += pr * (5 * xr), jt += sr >>> 13, sr &= 8191, Kt = jt, Kt += Yt * xr, Kt += Xt * Ar, Kt += Nt * Mr, Kt += Et * Sr, Kt += At * ft, jt = Kt >>> 13, Kt &= 8191, Kt += qt * _r, Kt += Ot * br, Kt += Dt * yr, Kt += Wt * (5 * Rr), Kt += pr * (5 * Er), jt += Kt >>> 13, Kt &= 8191, Qt = jt, Qt += Yt * Er, Qt += Xt * xr, Qt += Nt * Ar, Qt += Et * Mr, Qt += At * Sr, jt = Qt >>> 13, Qt &= 8191, Qt += qt * ft, Qt += Ot * _r, Qt += Dt * br, Qt += Wt * yr, Qt += pr * (5 * Rr), jt += Qt >>> 13, Qt &= 8191, $t = jt, $t += Yt * Rr, $t += Xt * Er, $t += Nt * xr, $t += Et * Ar, $t += At * Mr, jt = $t >>> 13, $t &= 8191, $t += qt * Sr, $t += Ot * ft, $t += Dt * _r, $t += Wt * br, $t += pr * yr, jt += $t >>> 13, $t &= 8191, jt = (jt << 2) + jt | 0, jt = jt + Ft | 0, Ft = jt & 8191, jt = jt >>> 13, er += jt, Yt = Ft, Xt = er, Nt = ar, Et = nr, At = ir, qt = Ht, Ot = sr, Dt = Kt, Wt = Qt, pr = $t, Pe += 16, qe -= 16; this.h[0] = Yt, this.h[1] = Xt, this.h[2] = Nt, this.h[3] = Et, this.h[4] = At, this.h[5] = qt, this.h[6] = Ot, this.h[7] = Dt, this.h[8] = Wt, this.h[9] = pr }, ie.prototype.finish = function (Re, Pe) { var qe = new Uint16Array(10), be, Fe, Qe, st; if (this.leftover) { for (st = this.leftover, this.buffer[st++] = 1; st < 16; st++)this.buffer[st] = 0; this.fin = 1, this.blocks(this.buffer, 0, 16) } for (be = this.h[1] >>> 13, this.h[1] &= 8191, st = 2; st < 10; st++)this.h[st] += be, be = this.h[st] >>> 13, this.h[st] &= 8191; for (this.h[0] += be * 5, be = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += be, be = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += be, qe[0] = this.h[0] + 5, be = qe[0] >>> 13, qe[0] &= 8191, st = 1; st < 10; st++)qe[st] = this.h[st] + be, be = qe[st] >>> 13, qe[st] &= 8191; for (qe[9] -= 8192, Fe = (be ^ 1) - 1, st = 0; st < 10; st++)qe[st] &= Fe; for (Fe = ~Fe, st = 0; st < 10; st++)this.h[st] = this.h[st] & Fe | qe[st]; for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Qe = this.h[0] + this.pad[0], this.h[0] = Qe & 65535, st = 1; st < 8; st++)Qe = (this.h[st] + this.pad[st] | 0) + (Qe >>> 16) | 0, this.h[st] = Qe & 65535; Re[Pe + 0] = this.h[0] >>> 0 & 255, Re[Pe + 1] = this.h[0] >>> 8 & 255, Re[Pe + 2] = this.h[1] >>> 0 & 255, Re[Pe + 3] = this.h[1] >>> 8 & 255, Re[Pe + 4] = this.h[2] >>> 0 & 255, Re[Pe + 5] = this.h[2] >>> 8 & 255, Re[Pe + 6] = this.h[3] >>> 0 & 255, Re[Pe + 7] = this.h[3] >>> 8 & 255, Re[Pe + 8] = this.h[4] >>> 0 & 255, Re[Pe + 9] = this.h[4] >>> 8 & 255, Re[Pe + 10] = this.h[5] >>> 0 & 255, Re[Pe + 11] = this.h[5] >>> 8 & 255, Re[Pe + 12] = this.h[6] >>> 0 & 255, Re[Pe + 13] = this.h[6] >>> 8 & 255, Re[Pe + 14] = this.h[7] >>> 0 & 255, Re[Pe + 15] = this.h[7] >>> 8 & 255 }, ie.prototype.update = function (Re, Pe, qe) { var be, Fe; if (this.leftover) { for (Fe = 16 - this.leftover, Fe > qe && (Fe = qe), be = 0; be < Fe; be++)this.buffer[this.leftover + be] = Re[Pe + be]; if (qe -= Fe, Pe += Fe, this.leftover += Fe, this.leftover < 16) return; this.blocks(this.buffer, 0, 16), this.leftover = 0 } if (qe >= 16 && (Fe = qe - qe % 16, this.blocks(Re, Pe, Fe), Pe += Fe, qe -= Fe), qe) { for (be = 0; be < qe; be++)this.buffer[this.leftover + be] = Re[Pe + be]; this.leftover += qe } }; function g(Re, Pe, qe, be, Fe, Qe) { var st = new ie(Qe); return st.update(qe, be, Fe), st.finish(Re, Pe), 0 } function P(Re, Pe, qe, be, Fe, Qe) { var st = new Uint8Array(16); return g(st, 0, qe, be, Fe, Qe), oe(Re, Pe, st, 0) } function U(Re, Pe, qe, be, Fe) { var Qe; if (qe < 32) return -1; for ($e(Re, 0, Pe, 0, qe, be, Fe), g(Re, 16, Re, 32, qe - 32, Re), Qe = 0; Qe < 16; Qe++)Re[Qe] = 0; return 0 } function K(Re, Pe, qe, be, Fe) { var Qe, st = new Uint8Array(32); if (qe < 32 || (Se(st, 0, 32, be, Fe), P(Pe, 16, Pe, 32, qe - 32, st) !== 0)) return -1; for ($e(Re, 0, Pe, 0, qe, be, Fe), Qe = 0; Qe < 32; Qe++)Re[Qe] = 0; return 0 } function Y(Re, Pe) { var qe; for (qe = 0; qe < 16; qe++)Re[qe] = Pe[qe] | 0 } function te(Re) { var Pe, qe, be = 1; for (Pe = 0; Pe < 16; Pe++)qe = Re[Pe] + be + 65535, be = Math.floor(qe / 65536), Re[Pe] = qe - be * 65536; Re[0] += be - 1 + 37 * (be - 1) } function ee(Re, Pe, qe) { for (var be, Fe = ~(qe - 1), Qe = 0; Qe < 16; Qe++)be = Fe & (Re[Qe] ^ Pe[Qe]), Re[Qe] ^= be, Pe[Qe] ^= be } function G(Re, Pe) { var qe, be, Fe, Qe = u(), st = u(); for (qe = 0; qe < 16; qe++)st[qe] = Pe[qe]; for (te(st), te(st), te(st), be = 0; be < 2; be++) { for (Qe[0] = st[0] - 65517, qe = 1; qe < 15; qe++)Qe[qe] = st[qe] - 65535 - (Qe[qe - 1] >> 16 & 1), Qe[qe - 1] &= 65535; Qe[15] = st[15] - 32767 - (Qe[14] >> 16 & 1), Fe = Qe[15] >> 16 & 1, Qe[14] &= 65535, ee(st, Qe, 1 - Fe) } for (qe = 0; qe < 16; qe++)Re[2 * qe] = st[qe] & 255, Re[2 * qe + 1] = st[qe] >> 8 } function y(Re, Pe) { var qe = new Uint8Array(32), be = new Uint8Array(32); return G(qe, Re), G(be, Pe), ae(qe, 0, be, 0) } function X(Re) { var Pe = new Uint8Array(32); return G(Pe, Re), Pe[0] & 1 } function ce(Re, Pe) { var qe; for (qe = 0; qe < 16; qe++)Re[qe] = Pe[2 * qe] + (Pe[2 * qe + 1] << 8); Re[15] &= 32767 } function me(Re, Pe, qe) { for (var be = 0; be < 16; be++)Re[be] = Pe[be] + qe[be] } function Ae(Re, Pe, qe) { for (var be = 0; be < 16; be++)Re[be] = Pe[be] - qe[be] } function Ie(Re, Pe, qe) { var be, Fe, Qe = 0, st = 0, rt = 0, ct = 0, Lt = 0, It = 0, lr = 0, jt = 0, Ft = 0, er = 0, ar = 0, nr = 0, ir = 0, Ht = 0, sr = 0, Kt = 0, Qt = 0, $t = 0, Yt = 0, Xt = 0, Nt = 0, Et = 0, At = 0, qt = 0, Ot = 0, Dt = 0, Wt = 0, pr = 0, yr = 0, br = 0, _r = 0, ft = qe[0], Sr = qe[1], Mr = qe[2], Ar = qe[3], xr = qe[4], Er = qe[5], Rr = qe[6], Ir = qe[7], dr = qe[8], Br = qe[9], Or = qe[10], Tr = qe[11], $r = qe[12], Hr = qe[13], Gr = qe[14], Vr = qe[15]; be = Pe[0], Qe += be * ft, st += be * Sr, rt += be * Mr, ct += be * Ar, Lt += be * xr, It += be * Er, lr += be * Rr, jt += be * Ir, Ft += be * dr, er += be * Br, ar += be * Or, nr += be * Tr, ir += be * $r, Ht += be * Hr, sr += be * Gr, Kt += be * Vr, be = Pe[1], st += be * ft, rt += be * Sr, ct += be * Mr, Lt += be * Ar, It += be * xr, lr += be * Er, jt += be * Rr, Ft += be * Ir, er += be * dr, ar += be * Br, nr += be * Or, ir += be * Tr, Ht += be * $r, sr += be * Hr, Kt += be * Gr, Qt += be * Vr, be = Pe[2], rt += be * ft, ct += be * Sr, Lt += be * Mr, It += be * Ar, lr += be * xr, jt += be * Er, Ft += be * Rr, er += be * Ir, ar += be * dr, nr += be * Br, ir += be * Or, Ht += be * Tr, sr += be * $r, Kt += be * Hr, Qt += be * Gr, $t += be * Vr, be = Pe[3], ct += be * ft, Lt += be * Sr, It += be * Mr, lr += be * Ar, jt += be * xr, Ft += be * Er, er += be * Rr, ar += be * Ir, nr += be * dr, ir += be * Br, Ht += be * Or, sr += be * Tr, Kt += be * $r, Qt += be * Hr, $t += be * Gr, Yt += be * Vr, be = Pe[4], Lt += be * ft, It += be * Sr, lr += be * Mr, jt += be * Ar, Ft += be * xr, er += be * Er, ar += be * Rr, nr += be * Ir, ir += be * dr, Ht += be * Br, sr += be * Or, Kt += be * Tr, Qt += be * $r, $t += be * Hr, Yt += be * Gr, Xt += be * Vr, be = Pe[5], It += be * ft, lr += be * Sr, jt += be * Mr, Ft += be * Ar, er += be * xr, ar += be * Er, nr += be * Rr, ir += be * Ir, Ht += be * dr, sr += be * Br, Kt += be * Or, Qt += be * Tr, $t += be * $r, Yt += be * Hr, Xt += be * Gr, Nt += be * Vr, be = Pe[6], lr += be * ft, jt += be * Sr, Ft += be * Mr, er += be * Ar, ar += be * xr, nr += be * Er, ir += be * Rr, Ht += be * Ir, sr += be * dr, Kt += be * Br, Qt += be * Or, $t += be * Tr, Yt += be * $r, Xt += be * Hr, Nt += be * Gr, Et += be * Vr, be = Pe[7], jt += be * ft, Ft += be * Sr, er += be * Mr, ar += be * Ar, nr += be * xr, ir += be * Er, Ht += be * Rr, sr += be * Ir, Kt += be * dr, Qt += be * Br, $t += be * Or, Yt += be * Tr, Xt += be * $r, Nt += be * Hr, Et += be * Gr, At += be * Vr, be = Pe[8], Ft += be * ft, er += be * Sr, ar += be * Mr, nr += be * Ar, ir += be * xr, Ht += be * Er, sr += be * Rr, Kt += be * Ir, Qt += be * dr, $t += be * Br, Yt += be * Or, Xt += be * Tr, Nt += be * $r, Et += be * Hr, At += be * Gr, qt += be * Vr, be = Pe[9], er += be * ft, ar += be * Sr, nr += be * Mr, ir += be * Ar, Ht += be * xr, sr += be * Er, Kt += be * Rr, Qt += be * Ir, $t += be * dr, Yt += be * Br, Xt += be * Or, Nt += be * Tr, Et += be * $r, At += be * Hr, qt += be * Gr, Ot += be * Vr, be = Pe[10], ar += be * ft, nr += be * Sr, ir += be * Mr, Ht += be * Ar, sr += be * xr, Kt += be * Er, Qt += be * Rr, $t += be * Ir, Yt += be * dr, Xt += be * Br, Nt += be * Or, Et += be * Tr, At += be * $r, qt += be * Hr, Ot += be * Gr, Dt += be * Vr, be = Pe[11], nr += be * ft, ir += be * Sr, Ht += be * Mr, sr += be * Ar, Kt += be * xr, Qt += be * Er, $t += be * Rr, Yt += be * Ir, Xt += be * dr, Nt += be * Br, Et += be * Or, At += be * Tr, qt += be * $r, Ot += be * Hr, Dt += be * Gr, Wt += be * Vr, be = Pe[12], ir += be * ft, Ht += be * Sr, sr += be * Mr, Kt += be * Ar, Qt += be * xr, $t += be * Er, Yt += be * Rr, Xt += be * Ir, Nt += be * dr, Et += be * Br, At += be * Or, qt += be * Tr, Ot += be * $r, Dt += be * Hr, Wt += be * Gr, pr += be * Vr, be = Pe[13], Ht += be * ft, sr += be * Sr, Kt += be * Mr, Qt += be * Ar, $t += be * xr, Yt += be * Er, Xt += be * Rr, Nt += be * Ir, Et += be * dr, At += be * Br, qt += be * Or, Ot += be * Tr, Dt += be * $r, Wt += be * Hr, pr += be * Gr, yr += be * Vr, be = Pe[14], sr += be * ft, Kt += be * Sr, Qt += be * Mr, $t += be * Ar, Yt += be * xr, Xt += be * Er, Nt += be * Rr, Et += be * Ir, At += be * dr, qt += be * Br, Ot += be * Or, Dt += be * Tr, Wt += be * $r, pr += be * Hr, yr += be * Gr, br += be * Vr, be = Pe[15], Kt += be * ft, Qt += be * Sr, $t += be * Mr, Yt += be * Ar, Xt += be * xr, Nt += be * Er, Et += be * Rr, At += be * Ir, qt += be * dr, Ot += be * Br, Dt += be * Or, Wt += be * Tr, pr += be * $r, yr += be * Hr, br += be * Gr, _r += be * Vr, Qe += 38 * Qt, st += 38 * $t, rt += 38 * Yt, ct += 38 * Xt, Lt += 38 * Nt, It += 38 * Et, lr += 38 * At, jt += 38 * qt, Ft += 38 * Ot, er += 38 * Dt, ar += 38 * Wt, nr += 38 * pr, ir += 38 * yr, Ht += 38 * br, sr += 38 * _r, Fe = 1, be = Qe + Fe + 65535, Fe = Math.floor(be / 65536), Qe = be - Fe * 65536, be = st + Fe + 65535, Fe = Math.floor(be / 65536), st = be - Fe * 65536, be = rt + Fe + 65535, Fe = Math.floor(be / 65536), rt = be - Fe * 65536, be = ct + Fe + 65535, Fe = Math.floor(be / 65536), ct = be - Fe * 65536, be = Lt + Fe + 65535, Fe = Math.floor(be / 65536), Lt = be - Fe * 65536, be = It + Fe + 65535, Fe = Math.floor(be / 65536), It = be - Fe * 65536, be = lr + Fe + 65535, Fe = Math.floor(be / 65536), lr = be - Fe * 65536, be = jt + Fe + 65535, Fe = Math.floor(be / 65536), jt = be - Fe * 65536, be = Ft + Fe + 65535, Fe = Math.floor(be / 65536), Ft = be - Fe * 65536, be = er + Fe + 65535, Fe = Math.floor(be / 65536), er = be - Fe * 65536, be = ar + Fe + 65535, Fe = Math.floor(be / 65536), ar = be - Fe * 65536, be = nr + Fe + 65535, Fe = Math.floor(be / 65536), nr = be - Fe * 65536, be = ir + Fe + 65535, Fe = Math.floor(be / 65536), ir = be - Fe * 65536, be = Ht + Fe + 65535, Fe = Math.floor(be / 65536), Ht = be - Fe * 65536, be = sr + Fe + 65535, Fe = Math.floor(be / 65536), sr = be - Fe * 65536, be = Kt + Fe + 65535, Fe = Math.floor(be / 65536), Kt = be - Fe * 65536, Qe += Fe - 1 + 37 * (Fe - 1), Fe = 1, be = Qe + Fe + 65535, Fe = Math.floor(be / 65536), Qe = be - Fe * 65536, be = st + Fe + 65535, Fe = Math.floor(be / 65536), st = be - Fe * 65536, be = rt + Fe + 65535, Fe = Math.floor(be / 65536), rt = be - Fe * 65536, be = ct + Fe + 65535, Fe = Math.floor(be / 65536), ct = be - Fe * 65536, be = Lt + Fe + 65535, Fe = Math.floor(be / 65536), Lt = be - Fe * 65536, be = It + Fe + 65535, Fe = Math.floor(be / 65536), It = be - Fe * 65536, be = lr + Fe + 65535, Fe = Math.floor(be / 65536), lr = be - Fe * 65536, be = jt + Fe + 65535, Fe = Math.floor(be / 65536), jt = be - Fe * 65536, be = Ft + Fe + 65535, Fe = Math.floor(be / 65536), Ft = be - Fe * 65536, be = er + Fe + 65535, Fe = Math.floor(be / 65536), er = be - Fe * 65536, be = ar + Fe + 65535, Fe = Math.floor(be / 65536), ar = be - Fe * 65536, be = nr + Fe + 65535, Fe = Math.floor(be / 65536), nr = be - Fe * 65536, be = ir + Fe + 65535, Fe = Math.floor(be / 65536), ir = be - Fe * 65536, be = Ht + Fe + 65535, Fe = Math.floor(be / 65536), Ht = be - Fe * 65536, be = sr + Fe + 65535, Fe = Math.floor(be / 65536), sr = be - Fe * 65536, be = Kt + Fe + 65535, Fe = Math.floor(be / 65536), Kt = be - Fe * 65536, Qe += Fe - 1 + 37 * (Fe - 1), Re[0] = Qe, Re[1] = st, Re[2] = rt, Re[3] = ct, Re[4] = Lt, Re[5] = It, Re[6] = lr, Re[7] = jt, Re[8] = Ft, Re[9] = er, Re[10] = ar, Re[11] = nr, Re[12] = ir, Re[13] = Ht, Re[14] = sr, Re[15] = Kt } function Be(Re, Pe) { Ie(Re, Pe, Pe) } function Me(Re, Pe) { var qe = u(), be; for (be = 0; be < 16; be++)qe[be] = Pe[be]; for (be = 253; be >= 0; be--)Be(qe, qe), be !== 2 && be !== 4 && Ie(qe, qe, Pe); for (be = 0; be < 16; be++)Re[be] = qe[be] } function De(Re, Pe) { var qe = u(), be; for (be = 0; be < 16; be++)qe[be] = Pe[be]; for (be = 250; be >= 0; be--)Be(qe, qe), be !== 1 && Ie(qe, qe, Pe); for (be = 0; be < 16; be++)Re[be] = qe[be] } function Ue(Re, Pe, qe) { var be = new Uint8Array(32), Fe = new Float64Array(80), Qe, st, rt = u(), ct = u(), Lt = u(), It = u(), lr = u(), jt = u(); for (st = 0; st < 31; st++)be[st] = Pe[st]; for (be[31] = Pe[31] & 127 | 64, be[0] &= 248, ce(Fe, qe), st = 0; st < 16; st++)ct[st] = Fe[st], It[st] = rt[st] = Lt[st] = 0; for (rt[0] = It[0] = 1, st = 254; st >= 0; --st)Qe = be[st >>> 3] >>> (st & 7) & 1, ee(rt, ct, Qe), ee(Lt, It, Qe), me(lr, rt, Lt), Ae(rt, rt, Lt), me(Lt, ct, It), Ae(ct, ct, It), Be(It, lr), Be(jt, rt), Ie(rt, Lt, rt), Ie(Lt, ct, lr), me(lr, rt, Lt), Ae(rt, rt, Lt), Be(ct, rt), Ae(Lt, It, jt), Ie(rt, Lt, I), me(rt, rt, It), Ie(Lt, Lt, rt), Ie(rt, It, jt), Ie(It, ct, Fe), Be(ct, lr), ee(rt, ct, Qe), ee(Lt, It, Qe); for (st = 0; st < 16; st++)Fe[st + 16] = rt[st], Fe[st + 32] = Lt[st], Fe[st + 48] = ct[st], Fe[st + 64] = It[st]; var Ft = Fe.subarray(32), er = Fe.subarray(16); return Me(Ft, Ft), Ie(er, er, Ft), G(Re, er), 0 } function Ke(Re, Pe) { return Ue(Re, Pe, d) } function Ve(Re, Pe) { return f(Pe, 32), Ke(Re, Pe) } function ke(Re, Pe, qe) { var be = new Uint8Array(32); return Ue(be, qe, Pe), he(Re, p, be, pe) } var Je = U, dt = K; function lt(Re, Pe, qe, be, Fe, Qe) { var st = new Uint8Array(32); return ke(st, Fe, Qe), Je(Re, Pe, qe, be, st) } function ht(Re, Pe, qe, be, Fe, Qe) { var st = new Uint8Array(32); return ke(st, Fe, Qe), dt(Re, Pe, qe, be, st) } var Bt = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; function mt(Re, Pe, qe, be) { for (var Fe = new Int32Array(16), Qe = new Int32Array(16), st, rt, ct, Lt, It, lr, jt, Ft, er, ar, nr, ir, Ht, sr, Kt, Qt, $t, Yt, Xt, Nt, Et, At, qt, Ot, Dt, Wt, pr = Re[0], yr = Re[1], br = Re[2], _r = Re[3], ft = Re[4], Sr = Re[5], Mr = Re[6], Ar = Re[7], xr = Pe[0], Er = Pe[1], Rr = Pe[2], Ir = Pe[3], dr = Pe[4], Br = Pe[5], Or = Pe[6], Tr = Pe[7], $r = 0; be >= 128;) { for (Xt = 0; Xt < 16; Xt++)Nt = 8 * Xt + $r, Fe[Xt] = qe[Nt + 0] << 24 | qe[Nt + 1] << 16 | qe[Nt + 2] << 8 | qe[Nt + 3], Qe[Xt] = qe[Nt + 4] << 24 | qe[Nt + 5] << 16 | qe[Nt + 6] << 8 | qe[Nt + 7]; for (Xt = 0; Xt < 80; Xt++)if (st = pr, rt = yr, ct = br, Lt = _r, It = ft, lr = Sr, jt = Mr, Ft = Ar, er = xr, ar = Er, nr = Rr, ir = Ir, Ht = dr, sr = Br, Kt = Or, Qt = Tr, Et = Ar, At = Tr, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = (ft >>> 14 | dr << 18) ^ (ft >>> 18 | dr << 14) ^ (dr >>> 9 | ft << 23), At = (dr >>> 14 | ft << 18) ^ (dr >>> 18 | ft << 14) ^ (ft >>> 9 | dr << 23), qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Et = ft & Sr ^ ~ft & Mr, At = dr & Br ^ ~dr & Or, qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Et = Bt[Xt * 2], At = Bt[Xt * 2 + 1], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Et = Fe[Xt % 16], At = Qe[Xt % 16], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, $t = Dt & 65535 | Wt << 16, Yt = qt & 65535 | Ot << 16, Et = $t, At = Yt, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = (pr >>> 28 | xr << 4) ^ (xr >>> 2 | pr << 30) ^ (xr >>> 7 | pr << 25), At = (xr >>> 28 | pr << 4) ^ (pr >>> 2 | xr << 30) ^ (pr >>> 7 | xr << 25), qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Et = pr & yr ^ pr & br ^ yr & br, At = xr & Er ^ xr & Rr ^ Er & Rr, qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Ft = Dt & 65535 | Wt << 16, Qt = qt & 65535 | Ot << 16, Et = Lt, At = ir, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = $t, At = Yt, qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Lt = Dt & 65535 | Wt << 16, ir = qt & 65535 | Ot << 16, yr = st, br = rt, _r = ct, ft = Lt, Sr = It, Mr = lr, Ar = jt, pr = Ft, Er = er, Rr = ar, Ir = nr, dr = ir, Br = Ht, Or = sr, Tr = Kt, xr = Qt, Xt % 16 === 15) for (Nt = 0; Nt < 16; Nt++)Et = Fe[Nt], At = Qe[Nt], qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Fe[(Nt + 9) % 16], At = Qe[(Nt + 9) % 16], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, $t = Fe[(Nt + 1) % 16], Yt = Qe[(Nt + 1) % 16], Et = ($t >>> 1 | Yt << 31) ^ ($t >>> 8 | Yt << 24) ^ $t >>> 7, At = (Yt >>> 1 | $t << 31) ^ (Yt >>> 8 | $t << 24) ^ (Yt >>> 7 | $t << 25), qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, $t = Fe[(Nt + 14) % 16], Yt = Qe[(Nt + 14) % 16], Et = ($t >>> 19 | Yt << 13) ^ (Yt >>> 29 | $t << 3) ^ $t >>> 6, At = (Yt >>> 19 | $t << 13) ^ ($t >>> 29 | Yt << 3) ^ (Yt >>> 6 | $t << 26), qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Fe[Nt] = Dt & 65535 | Wt << 16, Qe[Nt] = qt & 65535 | Ot << 16; Et = pr, At = xr, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[0], At = Pe[0], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[0] = pr = Dt & 65535 | Wt << 16, Pe[0] = xr = qt & 65535 | Ot << 16, Et = yr, At = Er, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[1], At = Pe[1], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[1] = yr = Dt & 65535 | Wt << 16, Pe[1] = Er = qt & 65535 | Ot << 16, Et = br, At = Rr, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[2], At = Pe[2], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[2] = br = Dt & 65535 | Wt << 16, Pe[2] = Rr = qt & 65535 | Ot << 16, Et = _r, At = Ir, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[3], At = Pe[3], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[3] = _r = Dt & 65535 | Wt << 16, Pe[3] = Ir = qt & 65535 | Ot << 16, Et = ft, At = dr, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[4], At = Pe[4], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[4] = ft = Dt & 65535 | Wt << 16, Pe[4] = dr = qt & 65535 | Ot << 16, Et = Sr, At = Br, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[5], At = Pe[5], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[5] = Sr = Dt & 65535 | Wt << 16, Pe[5] = Br = qt & 65535 | Ot << 16, Et = Mr, At = Or, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[6], At = Pe[6], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[6] = Mr = Dt & 65535 | Wt << 16, Pe[6] = Or = qt & 65535 | Ot << 16, Et = Ar, At = Tr, qt = At & 65535, Ot = At >>> 16, Dt = Et & 65535, Wt = Et >>> 16, Et = Re[7], At = Pe[7], qt += At & 65535, Ot += At >>> 16, Dt += Et & 65535, Wt += Et >>> 16, Ot += qt >>> 16, Dt += Ot >>> 16, Wt += Dt >>> 16, Re[7] = Ar = Dt & 65535 | Wt << 16, Pe[7] = Tr = qt & 65535 | Ot << 16, $r += 128, be -= 128 } return be } function et(Re, Pe, qe) { var be = new Int32Array(8), Fe = new Int32Array(8), Qe = new Uint8Array(256), st, rt = qe; for (be[0] = 1779033703, be[1] = 3144134277, be[2] = 1013904242, be[3] = 2773480762, be[4] = 1359893119, be[5] = 2600822924, be[6] = 528734635, be[7] = 1541459225, Fe[0] = 4089235720, Fe[1] = 2227873595, Fe[2] = 4271175723, Fe[3] = 1595750129, Fe[4] = 2917565137, Fe[5] = 725511199, Fe[6] = 4215389547, Fe[7] = 327033209, mt(be, Fe, Pe, qe), qe %= 128, st = 0; st < qe; st++)Qe[st] = Pe[rt - qe + st]; for (Qe[qe] = 128, qe = 256 - 128 * (qe < 112 ? 1 : 0), Qe[qe - 9] = 0, re(Qe, qe - 8, rt / 536870912 | 0, rt << 3), mt(be, Fe, Qe, qe), st = 0; st < 8; st++)re(Re, 8 * st, be[st], Fe[st]); return 0 } function Gt(Re, Pe) { var qe = u(), be = u(), Fe = u(), Qe = u(), st = u(), rt = u(), ct = u(), Lt = u(), It = u(); Ae(qe, Re[1], Re[0]), Ae(It, Pe[1], Pe[0]), Ie(qe, qe, It), me(be, Re[0], Re[1]), me(It, Pe[0], Pe[1]), Ie(be, be, It), Ie(Fe, Re[3], Pe[3]), Ie(Fe, Fe, B), Ie(Qe, Re[2], Pe[2]), me(Qe, Qe, Qe), Ae(st, be, qe), Ae(rt, Qe, Fe), me(ct, Qe, Fe), me(Lt, be, qe), Ie(Re[0], st, rt), Ie(Re[1], Lt, ct), Ie(Re[2], ct, rt), Ie(Re[3], st, Lt) } function pt(Re, Pe, qe) { var be; for (be = 0; be < 4; be++)ee(Re[be], Pe[be], qe) } function _t(Re, Pe) { var qe = u(), be = u(), Fe = u(); Me(Fe, Pe[2]), Ie(qe, Pe[0], Fe), Ie(be, Pe[1], Fe), G(Re, be), Re[31] ^= X(qe) << 7 } function zt(Re, Pe, qe) { var be, Fe; for (Y(Re[0], m), Y(Re[1], v), Y(Re[2], v), Y(Re[3], m), Fe = 255; Fe >= 0; --Fe)be = qe[Fe / 8 | 0] >> (Fe & 7) & 1, pt(Re, Pe, be), Gt(Pe, Re), Gt(Re, Re), pt(Re, Pe, be) } function bt(Re, Pe) { var qe = [u(), u(), u(), u()]; Y(qe[0], W), Y(qe[1], Z), Y(qe[2], v), Ie(qe[3], W, Z), zt(Re, qe, Pe) } function We(Re, Pe, qe) { var be = new Uint8Array(64), Fe = [u(), u(), u(), u()], Qe; for (qe || f(Pe, 32), et(be, Pe, 32), be[0] &= 248, be[31] &= 127, be[31] |= 64, bt(Fe, be), _t(Re, Fe), Qe = 0; Qe < 32; Qe++)Pe[Qe + 32] = Re[Qe]; return 0 } var Ge = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]); function ze(Re, Pe) { var qe, be, Fe, Qe; for (be = 63; be >= 32; --be) { for (qe = 0, Fe = be - 32, Qe = be - 12; Fe < Qe; ++Fe)Pe[Fe] += qe - 16 * Pe[be] * Ge[Fe - (be - 32)], qe = Math.floor((Pe[Fe] + 128) / 256), Pe[Fe] -= qe * 256; Pe[Fe] += qe, Pe[be] = 0 } for (qe = 0, Fe = 0; Fe < 32; Fe++)Pe[Fe] += qe - (Pe[31] >> 4) * Ge[Fe], qe = Pe[Fe] >> 8, Pe[Fe] &= 255; for (Fe = 0; Fe < 32; Fe++)Pe[Fe] -= qe * Ge[Fe]; for (be = 0; be < 32; be++)Pe[be + 1] += Pe[be] >> 8, Re[be] = Pe[be] & 255 } function Ze(Re) { var Pe = new Float64Array(64), qe; for (qe = 0; qe < 64; qe++)Pe[qe] = Re[qe]; for (qe = 0; qe < 64; qe++)Re[qe] = 0; ze(Re, Pe) } function ut(Re, Pe, qe, be) { var Fe = new Uint8Array(64), Qe = new Uint8Array(64), st = new Uint8Array(64), rt, ct, Lt = new Float64Array(64), It = [u(), u(), u(), u()]; et(Fe, be, 32), Fe[0] &= 248, Fe[31] &= 127, Fe[31] |= 64; var lr = qe + 64; for (rt = 0; rt < qe; rt++)Re[64 + rt] = Pe[rt]; for (rt = 0; rt < 32; rt++)Re[32 + rt] = Fe[32 + rt]; for (et(st, Re.subarray(32), qe + 32), Ze(st), bt(It, st), _t(Re, It), rt = 32; rt < 64; rt++)Re[rt] = be[rt]; for (et(Qe, Re, qe + 64), Ze(Qe), rt = 0; rt < 64; rt++)Lt[rt] = 0; for (rt = 0; rt < 32; rt++)Lt[rt] = st[rt]; for (rt = 0; rt < 32; rt++)for (ct = 0; ct < 32; ct++)Lt[rt + ct] += Qe[rt] * Fe[ct]; return ze(Re.subarray(32), Lt), lr } function ye(Re, Pe) { var qe = u(), be = u(), Fe = u(), Qe = u(), st = u(), rt = u(), ct = u(); return Y(Re[2], v), ce(Re[1], Pe), Be(Fe, Re[1]), Ie(Qe, Fe, F), Ae(Fe, Fe, Re[2]), me(Qe, Re[2], Qe), Be(st, Qe), Be(rt, st), Ie(ct, rt, st), Ie(qe, ct, Fe), Ie(qe, qe, Qe), De(qe, qe), Ie(qe, qe, Fe), Ie(qe, qe, Qe), Ie(qe, qe, Qe), Ie(Re[0], qe, Qe), Be(be, Re[0]), Ie(be, be, Qe), y(be, Fe) && Ie(Re[0], Re[0], Q), Be(be, Re[0]), Ie(be, be, Qe), y(be, Fe) ? -1 : (X(Re[0]) === Pe[31] >> 7 && Ae(Re[0], m, Re[0]), Ie(Re[3], Re[0], Re[1]), 0) } function ge(Re, Pe, qe, be) { var Fe, Qe = new Uint8Array(32), st = new Uint8Array(64), rt = [u(), u(), u(), u()], ct = [u(), u(), u(), u()]; if (qe < 64 || ye(ct, be)) return -1; for (Fe = 0; Fe < qe; Fe++)Re[Fe] = Pe[Fe]; for (Fe = 0; Fe < 32; Fe++)Re[Fe + 32] = be[Fe]; if (et(st, Re, qe), Ze(st), zt(rt, ct, st), bt(ct, Pe.subarray(32)), Gt(rt, ct), _t(Qe, rt), qe -= 64, ae(Pe, 0, Qe, 0)) { for (Fe = 0; Fe < qe; Fe++)Re[Fe] = 0; return -1 } for (Fe = 0; Fe < qe; Fe++)Re[Fe] = Pe[Fe + 64]; return qe } var Ee = 32, Oe = 24, je = 32, nt = 16, Xe = 32, it = 32, Tt = 32, tt = 32, yt = 32, kt = Oe, wt = je, Mt = nt, tr = 64, St = 32, gt = 64, rr = 32, Le = 64; l.lowlevel = { crypto_core_hsalsa20: he, crypto_stream_xor: $e, crypto_stream: Se, crypto_stream_salsa20_xor: ve, crypto_stream_salsa20: _e, crypto_onetimeauth: g, crypto_onetimeauth_verify: P, crypto_verify_16: oe, crypto_verify_32: ae, crypto_secretbox: U, crypto_secretbox_open: K, crypto_scalarmult: Ue, crypto_scalarmult_base: Ke, crypto_box_beforenm: ke, crypto_box_afternm: Je, crypto_box: lt, crypto_box_open: ht, crypto_box_keypair: Ve, crypto_hash: et, crypto_sign: ut, crypto_sign_keypair: We, crypto_sign_open: ge, crypto_secretbox_KEYBYTES: Ee, crypto_secretbox_NONCEBYTES: Oe, crypto_secretbox_ZEROBYTES: je, crypto_secretbox_BOXZEROBYTES: nt, crypto_scalarmult_BYTES: Xe, crypto_scalarmult_SCALARBYTES: it, crypto_box_PUBLICKEYBYTES: Tt, crypto_box_SECRETKEYBYTES: tt, crypto_box_BEFORENMBYTES: yt, crypto_box_NONCEBYTES: kt, crypto_box_ZEROBYTES: wt, crypto_box_BOXZEROBYTES: Mt, crypto_sign_BYTES: tr, crypto_sign_PUBLICKEYBYTES: St, crypto_sign_SECRETKEYBYTES: gt, crypto_sign_SEEDBYTES: rr, crypto_hash_BYTES: Le, gf: u, D: F, L: Ge, pack25519: G, unpack25519: ce, M: Ie, A: me, S: Be, Z: Ae, pow2523: De, add: Gt, set25519: Y, modL: ze, scalarmult: zt, scalarbase: bt }; function xe(Re, Pe) { if (Re.length !== Ee) throw new Error("bad key size"); if (Pe.length !== Oe) throw new Error("bad nonce size") } function Ce(Re, Pe) { if (Re.length !== Tt) throw new Error("bad public key size"); if (Pe.length !== tt) throw new Error("bad secret key size") } function Ne() { for (var Re = 0; Re < arguments.length; Re++)if (!(arguments[Re] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array") } function Ye(Re) { for (var Pe = 0; Pe < Re.length; Pe++)Re[Pe] = 0 } l.randomBytes = function (Re) { var Pe = new Uint8Array(Re); return f(Pe, Re), Pe }, l.secretbox = function (Re, Pe, qe) { Ne(Re, Pe, qe), xe(qe, Pe); for (var be = new Uint8Array(je + Re.length), Fe = new Uint8Array(be.length), Qe = 0; Qe < Re.length; Qe++)be[Qe + je] = Re[Qe]; return U(Fe, be, be.length, Pe, qe), Fe.subarray(nt) }, l.secretbox.open = function (Re, Pe, qe) { Ne(Re, Pe, qe), xe(qe, Pe); for (var be = new Uint8Array(nt + Re.length), Fe = new Uint8Array(be.length), Qe = 0; Qe < Re.length; Qe++)be[Qe + nt] = Re[Qe]; return be.length < 32 || K(Fe, be, be.length, Pe, qe) !== 0 ? null : Fe.subarray(je) }, l.secretbox.keyLength = Ee, l.secretbox.nonceLength = Oe, l.secretbox.overheadLength = nt, l.scalarMult = function (Re, Pe) { if (Ne(Re, Pe), Re.length !== it) throw new Error("bad n size"); if (Pe.length !== Xe) throw new Error("bad p size"); var qe = new Uint8Array(Xe); return Ue(qe, Re, Pe), qe }, l.scalarMult.base = function (Re) { if (Ne(Re), Re.length !== it) throw new Error("bad n size"); var Pe = new Uint8Array(Xe); return Ke(Pe, Re), Pe }, l.scalarMult.scalarLength = it, l.scalarMult.groupElementLength = Xe, l.box = function (Re, Pe, qe, be) { var Fe = l.box.before(qe, be); return l.secretbox(Re, Pe, Fe) }, l.box.before = function (Re, Pe) { Ne(Re, Pe), Ce(Re, Pe); var qe = new Uint8Array(yt); return ke(qe, Re, Pe), qe }, l.box.after = l.secretbox, l.box.open = function (Re, Pe, qe, be) { var Fe = l.box.before(qe, be); return l.secretbox.open(Re, Pe, Fe) }, l.box.open.after = l.secretbox.open, l.box.keyPair = function () { var Re = new Uint8Array(Tt), Pe = new Uint8Array(tt); return Ve(Re, Pe), { publicKey: Re, secretKey: Pe } }, l.box.keyPair.fromSecretKey = function (Re) { if (Ne(Re), Re.length !== tt) throw new Error("bad secret key size"); var Pe = new Uint8Array(Tt); return Ke(Pe, Re), { publicKey: Pe, secretKey: new Uint8Array(Re) } }, l.box.publicKeyLength = Tt, l.box.secretKeyLength = tt, l.box.sharedKeyLength = yt, l.box.nonceLength = kt, l.box.overheadLength = l.secretbox.overheadLength, l.sign = function (Re, Pe) { if (Ne(Re, Pe), Pe.length !== gt) throw new Error("bad secret key size"); var qe = new Uint8Array(tr + Re.length); return ut(qe, Re, Re.length, Pe), qe }, l.sign.open = function (Re, Pe) { if (Ne(Re, Pe), Pe.length !== St) throw new Error("bad public key size"); var qe = new Uint8Array(Re.length), be = ge(qe, Re, Re.length, Pe); if (be < 0) return null; for (var Fe = new Uint8Array(be), Qe = 0; Qe < Fe.length; Qe++)Fe[Qe] = qe[Qe]; return Fe }, l.sign.detached = function (Re, Pe) { for (var qe = l.sign(Re, Pe), be = new Uint8Array(tr), Fe = 0; Fe < be.length; Fe++)be[Fe] = qe[Fe]; return be }, l.sign.detached.verify = function (Re, Pe, qe) { if (Ne(Re, Pe, qe), Pe.length !== tr) throw new Error("bad signature size"); if (qe.length !== St) throw new Error("bad public key size"); var be = new Uint8Array(tr + Re.length), Fe = new Uint8Array(tr + Re.length), Qe; for (Qe = 0; Qe < tr; Qe++)be[Qe] = Pe[Qe]; for (Qe = 0; Qe < Re.length; Qe++)be[Qe + tr] = Re[Qe]; return ge(Fe, be, be.length, qe) >= 0 }, l.sign.keyPair = function () { var Re = new Uint8Array(St), Pe = new Uint8Array(gt); return We(Re, Pe), { publicKey: Re, secretKey: Pe } }, l.sign.keyPair.fromSecretKey = function (Re) { if (Ne(Re), Re.length !== gt) throw new Error("bad secret key size"); for (var Pe = new Uint8Array(St), qe = 0; qe < Pe.length; qe++)Pe[qe] = Re[32 + qe]; return { publicKey: Pe, secretKey: new Uint8Array(Re) } }, l.sign.keyPair.fromSeed = function (Re) { if (Ne(Re), Re.length !== rr) throw new Error("bad seed size"); for (var Pe = new Uint8Array(St), qe = new Uint8Array(gt), be = 0; be < 32; be++)qe[be] = Re[be]; return We(Pe, qe, !0), { publicKey: Pe, secretKey: qe } }, l.sign.publicKeyLength = St, l.sign.secretKeyLength = gt, l.sign.seedLength = rr, l.sign.signatureLength = tr, l.hash = function (Re) { Ne(Re); var Pe = new Uint8Array(Le); return et(Pe, Re, Re.length), Pe }, l.hash.hashLength = Le, l.verify = function (Re, Pe) { return Ne(Re, Pe), Re.length === 0 || Pe.length === 0 || Re.length !== Pe.length ? !1 : ne(Re, 0, Pe, 0, Re.length) === 0 }, l.setPRNG = function (Re) { f = Re }, function () { var Re = typeof self < "u" ? self.crypto || self.msCrypto : null; if (Re && Re.getRandomValues) { var Pe = 65536; l.setPRNG(function (qe, be) { var Fe, Qe = new Uint8Array(be); for (Fe = 0; Fe < be; Fe += Pe)Re.getRandomValues(Qe.subarray(Fe, Fe + Math.min(be - Fe, Pe))); for (Fe = 0; Fe < be; Fe++)qe[Fe] = Qe[Fe]; Ye(Qe) }) } else typeof commonjsRequire < "u" && (Re = requireCryptoBrowserify(), Re && Re.randomBytes && l.setPRNG(function (qe, be) { var Fe, Qe = Re.randomBytes(be); for (Fe = 0; Fe < be; Fe++)qe[Fe] = Qe[Fe]; Ye(Qe) })) }() })(o.exports ? o.exports : self.nacl = self.nacl || {}) }(naclFast)), naclFast.exports } var binary = {}, hasRequiredBinary; function requireBinary() { if (hasRequiredBinary) return binary; hasRequiredBinary = 1, Object.defineProperty(binary, "__esModule", { value: !0 }), binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0; function o(f, p, d) { for (; f.length < d;)f = p + f; return f } binary.lpad = o; function l(f) { let p = ""; for (let d = 0; d < f.length; d++) { let m = f.at(d); p += o(m.toString(2), "0", 8) } return p } binary.bytesToBits = l; function u(f) { if (f.length % 8 !== 0) throw Error("Uneven bits"); let p = []; for (; f.length > 0;)p.push(parseInt(f.slice(0, 8), 2)), f = f.slice(8); return Buffer.from(p) } return binary.bitsToBytes = u, binary } var wordlist = {}, hasRequiredWordlist; function requireWordlist() { if (hasRequiredWordlist) return wordlist; hasRequiredWordlist = 1, Object.defineProperty(wordlist, "__esModule", { value: !0 }), wordlist.wordlist = void 0; const o = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"]; return wordlist.wordlist = o, wordlist } var hasRequiredMnemonic; function requireMnemonic() { if (hasRequiredMnemonic) return mnemonic; hasRequiredMnemonic = 1; var o = mnemonic && mnemonic.__importDefault || function (ve) { return ve && ve.__esModule ? ve : { default: ve } }; Object.defineProperty(mnemonic, "__esModule", { value: !0 }), mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0; const l = o(requireNaclFast()), u = requireGetSecureRandom(), f = requireHmac_sha512(), p = requirePbkdf2_sha512(), d = requireBinary(), m = requireWordlist(), v = 1e5; async function I(ve) { const _e = await Z(ve); return await W(_e) && !await B(_e) } function F(ve) { return ve.map(_e => _e.toLowerCase().trim()) } async function B(ve) { return (await (0, p.pbkdf2_sha512)(ve, "TON seed version", Math.max(1, Math.floor(v / 256)), 64))[0] == 0 } async function W(ve) { return (await (0, p.pbkdf2_sha512)(ve, "TON fast seed version", 1, 64))[0] == 1 } async function Z(ve, _e) { return await (0, f.hmac_sha512)(ve.join(" "), _e && _e.length > 0 ? _e : "") } mnemonic.mnemonicToEntropy = Z; async function Q(ve, _e, Se) { const $e = await Z(ve, Se); return await (0, p.pbkdf2_sha512)($e, _e, v, 64) } mnemonic.mnemonicToSeed = Q; async function re(ve, _e) { ve = F(ve); const Se = await Q(ve, "TON default seed", _e); let $e = l.default.sign.keyPair.fromSeed(Se.slice(0, 32)); return { publicKey: Buffer.from($e.publicKey), secretKey: Buffer.from($e.secretKey) } } mnemonic.mnemonicToPrivateKey = re; async function ne(ve, _e) { let $e = (await re(ve, _e)).secretKey.slice(0, 32); const ie = l.default.sign.keyPair.fromSeed($e); return { publicKey: Buffer.from(ie.publicKey), secretKey: Buffer.from(ie.secretKey) } } mnemonic.mnemonicToWalletKey = ne; async function oe(ve, _e) { return ve = F(ve), await Q(ve, "TON HD Keys seed", _e) } mnemonic.mnemonicToHDSeed = oe; async function ae(ve, _e) { ve = F(ve); for (let Se of ve) if (m.wordlist.indexOf(Se) < 0) return !1; return _e && _e.length > 0 && !await I(ve) ? !1 : await B(await Z(ve, _e)) } mnemonic.mnemonicValidate = ae; async function se(ve = 24, _e) { let Se = []; for (; ;) { Se = []; for (let $e = 0; $e < ve; $e++) { let ie = await (0, u.getSecureRandomNumber)(0, m.wordlist.length); Se.push(m.wordlist[ie]) } if (!(_e && _e.length > 0 && !await I(Se)) && await B(await Z(Se, _e))) break } return Se } mnemonic.mnemonicNew = se; function le(ve, _e) { let Se = (0, d.bytesToBits)(ve), $e = []; for (let ie = 0; ie < _e; ie++) { let g = Se.slice(ie * 11, ie * 11 + 11); $e.push(parseInt(g, 2)) } return $e } mnemonic.bytesToMnemonicIndexes = le; function ue(ve, _e) { let Se = le(ve, _e), $e = []; for (let ie of Se) $e.push(m.wordlist[ie]); return $e } mnemonic.bytesToMnemonics = ue; function he(ve) { let _e = ""; for (let Se of ve) { if (!Number.isSafeInteger(Se) || Se < 0 || Se >= 2028) throw Error("Invalid input"); _e += (0, d.lpad)(Se.toString(2), "0", 11) } for (; _e.length % 8 !== 0;)_e = _e + "0"; return (0, d.bitsToBytes)(_e) } mnemonic.mnemonicIndexesToBytes = he; async function pe(ve, _e = 24, Se) { const $e = Math.ceil(_e * 11 / 8); let ie = ve; for (; ;) { let g = await (0, p.pbkdf2_sha512)(ie, "TON mnemonic seed", Math.max(1, Math.floor(v / 256)), $e), P = ue(g, _e); if (await ae(P, Se)) return P; ie = g } } return mnemonic.mnemonicFromRandomSeed = pe, mnemonic } var nacl = {}, hasRequiredNacl; function requireNacl() { if (hasRequiredNacl) return nacl; hasRequiredNacl = 1; var o = nacl && nacl.__importDefault || function (I) { return I && I.__esModule ? I : { default: I } }; Object.defineProperty(nacl, "__esModule", { value: !0 }), nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0; const l = o(requireNaclFast()); function u(I) { let F = l.default.sign.keyPair.fromSecretKey(new Uint8Array(I)); return { publicKey: Buffer.from(F.publicKey), secretKey: Buffer.from(F.secretKey) } } nacl.keyPairFromSecretKey = u; function f(I) { let F = l.default.sign.keyPair.fromSeed(new Uint8Array(I)); return { publicKey: Buffer.from(F.publicKey), secretKey: Buffer.from(F.secretKey) } } nacl.keyPairFromSeed = f; function p(I, F) { return Buffer.from(l.default.sign.detached(new Uint8Array(I), new Uint8Array(F))) } nacl.sign = p; function d(I, F, B) { return l.default.sign.detached.verify(new Uint8Array(I), new Uint8Array(F), new Uint8Array(B)) } nacl.signVerify = d; function m(I, F, B) { return Buffer.from(l.default.secretbox(I, F, B)) } nacl.sealBox = m; function v(I, F, B) { let W = l.default.secretbox.open(I, F, B); return W ? Buffer.from(W) : null } return nacl.openBox = v, nacl } var ed25519 = {}, hasRequiredEd25519; function requireEd25519() { if (hasRequiredEd25519) return ed25519; hasRequiredEd25519 = 1, Object.defineProperty(ed25519, "__esModule", { value: !0 }), ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0; const o = requireHmac_sha512(), l = "ed25519 seed", u = 2147483648; async function f(m) { const v = await (0, o.hmac_sha512)(l, m), I = v.slice(0, 32), F = v.slice(32); return { key: I, chainCode: F } } ed25519.getED25519MasterKeyFromSeed = f; async function p(m, v) { if (v >= u) throw Error("Key index must be less than offset"); const I = Buffer.alloc(4); I.writeUInt32BE(v + u, 0); const F = Buffer.concat([Buffer.alloc(1, 0), m.key, I]), B = await (0, o.hmac_sha512)(m.chainCode, F), W = B.slice(0, 32), Z = B.slice(32); return { key: W, chainCode: Z } } ed25519.deriveED25519HardenedKey = p; async function d(m, v) { let I = await f(m), F = [...v]; for (; F.length > 0;) { let B = F[0]; F = F.slice(1), I = await p(I, B) } return I.key } return ed25519.deriveEd25519Path = d, ed25519 } var symmetric = {}, hasRequiredSymmetric; function requireSymmetric() { if (hasRequiredSymmetric) return symmetric; hasRequiredSymmetric = 1, Object.defineProperty(symmetric, "__esModule", { value: !0 }), symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0; const o = requireHmac_sha512(), l = "Symmetric key seed"; async function u(d) { const m = await (0, o.hmac_sha512)(l, d), v = m.slice(32), I = m.slice(0, 32); return { key: v, chainCode: I } } symmetric.getSymmetricMasterKeyFromSeed = u; async function f(d, m) { const v = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(m)]), I = await (0, o.hmac_sha512)(d.chainCode, v), F = I.slice(32), B = I.slice(0, 32); return { key: F, chainCode: B } } symmetric.deriveSymmetricHardenedKey = f; async function p(d, m) { let v = await u(d), I = [...m]; for (; I.length > 0;) { let F = I[0]; I = I.slice(1), v = await f(v, F) } return v.key } return symmetric.deriveSymmetricPath = p, symmetric } var mnemonics = {}, hasRequiredMnemonics; function requireMnemonics() { if (hasRequiredMnemonics) return mnemonics; hasRequiredMnemonics = 1, Object.defineProperty(mnemonics, "__esModule", { value: !0 }), mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0; const o = requireMnemonic(), l = requireHmac_sha512(), u = 2147483648, f = "TON Mnemonics HD seed"; async function p(v) { const I = await (0, l.hmac_sha512)(f, v), F = I.slice(0, 32), B = I.slice(32); return { key: F, chainCode: B } } mnemonics.getMnemonicsMasterKeyFromSeed = p; async function d(v, I) { if (I >= u) throw Error("Key index must be less than offset"); const F = Buffer.alloc(4); F.writeUInt32BE(I + u, 0); const B = Buffer.concat([Buffer.alloc(1, 0), v.key, F]), W = await (0, l.hmac_sha512)(v.chainCode, B), Z = W.slice(0, 32), Q = W.slice(32); return { key: Z, chainCode: Q } } mnemonics.deriveMnemonicHardenedKey = d; async function m(v, I, F = 24, B) { let W = await p(v), Z = [...I]; for (; Z.length > 0;) { let Q = Z[0]; Z = Z.slice(1), W = await d(W, Q) } return await (0, o.mnemonicFromRandomSeed)(W.key, F, B) } return mnemonics.deriveMnemonicsPath = m, mnemonics } var hasRequiredDist$1; function requireDist$1() { return hasRequiredDist$1 || (hasRequiredDist$1 = 1, function (o) { Object.defineProperty(o, "__esModule", { value: !0 }), o.getMnemonicsMasterKeyFromSeed = o.deriveMnemonicHardenedKey = o.deriveMnemonicsPath = o.deriveSymmetricPath = o.deriveSymmetricHardenedKey = o.getSymmetricMasterKeyFromSeed = o.deriveEd25519Path = o.deriveED25519HardenedKey = o.getED25519MasterKeyFromSeed = o.signVerify = o.sign = o.keyPairFromSecretKey = o.keyPairFromSeed = o.openBox = o.sealBox = o.mnemonicWordList = o.mnemonicToHDSeed = o.mnemonicToSeed = o.mnemonicToWalletKey = o.mnemonicToPrivateKey = o.mnemonicValidate = o.mnemonicNew = o.newSecurePassphrase = o.newSecureWords = o.getSecureRandomNumber = o.getSecureRandomWords = o.getSecureRandomBytes = o.hmac_sha512 = o.pbkdf2_sha512 = o.sha512_sync = o.sha512 = o.sha256_sync = o.sha256 = void 0; var l = requireSha256$1(); Object.defineProperty(o, "sha256", { enumerable: !0, get: function () { return l.sha256 } }), Object.defineProperty(o, "sha256_sync", { enumerable: !0, get: function () { return l.sha256_sync } }); var u = requireSha512$1(); Object.defineProperty(o, "sha512", { enumerable: !0, get: function () { return u.sha512 } }), Object.defineProperty(o, "sha512_sync", { enumerable: !0, get: function () { return u.sha512_sync } }); var f = requirePbkdf2_sha512(); Object.defineProperty(o, "pbkdf2_sha512", { enumerable: !0, get: function () { return f.pbkdf2_sha512 } }); var p = requireHmac_sha512(); Object.defineProperty(o, "hmac_sha512", { enumerable: !0, get: function () { return p.hmac_sha512 } }); var d = requireGetSecureRandom(); Object.defineProperty(o, "getSecureRandomBytes", { enumerable: !0, get: function () { return d.getSecureRandomBytes } }), Object.defineProperty(o, "getSecureRandomWords", { enumerable: !0, get: function () { return d.getSecureRandomWords } }), Object.defineProperty(o, "getSecureRandomNumber", { enumerable: !0, get: function () { return d.getSecureRandomNumber } }); var m = requireNewSecureWords(); Object.defineProperty(o, "newSecureWords", { enumerable: !0, get: function () { return m.newSecureWords } }); var v = requireNewSecurePassphrase(); Object.defineProperty(o, "newSecurePassphrase", { enumerable: !0, get: function () { return v.newSecurePassphrase } }); var I = requireMnemonic(); Object.defineProperty(o, "mnemonicNew", { enumerable: !0, get: function () { return I.mnemonicNew } }), Object.defineProperty(o, "mnemonicValidate", { enumerable: !0, get: function () { return I.mnemonicValidate } }), Object.defineProperty(o, "mnemonicToPrivateKey", { enumerable: !0, get: function () { return I.mnemonicToPrivateKey } }), Object.defineProperty(o, "mnemonicToWalletKey", { enumerable: !0, get: function () { return I.mnemonicToWalletKey } }), Object.defineProperty(o, "mnemonicToSeed", { enumerable: !0, get: function () { return I.mnemonicToSeed } }), Object.defineProperty(o, "mnemonicToHDSeed", { enumerable: !0, get: function () { return I.mnemonicToHDSeed } }); var F = requireWordlist(); Object.defineProperty(o, "mnemonicWordList", { enumerable: !0, get: function () { return F.wordlist } }); var B = requireNacl(); Object.defineProperty(o, "sealBox", { enumerable: !0, get: function () { return B.sealBox } }), Object.defineProperty(o, "openBox", { enumerable: !0, get: function () { return B.openBox } }); var W = requireNacl(); Object.defineProperty(o, "keyPairFromSeed", { enumerable: !0, get: function () { return W.keyPairFromSeed } }), Object.defineProperty(o, "keyPairFromSecretKey", { enumerable: !0, get: function () { return W.keyPairFromSecretKey } }), Object.defineProperty(o, "sign", { enumerable: !0, get: function () { return W.sign } }), Object.defineProperty(o, "signVerify", { enumerable: !0, get: function () { return W.signVerify } }); var Z = requireEd25519(); Object.defineProperty(o, "getED25519MasterKeyFromSeed", { enumerable: !0, get: function () { return Z.getED25519MasterKeyFromSeed } }), Object.defineProperty(o, "deriveED25519HardenedKey", { enumerable: !0, get: function () { return Z.deriveED25519HardenedKey } }), Object.defineProperty(o, "deriveEd25519Path", { enumerable: !0, get: function () { return Z.deriveEd25519Path } }); var Q = requireSymmetric(); Object.defineProperty(o, "getSymmetricMasterKeyFromSeed", { enumerable: !0, get: function () { return Q.getSymmetricMasterKeyFromSeed } }), Object.defineProperty(o, "deriveSymmetricHardenedKey", { enumerable: !0, get: function () { return Q.deriveSymmetricHardenedKey } }), Object.defineProperty(o, "deriveSymmetricPath", { enumerable: !0, get: function () { return Q.deriveSymmetricPath } }); var re = requireMnemonics(); Object.defineProperty(o, "deriveMnemonicsPath", { enumerable: !0, get: function () { return re.deriveMnemonicsPath } }), Object.defineProperty(o, "deriveMnemonicHardenedKey", { enumerable: !0, get: function () { return re.deriveMnemonicHardenedKey } }), Object.defineProperty(o, "getMnemonicsMasterKeyFromSeed", { enumerable: !0, get: function () { return re.getMnemonicsMasterKeyFromSeed } }) }(dist$1)), dist$1 } var hasRequiredWonderCalculator; function requireWonderCalculator() { if (hasRequiredWonderCalculator) return wonderCalculator; hasRequiredWonderCalculator = 1, Object.defineProperty(wonderCalculator, "__esModule", { value: !0 }), wonderCalculator.wonderCalculator = void 0; const o = requireBitString(), l = requireCellType(), u = requireLevelMask(), f = requireExoticPruned(), p = requireExoticMerkleProof(), d = requireDescriptor(), m = requireDist$1(), v = requireExoticMerkleUpdate(), I = requireExoticLibrary(); function F(B, W, Z) { let Q, re = null; if (B === l.CellType.Ordinary) { let pe = 0; for (let ve of Z) pe = pe | ve.mask.value; Q = new u.LevelMask(pe) } else if (B === l.CellType.PrunedBranch) re = (0, f.exoticPruned)(W, Z), Q = new u.LevelMask(re.mask); else if (B === l.CellType.MerkleProof) (0, p.exoticMerkleProof)(W, Z), Q = new u.LevelMask(Z[0].mask.value >> 1); else if (B === l.CellType.MerkleUpdate) (0, v.exoticMerkleUpdate)(W, Z), Q = new u.LevelMask((Z[0].mask.value | Z[1].mask.value) >> 1); else if (B === l.CellType.Library) (0, I.exoticLibrary)(W, Z), Q = new u.LevelMask; else throw new Error("Unsupported exotic type"); let ne = [], oe = [], ae = B === l.CellType.PrunedBranch ? 1 : Q.hashCount, le = Q.hashCount - ae; for (let pe = 0, ve = 0; pe <= Q.level; pe++) { if (!Q.isSignificant(pe)) continue; if (ve < le) { ve++; continue } let _e; if (ve === le) { if (!(pe === 0 || B === l.CellType.PrunedBranch)) throw Error("Invalid"); _e = W } else { if (!(pe !== 0 && B !== l.CellType.PrunedBranch)) throw Error("Invalid: " + pe + ", " + B); _e = new o.BitString(oe[ve - le - 1], 0, 256) } let Se = 0; for (let P of Z) { let U; B == l.CellType.MerkleProof || B == l.CellType.MerkleUpdate ? U = P.depth(pe + 1) : U = P.depth(pe), Se = Math.max(Se, U) } Z.length > 0 && Se++; let $e = (0, d.getRepr)(W, _e, Z, pe, Q.apply(pe).value, B), ie = (0, m.sha256_sync)($e), g = ve - le; ne[g] = Se, oe[g] = ie, ve++ } let ue = [], he = []; if (re) for (let pe = 0; pe < 4; pe++) { const { hashIndex: ve } = Q.apply(pe), { hashIndex: _e } = Q; ve !== _e ? (ue.push(re.pruned[ve].hash), he.push(re.pruned[ve].depth)) : (ue.push(oe[0]), he.push(ne[0])) } else for (let pe = 0; pe < 4; pe++)ue.push(oe[Q.apply(pe).hashIndex]), he.push(ne[Q.apply(pe).hashIndex]); return { mask: Q, hashes: ue, depths: he } } return wonderCalculator.wonderCalculator = F, wonderCalculator } var serialization = {}, topologicalSort = {}, hasRequiredTopologicalSort; function requireTopologicalSort() { if (hasRequiredTopologicalSort) return topologicalSort; hasRequiredTopologicalSort = 1, Object.defineProperty(topologicalSort, "__esModule", { value: !0 }), topologicalSort.topologicalSort = void 0; function o(l) { let u = [l], f = new Map, p = new Set, d = []; for (; u.length > 0;) { const B = [...u]; u = []; for (let W of B) { const Z = W.hash().toString("hex"); if (!f.has(Z)) { p.add(Z), f.set(Z, { cell: W, refs: W.refs.map(Q => Q.hash().toString("hex")) }); for (let Q of W.refs) u.push(Q) } } } let m = new Set; function v(B) { if (!p.has(B)) return; if (m.has(B)) throw Error("Not a DAG"); m.add(B); let W = f.get(B).refs; for (let Z = W.length - 1; Z >= 0; Z--)v(W[Z]); d.push(B), m.delete(B), p.delete(B) } for (; p.size > 0;) { const B = Array.from(p)[0]; v(B) } let I = new Map; for (let B = 0; B < d.length; B++)I.set(d[d.length - B - 1], B); let F = []; for (let B = d.length - 1; B >= 0; B--) { let W = d[B]; const Z = f.get(W); F.push({ cell: Z.cell, refs: Z.refs.map(Q => I.get(Q)) }) } return F } return topologicalSort.topologicalSort = o, topologicalSort } var bitsForNumber = {}, hasRequiredBitsForNumber; function requireBitsForNumber() { if (hasRequiredBitsForNumber) return bitsForNumber; hasRequiredBitsForNumber = 1, Object.defineProperty(bitsForNumber, "__esModule", { value: !0 }), bitsForNumber.bitsForNumber = void 0; function o(l, u) { let f = BigInt(l); if (u === "int") return f === 0n || f === -1n ? 1 : (f > 0 ? f : -f).toString(2).length + 1; if (u === "uint") { if (f < 0) throw Error(`value is negative. Got ${l}`); return f.toString(2).length } else throw Error(`invalid mode. Got ${u}`) } return bitsForNumber.bitsForNumber = o, bitsForNumber } var crc32c = {}, hasRequiredCrc32c; function requireCrc32c() { if (hasRequiredCrc32c) return crc32c; hasRequiredCrc32c = 1, Object.defineProperty(crc32c, "__esModule", { value: !0 }), crc32c.crc32c = void 0; const o = 2197175160; function l(u) { let f = -1; for (let d = 0; d < u.length; d++)f ^= u[d], f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1, f = f & 1 ? f >>> 1 ^ o : f >>> 1; f = f ^ 4294967295; let p = Buffer.alloc(4); return p.writeInt32LE(f), p } return crc32c.crc32c = l, crc32c } var hasRequiredSerialization; function requireSerialization() { if (hasRequiredSerialization) return serialization; hasRequiredSerialization = 1, Object.defineProperty(serialization, "__esModule", { value: !0 }), serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0; const o = requireBitReader(), l = requireBitString(), u = requireCell(), f = requireTopologicalSort(), p = requireBitsForNumber(), d = requireBitBuilder(), m = requireDescriptor(), v = requirePaddedBits(), I = requireCrc32c(); function F(ae) { return B(ae & 7) } function B(ae) { let se = 0; for (let le = 0; le < 3; le++)se += ae & 1, ae = ae >> 1; return se + 1 } function W(ae, se) { const le = ae.loadUint(8), ue = le % 8, he = !!(le & 8), pe = ae.loadUint(8), ve = Math.ceil(pe / 2), _e = !!(pe % 2), Se = le >> 5, $e = (le & 16) != 0, g = $e ? F(Se) * 32 : 0, P = $e ? F(Se) * 2 : 0; ae.skip(g * 8), ae.skip(P * 8); let U = l.BitString.EMPTY; ve > 0 && (_e ? U = ae.loadPaddedBits(ve * 8) : U = ae.loadBits(ve * 8)); let K = []; for (let Y = 0; Y < ue; Y++)K.push(ae.loadUint(se * 8)); return { bits: U, refs: K, exotic: he } } function Z(ae, se) { return 2 + Math.ceil(ae.bits.length / 8) + ae.refs.length * se } function Q(ae) { let se = new o.BitReader(new l.BitString(ae, 0, ae.length * 8)), le = se.loadUint(32); if (le === 1761568243) { let ue = se.loadUint(8), he = se.loadUint(8), pe = se.loadUint(ue * 8), ve = se.loadUint(ue * 8), _e = se.loadUint(ue * 8), Se = se.loadUint(he * 8), $e = se.loadBuffer(pe * he), ie = se.loadBuffer(Se); return { size: ue, offBytes: he, cells: pe, roots: ve, absent: _e, totalCellSize: Se, index: $e, cellData: ie, root: [0] } } else if (le === 2898503464) { let ue = se.loadUint(8), he = se.loadUint(8), pe = se.loadUint(ue * 8), ve = se.loadUint(ue * 8), _e = se.loadUint(ue * 8), Se = se.loadUint(he * 8), $e = se.loadBuffer(pe * he), ie = se.loadBuffer(Se), g = se.loadBuffer(4); if (!(0, I.crc32c)(ae.subarray(0, ae.length - 4)).equals(g)) throw Error("Invalid CRC32C"); return { size: ue, offBytes: he, cells: pe, roots: ve, absent: _e, totalCellSize: Se, index: $e, cellData: ie, root: [0] } } else if (le === 3052313714) { let ue = se.loadUint(1), he = se.loadUint(1); se.loadUint(1), se.loadUint(2); let pe = se.loadUint(3), ve = se.loadUint(8), _e = se.loadUint(pe * 8), Se = se.loadUint(pe * 8), $e = se.loadUint(pe * 8), ie = se.loadUint(ve * 8), g = []; for (let K = 0; K < Se; K++)g.push(se.loadUint(pe * 8)); let P = null; ue && (P = se.loadBuffer(_e * ve)); let U = se.loadBuffer(ie); if (he) { let K = se.loadBuffer(4); if (!(0, I.crc32c)(ae.subarray(0, ae.length - 4)).equals(K)) throw Error("Invalid CRC32C") } return { size: pe, offBytes: ve, cells: _e, roots: Se, absent: $e, totalCellSize: ie, index: P, cellData: U, root: g } } else throw Error("Invalid magic") } serialization.parseBoc = Q; function re(ae) { let se = Q(ae), le = new o.BitReader(new l.BitString(se.cellData, 0, se.cellData.length * 8)), ue = []; for (let pe = 0; pe < se.cells; pe++) { let ve = W(le, se.size); ue.push({ ...ve, result: null }) } for (let pe = ue.length - 1; pe >= 0; pe--) { if (ue[pe].result) throw Error("Impossible"); let ve = []; for (let _e of ue[pe].refs) { if (!ue[_e].result) throw Error("Invalid BOC file"); ve.push(ue[_e].result) } ue[pe].result = new u.Cell({ bits: ue[pe].bits, refs: ve, exotic: ue[pe].exotic }) } let he = []; for (let pe = 0; pe < se.root.length; pe++)he.push(ue[se.root[pe]].result); return he } serialization.deserializeBoc = re; function ne(ae, se, le, ue) { let he = (0, m.getRefsDescriptor)(ae.refs, ae.mask.value, ae.type), pe = (0, m.getBitsDescriptor)(ae.bits); ue.writeUint(he, 8), ue.writeUint(pe, 8), ue.writeBuffer((0, v.bitsToPaddedBuffer)(ae.bits)); for (let ve of se) ue.writeUint(ve, le * 8) } function oe(ae, se) { let le = (0, f.topologicalSort)(ae), ue = le.length, he = se.idx, pe = se.crc32, ve = !1, _e = 0, Se = Math.max(Math.ceil((0, p.bitsForNumber)(ue, "uint") / 8), 1), $e = 0, ie = []; for (let Y of le) { let te = Z(Y.cell, Se); $e += te, ie.push($e) } let g = Math.max(Math.ceil((0, p.bitsForNumber)($e, "uint") / 8), 1), P = (6 + 3 * Se + g + 1 * Se + (he ? ue * g : 0) + $e + (pe ? 4 : 0)) * 8, U = new d.BitBuilder(P); if (U.writeUint(3052313714, 32), U.writeBit(he), U.writeBit(pe), U.writeBit(ve), U.writeUint(_e, 2), U.writeUint(Se, 3), U.writeUint(g, 8), U.writeUint(ue, Se * 8), U.writeUint(1, Se * 8), U.writeUint(0, Se * 8), U.writeUint($e, g * 8), U.writeUint(0, Se * 8), he) for (let Y = 0; Y < ue; Y++)U.writeUint(ie[Y], g * 8); for (let Y = 0; Y < ue; Y++)ne(le[Y].cell, le[Y].refs, Se, U); if (pe) { let Y = (0, I.crc32c)(U.buffer()); U.writeBuffer(Y) } let K = U.buffer(); if (K.length !== P / 8) throw Error("Internal error"); return K } return serialization.serializeBoc = oe, serialization } var hasRequiredCell; function requireCell() {
  if (hasRequiredCell) return Cell; hasRequiredCell = 1; var o = Cell && Cell.__importDefault || function (Z) { return Z && Z.__esModule ? Z : { default: Z } }, l; Object.defineProperty(Cell, "__esModule", { value: !0 }), Cell.Cell = void 0; const u = o(requireSymbol_inspect()), f = requireBitString(), p = requireCellType(), d = requireSlice(), m = requireResolveExotic(), v = requireWonderCalculator(), I = requireSerialization(), F = requireBitReader(), B = requireBuilder$1(); let W = class Mf {
    static fromBoc(Q) { return (0, I.deserializeBoc)(Q) } static fromBase64(Q) { let re = Mf.fromBoc(Buffer.from(Q, "base64")); if (re.length !== 1) throw new Error("Deserialized more than one cell"); return re[0] } constructor(Q) { this._hashes = [], this._depths = [], this.beginParse = (ue = !1) => { if (this.isExotic && !ue) throw new Error("Exotic cells cannot be parsed"); return new d.Slice(new F.BitReader(this.bits), this.refs) }, this.hash = (ue = 3) => this._hashes[Math.min(this._hashes.length - 1, ue)], this.depth = (ue = 3) => this._depths[Math.min(this._depths.length - 1, ue)], this.level = () => this.mask.level, this.equals = ue => this.hash().equals(ue.hash()), this[l] = () => this.toString(); let re = f.BitString.EMPTY; Q && Q.bits && (re = Q.bits); let ne = []; Q && Q.refs && (ne = [...Q.refs]); let oe, ae, se, le = p.CellType.Ordinary; if (Q && Q.exotic) { let ue = (0, m.resolveExotic)(re, ne), he = (0, v.wonderCalculator)(ue.type, re, ne); se = he.mask, ae = he.depths, oe = he.hashes, le = ue.type } else { if (ne.length > 4) throw new Error("Invalid number of references"); if (re.length > 1023) throw new Error(`Bits overflow: ${re.length} > 1023`); let ue = (0, v.wonderCalculator)(p.CellType.Ordinary, re, ne); se = ue.mask, ae = ue.depths, oe = ue.hashes, le = p.CellType.Ordinary } this.type = le, this.bits = re, this.refs = ne, this.mask = se, this._depths = ae, this._hashes = oe, Object.freeze(this), Object.freeze(this.refs), Object.freeze(this.bits), Object.freeze(this.mask), Object.freeze(this._depths), Object.freeze(this._hashes) } get isExotic() { return this.type !== p.CellType.Ordinary } toBoc(Q) { let re = Q && Q.idx !== null && Q.idx !== void 0 ? Q.idx : !1, ne = Q && Q.crc32 !== null && Q.crc32 !== void 0 ? Q.crc32 : !0; return (0, I.serializeBoc)(this, { idx: re, crc32: ne }) } toString(Q) {
      let re = Q || "", ne = "x"; this.isExotic && (this.type === p.CellType.MerkleProof ? ne = "p" : this.type === p.CellType.MerkleUpdate ? ne = "u" : this.type === p.CellType.PrunedBranch && (ne = "p")); let oe = re + (this.isExotic ? ne : "x") + "{" + this.bits.toString() + "}"; for (let ae in this.refs) {
        const se = this.refs[ae]; oe += `
`+ se.toString(re + " ")
      } return oe
    } asSlice() { return this.beginParse() } asBuilder() { return (0, B.beginCell)().storeSlice(this.asSlice()) }
  }; return Cell.Cell = W, l = u.default, W.EMPTY = new W, Cell
} var hasRequiredBuilder$1; function requireBuilder$1() { if (hasRequiredBuilder$1) return Builder; hasRequiredBuilder$1 = 1, Object.defineProperty(Builder, "__esModule", { value: !0 }), Builder.Builder = Builder.beginCell = void 0; const o = requireBitBuilder(), l = requireCell(), u = requireStrings(); function f() { return new p } Builder.beginCell = f; let p = class Af { constructor() { this._bits = new o.BitBuilder, this._refs = [] } get bits() { return this._bits.length } get refs() { return this._refs.length } get availableBits() { return 1023 - this.bits } get availableRefs() { return 4 - this.refs } storeBit(m) { return this._bits.writeBit(m), this } storeBits(m) { return this._bits.writeBits(m), this } storeBuffer(m, v) { if (v != null && m.length !== v) throw Error(`Buffer length ${m.length} is not equal to ${v}`); return this._bits.writeBuffer(m), this } storeMaybeBuffer(m, v) { return m !== null ? (this.storeBit(1), this.storeBuffer(m, v)) : this.storeBit(0), this } storeUint(m, v) { return this._bits.writeUint(m, v), this } storeMaybeUint(m, v) { return m != null ? (this.storeBit(1), this.storeUint(m, v)) : this.storeBit(0), this } storeInt(m, v) { return this._bits.writeInt(m, v), this } storeMaybeInt(m, v) { return m != null ? (this.storeBit(1), this.storeInt(m, v)) : this.storeBit(0), this } storeVarUint(m, v) { return this._bits.writeVarUint(m, v), this } storeMaybeVarUint(m, v) { return m != null ? (this.storeBit(1), this.storeVarUint(m, v)) : this.storeBit(0), this } storeVarInt(m, v) { return this._bits.writeVarInt(m, v), this } storeMaybeVarInt(m, v) { return m != null ? (this.storeBit(1), this.storeVarInt(m, v)) : this.storeBit(0), this } storeCoins(m) { return this._bits.writeCoins(m), this } storeMaybeCoins(m) { return m != null ? (this.storeBit(1), this.storeCoins(m)) : this.storeBit(0), this } storeAddress(m) { return this._bits.writeAddress(m), this } storeRef(m) { if (this._refs.length >= 4) throw new Error("Too many references"); if (m instanceof l.Cell) this._refs.push(m); else if (m instanceof Af) this._refs.push(m.endCell()); else throw new Error("Invalid argument"); return this } storeMaybeRef(m) { return m ? (this.storeBit(1), this.storeRef(m)) : this.storeBit(0), this } storeSlice(m) { let v = m.clone(); for (v.remainingBits > 0 && this.storeBits(v.loadBits(v.remainingBits)); v.remainingRefs > 0;)this.storeRef(v.loadRef()); return this } storeMaybeSlice(m) { return m ? (this.storeBit(1), this.storeSlice(m)) : this.storeBit(0), this } storeBuilder(m) { return this.storeSlice(m.endCell().beginParse()) } storeMaybeBuilder(m) { return m ? (this.storeBit(1), this.storeBuilder(m)) : this.storeBit(0), this } storeWritable(m) { return typeof m == "object" ? m.writeTo(this) : m(this), this } storeMaybeWritable(m) { return m ? (this.storeBit(1), this.storeWritable(m)) : this.storeBit(0), this } store(m) { return this.storeWritable(m), this } storeStringTail(m) { return (0, u.writeString)(m, this), this } storeMaybeStringTail(m) { return m != null ? (this.storeBit(1), (0, u.writeString)(m, this)) : this.storeBit(0), this } storeStringRefTail(m) { return this.storeRef(f().storeStringTail(m)), this } storeMaybeStringRefTail(m) { return m != null ? (this.storeBit(1), this.storeStringRefTail(m)) : this.storeBit(0), this } storeDict(m, v, I) { return m ? m.store(this, v, I) : this.storeBit(0), this } storeDictDirect(m, v, I) { return m.storeDirect(this, v, I), this } endCell(m) { return new l.Cell({ bits: this._bits.build(), refs: this._refs, exotic: m == null ? void 0 : m.exotic }) } asCell() { return this.endCell() } asSlice() { return this.endCell().beginParse() } }; return Builder.Builder = p, Builder } var StateInit = {}, SimpleLibrary = {}, hasRequiredSimpleLibrary; function requireSimpleLibrary() { if (hasRequiredSimpleLibrary) return SimpleLibrary; hasRequiredSimpleLibrary = 1, Object.defineProperty(SimpleLibrary, "__esModule", { value: !0 }), SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0; function o(u) { return { public: u.loadBit(), root: u.loadRef() } } SimpleLibrary.loadSimpleLibrary = o; function l(u) { return f => { f.storeBit(u.public), f.storeRef(u.root) } } return SimpleLibrary.storeSimpleLibrary = l, SimpleLibrary.SimpleLibraryValue = { serialize(u, f) { l(u)(f) }, parse(u) { return o(u) } }, SimpleLibrary } var TickTock = {}, hasRequiredTickTock; function requireTickTock() { if (hasRequiredTickTock) return TickTock; hasRequiredTickTock = 1, Object.defineProperty(TickTock, "__esModule", { value: !0 }), TickTock.storeTickTock = TickTock.loadTickTock = void 0; function o(u) { return { tick: u.loadBit(), tock: u.loadBit() } } TickTock.loadTickTock = o; function l(u) { return f => { f.storeBit(u.tick), f.storeBit(u.tock) } } return TickTock.storeTickTock = l, TickTock } var hasRequiredStateInit; function requireStateInit() { if (hasRequiredStateInit) return StateInit; hasRequiredStateInit = 1, Object.defineProperty(StateInit, "__esModule", { value: !0 }), StateInit.storeStateInit = StateInit.loadStateInit = void 0; const o = requireDictionary(), l = requireSimpleLibrary(), u = requireTickTock(); function f(d) { let m; d.loadBit() && (m = d.loadUint(5)); let v; d.loadBit() && (v = (0, u.loadTickTock)(d)); let I = d.loadMaybeRef(), F = d.loadMaybeRef(), B = d.loadDict(o.Dictionary.Keys.BigUint(256), l.SimpleLibraryValue); return B.size === 0 && (B = void 0), { splitDepth: m, special: v, code: I, data: F, libraries: B } } StateInit.loadStateInit = f; function p(d) { return m => { d.splitDepth !== null && d.splitDepth !== void 0 ? (m.storeBit(!0), m.storeUint(d.splitDepth, 5)) : m.storeBit(!1), d.special !== null && d.special !== void 0 ? (m.storeBit(!0), m.store((0, u.storeTickTock)(d.special))) : m.storeBit(!1), m.storeMaybeRef(d.code), m.storeMaybeRef(d.data), m.storeDict(d.libraries) } } return StateInit.storeStateInit = p, StateInit } var hasRequiredContractAddress; function requireContractAddress() { if (hasRequiredContractAddress) return contractAddress; hasRequiredContractAddress = 1, Object.defineProperty(contractAddress, "__esModule", { value: !0 }), contractAddress.contractAddress = void 0; const o = requireBuilder$1(), l = requireStateInit(), u = requireAddress(); function f(p, d) { let m = (0, o.beginCell)().store((0, l.storeStateInit)(d)).endCell().hash(); return new u.Address(p, m) } return contractAddress.contractAddress = f, contractAddress } var tuple = {}, hasRequiredTuple; function requireTuple() { if (hasRequiredTuple) return tuple; hasRequiredTuple = 1, Object.defineProperty(tuple, "__esModule", { value: !0 }), tuple.parseTuple = tuple.serializeTuple = void 0; const o = requireBuilder$1(), l = BigInt("-9223372036854775808"), u = BigInt("9223372036854775807"); function f(I, F) { if (I.type === "null") F.storeUint(0, 8); else if (I.type === "int") I.value <= u && I.value >= l ? (F.storeUint(1, 8), F.storeInt(I.value, 64)) : (F.storeUint(256, 15), F.storeInt(I.value, 257)); else if (I.type === "nan") F.storeInt(767, 16); else if (I.type === "cell") F.storeUint(3, 8), F.storeRef(I.cell); else if (I.type === "slice") F.storeUint(4, 8), F.storeUint(0, 10), F.storeUint(I.cell.bits.length, 10), F.storeUint(0, 3), F.storeUint(I.cell.refs.length, 3), F.storeRef(I.cell); else if (I.type === "builder") F.storeUint(5, 8), F.storeRef(I.cell); else if (I.type === "tuple") { let B = null, W = null; for (let Z = 0; Z < I.items.length; Z++) { let Q = B; B = W, W = Q, Z > 1 && (B = (0, o.beginCell)().storeRef(W).storeRef(B).endCell()); let re = (0, o.beginCell)(); f(I.items[Z], re), W = re.endCell() } F.storeUint(7, 8), F.storeUint(I.items.length, 16), B && F.storeRef(B), W && F.storeRef(W) } else throw Error("Invalid value") } function p(I) { let F = I.loadUint(8); if (F === 0) return { type: "null" }; if (F === 1) return { type: "int", value: I.loadIntBig(64) }; if (F === 2) return I.loadUint(7) === 0 ? { type: "int", value: I.loadIntBig(257) } : (I.loadBit(), { type: "nan" }); if (F === 3) return { type: "cell", cell: I.loadRef() }; if (F === 4) { let B = I.loadUint(10), W = I.loadUint(10), Z = I.loadUint(3), Q = I.loadUint(3), re = I.loadRef().beginParse(); re.skip(B); let ne = re.loadBits(W - B), oe = (0, o.beginCell)().storeBits(ne); if (Z < Q) { for (let ae = 0; ae < Z; ae++)re.loadRef(); for (let ae = 0; ae < Q - Z; ae++)oe.storeRef(re.loadRef()) } return { type: "slice", cell: oe.endCell() } } else { if (F === 5) return { type: "builder", cell: I.loadRef() }; if (F === 7) { let B = I.loadUint(16), W = []; if (B > 1) { let Z = I.loadRef().beginParse(), Q = I.loadRef().beginParse(); W.unshift(p(Q)); for (let re = 0; re < B - 2; re++) { let ne = Z; Z = ne.loadRef().beginParse(), Q = ne.loadRef().beginParse(), W.unshift(p(Q)) } W.unshift(p(Z)) } else B === 1 && W.push(p(I.loadRef().beginParse())); return { type: "tuple", items: W } } else throw Error("Unsupported stack item") } } function d(I, F) { if (I.length > 0) { let B = (0, o.beginCell)(); d(I.slice(0, I.length - 1), B), F.storeRef(B.endCell()), f(I[I.length - 1], F) } } function m(I) { let F = (0, o.beginCell)(); F.storeUint(I.length, 24); let B = [...I]; return d(B, F), F.endCell() } tuple.serializeTuple = m; function v(I) { let F = [], B = I.beginParse(), W = B.loadUint(24); for (let Z = 0; Z < W; Z++) { let Q = B.loadRef(); F.unshift(p(B)), B = Q.beginParse() } return F } return tuple.parseTuple = v, tuple } var reader = {}, hasRequiredReader; function requireReader() { if (hasRequiredReader) return reader; hasRequiredReader = 1, Object.defineProperty(reader, "__esModule", { value: !0 }), reader.TupleReader = void 0; class o { constructor(u) { this.items = [...u] } get remaining() { return this.items.length } peek() { if (this.items.length === 0) throw Error("EOF"); return this.items[0] } pop() { if (this.items.length === 0) throw Error("EOF"); let u = this.items[0]; return this.items.splice(0, 1), u } skip(u = 1) { for (let f = 0; f < u; f++)this.pop(); return this } readBigNumber() { let u = this.pop(); if (u.type !== "int") throw Error("Not a number"); return u.value } readBigNumberOpt() { let u = this.pop(); if (u.type === "null") return null; if (u.type !== "int") throw Error("Not a number"); return u.value } readNumber() { return Number(this.readBigNumber()) } readNumberOpt() { let u = this.readBigNumberOpt(); return u !== null ? Number(u) : null } readBoolean() { return this.readNumber() !== 0 } readBooleanOpt() { let u = this.readNumberOpt(); return u !== null ? u !== 0 : null } readAddress() { let u = this.readCell().beginParse().loadAddress(); if (u !== null) return u; throw Error("Not an address") } readAddressOpt() { let u = this.readCellOpt(); return u !== null ? u.beginParse().loadMaybeAddress() : null } readCell() { let u = this.pop(); if (u.type !== "cell" && u.type !== "slice" && u.type !== "builder") throw Error("Not a cell: " + u.type); return u.cell } readCellOpt() { let u = this.pop(); if (u.type === "null") return null; if (u.type !== "cell" && u.type !== "slice" && u.type !== "builder") throw Error("Not a cell"); return u.cell } readTuple() { let u = this.pop(); if (u.type !== "tuple") throw Error("Not a tuple"); return new o(u.items) } readTupleOpt() { let u = this.pop(); if (u.type === "null") return null; if (u.type !== "tuple") throw Error("Not a tuple"); return new o(u.items) } static readLispList(u) { const f = []; let p = u; for (; p !== null;) { var d = p.pop(); if (p.items.length === 0 || p.items[0].type !== "tuple" && p.items[0].type !== "null") throw Error("Lisp list consists only from (any, tuple) elements and ends with null"); p = p.readTupleOpt(), f.push(d) } return f } readLispListDirect() { return this.items.length === 1 && this.items[0].type === "null" ? [] : o.readLispList(this) } readLispList() { return o.readLispList(this.readTupleOpt()) } readBuffer() { let u = this.readCell().beginParse(); if (u.remainingRefs !== 0 || u.remainingBits % 8 !== 0) throw Error("Not a buffer"); return u.loadBuffer(u.remainingBits / 8) } readBufferOpt() { if (this.peek().type === "null") return null; let f = this.readCell().beginParse(); if (f.remainingRefs !== 0 || f.remainingBits % 8 !== 0) throw Error("Not a buffer"); return f.loadBuffer(f.remainingBits / 8) } readString() { return this.readCell().beginParse().loadStringTail() } readStringOpt() { return this.peek().type === "null" ? null : this.readCell().beginParse().loadStringTail() } } return reader.TupleReader = o, reader } var builder = {}, hasRequiredBuilder; function requireBuilder() { if (hasRequiredBuilder) return builder; hasRequiredBuilder = 1, Object.defineProperty(builder, "__esModule", { value: !0 }), builder.TupleBuilder = void 0; const o = requireBuilder$1(), l = requireCell(), u = requireSlice(); class f { constructor() { this._tuple = [] } writeNumber(d) { d == null ? this._tuple.push({ type: "null" }) : this._tuple.push({ type: "int", value: BigInt(d) }) } writeBoolean(d) { d == null ? this._tuple.push({ type: "null" }) : this._tuple.push({ type: "int", value: d ? -1n : 0n }) } writeBuffer(d) { d == null ? this._tuple.push({ type: "null" }) : this._tuple.push({ type: "slice", cell: (0, o.beginCell)().storeBuffer(d).endCell() }) } writeString(d) { d == null ? this._tuple.push({ type: "null" }) : this._tuple.push({ type: "slice", cell: (0, o.beginCell)().storeStringTail(d).endCell() }) } writeCell(d) { d == null ? this._tuple.push({ type: "null" }) : d instanceof l.Cell ? this._tuple.push({ type: "cell", cell: d }) : d instanceof u.Slice && this._tuple.push({ type: "cell", cell: d.asCell() }) } writeSlice(d) { d == null ? this._tuple.push({ type: "null" }) : d instanceof l.Cell ? this._tuple.push({ type: "slice", cell: d }) : d instanceof u.Slice && this._tuple.push({ type: "slice", cell: d.asCell() }) } writeBuilder(d) { d == null ? this._tuple.push({ type: "null" }) : d instanceof l.Cell ? this._tuple.push({ type: "builder", cell: d }) : d instanceof u.Slice && this._tuple.push({ type: "builder", cell: d.asCell() }) } writeTuple(d) { d == null ? this._tuple.push({ type: "null" }) : this._tuple.push({ type: "tuple", items: d }) } writeAddress(d) { d == null ? this._tuple.push({ type: "null" }) : this._tuple.push({ type: "slice", cell: (0, o.beginCell)().storeAddress(d).endCell() }) } build() { return [...this._tuple] } } return builder.TupleBuilder = f, builder } var _export = {}, _helpers = {}, convert = {}, hasRequiredConvert; function requireConvert() { if (hasRequiredConvert) return convert; hasRequiredConvert = 1, Object.defineProperty(convert, "__esModule", { value: !0 }), convert.fromNano = convert.toNano = void 0; function o(u) { if (typeof u == "bigint") return u * 1000000000n; { if (typeof u == "number") { if (!Number.isFinite(u)) throw Error("Invalid number"); if (Math.log10(u) <= 6) u = u.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: !1 }); else if (u - Math.trunc(u) === 0) u = u.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: !1 }); else throw Error("Not enough precision for a number value. Use string value instead") } let f = !1; for (; u.startsWith("-");)f = !f, u = u.slice(1); if (u === ".") throw Error("Invalid number"); let p = u.split("."); if (p.length > 2) throw Error("Invalid number"); let d = p[0], m = p[1]; if (d || (d = "0"), m || (m = "0"), m.length > 9) throw Error("Invalid number"); for (; m.length < 9;)m += "0"; let v = BigInt(d) * 1000000000n + BigInt(m); return f && (v = -v), v } } convert.toNano = o; function l(u) { let f = BigInt(u), p = !1; f < 0 && (p = !0, f = -f); let m = (f % 1000000000n).toString(); for (; m.length < 9;)m = "0" + m; m = m.match(/^([0-9]*[1-9]|0)(0*)/)[1]; let F = `${(f / 1000000000n).toString()}${m === "0" ? "" : `.${m}`}`; return p && (F = "-" + F), F } return convert.fromNano = l, convert } var hasRequired_helpers; function require_helpers() { if (hasRequired_helpers) return _helpers; hasRequired_helpers = 1, Object.defineProperty(_helpers, "__esModule", { value: !0 }), _helpers.comment = _helpers.external = _helpers.internal = void 0; const o = requireAddress(), l = requireCell(), u = requireBuilder$1(), f = requireConvert(); function p(v) { let I = !0; v.bounce !== null && v.bounce !== void 0 && (I = v.bounce); let F; if (typeof v.to == "string") F = o.Address.parse(v.to); else if (o.Address.isAddress(v.to)) F = v.to; else throw new Error(`Invalid address ${v.to}`); let B; typeof v.value == "string" ? B = (0, f.toNano)(v.value) : B = v.value; let W = l.Cell.EMPTY; return typeof v.body == "string" ? W = (0, u.beginCell)().storeUint(0, 32).storeStringTail(v.body).endCell() : v.body && (W = v.body), { info: { type: "internal", dest: F, value: { coins: B }, bounce: I, ihrDisabled: !0, bounced: !1, ihrFee: 0n, forwardFee: 0n, createdAt: 0, createdLt: 0n }, init: v.init ?? void 0, body: W } } _helpers.internal = p; function d(v) { let I; if (typeof v.to == "string") I = o.Address.parse(v.to); else if (o.Address.isAddress(v.to)) I = v.to; else throw new Error(`Invalid address ${v.to}`); return { info: { type: "external-in", dest: I, importFee: 0n }, init: v.init ?? void 0, body: v.body || l.Cell.EMPTY } } _helpers.external = d; function m(v) { return (0, u.beginCell)().storeUint(0, 32).storeStringTail(v).endCell() } return _helpers.comment = m, _helpers } var Account = {}, AccountStorage = {}, AccountState = {}, hasRequiredAccountState; function requireAccountState() { if (hasRequiredAccountState) return AccountState; hasRequiredAccountState = 1, Object.defineProperty(AccountState, "__esModule", { value: !0 }), AccountState.storeAccountState = AccountState.loadAccountState = void 0; const o = requireStateInit(); function l(f) { return f.loadBit() ? { type: "active", state: (0, o.loadStateInit)(f) } : f.loadBit() ? { type: "frozen", stateHash: f.loadUintBig(256) } : { type: "uninit" } } AccountState.loadAccountState = l; function u(f) { return p => { f.type === "active" ? (p.storeBit(!0), p.store((0, o.storeStateInit)(f.state))) : f.type === "frozen" ? (p.storeBit(!1), p.storeBit(!0), p.storeUint(f.stateHash, 256)) : f.type === "uninit" && (p.storeBit(!1), p.storeBit(!1)) } } return AccountState.storeAccountState = u, AccountState } var CurrencyCollection = {}, hasRequiredCurrencyCollection; function requireCurrencyCollection() { if (hasRequiredCurrencyCollection) return CurrencyCollection; hasRequiredCurrencyCollection = 1, Object.defineProperty(CurrencyCollection, "__esModule", { value: !0 }), CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0; const o = requireDictionary(); function l(f) { const p = f.loadCoins(), d = f.loadDict(o.Dictionary.Keys.Uint(32), o.Dictionary.Values.BigVarUint(5)); return d.size === 0 ? { coins: p } : { other: d, coins: p } } CurrencyCollection.loadCurrencyCollection = l; function u(f) { return p => { p.storeCoins(f.coins), f.other ? p.storeDict(f.other) : p.storeBit(0) } } return CurrencyCollection.storeCurrencyCollection = u, CurrencyCollection } var hasRequiredAccountStorage; function requireAccountStorage() { if (hasRequiredAccountStorage) return AccountStorage; hasRequiredAccountStorage = 1, Object.defineProperty(AccountStorage, "__esModule", { value: !0 }), AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0; const o = requireAccountState(), l = requireCurrencyCollection(); function u(p) { return { lastTransLt: p.loadUintBig(64), balance: (0, l.loadCurrencyCollection)(p), state: (0, o.loadAccountState)(p) } } AccountStorage.loadAccountStorage = u; function f(p) { return d => { d.storeUint(p.lastTransLt, 64), d.store((0, l.storeCurrencyCollection)(p.balance)), d.store((0, o.storeAccountState)(p.state)) } } return AccountStorage.storeAccountStorage = f, AccountStorage } var StorageInto = {}, StorageUsed = {}, hasRequiredStorageUsed; function requireStorageUsed() { if (hasRequiredStorageUsed) return StorageUsed; hasRequiredStorageUsed = 1, Object.defineProperty(StorageUsed, "__esModule", { value: !0 }), StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0; function o(u) { return { cells: u.loadVarUintBig(3), bits: u.loadVarUintBig(3), publicCells: u.loadVarUintBig(3) } } StorageUsed.loadStorageUsed = o; function l(u) { return f => { f.storeVarUint(u.cells, 3), f.storeVarUint(u.bits, 3), f.storeVarUint(u.publicCells, 3) } } return StorageUsed.storeStorageUsed = l, StorageUsed } var hasRequiredStorageInto; function requireStorageInto() { if (hasRequiredStorageInto) return StorageInto; hasRequiredStorageInto = 1, Object.defineProperty(StorageInto, "__esModule", { value: !0 }), StorageInto.storeStorageInfo = StorageInto.loadStorageInfo = void 0; const o = requireStorageUsed(); function l(f) { return { used: (0, o.loadStorageUsed)(f), lastPaid: f.loadUint(32), duePayment: f.loadMaybeCoins() } } StorageInto.loadStorageInfo = l; function u(f) { return p => { p.store((0, o.storeStorageUsed)(f.used)), p.storeUint(f.lastPaid, 32), p.storeMaybeCoins(f.duePayment) } } return StorageInto.storeStorageInfo = u, StorageInto } var hasRequiredAccount; function requireAccount() { if (hasRequiredAccount) return Account; hasRequiredAccount = 1, Object.defineProperty(Account, "__esModule", { value: !0 }), Account.storeAccount = Account.loadAccount = void 0; const o = requireAccountStorage(), l = requireStorageInto(); function u(p) { return { addr: p.loadAddress(), storageStats: (0, l.loadStorageInfo)(p), storage: (0, o.loadAccountStorage)(p) } } Account.loadAccount = u; function f(p) { return d => { d.storeAddress(p.addr), d.store((0, l.storeStorageInfo)(p.storageStats)), d.store((0, o.storeAccountStorage)(p.storage)) } } return Account.storeAccount = f, Account } var AccountStatus = {}, hasRequiredAccountStatus; function requireAccountStatus() { if (hasRequiredAccountStatus) return AccountStatus; hasRequiredAccountStatus = 1, Object.defineProperty(AccountStatus, "__esModule", { value: !0 }), AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0; function o(u) { const f = u.loadUint(2); if (f === 0) return "uninitialized"; if (f === 1) return "frozen"; if (f === 2) return "active"; if (f === 3) return "non-existing"; throw Error("Invalid data") } AccountStatus.loadAccountStatus = o; function l(u) { return f => { if (u === "uninitialized") f.storeUint(0, 2); else if (u === "frozen") f.storeUint(1, 2); else if (u === "active") f.storeUint(2, 2); else if (u === "non-existing") f.storeUint(3, 2); else throw Error("Invalid data"); return f } } return AccountStatus.storeAccountStatus = l, AccountStatus } var AccountStatusChange = {}, hasRequiredAccountStatusChange; function requireAccountStatusChange() { if (hasRequiredAccountStatusChange) return AccountStatusChange; hasRequiredAccountStatusChange = 1, Object.defineProperty(AccountStatusChange, "__esModule", { value: !0 }), AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0; function o(u) { return u.loadBit() ? u.loadBit() ? "deleted" : "frozen" : "unchanged" } AccountStatusChange.loadAccountStatusChange = o; function l(u) { return f => { if (u == "unchanged") f.storeBit(0); else if (u === "frozen") f.storeBit(1), f.storeBit(0); else if (u === "deleted") f.storeBit(1), f.storeBit(1); else throw Error("Invalid account status change") } } return AccountStatusChange.storeAccountStatusChange = l, AccountStatusChange } var OutList = {}, MessageRelaxed = {}, CommonMessageInfoRelaxed = {}, hasRequiredCommonMessageInfoRelaxed; function requireCommonMessageInfoRelaxed() { if (hasRequiredCommonMessageInfoRelaxed) return CommonMessageInfoRelaxed; hasRequiredCommonMessageInfoRelaxed = 1, Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", { value: !0 }), CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0; const o = requireCurrencyCollection(); function l(f) { if (!f.loadBit()) { const I = f.loadBit(), F = f.loadBit(), B = f.loadBit(), W = f.loadMaybeAddress(), Z = f.loadAddress(), Q = (0, o.loadCurrencyCollection)(f), re = f.loadCoins(), ne = f.loadCoins(), oe = f.loadUintBig(64), ae = f.loadUint(32); return { type: "internal", ihrDisabled: I, bounce: F, bounced: B, src: W, dest: Z, value: Q, ihrFee: re, forwardFee: ne, createdLt: oe, createdAt: ae } } if (!f.loadBit()) throw Error("External In message is not possible for CommonMessageInfoRelaxed"); const p = f.loadMaybeAddress(), d = f.loadMaybeExternalAddress(), m = f.loadUintBig(64), v = f.loadUint(32); return { type: "external-out", src: p, dest: d, createdLt: m, createdAt: v } } CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = l; function u(f) { return p => { if (f.type === "internal") p.storeBit(0), p.storeBit(f.ihrDisabled), p.storeBit(f.bounce), p.storeBit(f.bounced), p.storeAddress(f.src), p.storeAddress(f.dest), p.store((0, o.storeCurrencyCollection)(f.value)), p.storeCoins(f.ihrFee), p.storeCoins(f.forwardFee), p.storeUint(f.createdLt, 64), p.storeUint(f.createdAt, 32); else if (f.type === "external-out") p.storeBit(1), p.storeBit(1), p.storeAddress(f.src), p.storeAddress(f.dest), p.storeUint(f.createdLt, 64), p.storeUint(f.createdAt, 32); else throw new Error("Unknown CommonMessageInfo type") } } return CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = u, CommonMessageInfoRelaxed } var hasRequiredMessageRelaxed; function requireMessageRelaxed() { if (hasRequiredMessageRelaxed) return MessageRelaxed; hasRequiredMessageRelaxed = 1, Object.defineProperty(MessageRelaxed, "__esModule", { value: !0 }), MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0; const o = requireBuilder$1(), l = requireCommonMessageInfoRelaxed(), u = requireStateInit(); function f(d) { const m = (0, l.loadCommonMessageInfoRelaxed)(d); let v = null; d.loadBit() && (d.loadBit() ? v = (0, u.loadStateInit)(d.loadRef().beginParse()) : v = (0, u.loadStateInit)(d)); const I = d.loadBit() ? d.loadRef() : d.asCell(); return { info: m, init: v, body: I } } MessageRelaxed.loadMessageRelaxed = f; function p(d, m) { return v => { if (v.store((0, l.storeCommonMessageInfoRelaxed)(d.info)), d.init) { v.storeBit(!0); let F = (0, o.beginCell)().store((0, u.storeStateInit)(d.init)), B = !1; m && m.forceRef ? B = !0 : v.availableBits - 2 >= F.bits ? B = !1 : B = !0, B ? (v.storeBit(!0), v.storeRef(F)) : (v.storeBit(!1), v.storeBuilder(F)) } else v.storeBit(!1); let I = !1; m && m.forceRef ? I = !0 : v.availableBits - 1 >= d.body.bits.length && v.refs + d.body.refs.length <= 4 && !d.body.isExotic ? I = !1 : I = !0, I ? (v.storeBit(!0), v.storeRef(d.body)) : (v.storeBit(!1), v.storeBuilder(d.body.asBuilder())) } } return MessageRelaxed.storeMessageRelaxed = p, MessageRelaxed } var LibRef = {}, hasRequiredLibRef; function requireLibRef() { if (hasRequiredLibRef) return LibRef; hasRequiredLibRef = 1, Object.defineProperty(LibRef, "__esModule", { value: !0 }), LibRef.storeLibRef = LibRef.loadLibRef = void 0; function o(u) { return u.loadUint(1) === 0 ? { type: "hash", libHash: u.loadBuffer(32) } : { type: "ref", library: u.loadRef() } } LibRef.loadLibRef = o; function l(u) { return f => { u.type === "hash" ? (f.storeUint(0, 1), f.storeBuffer(u.libHash)) : (f.storeUint(1, 1), f.storeRef(u.library)) } } return LibRef.storeLibRef = l, LibRef } var hasRequiredOutList; function requireOutList() { if (hasRequiredOutList) return OutList; hasRequiredOutList = 1, Object.defineProperty(OutList, "__esModule", { value: !0 }), OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0; const o = requireMessageRelaxed(), l = requireBuilder$1(), u = requireCurrencyCollection(), f = requireLibRef(); function p(oe) { switch (oe.type) { case "sendMsg": return m(oe); case "setCode": return I(oe); case "reserve": return B(oe); case "changeLibrary": return Z(oe); default: throw new Error(`Unknown action type ${oe.type}`) } } OutList.storeOutAction = p; const d = 247711853; function m(oe) { return ae => { ae.storeUint(d, 32).storeUint(oe.mode, 8).storeRef((0, l.beginCell)().store((0, o.storeMessageRelaxed)(oe.outMsg)).endCell()) } } const v = 2907562126; function I(oe) { return ae => { ae.storeUint(v, 32).storeRef(oe.newCode) } } const F = 921090057; function B(oe) { return ae => { ae.storeUint(F, 32).storeUint(oe.mode, 8).store((0, u.storeCurrencyCollection)(oe.currency)) } } const W = 653925844; function Z(oe) { return ae => { ae.storeUint(W, 32).storeUint(oe.mode, 7).store((0, f.storeLibRef)(oe.libRef)) } } function Q(oe) { const ae = oe.loadUint(32); if (ae === d) { const se = oe.loadUint(8), le = (0, o.loadMessageRelaxed)(oe.loadRef().beginParse()); return { type: "sendMsg", mode: se, outMsg: le } } if (ae === v) return { type: "setCode", newCode: oe.loadRef() }; if (ae === F) { const se = oe.loadUint(8), le = (0, u.loadCurrencyCollection)(oe); return { type: "reserve", mode: se, currency: le } } if (ae === W) { const se = oe.loadUint(7), le = (0, f.loadLibRef)(oe); return { type: "changeLibrary", mode: se, libRef: le } } throw new Error(`Unknown out action tag 0x${ae.toString(16)}`) } OutList.loadOutAction = Q; function re(oe) { const ae = oe.reduce((se, le) => (0, l.beginCell)().storeRef(se).store(p(le)).endCell(), (0, l.beginCell)().endCell()); return se => { se.storeSlice(ae.beginParse()) } } OutList.storeOutList = re; function ne(oe) { const ae = []; for (; oe.remainingRefs;) { const se = oe.loadRef(); ae.push(Q(oe)), oe = se.beginParse() } return ae.reverse() } return OutList.loadOutList = ne, OutList } var CommonMessageInfo = {}, hasRequiredCommonMessageInfo; function requireCommonMessageInfo() { if (hasRequiredCommonMessageInfo) return CommonMessageInfo; hasRequiredCommonMessageInfo = 1, Object.defineProperty(CommonMessageInfo, "__esModule", { value: !0 }), CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0; const o = requireCurrencyCollection(); function l(f) { if (!f.loadBit()) { const I = f.loadBit(), F = f.loadBit(), B = f.loadBit(), W = f.loadAddress(), Z = f.loadAddress(), Q = (0, o.loadCurrencyCollection)(f), re = f.loadCoins(), ne = f.loadCoins(), oe = f.loadUintBig(64), ae = f.loadUint(32); return { type: "internal", ihrDisabled: I, bounce: F, bounced: B, src: W, dest: Z, value: Q, ihrFee: re, forwardFee: ne, createdLt: oe, createdAt: ae } } if (!f.loadBit()) { const I = f.loadMaybeExternalAddress(), F = f.loadAddress(), B = f.loadCoins(); return { type: "external-in", src: I, dest: F, importFee: B } } const p = f.loadAddress(), d = f.loadMaybeExternalAddress(), m = f.loadUintBig(64), v = f.loadUint(32); return { type: "external-out", src: p, dest: d, createdLt: m, createdAt: v } } CommonMessageInfo.loadCommonMessageInfo = l; function u(f) { return p => { if (f.type === "internal") p.storeBit(0), p.storeBit(f.ihrDisabled), p.storeBit(f.bounce), p.storeBit(f.bounced), p.storeAddress(f.src), p.storeAddress(f.dest), p.store((0, o.storeCurrencyCollection)(f.value)), p.storeCoins(f.ihrFee), p.storeCoins(f.forwardFee), p.storeUint(f.createdLt, 64), p.storeUint(f.createdAt, 32); else if (f.type === "external-in") p.storeBit(1), p.storeBit(0), p.storeAddress(f.src), p.storeAddress(f.dest), p.storeCoins(f.importFee); else if (f.type === "external-out") p.storeBit(1), p.storeBit(1), p.storeAddress(f.src), p.storeAddress(f.dest), p.storeUint(f.createdLt, 64), p.storeUint(f.createdAt, 32); else throw new Error("Unknown CommonMessageInfo type") } } return CommonMessageInfo.storeCommonMessageInfo = u, CommonMessageInfo } var ComputeSkipReason = {}, hasRequiredComputeSkipReason; function requireComputeSkipReason() { if (hasRequiredComputeSkipReason) return ComputeSkipReason; hasRequiredComputeSkipReason = 1, Object.defineProperty(ComputeSkipReason, "__esModule", { value: !0 }), ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0; function o(u) { let f = u.loadUint(2); if (f === 0) return "no-state"; if (f === 1) return "bad-state"; if (f === 2) return "no-gas"; throw new Error(`Unknown ComputeSkipReason: ${f}`) } ComputeSkipReason.loadComputeSkipReason = o; function l(u) { return f => { if (u === "no-state") f.storeUint(0, 2); else if (u === "bad-state") f.storeUint(1, 2); else if (u === "no-gas") f.storeUint(2, 2); else throw new Error(`Unknown ComputeSkipReason: ${u}`) } } return ComputeSkipReason.storeComputeSkipReason = l, ComputeSkipReason } var DepthBalanceInfo = {}, hasRequiredDepthBalanceInfo; function requireDepthBalanceInfo() { if (hasRequiredDepthBalanceInfo) return DepthBalanceInfo; hasRequiredDepthBalanceInfo = 1, Object.defineProperty(DepthBalanceInfo, "__esModule", { value: !0 }), DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0; const o = requireCurrencyCollection(); function l(f) { return { splitDepth: f.loadUint(5), balance: (0, o.loadCurrencyCollection)(f) } } DepthBalanceInfo.loadDepthBalanceInfo = l; function u(f) { return p => { p.storeUint(f.splitDepth, 5), p.store((0, o.storeCurrencyCollection)(f.balance)) } } return DepthBalanceInfo.storeDepthBalanceInfo = u, DepthBalanceInfo } var HashUpdate = {}, hasRequiredHashUpdate; function requireHashUpdate() { if (hasRequiredHashUpdate) return HashUpdate; hasRequiredHashUpdate = 1, Object.defineProperty(HashUpdate, "__esModule", { value: !0 }), HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0; function o(u) { if (u.loadUint(8) !== 114) throw Error("Invalid data"); const f = u.loadBuffer(32), p = u.loadBuffer(32); return { oldHash: f, newHash: p } } HashUpdate.loadHashUpdate = o; function l(u) { return f => { f.storeUint(114, 8), f.storeBuffer(u.oldHash), f.storeBuffer(u.newHash) } } return HashUpdate.storeHashUpdate = l, HashUpdate } var MasterchainStateExtra = {}, hasRequiredMasterchainStateExtra; function requireMasterchainStateExtra() { if (hasRequiredMasterchainStateExtra) return MasterchainStateExtra; hasRequiredMasterchainStateExtra = 1, Object.defineProperty(MasterchainStateExtra, "__esModule", { value: !0 }), MasterchainStateExtra.loadMasterchainStateExtra = void 0; const o = requireDictionary(), l = requireCurrencyCollection(); function u(f) { if (f.loadUint(16) !== 52262) throw Error("Invalid data"); f.loadBit() && f.loadRef(); let p = f.loadUintBig(256), d = o.Dictionary.load(o.Dictionary.Keys.Int(32), o.Dictionary.Values.Cell(), f); const m = (0, l.loadCurrencyCollection)(f); return { config: d, configAddress: p, globalBalance: m } } return MasterchainStateExtra.loadMasterchainStateExtra = u, MasterchainStateExtra } var Message = {}, hasRequiredMessage; function requireMessage() { if (hasRequiredMessage) return Message; hasRequiredMessage = 1, Object.defineProperty(Message, "__esModule", { value: !0 }), Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0; const o = requireBuilder$1(), l = requireCommonMessageInfo(), u = requireStateInit(); function f(d) { const m = (0, l.loadCommonMessageInfo)(d); let v = null; d.loadBit() && (d.loadBit() ? v = (0, u.loadStateInit)(d.loadRef().beginParse()) : v = (0, u.loadStateInit)(d)); const I = d.loadBit() ? d.loadRef() : d.asCell(); return { info: m, init: v, body: I } } Message.loadMessage = f; function p(d, m) { return v => { if (v.store((0, l.storeCommonMessageInfo)(d.info)), d.init) { v.storeBit(!0); let F = (0, o.beginCell)().store((0, u.storeStateInit)(d.init)), B = !1; m && m.forceRef ? B = !0 : B = v.availableBits - 2 < F.bits + d.body.bits.length, B ? (v.storeBit(!0), v.storeRef(F)) : (v.storeBit(!1), v.storeBuilder(F)) } else v.storeBit(!1); let I = !1; m && m.forceRef ? I = !0 : I = v.availableBits - 1 < d.body.bits.length || v.refs + d.body.refs.length > 4, I ? (v.storeBit(!0), v.storeRef(d.body)) : (v.storeBit(!1), v.storeBuilder(d.body.asBuilder())) } } return Message.storeMessage = p, Message.MessageValue = { serialize(d, m) { m.storeRef((0, o.beginCell)().store(p(d))) }, parse(d) { return f(d.loadRef().beginParse()) } }, Message } var SendMode = {}, hasRequiredSendMode; function requireSendMode() { if (hasRequiredSendMode) return SendMode; hasRequiredSendMode = 1, Object.defineProperty(SendMode, "__esModule", { value: !0 }), SendMode.SendMode = void 0; var o; return function (l) { l[l.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE", l[l.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE", l[l.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO", l[l.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY", l[l.IGNORE_ERRORS = 2] = "IGNORE_ERRORS", l[l.NONE = 0] = "NONE" }(o || (SendMode.SendMode = o = {})), SendMode } var ReserveMode = {}, hasRequiredReserveMode; function requireReserveMode() { if (hasRequiredReserveMode) return ReserveMode; hasRequiredReserveMode = 1, Object.defineProperty(ReserveMode, "__esModule", { value: !0 }), ReserveMode.ReserveMode = void 0; var o; return function (l) { l[l.THIS_AMOUNT = 0] = "THIS_AMOUNT", l[l.LEAVE_THIS_AMOUNT = 1] = "LEAVE_THIS_AMOUNT", l[l.AT_MOST_THIS_AMOUNT = 2] = "AT_MOST_THIS_AMOUNT", l[l.LEAVE_MAX_THIS_AMOUNT = 3] = "LEAVE_MAX_THIS_AMOUNT", l[l.BEFORE_BALANCE_PLUS_THIS_AMOUNT = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT", l[l.LEAVE_BBALANCE_PLUS_THIS_AMOUNT = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT", l[l.BEFORE_BALANCE_MINUS_THIS_AMOUNT = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT", l[l.LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT" }(o || (ReserveMode.ReserveMode = o = {})), ReserveMode } var ShardAccount = {}, hasRequiredShardAccount; function requireShardAccount() { if (hasRequiredShardAccount) return ShardAccount; hasRequiredShardAccount = 1, Object.defineProperty(ShardAccount, "__esModule", { value: !0 }), ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0; const o = requireBuilder$1(), l = requireAccount(); function u(p) { let d = p.loadRef(), m; if (!d.isExotic) { let v = d.beginParse(); v.loadBit() && (m = (0, l.loadAccount)(v)) } return { account: m, lastTransactionHash: p.loadUintBig(256), lastTransactionLt: p.loadUintBig(64) } } ShardAccount.loadShardAccount = u; function f(p) { return d => { p.account ? d.storeRef((0, o.beginCell)().storeBit(!0).store((0, l.storeAccount)(p.account))) : d.storeRef((0, o.beginCell)().storeBit(!1)), d.storeUint(p.lastTransactionHash, 256), d.storeUint(p.lastTransactionLt, 64) } } return ShardAccount.storeShardAccount = f, ShardAccount } var ShardAccounts = {}, hasRequiredShardAccounts; function requireShardAccounts() { return hasRequiredShardAccounts || (hasRequiredShardAccounts = 1, function (o) { Object.defineProperty(o, "__esModule", { value: !0 }), o.storeShardAccounts = o.loadShardAccounts = o.ShardAccountRefValue = void 0; const l = requireDictionary(), u = requireDepthBalanceInfo(), f = requireShardAccount(); o.ShardAccountRefValue = { parse: m => { let v = (0, u.loadDepthBalanceInfo)(m), I = (0, f.loadShardAccount)(m); return { depthBalanceInfo: v, shardAccount: I } }, serialize(m, v) { v.store((0, u.storeDepthBalanceInfo)(m.depthBalanceInfo)), v.store((0, f.storeShardAccount)(m.shardAccount)) } }; function p(m) { return l.Dictionary.load(l.Dictionary.Keys.BigUint(256), o.ShardAccountRefValue, m) } o.loadShardAccounts = p; function d(m) { return v => { v.storeDict(m) } } o.storeShardAccounts = d }(ShardAccounts)), ShardAccounts } var ShardIdent = {}, hasRequiredShardIdent; function requireShardIdent() { if (hasRequiredShardIdent) return ShardIdent; hasRequiredShardIdent = 1, Object.defineProperty(ShardIdent, "__esModule", { value: !0 }), ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0; function o(u) { if (u.loadUint(2) !== 0) throw Error("Invalid data"); return { shardPrefixBits: u.loadUint(6), workchainId: u.loadInt(32), shardPrefix: u.loadUintBig(64) } } ShardIdent.loadShardIdent = o; function l(u) { return f => { f.storeUint(0, 2), f.storeUint(u.shardPrefixBits, 6), f.storeInt(u.workchainId, 32), f.storeUint(u.shardPrefix, 64) } } return ShardIdent.storeShardIdent = l, ShardIdent } var ShardStateUnsplit = {}, hasRequiredShardStateUnsplit; function requireShardStateUnsplit() { if (hasRequiredShardStateUnsplit) return ShardStateUnsplit; hasRequiredShardStateUnsplit = 1, Object.defineProperty(ShardStateUnsplit, "__esModule", { value: !0 }), ShardStateUnsplit.loadShardStateUnsplit = void 0; const o = requireMasterchainStateExtra(), l = requireShardAccounts(), u = requireShardIdent(); function f(p) { if (p.loadUint(32) !== 2418257890) throw Error("Invalid data"); let d = p.loadInt(32), m = (0, u.loadShardIdent)(p), v = p.loadUint(32), I = p.loadUint(32), F = p.loadUint(32), B = p.loadUintBig(64), W = p.loadUint(32); p.loadRef(); let Z = p.loadBit(), Q = p.loadRef(), re; Q.isExotic || (re = (0, l.loadShardAccounts)(Q.beginParse())), p.loadRef(); let ne = p.loadBit(), oe = null; if (ne) { let ae = p.loadRef(); ae.isExotic || (oe = (0, o.loadMasterchainStateExtra)(ae.beginParse())) } return { globalId: d, shardId: m, seqno: v, vertSeqNo: I, genUtime: F, genLt: B, minRefMcSeqno: W, beforeSplit: Z, accounts: re, extras: oe } } return ShardStateUnsplit.loadShardStateUnsplit = f, ShardStateUnsplit } var SplitMergeInfo = {}, hasRequiredSplitMergeInfo; function requireSplitMergeInfo() { if (hasRequiredSplitMergeInfo) return SplitMergeInfo; hasRequiredSplitMergeInfo = 1, Object.defineProperty(SplitMergeInfo, "__esModule", { value: !0 }), SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0; function o(u) { let f = u.loadUint(6), p = u.loadUint(6), d = u.loadUintBig(256), m = u.loadUintBig(256); return { currentShardPrefixLength: f, accountSplitDepth: p, thisAddress: d, siblingAddress: m } } SplitMergeInfo.loadSplitMergeInfo = o; function l(u) { return f => { f.storeUint(u.currentShardPrefixLength, 6), f.storeUint(u.accountSplitDepth, 6), f.storeUint(u.thisAddress, 256), f.storeUint(u.siblingAddress, 256) } } return SplitMergeInfo.storeSplitMergeInfo = l, SplitMergeInfo } var StorageUsedShort = {}, hasRequiredStorageUsedShort; function requireStorageUsedShort() { if (hasRequiredStorageUsedShort) return StorageUsedShort; hasRequiredStorageUsedShort = 1, Object.defineProperty(StorageUsedShort, "__esModule", { value: !0 }), StorageUsedShort.storeStorageUsedShort = StorageUsedShort.loadStorageUsedShort = void 0; function o(u) { let f = u.loadVarUintBig(3), p = u.loadVarUintBig(3); return { cells: f, bits: p } } StorageUsedShort.loadStorageUsedShort = o; function l(u) { return f => { f.storeVarUint(u.cells, 3), f.storeVarUint(u.bits, 3) } } return StorageUsedShort.storeStorageUsedShort = l, StorageUsedShort } var Transaction = {}, TransactionDescription = {}, TransactionActionPhase = {}, hasRequiredTransactionActionPhase; function requireTransactionActionPhase() { if (hasRequiredTransactionActionPhase) return TransactionActionPhase; hasRequiredTransactionActionPhase = 1, Object.defineProperty(TransactionActionPhase, "__esModule", { value: !0 }), TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0; const o = requireAccountStatusChange(), l = requireStorageUsedShort(); function u(p) { let d = p.loadBit(), m = p.loadBit(), v = p.loadBit(), I = (0, o.loadAccountStatusChange)(p), F = p.loadBit() ? p.loadCoins() : void 0, B = p.loadBit() ? p.loadCoins() : void 0, W = p.loadInt(32), Z = p.loadBit() ? p.loadInt(32) : void 0, Q = p.loadUint(16), re = p.loadUint(16), ne = p.loadUint(16), oe = p.loadUint(16), ae = p.loadUintBig(256), se = (0, l.loadStorageUsedShort)(p); return { success: d, valid: m, noFunds: v, statusChange: I, totalFwdFees: F, totalActionFees: B, resultCode: W, resultArg: Z, totalActions: Q, specActions: re, skippedActions: ne, messagesCreated: oe, actionListHash: ae, totalMessageSize: se } } TransactionActionPhase.loadTransactionActionPhase = u; function f(p) { return d => { d.storeBit(p.success), d.storeBit(p.valid), d.storeBit(p.noFunds), d.store((0, o.storeAccountStatusChange)(p.statusChange)), d.storeMaybeCoins(p.totalFwdFees), d.storeMaybeCoins(p.totalActionFees), d.storeInt(p.resultCode, 32), d.storeMaybeInt(p.resultArg, 32), d.storeUint(p.totalActions, 16), d.storeUint(p.specActions, 16), d.storeUint(p.skippedActions, 16), d.storeUint(p.messagesCreated, 16), d.storeUint(p.actionListHash, 256), d.store((0, l.storeStorageUsedShort)(p.totalMessageSize)) } } return TransactionActionPhase.storeTransactionActionPhase = f, TransactionActionPhase } var TransactionBouncePhase = {}, hasRequiredTransactionBouncePhase; function requireTransactionBouncePhase() { if (hasRequiredTransactionBouncePhase) return TransactionBouncePhase; hasRequiredTransactionBouncePhase = 1, Object.defineProperty(TransactionBouncePhase, "__esModule", { value: !0 }), TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0; const o = requireStorageUsedShort(); function l(f) { if (f.loadBit()) { let p = (0, o.loadStorageUsedShort)(f), d = f.loadCoins(), m = f.loadCoins(); return { type: "ok", messageSize: p, messageFees: d, forwardFees: m } } if (f.loadBit()) { let p = (0, o.loadStorageUsedShort)(f), d = f.loadCoins(); return { type: "no-funds", messageSize: p, requiredForwardFees: d } } return { type: "negative-funds" } } TransactionBouncePhase.loadTransactionBouncePhase = l; function u(f) { return p => { if (f.type === "ok") p.storeBit(!0), p.store((0, o.storeStorageUsedShort)(f.messageSize)), p.storeCoins(f.messageFees), p.storeCoins(f.forwardFees); else if (f.type === "negative-funds") p.storeBit(!1), p.storeBit(!1); else if (f.type === "no-funds") p.storeBit(!1), p.storeBit(!0), p.store((0, o.storeStorageUsedShort)(f.messageSize)), p.storeCoins(f.requiredForwardFees); else throw new Error("Invalid TransactionBouncePhase type") } } return TransactionBouncePhase.storeTransactionBouncePhase = u, TransactionBouncePhase } var TransactionComputePhase = {}, hasRequiredTransactionComputePhase; function requireTransactionComputePhase() { if (hasRequiredTransactionComputePhase) return TransactionComputePhase; hasRequiredTransactionComputePhase = 1, Object.defineProperty(TransactionComputePhase, "__esModule", { value: !0 }), TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0; const o = requireBuilder$1(), l = requireComputeSkipReason(); function u(p) { if (!p.loadBit()) return { type: "skipped", reason: (0, l.loadComputeSkipReason)(p) }; let d = p.loadBit(), m = p.loadBit(), v = p.loadBit(), I = p.loadCoins(); const F = p.loadRef().beginParse(); let B = F.loadVarUintBig(3), W = F.loadVarUintBig(3), Z = F.loadBit() ? F.loadVarUintBig(2) : void 0, Q = F.loadUint(8), re = F.loadInt(32), ne = F.loadBit() ? F.loadInt(32) : void 0, oe = F.loadUint(32), ae = F.loadUintBig(256), se = F.loadUintBig(256); return { type: "vm", success: d, messageStateUsed: m, accountActivated: v, gasFees: I, gasUsed: B, gasLimit: W, gasCredit: Z, mode: Q, exitCode: re, exitArg: ne, vmSteps: oe, vmInitStateHash: ae, vmFinalStateHash: se } } TransactionComputePhase.loadTransactionComputePhase = u; function f(p) { return d => { if (p.type === "skipped") { d.storeBit(0), d.store((0, l.storeComputeSkipReason)(p.reason)); return } d.storeBit(1), d.storeBit(p.success), d.storeBit(p.messageStateUsed), d.storeBit(p.accountActivated), d.storeCoins(p.gasFees), d.storeRef((0, o.beginCell)().storeVarUint(p.gasUsed, 3).storeVarUint(p.gasLimit, 3).store(m => p.gasCredit !== void 0 && p.gasCredit !== null ? m.storeBit(1).storeVarUint(p.gasCredit, 2) : m.storeBit(0)).storeUint(p.mode, 8).storeInt(p.exitCode, 32).store(m => p.exitArg !== void 0 && p.exitArg !== null ? m.storeBit(1).storeInt(p.exitArg, 32) : m.storeBit(0)).storeUint(p.vmSteps, 32).storeUint(p.vmInitStateHash, 256).storeUint(p.vmFinalStateHash, 256).endCell()) } } return TransactionComputePhase.storeTransactionComputePhase = f, TransactionComputePhase } var TransactionCreditPhase = {}, hasRequiredTransactionCreditPhase; function requireTransactionCreditPhase() { if (hasRequiredTransactionCreditPhase) return TransactionCreditPhase; hasRequiredTransactionCreditPhase = 1, Object.defineProperty(TransactionCreditPhase, "__esModule", { value: !0 }), TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0; const o = requireCurrencyCollection(); function l(f) { const p = f.loadBit() ? f.loadCoins() : void 0, d = (0, o.loadCurrencyCollection)(f); return { dueFeesColelcted: p, credit: d } } TransactionCreditPhase.loadTransactionCreditPhase = l; function u(f) { return p => { f.dueFeesColelcted === null || f.dueFeesColelcted === void 0 ? p.storeBit(!1) : (p.storeBit(!0), p.storeCoins(f.dueFeesColelcted)), p.store((0, o.storeCurrencyCollection)(f.credit)) } } return TransactionCreditPhase.storeTransactionCreditPhase = u, TransactionCreditPhase } var TransactionStoragePhase = {}, hasRequiredTransactionStoragePhase; function requireTransactionStoragePhase() { if (hasRequiredTransactionStoragePhase) return TransactionStoragePhase; hasRequiredTransactionStoragePhase = 1, Object.defineProperty(TransactionStoragePhase, "__esModule", { value: !0 }), TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0; const o = requireAccountStatusChange(); function l(f) { const p = f.loadCoins(); let d; f.loadBit() && (d = f.loadCoins()); const m = (0, o.loadAccountStatusChange)(f); return { storageFeesCollected: p, storageFeesDue: d, statusChange: m } } TransactionStoragePhase.loadTransactionStoragePhase = l; function u(f) { return p => { p.storeCoins(f.storageFeesCollected), f.storageFeesDue === null || f.storageFeesDue === void 0 ? p.storeBit(!1) : (p.storeBit(!0), p.storeCoins(f.storageFeesDue)), p.store((0, o.storeAccountStatusChange)(f.statusChange)) } } return TransactionStoragePhase.storeTransactionsStoragePhase = u, TransactionStoragePhase } var hasRequiredTransactionDescription; function requireTransactionDescription() { if (hasRequiredTransactionDescription) return TransactionDescription; hasRequiredTransactionDescription = 1, Object.defineProperty(TransactionDescription, "__esModule", { value: !0 }), TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0; const o = requireBuilder$1(), l = requireSplitMergeInfo(), u = requireTransaction(), f = requireTransactionActionPhase(), p = requireTransactionBouncePhase(), d = requireTransactionComputePhase(), m = requireTransactionCreditPhase(), v = requireTransactionStoragePhase(); function I(B) { let W = B.loadUint(4); if (W === 0) { const Z = B.loadBit(); let Q; B.loadBit() && (Q = (0, v.loadTransactionStoragePhase)(B)); let re; B.loadBit() && (re = (0, m.loadTransactionCreditPhase)(B)); let ne = (0, d.loadTransactionComputePhase)(B), oe; B.loadBit() && (oe = (0, f.loadTransactionActionPhase)(B.loadRef().beginParse())); let ae = B.loadBit(), se; B.loadBit() && (se = (0, p.loadTransactionBouncePhase)(B)); const le = B.loadBit(); return { type: "generic", creditFirst: Z, storagePhase: Q, creditPhase: re, computePhase: ne, actionPhase: oe, bouncePhase: se, aborted: ae, destroyed: le } } if (W === 1) return { type: "storage", storagePhase: (0, v.loadTransactionStoragePhase)(B) }; if (W === 2 || W === 3) { const Z = W === 3; let Q = (0, v.loadTransactionStoragePhase)(B), re = (0, d.loadTransactionComputePhase)(B), ne; B.loadBit() && (ne = (0, f.loadTransactionActionPhase)(B.loadRef().beginParse())); const oe = B.loadBit(), ae = B.loadBit(); return { type: "tick-tock", isTock: Z, storagePhase: Q, computePhase: re, actionPhase: ne, aborted: oe, destroyed: ae } } if (W === 4) { let Z = (0, l.loadSplitMergeInfo)(B), Q; B.loadBit() && (Q = (0, v.loadTransactionStoragePhase)(B)); let re = (0, d.loadTransactionComputePhase)(B), ne; B.loadBit() && (ne = (0, f.loadTransactionActionPhase)(B.loadRef().beginParse())); const oe = B.loadBit(), ae = B.loadBit(); return { type: "split-prepare", splitInfo: Z, storagePhase: Q, computePhase: re, actionPhase: ne, aborted: oe, destroyed: ae } } if (W === 5) { let Z = (0, l.loadSplitMergeInfo)(B), Q = (0, u.loadTransaction)(B.loadRef().beginParse()); const re = B.loadBit(); return { type: "split-install", splitInfo: Z, prepareTransaction: Q, installed: re } } throw Error(`Unsupported transaction description type ${W}`) } TransactionDescription.loadTransactionDescription = I; function F(B) { return W => { if (B.type === "generic") W.storeUint(0, 4), W.storeBit(B.creditFirst), B.storagePhase ? (W.storeBit(!0), W.store((0, v.storeTransactionsStoragePhase)(B.storagePhase))) : W.storeBit(!1), B.creditPhase ? (W.storeBit(!0), W.store((0, m.storeTransactionCreditPhase)(B.creditPhase))) : W.storeBit(!1), W.store((0, d.storeTransactionComputePhase)(B.computePhase)), B.actionPhase ? (W.storeBit(!0), W.storeRef((0, o.beginCell)().store((0, f.storeTransactionActionPhase)(B.actionPhase)))) : W.storeBit(!1), W.storeBit(B.aborted), B.bouncePhase ? (W.storeBit(!0), W.store((0, p.storeTransactionBouncePhase)(B.bouncePhase))) : W.storeBit(!1), W.storeBit(B.destroyed); else if (B.type === "storage") W.storeUint(1, 4), W.store((0, v.storeTransactionsStoragePhase)(B.storagePhase)); else if (B.type === "tick-tock") W.storeUint(B.isTock ? 3 : 2, 4), W.store((0, v.storeTransactionsStoragePhase)(B.storagePhase)), W.store((0, d.storeTransactionComputePhase)(B.computePhase)), B.actionPhase ? (W.storeBit(!0), W.storeRef((0, o.beginCell)().store((0, f.storeTransactionActionPhase)(B.actionPhase)))) : W.storeBit(!1), W.storeBit(B.aborted), W.storeBit(B.destroyed); else if (B.type === "split-prepare") W.storeUint(4, 4), W.store((0, l.storeSplitMergeInfo)(B.splitInfo)), B.storagePhase ? (W.storeBit(!0), W.store((0, v.storeTransactionsStoragePhase)(B.storagePhase))) : W.storeBit(!1), W.store((0, d.storeTransactionComputePhase)(B.computePhase)), B.actionPhase ? (W.storeBit(!0), W.store((0, f.storeTransactionActionPhase)(B.actionPhase))) : W.storeBit(!1), W.storeBit(B.aborted), W.storeBit(B.destroyed); else if (B.type === "split-install") W.storeUint(5, 4), W.store((0, l.storeSplitMergeInfo)(B.splitInfo)), W.storeRef((0, o.beginCell)().store((0, u.storeTransaction)(B.prepareTransaction))), W.storeBit(B.installed); else throw Error(`Unsupported transaction description type ${B.type}`) } } return TransactionDescription.storeTransactionDescription = F, TransactionDescription } var hasRequiredTransaction; function requireTransaction() { if (hasRequiredTransaction) return Transaction; hasRequiredTransaction = 1, Object.defineProperty(Transaction, "__esModule", { value: !0 }), Transaction.storeTransaction = Transaction.loadTransaction = void 0; const o = requireBuilder$1(), l = requireDictionary(), u = requireAccountStatus(), f = requireCurrencyCollection(), p = requireHashUpdate(), d = requireMessage(), m = requireTransactionDescription(); function v(F) { let B = F.asCell(); if (F.loadUint(4) !== 7) throw Error("Invalid data"); let W = F.loadUintBig(256), Z = F.loadUintBig(64), Q = F.loadUintBig(256), re = F.loadUintBig(64), ne = F.loadUint(32), oe = F.loadUint(15), ae = (0, u.loadAccountStatus)(F), se = (0, u.loadAccountStatus)(F), ue = F.loadRef().beginParse(), he = ue.loadBit() ? (0, d.loadMessage)(ue.loadRef().beginParse()) : void 0, pe = ue.loadDict(l.Dictionary.Keys.Uint(15), d.MessageValue); ue.endParse(); let ve = (0, f.loadCurrencyCollection)(F), _e = (0, p.loadHashUpdate)(F.loadRef().beginParse()), Se = (0, m.loadTransactionDescription)(F.loadRef().beginParse()); return { address: W, lt: Z, prevTransactionHash: Q, prevTransactionLt: re, now: ne, outMessagesCount: oe, oldStatus: ae, endStatus: se, inMessage: he, outMessages: pe, totalFees: ve, stateUpdate: _e, description: Se, raw: B, hash: () => B.hash() } } Transaction.loadTransaction = v; function I(F) { return B => { B.storeUint(7, 4), B.storeUint(F.address, 256), B.storeUint(F.lt, 64), B.storeUint(F.prevTransactionHash, 256), B.storeUint(F.prevTransactionLt, 64), B.storeUint(F.now, 32), B.storeUint(F.outMessagesCount, 15), B.store((0, u.storeAccountStatus)(F.oldStatus)), B.store((0, u.storeAccountStatus)(F.endStatus)); let W = (0, o.beginCell)(); F.inMessage ? (W.storeBit(!0), W.storeRef((0, o.beginCell)().store((0, d.storeMessage)(F.inMessage)))) : W.storeBit(!1), W.storeDict(F.outMessages), B.storeRef(W), B.store((0, f.storeCurrencyCollection)(F.totalFees)), B.storeRef((0, o.beginCell)().store((0, p.storeHashUpdate)(F.stateUpdate))), B.storeRef((0, o.beginCell)().store((0, m.storeTransactionDescription)(F.description))) } } return Transaction.storeTransaction = I, Transaction } var hasRequired_export; function require_export() { return hasRequired_export || (hasRequired_export = 1, function (o) { Object.defineProperty(o, "__esModule", { value: !0 }), o.storeSplitMergeInfo = o.loadSplitMergeInfo = o.storeLibRef = o.loadLibRef = o.storeSimpleLibrary = o.loadSimpleLibrary = o.loadShardStateUnsplit = o.storeShardIdent = o.loadShardIdent = o.storeShardAccounts = o.loadShardAccounts = o.ShardAccountRefValue = o.storeShardAccount = o.loadShardAccount = o.ReserveMode = o.SendMode = o.storeMessageRelaxed = o.loadMessageRelaxed = o.storeMessage = o.loadMessage = o.loadMasterchainStateExtra = o.storeHashUpdate = o.loadHashUpdate = o.storeDepthBalanceInfo = o.loadDepthBalanceInfo = o.storeCurrencyCollection = o.loadCurrencyCollection = o.storeComputeSkipReason = o.loadComputeSkipReason = o.storeCommonMessageInfoRelaxed = o.loadCommonMessageInfoRelaxed = o.storeCommonMessageInfo = o.loadCommonMessageInfo = o.storeOutList = o.loadOutList = o.storeOutAction = o.loadOutAction = o.storeAccountStorage = o.loadAccountStorage = o.storeAccountStatusChange = o.loadAccountStatusChange = o.storeAccountStatus = o.loadAccountStatus = o.storeAccountState = o.loadAccountState = o.storeAccount = o.loadAccount = o.comment = o.external = o.internal = void 0, o.storeTransactionsStoragePhase = o.loadTransactionStoragePhase = o.storeTransactionDescription = o.loadTransactionDescription = o.storeTransactionCreditPhase = o.loadTransactionCreditPhase = o.storeTransactionComputePhase = o.loadTransactionComputePhase = o.storeTransactionBouncePhase = o.loadTransactionBouncePhase = o.storeTransactionActionPhase = o.loadTransactionActionPhase = o.storeTransaction = o.loadTransaction = o.storeTickTock = o.loadTickTock = o.storeStorageUsedShort = o.loadStorageUsedShort = o.storeStorageUsed = o.loadStorageUsed = o.storeStorageInfo = o.loadStorageInfo = o.storeStateInit = o.loadStateInit = void 0; var l = require_helpers(); Object.defineProperty(o, "internal", { enumerable: !0, get: function () { return l.internal } }), Object.defineProperty(o, "external", { enumerable: !0, get: function () { return l.external } }), Object.defineProperty(o, "comment", { enumerable: !0, get: function () { return l.comment } }); var u = requireAccount(); Object.defineProperty(o, "loadAccount", { enumerable: !0, get: function () { return u.loadAccount } }), Object.defineProperty(o, "storeAccount", { enumerable: !0, get: function () { return u.storeAccount } }); var f = requireAccountState(); Object.defineProperty(o, "loadAccountState", { enumerable: !0, get: function () { return f.loadAccountState } }), Object.defineProperty(o, "storeAccountState", { enumerable: !0, get: function () { return f.storeAccountState } }); var p = requireAccountStatus(); Object.defineProperty(o, "loadAccountStatus", { enumerable: !0, get: function () { return p.loadAccountStatus } }), Object.defineProperty(o, "storeAccountStatus", { enumerable: !0, get: function () { return p.storeAccountStatus } }); var d = requireAccountStatusChange(); Object.defineProperty(o, "loadAccountStatusChange", { enumerable: !0, get: function () { return d.loadAccountStatusChange } }), Object.defineProperty(o, "storeAccountStatusChange", { enumerable: !0, get: function () { return d.storeAccountStatusChange } }); var m = requireAccountStorage(); Object.defineProperty(o, "loadAccountStorage", { enumerable: !0, get: function () { return m.loadAccountStorage } }), Object.defineProperty(o, "storeAccountStorage", { enumerable: !0, get: function () { return m.storeAccountStorage } }); var v = requireOutList(); Object.defineProperty(o, "loadOutAction", { enumerable: !0, get: function () { return v.loadOutAction } }), Object.defineProperty(o, "storeOutAction", { enumerable: !0, get: function () { return v.storeOutAction } }), Object.defineProperty(o, "loadOutList", { enumerable: !0, get: function () { return v.loadOutList } }), Object.defineProperty(o, "storeOutList", { enumerable: !0, get: function () { return v.storeOutList } }); var I = requireCommonMessageInfo(); Object.defineProperty(o, "loadCommonMessageInfo", { enumerable: !0, get: function () { return I.loadCommonMessageInfo } }), Object.defineProperty(o, "storeCommonMessageInfo", { enumerable: !0, get: function () { return I.storeCommonMessageInfo } }); var F = requireCommonMessageInfoRelaxed(); Object.defineProperty(o, "loadCommonMessageInfoRelaxed", { enumerable: !0, get: function () { return F.loadCommonMessageInfoRelaxed } }), Object.defineProperty(o, "storeCommonMessageInfoRelaxed", { enumerable: !0, get: function () { return F.storeCommonMessageInfoRelaxed } }); var B = requireComputeSkipReason(); Object.defineProperty(o, "loadComputeSkipReason", { enumerable: !0, get: function () { return B.loadComputeSkipReason } }), Object.defineProperty(o, "storeComputeSkipReason", { enumerable: !0, get: function () { return B.storeComputeSkipReason } }); var W = requireCurrencyCollection(); Object.defineProperty(o, "loadCurrencyCollection", { enumerable: !0, get: function () { return W.loadCurrencyCollection } }), Object.defineProperty(o, "storeCurrencyCollection", { enumerable: !0, get: function () { return W.storeCurrencyCollection } }); var Z = requireDepthBalanceInfo(); Object.defineProperty(o, "loadDepthBalanceInfo", { enumerable: !0, get: function () { return Z.loadDepthBalanceInfo } }), Object.defineProperty(o, "storeDepthBalanceInfo", { enumerable: !0, get: function () { return Z.storeDepthBalanceInfo } }); var Q = requireHashUpdate(); Object.defineProperty(o, "loadHashUpdate", { enumerable: !0, get: function () { return Q.loadHashUpdate } }), Object.defineProperty(o, "storeHashUpdate", { enumerable: !0, get: function () { return Q.storeHashUpdate } }); var re = requireMasterchainStateExtra(); Object.defineProperty(o, "loadMasterchainStateExtra", { enumerable: !0, get: function () { return re.loadMasterchainStateExtra } }); var ne = requireMessage(); Object.defineProperty(o, "loadMessage", { enumerable: !0, get: function () { return ne.loadMessage } }), Object.defineProperty(o, "storeMessage", { enumerable: !0, get: function () { return ne.storeMessage } }); var oe = requireMessageRelaxed(); Object.defineProperty(o, "loadMessageRelaxed", { enumerable: !0, get: function () { return oe.loadMessageRelaxed } }), Object.defineProperty(o, "storeMessageRelaxed", { enumerable: !0, get: function () { return oe.storeMessageRelaxed } }); var ae = requireSendMode(); Object.defineProperty(o, "SendMode", { enumerable: !0, get: function () { return ae.SendMode } }); var se = requireReserveMode(); Object.defineProperty(o, "ReserveMode", { enumerable: !0, get: function () { return se.ReserveMode } }); var le = requireShardAccount(); Object.defineProperty(o, "loadShardAccount", { enumerable: !0, get: function () { return le.loadShardAccount } }), Object.defineProperty(o, "storeShardAccount", { enumerable: !0, get: function () { return le.storeShardAccount } }); var ue = requireShardAccounts(); Object.defineProperty(o, "ShardAccountRefValue", { enumerable: !0, get: function () { return ue.ShardAccountRefValue } }), Object.defineProperty(o, "loadShardAccounts", { enumerable: !0, get: function () { return ue.loadShardAccounts } }), Object.defineProperty(o, "storeShardAccounts", { enumerable: !0, get: function () { return ue.storeShardAccounts } }); var he = requireShardIdent(); Object.defineProperty(o, "loadShardIdent", { enumerable: !0, get: function () { return he.loadShardIdent } }), Object.defineProperty(o, "storeShardIdent", { enumerable: !0, get: function () { return he.storeShardIdent } }); var pe = requireShardStateUnsplit(); Object.defineProperty(o, "loadShardStateUnsplit", { enumerable: !0, get: function () { return pe.loadShardStateUnsplit } }); var ve = requireSimpleLibrary(); Object.defineProperty(o, "loadSimpleLibrary", { enumerable: !0, get: function () { return ve.loadSimpleLibrary } }), Object.defineProperty(o, "storeSimpleLibrary", { enumerable: !0, get: function () { return ve.storeSimpleLibrary } }); var _e = requireLibRef(); Object.defineProperty(o, "loadLibRef", { enumerable: !0, get: function () { return _e.loadLibRef } }), Object.defineProperty(o, "storeLibRef", { enumerable: !0, get: function () { return _e.storeLibRef } }); var Se = requireSplitMergeInfo(); Object.defineProperty(o, "loadSplitMergeInfo", { enumerable: !0, get: function () { return Se.loadSplitMergeInfo } }), Object.defineProperty(o, "storeSplitMergeInfo", { enumerable: !0, get: function () { return Se.storeSplitMergeInfo } }); var $e = requireStateInit(); Object.defineProperty(o, "loadStateInit", { enumerable: !0, get: function () { return $e.loadStateInit } }), Object.defineProperty(o, "storeStateInit", { enumerable: !0, get: function () { return $e.storeStateInit } }); var ie = requireStorageInto(); Object.defineProperty(o, "loadStorageInfo", { enumerable: !0, get: function () { return ie.loadStorageInfo } }), Object.defineProperty(o, "storeStorageInfo", { enumerable: !0, get: function () { return ie.storeStorageInfo } }); var g = requireStorageUsed(); Object.defineProperty(o, "loadStorageUsed", { enumerable: !0, get: function () { return g.loadStorageUsed } }), Object.defineProperty(o, "storeStorageUsed", { enumerable: !0, get: function () { return g.storeStorageUsed } }); var P = requireStorageUsedShort(); Object.defineProperty(o, "loadStorageUsedShort", { enumerable: !0, get: function () { return P.loadStorageUsedShort } }), Object.defineProperty(o, "storeStorageUsedShort", { enumerable: !0, get: function () { return P.storeStorageUsedShort } }); var U = requireTickTock(); Object.defineProperty(o, "loadTickTock", { enumerable: !0, get: function () { return U.loadTickTock } }), Object.defineProperty(o, "storeTickTock", { enumerable: !0, get: function () { return U.storeTickTock } }); var K = requireTransaction(); Object.defineProperty(o, "loadTransaction", { enumerable: !0, get: function () { return K.loadTransaction } }), Object.defineProperty(o, "storeTransaction", { enumerable: !0, get: function () { return K.storeTransaction } }); var Y = requireTransactionActionPhase(); Object.defineProperty(o, "loadTransactionActionPhase", { enumerable: !0, get: function () { return Y.loadTransactionActionPhase } }), Object.defineProperty(o, "storeTransactionActionPhase", { enumerable: !0, get: function () { return Y.storeTransactionActionPhase } }); var te = requireTransactionBouncePhase(); Object.defineProperty(o, "loadTransactionBouncePhase", { enumerable: !0, get: function () { return te.loadTransactionBouncePhase } }), Object.defineProperty(o, "storeTransactionBouncePhase", { enumerable: !0, get: function () { return te.storeTransactionBouncePhase } }); var ee = requireTransactionComputePhase(); Object.defineProperty(o, "loadTransactionComputePhase", { enumerable: !0, get: function () { return ee.loadTransactionComputePhase } }), Object.defineProperty(o, "storeTransactionComputePhase", { enumerable: !0, get: function () { return ee.storeTransactionComputePhase } }); var G = requireTransactionCreditPhase(); Object.defineProperty(o, "loadTransactionCreditPhase", { enumerable: !0, get: function () { return G.loadTransactionCreditPhase } }), Object.defineProperty(o, "storeTransactionCreditPhase", { enumerable: !0, get: function () { return G.storeTransactionCreditPhase } }); var y = requireTransactionDescription(); Object.defineProperty(o, "loadTransactionDescription", { enumerable: !0, get: function () { return y.loadTransactionDescription } }), Object.defineProperty(o, "storeTransactionDescription", { enumerable: !0, get: function () { return y.storeTransactionDescription } }); var X = requireTransactionStoragePhase(); Object.defineProperty(o, "loadTransactionStoragePhase", { enumerable: !0, get: function () { return X.loadTransactionStoragePhase } }), Object.defineProperty(o, "storeTransactionsStoragePhase", { enumerable: !0, get: function () { return X.storeTransactionsStoragePhase } }) }(_export)), _export } var openContract = {}, hasRequiredOpenContract; function requireOpenContract() { if (hasRequiredOpenContract) return openContract; hasRequiredOpenContract = 1, Object.defineProperty(openContract, "__esModule", { value: !0 }), openContract.openContract = void 0; const o = requireAddress(), l = requireCell(); function u(f, p) { let d, m = null; if (!o.Address.isAddress(f.address)) throw Error("Invalid address"); if (d = f.address, f.init) { if (!(f.init.code instanceof l.Cell)) throw Error("Invalid init.code"); if (!(f.init.data instanceof l.Cell)) throw Error("Invalid init.data"); m = f.init } let v = p({ address: d, init: m }); return new Proxy(f, { get(I, F) { const B = I[F]; return typeof F == "string" && (F.startsWith("get") || F.startsWith("send") || F.startsWith("is")) && typeof B == "function" ? (...W) => B.apply(I, [v, ...W]) : B } }) } return openContract.openContract = u, openContract } var ComputeError = {}, hasRequiredComputeError; function requireComputeError() { if (hasRequiredComputeError) return ComputeError; hasRequiredComputeError = 1, Object.defineProperty(ComputeError, "__esModule", { value: !0 }), ComputeError.ComputeError = void 0; let o = class Rf extends Error { constructor(u, f, p) { super(u), this.exitCode = f, this.debugLogs = p && p.debugLogs ? p.debugLogs : null, this.logs = p && p.logs ? p.logs : null, Object.setPrototypeOf(this, Rf.prototype) } }; return ComputeError.ComputeError = o, ComputeError } var getMethodId = {}, hasRequiredGetMethodId; function requireGetMethodId() { if (hasRequiredGetMethodId) return getMethodId; hasRequiredGetMethodId = 1, Object.defineProperty(getMethodId, "__esModule", { value: !0 }), getMethodId.getMethodId = void 0; const o = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]); function l(f) { f instanceof Buffer || (f = Buffer.from(f)); let p = 0; for (let d = 0; d < f.length; d++) { const m = f[d]; p = (o[(p >> 8 ^ m) & 255] ^ p << 8) & 65535 } return p } function u(f) { return l(f) & 65535 | 65536 } return getMethodId.getMethodId = u, getMethodId } var safeSign = {}, hasRequiredSafeSign; function requireSafeSign() { if (hasRequiredSafeSign) return safeSign; hasRequiredSafeSign = 1, Object.defineProperty(safeSign, "__esModule", { value: !0 }), safeSign.safeSignVerify = safeSign.safeSign = void 0; const o = requireDist$1(), l = 8, u = 64; function f(m, v) { let I = Buffer.from(v); if (I.length > u) throw Error("Seed can	 be longer than 64 bytes"); if (I.length < l) throw Error("Seed must be at least 8 bytes"); return (0, o.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), I, m.hash()])) } function p(m, v, I = "ton-safe-sign-magic") { return (0, o.sign)(f(m, I), v) } safeSign.safeSign = p; function d(m, v, I, F = "ton-safe-sign-magic") { return (0, o.signVerify)(f(m, F), v, I) } return safeSign.safeSignVerify = d, safeSign } var hasRequiredDist; function requireDist() { return hasRequiredDist || (hasRequiredDist = 1, function (o) { var l = dist$2 && dist$2.__createBinding || (Object.create ? function (K, Y, te, ee) { ee === void 0 && (ee = te); var G = Object.getOwnPropertyDescriptor(Y, te); (!G || ("get" in G ? !Y.__esModule : G.writable || G.configurable)) && (G = { enumerable: !0, get: function () { return Y[te] } }), Object.defineProperty(K, ee, G) } : function (K, Y, te, ee) { ee === void 0 && (ee = te), K[ee] = Y[te] }), u = dist$2 && dist$2.__exportStar || function (K, Y) { for (var te in K) te !== "default" && !Object.prototype.hasOwnProperty.call(Y, te) && l(Y, K, te) }; Object.defineProperty(o, "__esModule", { value: !0 }), o.safeSignVerify = o.safeSign = o.getMethodId = o.base32Encode = o.base32Decode = o.crc32c = o.crc16 = o.fromNano = o.toNano = o.ComputeError = o.openContract = o.TupleBuilder = o.TupleReader = o.serializeTuple = o.parseTuple = o.generateMerkleUpdate = o.generateMerkleProofDirect = o.generateMerkleProof = o.exoticPruned = o.exoticMerkleUpdate = o.convertToMerkleProof = o.exoticMerkleProof = o.Dictionary = o.Cell = o.CellType = o.Slice = o.beginCell = o.Builder = o.BitBuilder = o.BitReader = o.BitString = o.contractAddress = o.ADNLAddress = o.ExternalAddress = o.address = o.Address = void 0; var f = requireAddress(); Object.defineProperty(o, "Address", { enumerable: !0, get: function () { return f.Address } }), Object.defineProperty(o, "address", { enumerable: !0, get: function () { return f.address } }); var p = requireExternalAddress(); Object.defineProperty(o, "ExternalAddress", { enumerable: !0, get: function () { return p.ExternalAddress } }); var d = requireADNLAddress(); Object.defineProperty(o, "ADNLAddress", { enumerable: !0, get: function () { return d.ADNLAddress } }); var m = requireContractAddress(); Object.defineProperty(o, "contractAddress", { enumerable: !0, get: function () { return m.contractAddress } }); var v = requireBitString(); Object.defineProperty(o, "BitString", { enumerable: !0, get: function () { return v.BitString } }); var I = requireBitReader(); Object.defineProperty(o, "BitReader", { enumerable: !0, get: function () { return I.BitReader } }); var F = requireBitBuilder(); Object.defineProperty(o, "BitBuilder", { enumerable: !0, get: function () { return F.BitBuilder } }); var B = requireBuilder$1(); Object.defineProperty(o, "Builder", { enumerable: !0, get: function () { return B.Builder } }), Object.defineProperty(o, "beginCell", { enumerable: !0, get: function () { return B.beginCell } }); var W = requireSlice(); Object.defineProperty(o, "Slice", { enumerable: !0, get: function () { return W.Slice } }); var Z = requireCellType(); Object.defineProperty(o, "CellType", { enumerable: !0, get: function () { return Z.CellType } }); var Q = requireCell(); Object.defineProperty(o, "Cell", { enumerable: !0, get: function () { return Q.Cell } }); var re = requireDictionary(); Object.defineProperty(o, "Dictionary", { enumerable: !0, get: function () { return re.Dictionary } }); var ne = requireExoticMerkleProof(); Object.defineProperty(o, "exoticMerkleProof", { enumerable: !0, get: function () { return ne.exoticMerkleProof } }), Object.defineProperty(o, "convertToMerkleProof", { enumerable: !0, get: function () { return ne.convertToMerkleProof } }); var oe = requireExoticMerkleUpdate(); Object.defineProperty(o, "exoticMerkleUpdate", { enumerable: !0, get: function () { return oe.exoticMerkleUpdate } }); var ae = requireExoticPruned(); Object.defineProperty(o, "exoticPruned", { enumerable: !0, get: function () { return ae.exoticPruned } }); var se = requireGenerateMerkleProof(); Object.defineProperty(o, "generateMerkleProof", { enumerable: !0, get: function () { return se.generateMerkleProof } }), Object.defineProperty(o, "generateMerkleProofDirect", { enumerable: !0, get: function () { return se.generateMerkleProofDirect } }); var le = requireGenerateMerkleUpdate(); Object.defineProperty(o, "generateMerkleUpdate", { enumerable: !0, get: function () { return le.generateMerkleUpdate } }); var ue = requireTuple(); Object.defineProperty(o, "parseTuple", { enumerable: !0, get: function () { return ue.parseTuple } }), Object.defineProperty(o, "serializeTuple", { enumerable: !0, get: function () { return ue.serializeTuple } }); var he = requireReader(); Object.defineProperty(o, "TupleReader", { enumerable: !0, get: function () { return he.TupleReader } }); var pe = requireBuilder(); Object.defineProperty(o, "TupleBuilder", { enumerable: !0, get: function () { return pe.TupleBuilder } }), u(require_export(), o); var ve = requireOpenContract(); Object.defineProperty(o, "openContract", { enumerable: !0, get: function () { return ve.openContract } }); var _e = requireComputeError(); Object.defineProperty(o, "ComputeError", { enumerable: !0, get: function () { return _e.ComputeError } }); var Se = requireConvert(); Object.defineProperty(o, "toNano", { enumerable: !0, get: function () { return Se.toNano } }), Object.defineProperty(o, "fromNano", { enumerable: !0, get: function () { return Se.fromNano } }); var $e = requireCrc16(); Object.defineProperty(o, "crc16", { enumerable: !0, get: function () { return $e.crc16 } }); var ie = requireCrc32c(); Object.defineProperty(o, "crc32c", { enumerable: !0, get: function () { return ie.crc32c } }); var g = requireBase32(); Object.defineProperty(o, "base32Decode", { enumerable: !0, get: function () { return g.base32Decode } }), Object.defineProperty(o, "base32Encode", { enumerable: !0, get: function () { return g.base32Encode } }); var P = requireGetMethodId(); Object.defineProperty(o, "getMethodId", { enumerable: !0, get: function () { return P.getMethodId } }); var U = requireSafeSign(); Object.defineProperty(o, "safeSign", { enumerable: !0, get: function () { return U.safeSign } }), Object.defineProperty(o, "safeSignVerify", { enumerable: !0, get: function () { return U.safeSignVerify } }) }(dist$2)), dist$2 } var distExports = requireDist(), lottie$2 = { exports: {} }, lottie$1 = lottie$2.exports, hasRequiredLottie; function requireLottie() {
  return hasRequiredLottie || (hasRequiredLottie = 1, function (module, exports) {
    typeof navigator < "u" && function (o, l) { module.exports = l() }(lottie$1, function () {
      var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function (l) { _useWebWorker = !!l }, getWebWorker = function () { return _useWebWorker }, setLocationHref = function (l) { locationHref = l }, getLocationHref = function () { return locationHref }; function createTag(o) { return document.createElement(o) } function extendPrototype(o, l) { var u, f = o.length, p; for (u = 0; u < f; u += 1) { p = o[u].prototype; for (var d in p) Object.prototype.hasOwnProperty.call(p, d) && (l.prototype[d] = p[d]) } } function getDescriptor(o, l) { return Object.getOwnPropertyDescriptor(o, l) } function createProxyFunction(o) { function l() { } return l.prototype = o, l } var audioControllerFactory = function () { function o(l) { this.audios = [], this.audioFactory = l, this._volume = 1, this._isMuted = !1 } return o.prototype = { addAudio: function (u) { this.audios.push(u) }, pause: function () { var u, f = this.audios.length; for (u = 0; u < f; u += 1)this.audios[u].pause() }, resume: function () { var u, f = this.audios.length; for (u = 0; u < f; u += 1)this.audios[u].resume() }, setRate: function (u) { var f, p = this.audios.length; for (f = 0; f < p; f += 1)this.audios[f].setRate(u) }, createAudio: function (u) { return this.audioFactory ? this.audioFactory(u) : window.Howl ? new window.Howl({ src: [u] }) : { isPlaying: !1, play: function () { this.isPlaying = !0 }, seek: function () { this.isPlaying = !1 }, playing: function () { }, rate: function () { }, setVolume: function () { } } }, setAudioFactory: function (u) { this.audioFactory = u }, setVolume: function (u) { this._volume = u, this._updateVolume() }, mute: function () { this._isMuted = !0, this._updateVolume() }, unmute: function () { this._isMuted = !1, this._updateVolume() }, getVolume: function () { return this._volume }, _updateVolume: function () { var u, f = this.audios.length; for (u = 0; u < f; u += 1)this.audios[u].volume(this._volume * (this._isMuted ? 0 : 1)) } }, function () { return new o } }(), createTypedArray = function () { function o(u, f) { var p = 0, d = [], m; switch (u) { case "int16": case "uint8c": m = 1; break; default: m = 1.1; break }for (p = 0; p < f; p += 1)d.push(m); return d } function l(u, f) { return u === "float32" ? new Float32Array(f) : u === "int16" ? new Int16Array(f) : u === "uint8c" ? new Uint8ClampedArray(f) : o(u, f) } return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? l : o }(); function createSizedArray(o) { return Array.apply(null, { length: o }) } function _typeof$6(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function (u) { return typeof u } : _typeof$6 = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof$6(o) } var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {}; (function () { var o = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], l, u = o.length; for (l = 0; l < u; l += 1)BMMath[o[l]] = Math[o[l]] })(), BMMath.random = Math.random, BMMath.abs = function (o) { var l = _typeof$6(o); if (l === "object" && o.length) { var u = createSizedArray(o.length), f, p = o.length; for (f = 0; f < p; f += 1)u[f] = Math.abs(o[f]); return u } return Math.abs(o) }; var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = .5519; function styleDiv(o) { o.style.position = "absolute", o.style.top = 0, o.style.left = 0, o.style.display = "block", o.style.transformOrigin = "0 0", o.style.webkitTransformOrigin = "0 0", o.style.backfaceVisibility = "visible", o.style.webkitBackfaceVisibility = "visible", o.style.transformStyle = "preserve-3d", o.style.webkitTransformStyle = "preserve-3d", o.style.mozTransformStyle = "preserve-3d" } function BMEnterFrameEvent(o, l, u, f) { this.type = o, this.currentTime = l, this.totalTime = u, this.direction = f < 0 ? -1 : 1 } function BMCompleteEvent(o, l) { this.type = o, this.direction = l < 0 ? -1 : 1 } function BMCompleteLoopEvent(o, l, u, f) { this.type = o, this.currentLoop = u, this.totalLoops = l, this.direction = f < 0 ? -1 : 1 } function BMSegmentStartEvent(o, l, u) { this.type = o, this.firstFrame = l, this.totalFrames = u } function BMDestroyEvent(o, l) { this.type = o, this.target = l } function BMRenderFrameErrorEvent(o, l) { this.type = "renderFrameError", this.nativeError = o, this.currentTime = l } function BMConfigErrorEvent(o) { this.type = "configError", this.nativeError = o } var createElementID = function () { var o = 0; return function () { return o += 1, idPrefix$1 + "__lottie_element_" + o } }(); function HSVtoRGB(o, l, u) { var f, p, d, m, v, I, F, B; switch (m = Math.floor(o * 6), v = o * 6 - m, I = u * (1 - l), F = u * (1 - v * l), B = u * (1 - (1 - v) * l), m % 6) { case 0: f = u, p = B, d = I; break; case 1: f = F, p = u, d = I; break; case 2: f = I, p = u, d = B; break; case 3: f = I, p = F, d = u; break; case 4: f = B, p = I, d = u; break; case 5: f = u, p = I, d = F; break }return [f, p, d] } function RGBtoHSV(o, l, u) { var f = Math.max(o, l, u), p = Math.min(o, l, u), d = f - p, m, v = f === 0 ? 0 : d / f, I = f / 255; switch (f) { case p: m = 0; break; case o: m = l - u + d * (l < u ? 6 : 0), m /= 6 * d; break; case l: m = u - o + d * 2, m /= 6 * d; break; case u: m = o - l + d * 4, m /= 6 * d; break }return [m, v, I] } function addSaturationToRGB(o, l) { var u = RGBtoHSV(o[0] * 255, o[1] * 255, o[2] * 255); return u[1] += l, u[1] > 1 ? u[1] = 1 : u[1] <= 0 && (u[1] = 0), HSVtoRGB(u[0], u[1], u[2]) } function addBrightnessToRGB(o, l) { var u = RGBtoHSV(o[0] * 255, o[1] * 255, o[2] * 255); return u[2] += l, u[2] > 1 ? u[2] = 1 : u[2] < 0 && (u[2] = 0), HSVtoRGB(u[0], u[1], u[2]) } function addHueToRGB(o, l) { var u = RGBtoHSV(o[0] * 255, o[1] * 255, o[2] * 255); return u[0] += l / 360, u[0] > 1 ? u[0] -= 1 : u[0] < 0 && (u[0] += 1), HSVtoRGB(u[0], u[1], u[2]) } var rgbToHex = function () { var o = [], l, u; for (l = 0; l < 256; l += 1)u = l.toString(16), o[l] = u.length === 1 ? "0" + u : u; return function (f, p, d) { return f < 0 && (f = 0), p < 0 && (p = 0), d < 0 && (d = 0), "#" + o[f] + o[p] + o[d] } }(), setSubframeEnabled = function (l) { subframeEnabled = !!l }, getSubframeEnabled = function () { return subframeEnabled }, setExpressionsPlugin = function (l) { expressionsPlugin = l }, getExpressionsPlugin = function () { return expressionsPlugin }, setExpressionInterfaces = function (l) { expressionsInterfaces = l }, getExpressionInterfaces = function () { return expressionsInterfaces }, setDefaultCurveSegments = function (l) { defaultCurveSegments = l }, getDefaultCurveSegments = function () { return defaultCurveSegments }, setIdPrefix = function (l) { idPrefix$1 = l }; function createNS(o) { return document.createElementNS(svgNS, o) } function _typeof$5(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function (u) { return typeof u } : _typeof$5 = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof$5(o) } var dataManager = function () { var o = 1, l = [], u, f, p = { onmessage: function () { }, postMessage: function (Q) { u({ data: Q }) } }, d = { postMessage: function (Q) { p.onmessage({ data: Q }) } }; function m(Z) { if (window.Worker && window.Blob && getWebWorker()) { var Q = new Blob(["var _workerSelf = self; self.onmessage = ", Z.toString()], { type: "text/javascript" }), re = URL.createObjectURL(Q); return new Worker(re) } return u = Z, p } function v() { f || (f = m(function (Q) { function re() { function oe(K, Y) { var te, ee, G = K.length, y, X, ce, me; for (ee = 0; ee < G; ee += 1)if (te = K[ee], "ks" in te && !te.completed) { if (te.completed = !0, te.hasMask) { var Ae = te.masksProperties; for (X = Ae.length, y = 0; y < X; y += 1)if (Ae[y].pt.k.i) he(Ae[y].pt.k); else for (me = Ae[y].pt.k.length, ce = 0; ce < me; ce += 1)Ae[y].pt.k[ce].s && he(Ae[y].pt.k[ce].s[0]), Ae[y].pt.k[ce].e && he(Ae[y].pt.k[ce].e[0]) } te.ty === 0 ? (te.layers = le(te.refId, Y), oe(te.layers, Y)) : te.ty === 4 ? ue(te.shapes) : te.ty === 5 && P(te) } } function ae(K, Y) { if (K) { var te = 0, ee = K.length; for (te = 0; te < ee; te += 1)K[te].t === 1 && (K[te].data.layers = le(K[te].data.refId, Y), oe(K[te].data.layers, Y)) } } function se(K, Y) { for (var te = 0, ee = Y.length; te < ee;) { if (Y[te].id === K) return Y[te]; te += 1 } return null } function le(K, Y) { var te = se(K, Y); return te ? te.layers.__used ? JSON.parse(JSON.stringify(te.layers)) : (te.layers.__used = !0, te.layers) : null } function ue(K) { var Y, te = K.length, ee, G; for (Y = te - 1; Y >= 0; Y -= 1)if (K[Y].ty === "sh") if (K[Y].ks.k.i) he(K[Y].ks.k); else for (G = K[Y].ks.k.length, ee = 0; ee < G; ee += 1)K[Y].ks.k[ee].s && he(K[Y].ks.k[ee].s[0]), K[Y].ks.k[ee].e && he(K[Y].ks.k[ee].e[0]); else K[Y].ty === "gr" && ue(K[Y].it) } function he(K) { var Y, te = K.i.length; for (Y = 0; Y < te; Y += 1)K.i[Y][0] += K.v[Y][0], K.i[Y][1] += K.v[Y][1], K.o[Y][0] += K.v[Y][0], K.o[Y][1] += K.v[Y][1] } function pe(K, Y) { var te = Y ? Y.split(".") : [100, 100, 100]; return K[0] > te[0] ? !0 : te[0] > K[0] ? !1 : K[1] > te[1] ? !0 : te[1] > K[1] ? !1 : K[2] > te[2] ? !0 : te[2] > K[2] ? !1 : null } var ve = function () { var K = [4, 4, 14]; function Y(ee) { var G = ee.t.d; ee.t.d = { k: [{ s: G, t: 0 }] } } function te(ee) { var G, y = ee.length; for (G = 0; G < y; G += 1)ee[G].ty === 5 && Y(ee[G]) } return function (ee) { if (pe(K, ee.v) && (te(ee.layers), ee.assets)) { var G, y = ee.assets.length; for (G = 0; G < y; G += 1)ee.assets[G].layers && te(ee.assets[G].layers) } } }(), _e = function () { var K = [4, 7, 99]; return function (Y) { if (Y.chars && !pe(K, Y.v)) { var te, ee = Y.chars.length; for (te = 0; te < ee; te += 1) { var G = Y.chars[te]; G.data && G.data.shapes && (ue(G.data.shapes), G.data.ip = 0, G.data.op = 99999, G.data.st = 0, G.data.sr = 1, G.data.ks = { p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 } }, Y.chars[te].t || (G.data.shapes.push({ ty: "no" }), G.data.shapes[0].it.push({ p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 }, sk: { k: 0, a: 0 }, sa: { k: 0, a: 0 }, ty: "tr" }))) } } } }(), Se = function () { var K = [5, 7, 15]; function Y(ee) { var G = ee.t.p; typeof G.a == "number" && (G.a = { a: 0, k: G.a }), typeof G.p == "number" && (G.p = { a: 0, k: G.p }), typeof G.r == "number" && (G.r = { a: 0, k: G.r }) } function te(ee) { var G, y = ee.length; for (G = 0; G < y; G += 1)ee[G].ty === 5 && Y(ee[G]) } return function (ee) { if (pe(K, ee.v) && (te(ee.layers), ee.assets)) { var G, y = ee.assets.length; for (G = 0; G < y; G += 1)ee.assets[G].layers && te(ee.assets[G].layers) } } }(), $e = function () { var K = [4, 1, 9]; function Y(ee) { var G, y = ee.length, X, ce; for (G = 0; G < y; G += 1)if (ee[G].ty === "gr") Y(ee[G].it); else if (ee[G].ty === "fl" || ee[G].ty === "st") if (ee[G].c.k && ee[G].c.k[0].i) for (ce = ee[G].c.k.length, X = 0; X < ce; X += 1)ee[G].c.k[X].s && (ee[G].c.k[X].s[0] /= 255, ee[G].c.k[X].s[1] /= 255, ee[G].c.k[X].s[2] /= 255, ee[G].c.k[X].s[3] /= 255), ee[G].c.k[X].e && (ee[G].c.k[X].e[0] /= 255, ee[G].c.k[X].e[1] /= 255, ee[G].c.k[X].e[2] /= 255, ee[G].c.k[X].e[3] /= 255); else ee[G].c.k[0] /= 255, ee[G].c.k[1] /= 255, ee[G].c.k[2] /= 255, ee[G].c.k[3] /= 255 } function te(ee) { var G, y = ee.length; for (G = 0; G < y; G += 1)ee[G].ty === 4 && Y(ee[G].shapes) } return function (ee) { if (pe(K, ee.v) && (te(ee.layers), ee.assets)) { var G, y = ee.assets.length; for (G = 0; G < y; G += 1)ee.assets[G].layers && te(ee.assets[G].layers) } } }(), ie = function () { var K = [4, 4, 18]; function Y(ee) { var G, y = ee.length, X, ce; for (G = y - 1; G >= 0; G -= 1)if (ee[G].ty === "sh") if (ee[G].ks.k.i) ee[G].ks.k.c = ee[G].closed; else for (ce = ee[G].ks.k.length, X = 0; X < ce; X += 1)ee[G].ks.k[X].s && (ee[G].ks.k[X].s[0].c = ee[G].closed), ee[G].ks.k[X].e && (ee[G].ks.k[X].e[0].c = ee[G].closed); else ee[G].ty === "gr" && Y(ee[G].it) } function te(ee) { var G, y, X = ee.length, ce, me, Ae, Ie; for (y = 0; y < X; y += 1) { if (G = ee[y], G.hasMask) { var Be = G.masksProperties; for (me = Be.length, ce = 0; ce < me; ce += 1)if (Be[ce].pt.k.i) Be[ce].pt.k.c = Be[ce].cl; else for (Ie = Be[ce].pt.k.length, Ae = 0; Ae < Ie; Ae += 1)Be[ce].pt.k[Ae].s && (Be[ce].pt.k[Ae].s[0].c = Be[ce].cl), Be[ce].pt.k[Ae].e && (Be[ce].pt.k[Ae].e[0].c = Be[ce].cl) } G.ty === 4 && Y(G.shapes) } } return function (ee) { if (pe(K, ee.v) && (te(ee.layers), ee.assets)) { var G, y = ee.assets.length; for (G = 0; G < y; G += 1)ee.assets[G].layers && te(ee.assets[G].layers) } } }(); function g(K) { K.__complete || ($e(K), ve(K), _e(K), Se(K), ie(K), oe(K.layers, K.assets), ae(K.chars, K.assets), K.__complete = !0) } function P(K) { K.t.a.length === 0 && "m" in K.t.p } var U = {}; return U.completeData = g, U.checkColors = $e, U.checkChars = _e, U.checkPathProperties = Se, U.checkShapes = ie, U.completeLayers = oe, U } if (d.dataManager || (d.dataManager = re()), d.assetLoader || (d.assetLoader = function () { function oe(se) { var le = se.getResponseHeader("content-type"); return le && se.responseType === "json" && le.indexOf("json") !== -1 || se.response && _typeof$5(se.response) === "object" ? se.response : se.response && typeof se.response == "string" ? JSON.parse(se.response) : se.responseText ? JSON.parse(se.responseText) : null } function ae(se, le, ue, he) { var pe, ve = new XMLHttpRequest; try { ve.responseType = "json" } catch { } ve.onreadystatechange = function () { if (ve.readyState === 4) if (ve.status === 200) pe = oe(ve), ue(pe); else try { pe = oe(ve), ue(pe) } catch (_e) { he && he(_e) } }; try { ve.open(["G", "E", "T"].join(""), se, !0) } catch { ve.open(["G", "E", "T"].join(""), le + "/" + se, !0) } ve.send() } return { load: ae } }()), Q.data.type === "loadAnimation") d.assetLoader.load(Q.data.path, Q.data.fullPath, function (oe) { d.dataManager.completeData(oe), d.postMessage({ id: Q.data.id, payload: oe, status: "success" }) }, function () { d.postMessage({ id: Q.data.id, status: "error" }) }); else if (Q.data.type === "complete") { var ne = Q.data.animation; d.dataManager.completeData(ne), d.postMessage({ id: Q.data.id, payload: ne, status: "success" }) } else Q.data.type === "loadData" && d.assetLoader.load(Q.data.path, Q.data.fullPath, function (oe) { d.postMessage({ id: Q.data.id, payload: oe, status: "success" }) }, function () { d.postMessage({ id: Q.data.id, status: "error" }) }) }), f.onmessage = function (Z) { var Q = Z.data, re = Q.id, ne = l[re]; l[re] = null, Q.status === "success" ? ne.onComplete(Q.payload) : ne.onError && ne.onError() }) } function I(Z, Q) { o += 1; var re = "processId_" + o; return l[re] = { onComplete: Z, onError: Q }, re } function F(Z, Q, re) { v(); var ne = I(Q, re); f.postMessage({ type: "loadAnimation", path: Z, fullPath: window.location.origin + window.location.pathname, id: ne }) } function B(Z, Q, re) { v(); var ne = I(Q, re); f.postMessage({ type: "loadData", path: Z, fullPath: window.location.origin + window.location.pathname, id: ne }) } function W(Z, Q, re) { v(); var ne = I(Q, re); f.postMessage({ type: "complete", animation: Z, id: ne }) } return { loadAnimation: F, loadData: B, completeAnimation: W } }(), ImagePreloader = function () { var o = function () { var ae = createTag("canvas"); ae.width = 1, ae.height = 1; var se = ae.getContext("2d"); return se.fillStyle = "rgba(0,0,0,0)", se.fillRect(0, 0, 1, 1), ae }(); function l() { this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function u() { this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function f(ae, se, le) { var ue = ""; if (ae.e) ue = ae.p; else if (se) { var he = ae.p; he.indexOf("images/") !== -1 && (he = he.split("/")[1]), ue = se + he } else ue = le, ue += ae.u ? ae.u : "", ue += ae.p; return ue } function p(ae) { var se = 0, le = setInterval((function () { var ue = ae.getBBox(); (ue.width || se > 500) && (this._imageLoaded(), clearInterval(le)), se += 1 }).bind(this), 50) } function d(ae) { var se = f(ae, this.assetsPath, this.path), le = createNS("image"); isSafari ? this.testImageLoaded(le) : le.addEventListener("load", this._imageLoaded, !1), le.addEventListener("error", (function () { ue.img = o, this._imageLoaded() }).bind(this), !1), le.setAttributeNS("http://www.w3.org/1999/xlink", "href", se), this._elementHelper.append ? this._elementHelper.append(le) : this._elementHelper.appendChild(le); var ue = { img: le, assetData: ae }; return ue } function m(ae) { var se = f(ae, this.assetsPath, this.path), le = createTag("img"); le.crossOrigin = "anonymous", le.addEventListener("load", this._imageLoaded, !1), le.addEventListener("error", (function () { ue.img = o, this._imageLoaded() }).bind(this), !1), le.src = se; var ue = { img: le, assetData: ae }; return ue } function v(ae) { var se = { assetData: ae }, le = f(ae, this.assetsPath, this.path); return dataManager.loadData(le, (function (ue) { se.img = ue, this._footageLoaded() }).bind(this), (function () { se.img = {}, this._footageLoaded() }).bind(this)), se } function I(ae, se) { this.imagesLoadedCb = se; var le, ue = ae.length; for (le = 0; le < ue; le += 1)ae[le].layers || (!ae[le].t || ae[le].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(ae[le]))) : ae[le].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(ae[le])))) } function F(ae) { this.path = ae || "" } function B(ae) { this.assetsPath = ae || "" } function W(ae) { for (var se = 0, le = this.images.length; se < le;) { if (this.images[se].assetData === ae) return this.images[se].img; se += 1 } return null } function Z() { this.imagesLoadedCb = null, this.images.length = 0 } function Q() { return this.totalImages === this.loadedAssets } function re() { return this.totalFootages === this.loadedFootagesCount } function ne(ae, se) { ae === "svg" ? (this._elementHelper = se, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this) } function oe() { this._imageLoaded = l.bind(this), this._footageLoaded = u.bind(this), this.testImageLoaded = p.bind(this), this.createFootageData = v.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [] } return oe.prototype = { loadAssets: I, setAssetsPath: B, setPath: F, loadedImages: Q, loadedFootages: re, destroy: Z, getAsset: W, createImgData: m, createImageData: d, imageLoaded: l, footageLoaded: u, setCacheType: ne }, oe }(); function BaseEvent() { } BaseEvent.prototype = { triggerEvent: function (l, u) { if (this._cbs[l]) for (var f = this._cbs[l], p = 0; p < f.length; p += 1)f[p](u) }, addEventListener: function (l, u) { return this._cbs[l] || (this._cbs[l] = []), this._cbs[l].push(u), (function () { this.removeEventListener(l, u) }).bind(this) }, removeEventListener: function (l, u) { if (!u) this._cbs[l] = null; else if (this._cbs[l]) { for (var f = 0, p = this._cbs[l].length; f < p;)this._cbs[l][f] === u && (this._cbs[l].splice(f, 1), f -= 1, p -= 1), f += 1; this._cbs[l].length || (this._cbs[l] = null) } } }; var markerParser = function () {
        function o(l) {
          for (var u = l.split(`\r
`), f = {}, p, d = 0, m = 0; m < u.length; m += 1)p = u[m].split(":"), p.length === 2 && (f[p[0]] = p[1].trim(), d += 1); if (d === 0) throw new Error; return f
        } return function (l) { for (var u = [], f = 0; f < l.length; f += 1) { var p = l[f], d = { time: p.tm, duration: p.dr }; try { d.payload = JSON.parse(l[f].cm) } catch { try { d.payload = o(l[f].cm) } catch { d.payload = { name: l[f].cm } } } u.push(d) } return u }
      }(), ProjectInterface = function () { function o(l) { this.compositions.push(l) } return function () { function l(u) { for (var f = 0, p = this.compositions.length; f < p;) { if (this.compositions[f].data && this.compositions[f].data.nm === u) return this.compositions[f].prepareFrame && this.compositions[f].data.xt && this.compositions[f].prepareFrame(this.currentFrame), this.compositions[f].compInterface; f += 1 } return null } return l.compositions = [], l.currentFrame = 0, l.registerComposition = o, l } }(), renderers = {}, registerRenderer = function (l, u) { renderers[l] = u }; function getRenderer(o) { return renderers[o] } function getRegisteredRenderer() { if (renderers.canvas) return "canvas"; for (var o in renderers) if (renderers[o]) return o; return "" } function _typeof$4(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function (u) { return typeof u } : _typeof$4 = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof$4(o) } var AnimationItem = function () { this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin() }; extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (o) { (o.wrapper || o.container) && (this.wrapper = o.wrapper || o.container); var l = "svg"; o.animType ? l = o.animType : o.renderer && (l = o.renderer); var u = getRenderer(l); this.renderer = new u(this, o.rendererSettings), this.imagePreloader.setCacheType(l, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = l, o.loop === "" || o.loop === null || o.loop === void 0 || o.loop === !0 ? this.loop = !0 : o.loop === !1 ? this.loop = !1 : this.loop = parseInt(o.loop, 10), this.autoplay = "autoplay" in o ? o.autoplay : !0, this.name = o.name ? o.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(o, "autoloadSegments") ? o.autoloadSegments : !0, this.assetsPath = o.assetsPath, this.initialSegment = o.initialSegment, o.audioFactory && this.audioController.setAudioFactory(o.audioFactory), o.animationData ? this.setupAnimation(o.animationData) : o.path && (o.path.lastIndexOf("\\") !== -1 ? this.path = o.path.substr(0, o.path.lastIndexOf("\\") + 1) : this.path = o.path.substr(0, o.path.lastIndexOf("/") + 1), this.fileName = o.path.substr(o.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(o.path, this.configAnimation, this.onSetupError)) }, AnimationItem.prototype.onSetupError = function () { this.trigger("data_failed") }, AnimationItem.prototype.setupAnimation = function (o) { dataManager.completeAnimation(o, this.configAnimation) }, AnimationItem.prototype.setData = function (o, l) { l && _typeof$4(l) !== "object" && (l = JSON.parse(l)); var u = { wrapper: o, animationData: l }, f = o.attributes; u.path = f.getNamedItem("data-animation-path") ? f.getNamedItem("data-animation-path").value : f.getNamedItem("data-bm-path") ? f.getNamedItem("data-bm-path").value : f.getNamedItem("bm-path") ? f.getNamedItem("bm-path").value : "", u.animType = f.getNamedItem("data-anim-type") ? f.getNamedItem("data-anim-type").value : f.getNamedItem("data-bm-type") ? f.getNamedItem("data-bm-type").value : f.getNamedItem("bm-type") ? f.getNamedItem("bm-type").value : f.getNamedItem("data-bm-renderer") ? f.getNamedItem("data-bm-renderer").value : f.getNamedItem("bm-renderer") ? f.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas"; var p = f.getNamedItem("data-anim-loop") ? f.getNamedItem("data-anim-loop").value : f.getNamedItem("data-bm-loop") ? f.getNamedItem("data-bm-loop").value : f.getNamedItem("bm-loop") ? f.getNamedItem("bm-loop").value : ""; p === "false" ? u.loop = !1 : p === "true" ? u.loop = !0 : p !== "" && (u.loop = parseInt(p, 10)); var d = f.getNamedItem("data-anim-autoplay") ? f.getNamedItem("data-anim-autoplay").value : f.getNamedItem("data-bm-autoplay") ? f.getNamedItem("data-bm-autoplay").value : f.getNamedItem("bm-autoplay") ? f.getNamedItem("bm-autoplay").value : !0; u.autoplay = d !== "false", u.name = f.getNamedItem("data-name") ? f.getNamedItem("data-name").value : f.getNamedItem("data-bm-name") ? f.getNamedItem("data-bm-name").value : f.getNamedItem("bm-name") ? f.getNamedItem("bm-name").value : ""; var m = f.getNamedItem("data-anim-prerender") ? f.getNamedItem("data-anim-prerender").value : f.getNamedItem("data-bm-prerender") ? f.getNamedItem("data-bm-prerender").value : f.getNamedItem("bm-prerender") ? f.getNamedItem("bm-prerender").value : ""; m === "false" && (u.prerender = !1), u.path ? this.setParams(u) : this.trigger("destroy") }, AnimationItem.prototype.includeLayers = function (o) { o.op > this.animationData.op && (this.animationData.op = o.op, this.totalFrames = Math.floor(o.op - this.animationData.ip)); var l = this.animationData.layers, u, f = l.length, p = o.layers, d, m = p.length; for (d = 0; d < m; d += 1)for (u = 0; u < f;) { if (l[u].id === p[d].id) { l[u] = p[d]; break } u += 1 } if ((o.chars || o.fonts) && (this.renderer.globalData.fontManager.addChars(o.chars), this.renderer.globalData.fontManager.addFonts(o.fonts, this.renderer.globalData.defs)), o.assets) for (f = o.assets.length, u = 0; u < f; u += 1)this.animationData.assets.push(o.assets[u]); this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete) }, AnimationItem.prototype.onSegmentComplete = function (o) { this.animationData = o; var l = getExpressionsPlugin(); l && l.initExpressions(this), this.loadNextSegment() }, AnimationItem.prototype.loadNextSegment = function () { var o = this.animationData.segments; if (!o || o.length === 0 || !this.autoloadSegments) { this.trigger("data_ready"), this.timeCompleted = this.totalFrames; return } var l = o.shift(); this.timeCompleted = l.time * this.frameRate; var u = this.path + this.fileName + "_" + this.segmentPos + ".json"; this.segmentPos += 1, dataManager.loadData(u, this.includeLayers.bind(this), (function () { this.trigger("data_failed") }).bind(this)) }, AnimationItem.prototype.loadSegments = function () { var o = this.animationData.segments; o || (this.timeCompleted = this.totalFrames), this.loadNextSegment() }, AnimationItem.prototype.imagesLoaded = function () { this.trigger("loaded_images"), this.checkLoaded() }, AnimationItem.prototype.preloadImages = function () { this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this)) }, AnimationItem.prototype.configAnimation = function (o) { if (this.renderer) try { this.animationData = o, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(o), o.assets || (o.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(o.assets), this.markers = markerParser(o.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause() } catch (l) { this.triggerConfigError(l) } }, AnimationItem.prototype.waitForFontsLoaded = function () { this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20)) }, AnimationItem.prototype.checkLoaded = function () { if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) { this.isLoaded = !0; var o = getExpressionsPlugin(); o && o.initExpressions(this), this.renderer.initItems(), setTimeout((function () { this.trigger("DOMLoaded") }).bind(this), 0), this.gotoFrame(), this.autoplay && this.play() } }, AnimationItem.prototype.resize = function (o, l) { var u = typeof o == "number" ? o : void 0, f = typeof l == "number" ? l : void 0; this.renderer.updateContainerSize(u, f) }, AnimationItem.prototype.setSubframe = function (o) { this.isSubframeEnabled = !!o }, AnimationItem.prototype.gotoFrame = function () { this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame") }, AnimationItem.prototype.renderFrame = function () { if (!(this.isLoaded === !1 || !this.renderer)) try { this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame) } catch (o) { this.triggerRenderFrameError(o) } }, AnimationItem.prototype.play = function (o) { o && this.name !== o || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active"))) }, AnimationItem.prototype.pause = function (o) { o && this.name !== o || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause()) }, AnimationItem.prototype.togglePause = function (o) { o && this.name !== o || (this.isPaused === !0 ? this.play() : this.pause()) }, AnimationItem.prototype.stop = function (o) { o && this.name !== o || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0)) }, AnimationItem.prototype.getMarkerData = function (o) { for (var l, u = 0; u < this.markers.length; u += 1)if (l = this.markers[u], l.payload && l.payload.name === o) return l; return null }, AnimationItem.prototype.goToAndStop = function (o, l, u) { if (!(u && this.name !== u)) { var f = Number(o); if (isNaN(f)) { var p = this.getMarkerData(o); p && this.goToAndStop(p.time, !0) } else l ? this.setCurrentRawFrameValue(o) : this.setCurrentRawFrameValue(o * this.frameModifier); this.pause() } }, AnimationItem.prototype.goToAndPlay = function (o, l, u) { if (!(u && this.name !== u)) { var f = Number(o); if (isNaN(f)) { var p = this.getMarkerData(o); p && (p.duration ? this.playSegments([p.time, p.time + p.duration], !0) : this.goToAndStop(p.time, !0)) } else this.goToAndStop(f, l, u); this.play() } }, AnimationItem.prototype.advanceTime = function (o) { if (!(this.isPaused === !0 || this.isLoaded === !1)) { var l = this.currentRawFrame + o * this.frameModifier, u = !1; l >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(l > this.totalFrames ? l % this.totalFrames : 0) || (u = !0, l = this.totalFrames - 1) : l >= this.totalFrames ? (this.playCount += 1, this.checkSegments(l % this.totalFrames) || (this.setCurrentRawFrameValue(l % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(l) : l < 0 ? this.checkSegments(l % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + l % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (u = !0, l = 0)) : this.setCurrentRawFrameValue(l), u && (this.setCurrentRawFrameValue(l), this.pause(), this.trigger("complete")) } }, AnimationItem.prototype.adjustSegment = function (o, l) { this.playCount = 0, o[1] < o[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = o[0] - o[1], this.timeCompleted = this.totalFrames, this.firstFrame = o[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - l)) : o[1] > o[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = o[1] - o[0], this.timeCompleted = this.totalFrames, this.firstFrame = o[0], this.setCurrentRawFrameValue(.001 + l)), this.trigger("segmentStart") }, AnimationItem.prototype.setSegment = function (o, l) { var u = -1; this.isPaused && (this.currentRawFrame + this.firstFrame < o ? u = o : this.currentRawFrame + this.firstFrame > l && (u = l - o)), this.firstFrame = o, this.totalFrames = l - o, this.timeCompleted = this.totalFrames, u !== -1 && this.goToAndStop(u, !0) }, AnimationItem.prototype.playSegments = function (o, l) { if (l && (this.segments.length = 0), _typeof$4(o[0]) === "object") { var u, f = o.length; for (u = 0; u < f; u += 1)this.segments.push(o[u]) } else this.segments.push(o); this.segments.length && l && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play() }, AnimationItem.prototype.resetSegments = function (o) { this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), o && this.checkSegments(0) }, AnimationItem.prototype.checkSegments = function (o) { return this.segments.length ? (this.adjustSegment(this.segments.shift(), o), !0) : !1 }, AnimationItem.prototype.destroy = function (o) { o && this.name !== o || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null) }, AnimationItem.prototype.setCurrentRawFrameValue = function (o) { this.currentRawFrame = o, this.gotoFrame() }, AnimationItem.prototype.setSpeed = function (o) { this.playSpeed = o, this.updaFrameModifier() }, AnimationItem.prototype.setDirection = function (o) { this.playDirection = o < 0 ? -1 : 1, this.updaFrameModifier() }, AnimationItem.prototype.setLoop = function (o) { this.loop = o }, AnimationItem.prototype.setVolume = function (o, l) { l && this.name !== l || this.audioController.setVolume(o) }, AnimationItem.prototype.getVolume = function () { return this.audioController.getVolume() }, AnimationItem.prototype.mute = function (o) { o && this.name !== o || this.audioController.mute() }, AnimationItem.prototype.unmute = function (o) { o && this.name !== o || this.audioController.unmute() }, AnimationItem.prototype.updaFrameModifier = function () { this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection) }, AnimationItem.prototype.getPath = function () { return this.path }, AnimationItem.prototype.getAssetsPath = function (o) { var l = ""; if (o.e) l = o.p; else if (this.assetsPath) { var u = o.p; u.indexOf("images/") !== -1 && (u = u.split("/")[1]), l = this.assetsPath + u } else l = this.path, l += o.u ? o.u : "", l += o.p; return l }, AnimationItem.prototype.getAssetData = function (o) { for (var l = 0, u = this.assets.length; l < u;) { if (o === this.assets[l].id) return this.assets[l]; l += 1 } return null }, AnimationItem.prototype.hide = function () { this.renderer.hide() }, AnimationItem.prototype.show = function () { this.renderer.show() }, AnimationItem.prototype.getDuration = function (o) { return o ? this.totalFrames : this.totalFrames / this.frameRate }, AnimationItem.prototype.updateDocumentData = function (o, l, u) { try { var f = this.renderer.getElementByPath(o); f.updateDocumentData(l, u) } catch { } }, AnimationItem.prototype.trigger = function (o) { if (this._cbs && this._cbs[o]) switch (o) { case "enterFrame": this.triggerEvent(o, new BMEnterFrameEvent(o, this.currentFrame, this.totalFrames, this.frameModifier)); break; case "drawnFrame": this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(o, this.drawnFrameEvent); break; case "loopComplete": this.triggerEvent(o, new BMCompleteLoopEvent(o, this.loop, this.playCount, this.frameMult)); break; case "complete": this.triggerEvent(o, new BMCompleteEvent(o, this.frameMult)); break; case "segmentStart": this.triggerEvent(o, new BMSegmentStartEvent(o, this.firstFrame, this.totalFrames)); break; case "destroy": this.triggerEvent(o, new BMDestroyEvent(o, this)); break; default: this.triggerEvent(o) }o === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(o, this.currentFrame, this.totalFrames, this.frameMult)), o === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(o, this.loop, this.playCount, this.frameMult)), o === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(o, this.frameMult)), o === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(o, this.firstFrame, this.totalFrames)), o === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(o, this)) }, AnimationItem.prototype.triggerRenderFrameError = function (o) { var l = new BMRenderFrameErrorEvent(o, this.currentFrame); this.triggerEvent("error", l), this.onError && this.onError.call(this, l) }, AnimationItem.prototype.triggerConfigError = function (o) { var l = new BMConfigErrorEvent(o, this.currentFrame); this.triggerEvent("error", l), this.onError && this.onError.call(this, l) }; var animationManager = function () { var o = {}, l = [], u = 0, f = 0, p = 0, d = !0, m = !1; function v(Y) { for (var te = 0, ee = Y.target; te < f;)l[te].animation === ee && (l.splice(te, 1), te -= 1, f -= 1, ee.isPaused || W()), te += 1 } function I(Y, te) { if (!Y) return null; for (var ee = 0; ee < f;) { if (l[ee].elem === Y && l[ee].elem !== null) return l[ee].animation; ee += 1 } var G = new AnimationItem; return Z(G, Y), G.setData(Y, te), G } function F() { var Y, te = l.length, ee = []; for (Y = 0; Y < te; Y += 1)ee.push(l[Y].animation); return ee } function B() { p += 1, $e() } function W() { p -= 1 } function Z(Y, te) { Y.addEventListener("destroy", v), Y.addEventListener("_active", B), Y.addEventListener("_idle", W), l.push({ elem: te, animation: Y }), f += 1 } function Q(Y) { var te = new AnimationItem; return Z(te, null), te.setParams(Y), te } function re(Y, te) { var ee; for (ee = 0; ee < f; ee += 1)l[ee].animation.setSpeed(Y, te) } function ne(Y, te) { var ee; for (ee = 0; ee < f; ee += 1)l[ee].animation.setDirection(Y, te) } function oe(Y) { var te; for (te = 0; te < f; te += 1)l[te].animation.play(Y) } function ae(Y) { var te = Y - u, ee; for (ee = 0; ee < f; ee += 1)l[ee].animation.advanceTime(te); u = Y, p && !m ? window.requestAnimationFrame(ae) : d = !0 } function se(Y) { u = Y, window.requestAnimationFrame(ae) } function le(Y) { var te; for (te = 0; te < f; te += 1)l[te].animation.pause(Y) } function ue(Y, te, ee) { var G; for (G = 0; G < f; G += 1)l[G].animation.goToAndStop(Y, te, ee) } function he(Y) { var te; for (te = 0; te < f; te += 1)l[te].animation.stop(Y) } function pe(Y) { var te; for (te = 0; te < f; te += 1)l[te].animation.togglePause(Y) } function ve(Y) { var te; for (te = f - 1; te >= 0; te -= 1)l[te].animation.destroy(Y) } function _e(Y, te, ee) { var G = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), y, X = G.length; for (y = 0; y < X; y += 1)ee && G[y].setAttribute("data-bm-type", ee), I(G[y], Y); if (te && X === 0) { ee || (ee = "svg"); var ce = document.getElementsByTagName("body")[0]; ce.innerText = ""; var me = createTag("div"); me.style.width = "100%", me.style.height = "100%", me.setAttribute("data-bm-type", ee), ce.appendChild(me), I(me, Y) } } function Se() { var Y; for (Y = 0; Y < f; Y += 1)l[Y].animation.resize() } function $e() { !m && p && d && (window.requestAnimationFrame(se), d = !1) } function ie() { m = !0 } function g() { m = !1, $e() } function P(Y, te) { var ee; for (ee = 0; ee < f; ee += 1)l[ee].animation.setVolume(Y, te) } function U(Y) { var te; for (te = 0; te < f; te += 1)l[te].animation.mute(Y) } function K(Y) { var te; for (te = 0; te < f; te += 1)l[te].animation.unmute(Y) } return o.registerAnimation = I, o.loadAnimation = Q, o.setSpeed = re, o.setDirection = ne, o.play = oe, o.pause = le, o.stop = he, o.togglePause = pe, o.searchAnimations = _e, o.resize = Se, o.goToAndStop = ue, o.destroy = ve, o.freeze = ie, o.unfreeze = g, o.setVolume = P, o.mute = U, o.unmute = K, o.getRegisteredAnimations = F, o }(), BezierFactory = function () { var o = {}; o.getBezierEasing = u; var l = {}; function u(se, le, ue, he, pe) { var ve = pe || ("bez_" + se + "_" + le + "_" + ue + "_" + he).replace(/\./g, "p"); if (l[ve]) return l[ve]; var _e = new ae([se, le, ue, he]); return l[ve] = _e, _e } var f = 4, p = .001, d = 1e-7, m = 10, v = 11, I = 1 / (v - 1), F = typeof Float32Array == "function"; function B(se, le) { return 1 - 3 * le + 3 * se } function W(se, le) { return 3 * le - 6 * se } function Z(se) { return 3 * se } function Q(se, le, ue) { return ((B(le, ue) * se + W(le, ue)) * se + Z(le)) * se } function re(se, le, ue) { return 3 * B(le, ue) * se * se + 2 * W(le, ue) * se + Z(le) } function ne(se, le, ue, he, pe) { var ve, _e, Se = 0; do _e = le + (ue - le) / 2, ve = Q(_e, he, pe) - se, ve > 0 ? ue = _e : le = _e; while (Math.abs(ve) > d && ++Se < m); return _e } function oe(se, le, ue, he) { for (var pe = 0; pe < f; ++pe) { var ve = re(le, ue, he); if (ve === 0) return le; var _e = Q(le, ue, he) - se; le -= _e / ve } return le } function ae(se) { this._p = se, this._mSampleValues = F ? new Float32Array(v) : new Array(v), this._precomputed = !1, this.get = this.get.bind(this) } return ae.prototype = { get: function (le) { var ue = this._p[0], he = this._p[1], pe = this._p[2], ve = this._p[3]; return this._precomputed || this._precompute(), ue === he && pe === ve ? le : le === 0 ? 0 : le === 1 ? 1 : Q(this._getTForX(le), he, ve) }, _precompute: function () { var le = this._p[0], ue = this._p[1], he = this._p[2], pe = this._p[3]; this._precomputed = !0, (le !== ue || he !== pe) && this._calcSampleValues() }, _calcSampleValues: function () { for (var le = this._p[0], ue = this._p[2], he = 0; he < v; ++he)this._mSampleValues[he] = Q(he * I, le, ue) }, _getTForX: function (le) { for (var ue = this._p[0], he = this._p[2], pe = this._mSampleValues, ve = 0, _e = 1, Se = v - 1; _e !== Se && pe[_e] <= le; ++_e)ve += I; --_e; var $e = (le - pe[_e]) / (pe[_e + 1] - pe[_e]), ie = ve + $e * I, g = re(ie, ue, he); return g >= p ? oe(le, ie, ue, he) : g === 0 ? ie : ne(le, ve, ve + I, ue, he) } }, o }(), pooling = function () { function o(l) { return l.concat(createSizedArray(l.length)) } return { double: o } }(), poolFactory = function () { return function (o, l, u) { var f = 0, p = o, d = createSizedArray(p), m = { newElement: v, release: I }; function v() { var F; return f ? (f -= 1, F = d[f]) : F = l(), F } function I(F) { f === p && (d = pooling.double(d), p *= 2), u && u(F), d[f] = F, f += 1 } return m } }(), bezierLengthPool = function () { function o() { return { addedLength: 0, percents: createTypedArray("float32", getDefaultCurveSegments()), lengths: createTypedArray("float32", getDefaultCurveSegments()) } } return poolFactory(8, o) }(), segmentsLengthPool = function () { function o() { return { lengths: [], totalLength: 0 } } function l(u) { var f, p = u.lengths.length; for (f = 0; f < p; f += 1)bezierLengthPool.release(u.lengths[f]); u.lengths.length = 0 } return poolFactory(8, o, l) }(); function bezFunction() { var o = Math; function l(Z, Q, re, ne, oe, ae) { var se = Z * ne + Q * oe + re * ae - oe * ne - ae * Z - re * Q; return se > -.001 && se < .001 } function u(Z, Q, re, ne, oe, ae, se, le, ue) { if (re === 0 && ae === 0 && ue === 0) return l(Z, Q, ne, oe, se, le); var he = o.sqrt(o.pow(ne - Z, 2) + o.pow(oe - Q, 2) + o.pow(ae - re, 2)), pe = o.sqrt(o.pow(se - Z, 2) + o.pow(le - Q, 2) + o.pow(ue - re, 2)), ve = o.sqrt(o.pow(se - ne, 2) + o.pow(le - oe, 2) + o.pow(ue - ae, 2)), _e; return he > pe ? he > ve ? _e = he - pe - ve : _e = ve - pe - he : ve > pe ? _e = ve - pe - he : _e = pe - he - ve, _e > -1e-4 && _e < 1e-4 } var f = function () { return function (Z, Q, re, ne) { var oe = getDefaultCurveSegments(), ae, se, le, ue, he, pe = 0, ve, _e = [], Se = [], $e = bezierLengthPool.newElement(); for (le = re.length, ae = 0; ae < oe; ae += 1) { for (he = ae / (oe - 1), ve = 0, se = 0; se < le; se += 1)ue = bmPow(1 - he, 3) * Z[se] + 3 * bmPow(1 - he, 2) * he * re[se] + 3 * (1 - he) * bmPow(he, 2) * ne[se] + bmPow(he, 3) * Q[se], _e[se] = ue, Se[se] !== null && (ve += bmPow(_e[se] - Se[se], 2)), Se[se] = _e[se]; ve && (ve = bmSqrt(ve), pe += ve), $e.percents[ae] = he, $e.lengths[ae] = pe } return $e.addedLength = pe, $e } }(); function p(Z) { var Q = segmentsLengthPool.newElement(), re = Z.c, ne = Z.v, oe = Z.o, ae = Z.i, se, le = Z._length, ue = Q.lengths, he = 0; for (se = 0; se < le - 1; se += 1)ue[se] = f(ne[se], ne[se + 1], oe[se], ae[se + 1]), he += ue[se].addedLength; return re && le && (ue[se] = f(ne[se], ne[0], oe[se], ae[0]), he += ue[se].addedLength), Q.totalLength = he, Q } function d(Z) { this.segmentLength = 0, this.points = new Array(Z) } function m(Z, Q) { this.partialLength = Z, this.point = Q } var v = function () { var Z = {}; return function (Q, re, ne, oe) { var ae = (Q[0] + "_" + Q[1] + "_" + re[0] + "_" + re[1] + "_" + ne[0] + "_" + ne[1] + "_" + oe[0] + "_" + oe[1]).replace(/\./g, "p"); if (!Z[ae]) { var se = getDefaultCurveSegments(), le, ue, he, pe, ve, _e = 0, Se, $e, ie = null; Q.length === 2 && (Q[0] !== re[0] || Q[1] !== re[1]) && l(Q[0], Q[1], re[0], re[1], Q[0] + ne[0], Q[1] + ne[1]) && l(Q[0], Q[1], re[0], re[1], re[0] + oe[0], re[1] + oe[1]) && (se = 2); var g = new d(se); for (he = ne.length, le = 0; le < se; le += 1) { for ($e = createSizedArray(he), ve = le / (se - 1), Se = 0, ue = 0; ue < he; ue += 1)pe = bmPow(1 - ve, 3) * Q[ue] + 3 * bmPow(1 - ve, 2) * ve * (Q[ue] + ne[ue]) + 3 * (1 - ve) * bmPow(ve, 2) * (re[ue] + oe[ue]) + bmPow(ve, 3) * re[ue], $e[ue] = pe, ie !== null && (Se += bmPow($e[ue] - ie[ue], 2)); Se = bmSqrt(Se), _e += Se, g.points[le] = new m(Se, $e), ie = $e } g.segmentLength = _e, Z[ae] = g } return Z[ae] } }(); function I(Z, Q) { var re = Q.percents, ne = Q.lengths, oe = re.length, ae = bmFloor((oe - 1) * Z), se = Z * Q.addedLength, le = 0; if (ae === oe - 1 || ae === 0 || se === ne[ae]) return re[ae]; for (var ue = ne[ae] > se ? -1 : 1, he = !0; he;)if (ne[ae] <= se && ne[ae + 1] > se ? (le = (se - ne[ae]) / (ne[ae + 1] - ne[ae]), he = !1) : ae += ue, ae < 0 || ae >= oe - 1) { if (ae === oe - 1) return re[ae]; he = !1 } return re[ae] + (re[ae + 1] - re[ae]) * le } function F(Z, Q, re, ne, oe, ae) { var se = I(oe, ae), le = 1 - se, ue = o.round((le * le * le * Z[0] + (se * le * le + le * se * le + le * le * se) * re[0] + (se * se * le + le * se * se + se * le * se) * ne[0] + se * se * se * Q[0]) * 1e3) / 1e3, he = o.round((le * le * le * Z[1] + (se * le * le + le * se * le + le * le * se) * re[1] + (se * se * le + le * se * se + se * le * se) * ne[1] + se * se * se * Q[1]) * 1e3) / 1e3; return [ue, he] } var B = createTypedArray("float32", 8); function W(Z, Q, re, ne, oe, ae, se) { oe < 0 ? oe = 0 : oe > 1 && (oe = 1); var le = I(oe, se); ae = ae > 1 ? 1 : ae; var ue = I(ae, se), he, pe = Z.length, ve = 1 - le, _e = 1 - ue, Se = ve * ve * ve, $e = le * ve * ve * 3, ie = le * le * ve * 3, g = le * le * le, P = ve * ve * _e, U = le * ve * _e + ve * le * _e + ve * ve * ue, K = le * le * _e + ve * le * ue + le * ve * ue, Y = le * le * ue, te = ve * _e * _e, ee = le * _e * _e + ve * ue * _e + ve * _e * ue, G = le * ue * _e + ve * ue * ue + le * _e * ue, y = le * ue * ue, X = _e * _e * _e, ce = ue * _e * _e + _e * ue * _e + _e * _e * ue, me = ue * ue * _e + _e * ue * ue + ue * _e * ue, Ae = ue * ue * ue; for (he = 0; he < pe; he += 1)B[he * 4] = o.round((Se * Z[he] + $e * re[he] + ie * ne[he] + g * Q[he]) * 1e3) / 1e3, B[he * 4 + 1] = o.round((P * Z[he] + U * re[he] + K * ne[he] + Y * Q[he]) * 1e3) / 1e3, B[he * 4 + 2] = o.round((te * Z[he] + ee * re[he] + G * ne[he] + y * Q[he]) * 1e3) / 1e3, B[he * 4 + 3] = o.round((X * Z[he] + ce * re[he] + me * ne[he] + Ae * Q[he]) * 1e3) / 1e3; return B } return { getSegmentsLength: p, getNewSegment: W, getPointInSegment: F, buildBezierData: v, pointOnLine2D: l, pointOnLine3D: u } } var bez = bezFunction(), initFrame = initialDefaultFrame, mathAbs = Math.abs; function interpolateValue(o, l) { var u = this.offsetTime, f; this.propType === "multidimensional" && (f = createTypedArray("float32", this.pv.length)); for (var p = l.lastIndex, d = p, m = this.keyframes.length - 1, v = !0, I, F, B; v;) { if (I = this.keyframes[d], F = this.keyframes[d + 1], d === m - 1 && o >= F.t - u) { I.h && (I = F), p = 0; break } if (F.t - u > o) { p = d; break } d < m - 1 ? d += 1 : (p = 0, v = !1) } B = this.keyframesMetadata[d] || {}; var W, Z, Q, re, ne, oe, ae = F.t - u, se = I.t - u, le; if (I.to) { B.bezierData || (B.bezierData = bez.buildBezierData(I.s, F.s || I.e, I.to, I.ti)); var ue = B.bezierData; if (o >= ae || o < se) { var he = o >= ae ? ue.points.length - 1 : 0; for (Z = ue.points[he].point.length, W = 0; W < Z; W += 1)f[W] = ue.points[he].point[W] } else { B.__fnct ? oe = B.__fnct : (oe = BezierFactory.getBezierEasing(I.o.x, I.o.y, I.i.x, I.i.y, I.n).get, B.__fnct = oe), Q = oe((o - se) / (ae - se)); var pe = ue.segmentLength * Q, ve, _e = l.lastFrame < o && l._lastKeyframeIndex === d ? l._lastAddedLength : 0; for (ne = l.lastFrame < o && l._lastKeyframeIndex === d ? l._lastPoint : 0, v = !0, re = ue.points.length; v;) { if (_e += ue.points[ne].partialLength, pe === 0 || Q === 0 || ne === ue.points.length - 1) { for (Z = ue.points[ne].point.length, W = 0; W < Z; W += 1)f[W] = ue.points[ne].point[W]; break } else if (pe >= _e && pe < _e + ue.points[ne + 1].partialLength) { for (ve = (pe - _e) / ue.points[ne + 1].partialLength, Z = ue.points[ne].point.length, W = 0; W < Z; W += 1)f[W] = ue.points[ne].point[W] + (ue.points[ne + 1].point[W] - ue.points[ne].point[W]) * ve; break } ne < re - 1 ? ne += 1 : v = !1 } l._lastPoint = ne, l._lastAddedLength = _e - ue.points[ne].partialLength, l._lastKeyframeIndex = d } } else { var Se, $e, ie, g, P; if (m = I.s.length, le = F.s || I.e, this.sh && I.h !== 1) if (o >= ae) f[0] = le[0], f[1] = le[1], f[2] = le[2]; else if (o <= se) f[0] = I.s[0], f[1] = I.s[1], f[2] = I.s[2]; else { var U = createQuaternion(I.s), K = createQuaternion(le), Y = (o - se) / (ae - se); quaternionToEuler(f, slerp(U, K, Y)) } else for (d = 0; d < m; d += 1)I.h !== 1 && (o >= ae ? Q = 1 : o < se ? Q = 0 : (I.o.x.constructor === Array ? (B.__fnct || (B.__fnct = []), B.__fnct[d] ? oe = B.__fnct[d] : (Se = I.o.x[d] === void 0 ? I.o.x[0] : I.o.x[d], $e = I.o.y[d] === void 0 ? I.o.y[0] : I.o.y[d], ie = I.i.x[d] === void 0 ? I.i.x[0] : I.i.x[d], g = I.i.y[d] === void 0 ? I.i.y[0] : I.i.y[d], oe = BezierFactory.getBezierEasing(Se, $e, ie, g).get, B.__fnct[d] = oe)) : B.__fnct ? oe = B.__fnct : (Se = I.o.x, $e = I.o.y, ie = I.i.x, g = I.i.y, oe = BezierFactory.getBezierEasing(Se, $e, ie, g).get, I.keyframeMetadata = oe), Q = oe((o - se) / (ae - se)))), le = F.s || I.e, P = I.h === 1 ? I.s[d] : I.s[d] + (le[d] - I.s[d]) * Q, this.propType === "multidimensional" ? f[d] = P : f = P } return l.lastIndex = p, f } function slerp(o, l, u) { var f = [], p = o[0], d = o[1], m = o[2], v = o[3], I = l[0], F = l[1], B = l[2], W = l[3], Z, Q, re, ne, oe; return Q = p * I + d * F + m * B + v * W, Q < 0 && (Q = -Q, I = -I, F = -F, B = -B, W = -W), 1 - Q > 1e-6 ? (Z = Math.acos(Q), re = Math.sin(Z), ne = Math.sin((1 - u) * Z) / re, oe = Math.sin(u * Z) / re) : (ne = 1 - u, oe = u), f[0] = ne * p + oe * I, f[1] = ne * d + oe * F, f[2] = ne * m + oe * B, f[3] = ne * v + oe * W, f } function quaternionToEuler(o, l) { var u = l[0], f = l[1], p = l[2], d = l[3], m = Math.atan2(2 * f * d - 2 * u * p, 1 - 2 * f * f - 2 * p * p), v = Math.asin(2 * u * f + 2 * p * d), I = Math.atan2(2 * u * d - 2 * f * p, 1 - 2 * u * u - 2 * p * p); o[0] = m / degToRads, o[1] = v / degToRads, o[2] = I / degToRads } function createQuaternion(o) { var l = o[0] * degToRads, u = o[1] * degToRads, f = o[2] * degToRads, p = Math.cos(l / 2), d = Math.cos(u / 2), m = Math.cos(f / 2), v = Math.sin(l / 2), I = Math.sin(u / 2), F = Math.sin(f / 2), B = p * d * m - v * I * F, W = v * I * m + p * d * F, Z = v * d * m + p * I * F, Q = p * I * m - v * d * F; return [W, Z, Q, B] } function getValueAtCurrentTime() { var o = this.comp.renderedFrame - this.offsetTime, l = this.keyframes[0].t - this.offsetTime, u = this.keyframes[this.keyframes.length - 1].t - this.offsetTime; if (!(o === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= u && o >= u || this._caching.lastFrame < l && o < l))) { this._caching.lastFrame >= o && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0); var f = this.interpolateValue(o, this._caching); this.pv = f } return this._caching.lastFrame = o, this.pv } function setVValue(o) { var l; if (this.propType === "unidimensional") l = o * this.mult, mathAbs(this.v - l) > 1e-5 && (this.v = l, this._mdf = !0); else for (var u = 0, f = this.v.length; u < f;)l = o[u] * this.mult, mathAbs(this.v[u] - l) > 1e-5 && (this.v[u] = l, this._mdf = !0), u += 1 } function processEffectsSequence() { if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) { if (this.lock) { this.setVValue(this.pv); return } this.lock = !0, this._mdf = this._isFirstFrame; var o, l = this.effectsSequence.length, u = this.kf ? this.pv : this.data.k; for (o = 0; o < l; o += 1)u = this.effectsSequence[o](u); this.setVValue(u), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId } } function addEffect(o) { this.effectsSequence.push(o), this.container.addDynamicProperty(this) } function ValueProperty(o, l, u, f) { this.propType = "unidimensional", this.mult = u || 1, this.data = l, this.v = u ? l.k * u : l.k, this.pv = l.k, this._mdf = !1, this.elem = o, this.container = f, this.comp = o.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect } function MultiDimensionalProperty(o, l, u, f) { this.propType = "multidimensional", this.mult = u || 1, this.data = l, this._mdf = !1, this.elem = o, this.container = f, this.comp = o.comp, this.k = !1, this.kf = !1, this.frameId = -1; var p, d = l.k.length; for (this.v = createTypedArray("float32", d), this.pv = createTypedArray("float32", d), this.vel = createTypedArray("float32", d), p = 0; p < d; p += 1)this.v[p] = l.k[p] * this.mult, this.pv[p] = l.k[p]; this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect } function KeyframedValueProperty(o, l, u, f) { this.propType = "unidimensional", this.keyframes = l.k, this.keyframesMetadata = [], this.offsetTime = o.data.st, this.frameId = -1, this._caching = { lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1 }, this.k = !0, this.kf = !0, this.data = l, this.mult = u || 1, this.elem = o, this.container = f, this.comp = o.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect } function KeyframedMultidimensionalProperty(o, l, u, f) { this.propType = "multidimensional"; var p, d = l.k.length, m, v, I, F; for (p = 0; p < d - 1; p += 1)l.k[p].to && l.k[p].s && l.k[p + 1] && l.k[p + 1].s && (m = l.k[p].s, v = l.k[p + 1].s, I = l.k[p].to, F = l.k[p].ti, (m.length === 2 && !(m[0] === v[0] && m[1] === v[1]) && bez.pointOnLine2D(m[0], m[1], v[0], v[1], m[0] + I[0], m[1] + I[1]) && bez.pointOnLine2D(m[0], m[1], v[0], v[1], v[0] + F[0], v[1] + F[1]) || m.length === 3 && !(m[0] === v[0] && m[1] === v[1] && m[2] === v[2]) && bez.pointOnLine3D(m[0], m[1], m[2], v[0], v[1], v[2], m[0] + I[0], m[1] + I[1], m[2] + I[2]) && bez.pointOnLine3D(m[0], m[1], m[2], v[0], v[1], v[2], v[0] + F[0], v[1] + F[1], v[2] + F[2])) && (l.k[p].to = null, l.k[p].ti = null), m[0] === v[0] && m[1] === v[1] && I[0] === 0 && I[1] === 0 && F[0] === 0 && F[1] === 0 && (m.length === 2 || m[2] === v[2] && I[2] === 0 && F[2] === 0) && (l.k[p].to = null, l.k[p].ti = null)); this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = l, this.keyframes = l.k, this.keyframesMetadata = [], this.offsetTime = o.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = u || 1, this.elem = o, this.container = f, this.comp = o.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1; var B = l.k[0].s.length; for (this.v = createTypedArray("float32", B), this.pv = createTypedArray("float32", B), p = 0; p < B; p += 1)this.v[p] = initFrame, this.pv[p] = initFrame; this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray("float32", B) }, this.addEffect = addEffect } var PropertyFactory = function () { function o(u, f, p, d, m) { f.sid && (f = u.globalData.slotManager.getProp(f)); var v; if (!f.k.length) v = new ValueProperty(u, f, d, m); else if (typeof f.k[0] == "number") v = new MultiDimensionalProperty(u, f, d, m); else switch (p) { case 0: v = new KeyframedValueProperty(u, f, d, m); break; case 1: v = new KeyframedMultidimensionalProperty(u, f, d, m); break }return v.effectsSequence.length && m.addDynamicProperty(v), v } var l = { getProp: o }; return l }(); function DynamicPropertyContainer() { } DynamicPropertyContainer.prototype = { addDynamicProperty: function (l) { this.dynamicProperties.indexOf(l) === -1 && (this.dynamicProperties.push(l), this.container.addDynamicProperty(this), this._isAnimated = !0) }, iterateDynamicProperties: function () { this._mdf = !1; var l, u = this.dynamicProperties.length; for (l = 0; l < u; l += 1)this.dynamicProperties[l].getValue(), this.dynamicProperties[l]._mdf && (this._mdf = !0) }, initDynamicPropertyContainer: function (l) { this.container = l, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1 } }; var pointPool = function () { function o() { return createTypedArray("float32", 2) } return poolFactory(8, o) }(); function ShapePath() { this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength) } ShapePath.prototype.setPathData = function (o, l) { this.c = o, this.setLength(l); for (var u = 0; u < l;)this.v[u] = pointPool.newElement(), this.o[u] = pointPool.newElement(), this.i[u] = pointPool.newElement(), u += 1 }, ShapePath.prototype.setLength = function (o) { for (; this._maxLength < o;)this.doubleArrayLength(); this._length = o }, ShapePath.prototype.doubleArrayLength = function () { this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2 }, ShapePath.prototype.setXYAt = function (o, l, u, f, p) { var d; switch (this._length = Math.max(this._length, f + 1), this._length >= this._maxLength && this.doubleArrayLength(), u) { case "v": d = this.v; break; case "i": d = this.i; break; case "o": d = this.o; break; default: d = []; break }(!d[f] || d[f] && !p) && (d[f] = pointPool.newElement()), d[f][0] = o, d[f][1] = l }, ShapePath.prototype.setTripleAt = function (o, l, u, f, p, d, m, v) { this.setXYAt(o, l, "v", m, v), this.setXYAt(u, f, "o", m, v), this.setXYAt(p, d, "i", m, v) }, ShapePath.prototype.reverse = function () { var o = new ShapePath; o.setPathData(this.c, this._length); var l = this.v, u = this.o, f = this.i, p = 0; this.c && (o.setTripleAt(l[0][0], l[0][1], f[0][0], f[0][1], u[0][0], u[0][1], 0, !1), p = 1); var d = this._length - 1, m = this._length, v; for (v = p; v < m; v += 1)o.setTripleAt(l[d][0], l[d][1], f[d][0], f[d][1], u[d][0], u[d][1], v, !1), d -= 1; return o }, ShapePath.prototype.length = function () { return this._length }; var shapePool = function () { function o() { return new ShapePath } function l(p) { var d = p._length, m; for (m = 0; m < d; m += 1)pointPool.release(p.v[m]), pointPool.release(p.i[m]), pointPool.release(p.o[m]), p.v[m] = null, p.i[m] = null, p.o[m] = null; p._length = 0, p.c = !1 } function u(p) { var d = f.newElement(), m, v = p._length === void 0 ? p.v.length : p._length; for (d.setLength(v), d.c = p.c, m = 0; m < v; m += 1)d.setTripleAt(p.v[m][0], p.v[m][1], p.o[m][0], p.o[m][1], p.i[m][0], p.i[m][1], m); return d } var f = poolFactory(4, o, l); return f.clone = u, f }(); function ShapeCollection() { this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength) } ShapeCollection.prototype.addShape = function (o) { this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = o, this._length += 1 }, ShapeCollection.prototype.releaseShapes = function () { var o; for (o = 0; o < this._length; o += 1)shapePool.release(this.shapes[o]); this._length = 0 }; var shapeCollectionPool = function () { var o = { newShapeCollection: p, release: d }, l = 0, u = 4, f = createSizedArray(u); function p() { var m; return l ? (l -= 1, m = f[l]) : m = new ShapeCollection, m } function d(m) { var v, I = m._length; for (v = 0; v < I; v += 1)shapePool.release(m.shapes[v]); m._length = 0, l === u && (f = pooling.double(f), u *= 2), f[l] = m, l += 1 } return o }(), ShapePropertyFactory = function () { var o = -999999; function l(ae, se, le) { var ue = le.lastIndex, he, pe, ve, _e, Se, $e, ie, g, P, U = this.keyframes; if (ae < U[0].t - this.offsetTime) he = U[0].s[0], ve = !0, ue = 0; else if (ae >= U[U.length - 1].t - this.offsetTime) he = U[U.length - 1].s ? U[U.length - 1].s[0] : U[U.length - 2].e[0], ve = !0; else { for (var K = ue, Y = U.length - 1, te = !0, ee, G, y; te && (ee = U[K], G = U[K + 1], !(G.t - this.offsetTime > ae));)K < Y - 1 ? K += 1 : te = !1; if (y = this.keyframesMetadata[K] || {}, ve = ee.h === 1, ue = K, !ve) { if (ae >= G.t - this.offsetTime) g = 1; else if (ae < ee.t - this.offsetTime) g = 0; else { var X; y.__fnct ? X = y.__fnct : (X = BezierFactory.getBezierEasing(ee.o.x, ee.o.y, ee.i.x, ee.i.y).get, y.__fnct = X), g = X((ae - (ee.t - this.offsetTime)) / (G.t - this.offsetTime - (ee.t - this.offsetTime))) } pe = G.s ? G.s[0] : ee.e[0] } he = ee.s[0] } for ($e = se._length, ie = he.i[0].length, le.lastIndex = ue, _e = 0; _e < $e; _e += 1)for (Se = 0; Se < ie; Se += 1)P = ve ? he.i[_e][Se] : he.i[_e][Se] + (pe.i[_e][Se] - he.i[_e][Se]) * g, se.i[_e][Se] = P, P = ve ? he.o[_e][Se] : he.o[_e][Se] + (pe.o[_e][Se] - he.o[_e][Se]) * g, se.o[_e][Se] = P, P = ve ? he.v[_e][Se] : he.v[_e][Se] + (pe.v[_e][Se] - he.v[_e][Se]) * g, se.v[_e][Se] = P } function u() { var ae = this.comp.renderedFrame - this.offsetTime, se = this.keyframes[0].t - this.offsetTime, le = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, ue = this._caching.lastFrame; return ue !== o && (ue < se && ae < se || ue > le && ae > le) || (this._caching.lastIndex = ue < ae ? this._caching.lastIndex : 0, this.interpolateShape(ae, this.pv, this._caching)), this._caching.lastFrame = ae, this.pv } function f() { this.paths = this.localShapeCollection } function p(ae, se) { if (ae._length !== se._length || ae.c !== se.c) return !1; var le, ue = ae._length; for (le = 0; le < ue; le += 1)if (ae.v[le][0] !== se.v[le][0] || ae.v[le][1] !== se.v[le][1] || ae.o[le][0] !== se.o[le][0] || ae.o[le][1] !== se.o[le][1] || ae.i[le][0] !== se.i[le][0] || ae.i[le][1] !== se.i[le][1]) return !1; return !0 } function d(ae) { p(this.v, ae) || (this.v = shapePool.clone(ae), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection) } function m() { if (this.elem.globalData.frameId !== this.frameId) { if (!this.effectsSequence.length) { this._mdf = !1; return } if (this.lock) { this.setVValue(this.pv); return } this.lock = !0, this._mdf = !1; var ae; this.kf ? ae = this.pv : this.data.ks ? ae = this.data.ks.k : ae = this.data.pt.k; var se, le = this.effectsSequence.length; for (se = 0; se < le; se += 1)ae = this.effectsSequence[se](ae); this.setVValue(ae), this.lock = !1, this.frameId = this.elem.globalData.frameId } } function v(ae, se, le) { this.propType = "shape", this.comp = ae.comp, this.container = ae, this.elem = ae, this.data = se, this.k = !1, this.kf = !1, this._mdf = !1; var ue = le === 3 ? se.pt.k : se.ks.k; this.v = shapePool.clone(ue), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = f, this.effectsSequence = [] } function I(ae) { this.effectsSequence.push(ae), this.container.addDynamicProperty(this) } v.prototype.interpolateShape = l, v.prototype.getValue = m, v.prototype.setVValue = d, v.prototype.addEffect = I; function F(ae, se, le) { this.propType = "shape", this.comp = ae.comp, this.elem = ae, this.container = ae, this.offsetTime = ae.data.st, this.keyframes = le === 3 ? se.pt.k : se.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0; var ue = this.keyframes[0].s[0].i.length; this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, ue), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = o, this.reset = f, this._caching = { lastFrame: o, lastIndex: 0 }, this.effectsSequence = [u.bind(this)] } F.prototype.getValue = m, F.prototype.interpolateShape = l, F.prototype.setVValue = d, F.prototype.addEffect = I; var B = function () { var ae = roundCorner; function se(le, ue) { this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = ue.d, this.elem = le, this.comp = le.comp, this.frameId = -1, this.initDynamicPropertyContainer(le), this.p = PropertyFactory.getProp(le, ue.p, 1, 0, this), this.s = PropertyFactory.getProp(le, ue.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath()) } return se.prototype = { reset: f, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath()) }, convertEllToPath: function () { var ue = this.p.v[0], he = this.p.v[1], pe = this.s.v[0] / 2, ve = this.s.v[1] / 2, _e = this.d !== 3, Se = this.v; Se.v[0][0] = ue, Se.v[0][1] = he - ve, Se.v[1][0] = _e ? ue + pe : ue - pe, Se.v[1][1] = he, Se.v[2][0] = ue, Se.v[2][1] = he + ve, Se.v[3][0] = _e ? ue - pe : ue + pe, Se.v[3][1] = he, Se.i[0][0] = _e ? ue - pe * ae : ue + pe * ae, Se.i[0][1] = he - ve, Se.i[1][0] = _e ? ue + pe : ue - pe, Se.i[1][1] = he - ve * ae, Se.i[2][0] = _e ? ue + pe * ae : ue - pe * ae, Se.i[2][1] = he + ve, Se.i[3][0] = _e ? ue - pe : ue + pe, Se.i[3][1] = he + ve * ae, Se.o[0][0] = _e ? ue + pe * ae : ue - pe * ae, Se.o[0][1] = he - ve, Se.o[1][0] = _e ? ue + pe : ue - pe, Se.o[1][1] = he + ve * ae, Se.o[2][0] = _e ? ue - pe * ae : ue + pe * ae, Se.o[2][1] = he + ve, Se.o[3][0] = _e ? ue - pe : ue + pe, Se.o[3][1] = he - ve * ae } }, extendPrototype([DynamicPropertyContainer], se), se }(), W = function () { function ae(se, le) { this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = se, this.comp = se.comp, this.data = le, this.frameId = -1, this.d = le.d, this.initDynamicPropertyContainer(se), le.sy === 1 ? (this.ir = PropertyFactory.getProp(se, le.ir, 0, 0, this), this.is = PropertyFactory.getProp(se, le.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(se, le.pt, 0, 0, this), this.p = PropertyFactory.getProp(se, le.p, 1, 0, this), this.r = PropertyFactory.getProp(se, le.r, 0, degToRads, this), this.or = PropertyFactory.getProp(se, le.or, 0, 0, this), this.os = PropertyFactory.getProp(se, le.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath()) } return ae.prototype = { reset: f, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath()) }, convertStarToPath: function () { var le = Math.floor(this.pt.v) * 2, ue = Math.PI * 2 / le, he = !0, pe = this.or.v, ve = this.ir.v, _e = this.os.v, Se = this.is.v, $e = 2 * Math.PI * pe / (le * 2), ie = 2 * Math.PI * ve / (le * 2), g, P, U, K, Y = -Math.PI / 2; Y += this.r.v; var te = this.data.d === 3 ? -1 : 1; for (this.v._length = 0, g = 0; g < le; g += 1) { P = he ? pe : ve, U = he ? _e : Se, K = he ? $e : ie; var ee = P * Math.cos(Y), G = P * Math.sin(Y), y = ee === 0 && G === 0 ? 0 : G / Math.sqrt(ee * ee + G * G), X = ee === 0 && G === 0 ? 0 : -ee / Math.sqrt(ee * ee + G * G); ee += +this.p.v[0], G += +this.p.v[1], this.v.setTripleAt(ee, G, ee - y * K * U * te, G - X * K * U * te, ee + y * K * U * te, G + X * K * U * te, g, !0), he = !he, Y += ue * te } }, convertPolygonToPath: function () { var le = Math.floor(this.pt.v), ue = Math.PI * 2 / le, he = this.or.v, pe = this.os.v, ve = 2 * Math.PI * he / (le * 4), _e, Se = -Math.PI * .5, $e = this.data.d === 3 ? -1 : 1; for (Se += this.r.v, this.v._length = 0, _e = 0; _e < le; _e += 1) { var ie = he * Math.cos(Se), g = he * Math.sin(Se), P = ie === 0 && g === 0 ? 0 : g / Math.sqrt(ie * ie + g * g), U = ie === 0 && g === 0 ? 0 : -ie / Math.sqrt(ie * ie + g * g); ie += +this.p.v[0], g += +this.p.v[1], this.v.setTripleAt(ie, g, ie - P * ve * pe * $e, g - U * ve * pe * $e, ie + P * ve * pe * $e, g + U * ve * pe * $e, _e, !0), Se += ue * $e } this.paths.length = 0, this.paths[0] = this.v } }, extendPrototype([DynamicPropertyContainer], ae), ae }(), Z = function () { function ae(se, le) { this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = se, this.comp = se.comp, this.frameId = -1, this.d = le.d, this.initDynamicPropertyContainer(se), this.p = PropertyFactory.getProp(se, le.p, 1, 0, this), this.s = PropertyFactory.getProp(se, le.s, 1, 0, this), this.r = PropertyFactory.getProp(se, le.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath()) } return ae.prototype = { convertRectToPath: function () { var le = this.p.v[0], ue = this.p.v[1], he = this.s.v[0] / 2, pe = this.s.v[1] / 2, ve = bmMin(he, pe, this.r.v), _e = ve * (1 - roundCorner); this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(le + he, ue - pe + ve, le + he, ue - pe + ve, le + he, ue - pe + _e, 0, !0), this.v.setTripleAt(le + he, ue + pe - ve, le + he, ue + pe - _e, le + he, ue + pe - ve, 1, !0), ve !== 0 ? (this.v.setTripleAt(le + he - ve, ue + pe, le + he - ve, ue + pe, le + he - _e, ue + pe, 2, !0), this.v.setTripleAt(le - he + ve, ue + pe, le - he + _e, ue + pe, le - he + ve, ue + pe, 3, !0), this.v.setTripleAt(le - he, ue + pe - ve, le - he, ue + pe - ve, le - he, ue + pe - _e, 4, !0), this.v.setTripleAt(le - he, ue - pe + ve, le - he, ue - pe + _e, le - he, ue - pe + ve, 5, !0), this.v.setTripleAt(le - he + ve, ue - pe, le - he + ve, ue - pe, le - he + _e, ue - pe, 6, !0), this.v.setTripleAt(le + he - ve, ue - pe, le + he - _e, ue - pe, le + he - ve, ue - pe, 7, !0)) : (this.v.setTripleAt(le - he, ue + pe, le - he + _e, ue + pe, le - he, ue + pe, 2), this.v.setTripleAt(le - he, ue - pe, le - he, ue - pe + _e, le - he, ue - pe, 3))) : (this.v.setTripleAt(le + he, ue - pe + ve, le + he, ue - pe + _e, le + he, ue - pe + ve, 0, !0), ve !== 0 ? (this.v.setTripleAt(le + he - ve, ue - pe, le + he - ve, ue - pe, le + he - _e, ue - pe, 1, !0), this.v.setTripleAt(le - he + ve, ue - pe, le - he + _e, ue - pe, le - he + ve, ue - pe, 2, !0), this.v.setTripleAt(le - he, ue - pe + ve, le - he, ue - pe + ve, le - he, ue - pe + _e, 3, !0), this.v.setTripleAt(le - he, ue + pe - ve, le - he, ue + pe - _e, le - he, ue + pe - ve, 4, !0), this.v.setTripleAt(le - he + ve, ue + pe, le - he + ve, ue + pe, le - he + _e, ue + pe, 5, !0), this.v.setTripleAt(le + he - ve, ue + pe, le + he - _e, ue + pe, le + he - ve, ue + pe, 6, !0), this.v.setTripleAt(le + he, ue + pe - ve, le + he, ue + pe - ve, le + he, ue + pe - _e, 7, !0)) : (this.v.setTripleAt(le - he, ue - pe, le - he + _e, ue - pe, le - he, ue - pe, 1, !0), this.v.setTripleAt(le - he, ue + pe, le - he, ue + pe - _e, le - he, ue + pe, 2, !0), this.v.setTripleAt(le + he, ue + pe, le + he - _e, ue + pe, le + he, ue + pe, 3, !0))) }, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath()) }, reset: f }, extendPrototype([DynamicPropertyContainer], ae), ae }(); function Q(ae, se, le) { var ue; if (le === 3 || le === 4) { var he = le === 3 ? se.pt : se.ks, pe = he.k; pe.length ? ue = new F(ae, se, le) : ue = new v(ae, se, le) } else le === 5 ? ue = new Z(ae, se) : le === 6 ? ue = new B(ae, se) : le === 7 && (ue = new W(ae, se)); return ue.k && ae.addDynamicProperty(ue), ue } function re() { return v } function ne() { return F } var oe = {}; return oe.getShapeProp = Q, oe.getConstructorFunction = re, oe.getKeyframedConstructorFunction = ne, oe }();/*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */var Matrix = function () { var o = Math.cos, l = Math.sin, u = Math.tan, f = Math.round; function p() { return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this } function d(ee) { if (ee === 0) return this; var G = o(ee), y = l(ee); return this._t(G, -y, 0, 0, y, G, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function m(ee) { if (ee === 0) return this; var G = o(ee), y = l(ee); return this._t(1, 0, 0, 0, 0, G, -y, 0, 0, y, G, 0, 0, 0, 0, 1) } function v(ee) { if (ee === 0) return this; var G = o(ee), y = l(ee); return this._t(G, 0, y, 0, 0, 1, 0, 0, -y, 0, G, 0, 0, 0, 0, 1) } function I(ee) { if (ee === 0) return this; var G = o(ee), y = l(ee); return this._t(G, -y, 0, 0, y, G, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function F(ee, G) { return this._t(1, G, ee, 1, 0, 0) } function B(ee, G) { return this.shear(u(ee), u(G)) } function W(ee, G) { var y = o(G), X = l(G); return this._t(y, X, 0, 0, -X, y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, u(ee), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(y, -X, 0, 0, X, y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function Z(ee, G, y) { return !y && y !== 0 && (y = 1), ee === 1 && G === 1 && y === 1 ? this : this._t(ee, 0, 0, 0, 0, G, 0, 0, 0, 0, y, 0, 0, 0, 0, 1) } function Q(ee, G, y, X, ce, me, Ae, Ie, Be, Me, De, Ue, Ke, Ve, ke, Je) { return this.props[0] = ee, this.props[1] = G, this.props[2] = y, this.props[3] = X, this.props[4] = ce, this.props[5] = me, this.props[6] = Ae, this.props[7] = Ie, this.props[8] = Be, this.props[9] = Me, this.props[10] = De, this.props[11] = Ue, this.props[12] = Ke, this.props[13] = Ve, this.props[14] = ke, this.props[15] = Je, this } function re(ee, G, y) { return y = y || 0, ee !== 0 || G !== 0 || y !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ee, G, y, 1) : this } function ne(ee, G, y, X, ce, me, Ae, Ie, Be, Me, De, Ue, Ke, Ve, ke, Je) { var dt = this.props; if (ee === 1 && G === 0 && y === 0 && X === 0 && ce === 0 && me === 1 && Ae === 0 && Ie === 0 && Be === 0 && Me === 0 && De === 1 && Ue === 0) return dt[12] = dt[12] * ee + dt[15] * Ke, dt[13] = dt[13] * me + dt[15] * Ve, dt[14] = dt[14] * De + dt[15] * ke, dt[15] *= Je, this._identityCalculated = !1, this; var lt = dt[0], ht = dt[1], Bt = dt[2], mt = dt[3], et = dt[4], Gt = dt[5], pt = dt[6], _t = dt[7], zt = dt[8], bt = dt[9], We = dt[10], Ge = dt[11], ze = dt[12], Ze = dt[13], ut = dt[14], ye = dt[15]; return dt[0] = lt * ee + ht * ce + Bt * Be + mt * Ke, dt[1] = lt * G + ht * me + Bt * Me + mt * Ve, dt[2] = lt * y + ht * Ae + Bt * De + mt * ke, dt[3] = lt * X + ht * Ie + Bt * Ue + mt * Je, dt[4] = et * ee + Gt * ce + pt * Be + _t * Ke, dt[5] = et * G + Gt * me + pt * Me + _t * Ve, dt[6] = et * y + Gt * Ae + pt * De + _t * ke, dt[7] = et * X + Gt * Ie + pt * Ue + _t * Je, dt[8] = zt * ee + bt * ce + We * Be + Ge * Ke, dt[9] = zt * G + bt * me + We * Me + Ge * Ve, dt[10] = zt * y + bt * Ae + We * De + Ge * ke, dt[11] = zt * X + bt * Ie + We * Ue + Ge * Je, dt[12] = ze * ee + Ze * ce + ut * Be + ye * Ke, dt[13] = ze * G + Ze * me + ut * Me + ye * Ve, dt[14] = ze * y + Ze * Ae + ut * De + ye * ke, dt[15] = ze * X + Ze * Ie + ut * Ue + ye * Je, this._identityCalculated = !1, this } function oe(ee) { var G = ee.props; return this.transform(G[0], G[1], G[2], G[3], G[4], G[5], G[6], G[7], G[8], G[9], G[10], G[11], G[12], G[13], G[14], G[15]) } function ae() { return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity } function se(ee) { for (var G = 0; G < 16;) { if (ee.props[G] !== this.props[G]) return !1; G += 1 } return !0 } function le(ee) { var G; for (G = 0; G < 16; G += 1)ee.props[G] = this.props[G]; return ee } function ue(ee) { var G; for (G = 0; G < 16; G += 1)this.props[G] = ee[G] } function he(ee, G, y) { return { x: ee * this.props[0] + G * this.props[4] + y * this.props[8] + this.props[12], y: ee * this.props[1] + G * this.props[5] + y * this.props[9] + this.props[13], z: ee * this.props[2] + G * this.props[6] + y * this.props[10] + this.props[14] } } function pe(ee, G, y) { return ee * this.props[0] + G * this.props[4] + y * this.props[8] + this.props[12] } function ve(ee, G, y) { return ee * this.props[1] + G * this.props[5] + y * this.props[9] + this.props[13] } function _e(ee, G, y) { return ee * this.props[2] + G * this.props[6] + y * this.props[10] + this.props[14] } function Se() { var ee = this.props[0] * this.props[5] - this.props[1] * this.props[4], G = this.props[5] / ee, y = -this.props[1] / ee, X = -this.props[4] / ee, ce = this.props[0] / ee, me = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / ee, Ae = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / ee, Ie = new Matrix; return Ie.props[0] = G, Ie.props[1] = y, Ie.props[4] = X, Ie.props[5] = ce, Ie.props[12] = me, Ie.props[13] = Ae, Ie } function $e(ee) { var G = this.getInverseMatrix(); return G.applyToPointArray(ee[0], ee[1], ee[2] || 0) } function ie(ee) { var G, y = ee.length, X = []; for (G = 0; G < y; G += 1)X[G] = $e(ee[G]); return X } function g(ee, G, y) { var X = createTypedArray("float32", 6); if (this.isIdentity()) X[0] = ee[0], X[1] = ee[1], X[2] = G[0], X[3] = G[1], X[4] = y[0], X[5] = y[1]; else { var ce = this.props[0], me = this.props[1], Ae = this.props[4], Ie = this.props[5], Be = this.props[12], Me = this.props[13]; X[0] = ee[0] * ce + ee[1] * Ae + Be, X[1] = ee[0] * me + ee[1] * Ie + Me, X[2] = G[0] * ce + G[1] * Ae + Be, X[3] = G[0] * me + G[1] * Ie + Me, X[4] = y[0] * ce + y[1] * Ae + Be, X[5] = y[0] * me + y[1] * Ie + Me } return X } function P(ee, G, y) { var X; return this.isIdentity() ? X = [ee, G, y] : X = [ee * this.props[0] + G * this.props[4] + y * this.props[8] + this.props[12], ee * this.props[1] + G * this.props[5] + y * this.props[9] + this.props[13], ee * this.props[2] + G * this.props[6] + y * this.props[10] + this.props[14]], X } function U(ee, G) { if (this.isIdentity()) return ee + "," + G; var y = this.props; return Math.round((ee * y[0] + G * y[4] + y[12]) * 100) / 100 + "," + Math.round((ee * y[1] + G * y[5] + y[13]) * 100) / 100 } function K() { for (var ee = 0, G = this.props, y = "matrix3d(", X = 1e4; ee < 16;)y += f(G[ee] * X) / X, y += ee === 15 ? ")" : ",", ee += 1; return y } function Y(ee) { var G = 1e4; return ee < 1e-6 && ee > 0 || ee > -1e-6 && ee < 0 ? f(ee * G) / G : ee } function te() { var ee = this.props, G = Y(ee[0]), y = Y(ee[1]), X = Y(ee[4]), ce = Y(ee[5]), me = Y(ee[12]), Ae = Y(ee[13]); return "matrix(" + G + "," + y + "," + X + "," + ce + "," + me + "," + Ae + ")" } return function () { this.reset = p, this.rotate = d, this.rotateX = m, this.rotateY = v, this.rotateZ = I, this.skew = B, this.skewFromAxis = W, this.shear = F, this.scale = Z, this.setTransform = Q, this.translate = re, this.transform = ne, this.multiply = oe, this.applyToPoint = he, this.applyToX = pe, this.applyToY = ve, this.applyToZ = _e, this.applyToPointArray = P, this.applyToTriplePoints = g, this.applyToPointStringified = U, this.toCSS = K, this.to2dCSS = te, this.clone = le, this.cloneFromProps = ue, this.equals = se, this.inversePoints = ie, this.inversePoint = $e, this.getInverseMatrix = Se, this._t = this.transform, this.isIdentity = ae, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset() } }(); function _typeof$3(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function (u) { return typeof u } : _typeof$3 = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof$3(o) } var lottie = {}; function setLocation(o) { setLocationHref(o) } function searchAnimations() { animationManager.searchAnimations() } function setSubframeRendering(o) { setSubframeEnabled(o) } function setPrefix(o) { setIdPrefix(o) } function loadAnimation(o) { return animationManager.loadAnimation(o) } function setQuality(o) { if (typeof o == "string") switch (o) { case "high": setDefaultCurveSegments(200); break; default: case "medium": setDefaultCurveSegments(50); break; case "low": setDefaultCurveSegments(10); break } else !isNaN(o) && o > 1 && setDefaultCurveSegments(o) } function inBrowser() { return typeof navigator < "u" } function installPlugin(o, l) { o === "expressions" && setExpressionsPlugin(l) } function getFactory(o) { switch (o) { case "propertyFactory": return PropertyFactory; case "shapePropertyFactory": return ShapePropertyFactory; case "matrix": return Matrix; default: return null } } lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2"; function checkReady() { document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations()) } function getQueryVariable(o) { for (var l = queryString.split("&"), u = 0; u < l.length; u += 1) { var f = l[u].split("="); if (decodeURIComponent(f[0]) == o) return decodeURIComponent(f[1]) } return null } var queryString = ""; { var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || { src: "" }; queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer") } var readyStateCheckInterval = setInterval(checkReady, 100); try { _typeof$3(exports) !== "object" && (window.bodymovin = lottie) } catch (o) { } var ShapeModifiers = function () { var o = {}, l = {}; o.registerModifier = u, o.getModifier = f; function u(p, d) { l[p] || (l[p] = d) } function f(p, d, m) { return new l[p](d, m) } return o }(); function ShapeModifier() { } ShapeModifier.prototype.initModifierProperties = function () { }, ShapeModifier.prototype.addShapeToModifier = function () { }, ShapeModifier.prototype.addShape = function (o) { if (!this.closed) { o.sh.container.addDynamicProperty(o.sh); var l = { shape: o.sh, data: o, localShapeCollection: shapeCollectionPool.newShapeCollection() }; this.shapes.push(l), this.addShapeToModifier(l), this._isAnimated && o.setAsAnimated() } }, ShapeModifier.prototype.init = function (o, l) { this.shapes = [], this.elem = o, this.initDynamicPropertyContainer(o), this.initModifierProperties(o, l), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, ShapeModifier.prototype.processKeys = function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties()) }, extendPrototype([DynamicPropertyContainer], ShapeModifier); function TrimModifier() { } extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (o, l) { this.s = PropertyFactory.getProp(o, l.s, 0, .01, this), this.e = PropertyFactory.getProp(o, l.e, 0, .01, this), this.o = PropertyFactory.getProp(o, l.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = l.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length }, TrimModifier.prototype.addShapeToModifier = function (o) { o.pathsData = [] }, TrimModifier.prototype.calculateShapeEdges = function (o, l, u, f, p) { var d = []; l <= 1 ? d.push({ s: o, e: l }) : o >= 1 ? d.push({ s: o - 1, e: l - 1 }) : (d.push({ s: o, e: 1 }), d.push({ s: 0, e: l - 1 })); var m = [], v, I = d.length, F; for (v = 0; v < I; v += 1)if (F = d[v], !(F.e * p < f || F.s * p > f + u)) { var B, W; F.s * p <= f ? B = 0 : B = (F.s * p - f) / u, F.e * p >= f + u ? W = 1 : W = (F.e * p - f) / u, m.push([B, W]) } return m.length || m.push([0, 0]), m }, TrimModifier.prototype.releasePathsData = function (o) { var l, u = o.length; for (l = 0; l < u; l += 1)segmentsLengthPool.release(o[l]); return o.length = 0, o }, TrimModifier.prototype.processShapes = function (o) { var l, u; if (this._mdf || o) { var f = this.o.v % 360 / 360; if (f < 0 && (f += 1), this.s.v > 1 ? l = 1 + f : this.s.v < 0 ? l = 0 + f : l = this.s.v + f, this.e.v > 1 ? u = 1 + f : this.e.v < 0 ? u = 0 + f : u = this.e.v + f, l > u) { var p = l; l = u, u = p } l = Math.round(l * 1e4) * 1e-4, u = Math.round(u * 1e4) * 1e-4, this.sValue = l, this.eValue = u } else l = this.sValue, u = this.eValue; var d, m, v = this.shapes.length, I, F, B, W, Z, Q = 0; if (u === l) for (m = 0; m < v; m += 1)this.shapes[m].localShapeCollection.releaseShapes(), this.shapes[m].shape._mdf = !0, this.shapes[m].shape.paths = this.shapes[m].localShapeCollection, this._mdf && (this.shapes[m].pathsData.length = 0); else if (u === 1 && l === 0 || u === 0 && l === 1) { if (this._mdf) for (m = 0; m < v; m += 1)this.shapes[m].pathsData.length = 0, this.shapes[m].shape._mdf = !0 } else { var re = [], ne, oe; for (m = 0; m < v; m += 1)if (ne = this.shapes[m], !ne.shape._mdf && !this._mdf && !o && this.m !== 2) ne.shape.paths = ne.localShapeCollection; else { if (d = ne.shape.paths, F = d._length, Z = 0, !ne.shape._mdf && ne.pathsData.length) Z = ne.totalShapeLength; else { for (B = this.releasePathsData(ne.pathsData), I = 0; I < F; I += 1)W = bez.getSegmentsLength(d.shapes[I]), B.push(W), Z += W.totalLength; ne.totalShapeLength = Z, ne.pathsData = B } Q += Z, ne.shape._mdf = !0 } var ae = l, se = u, le = 0, ue; for (m = v - 1; m >= 0; m -= 1)if (ne = this.shapes[m], ne.shape._mdf) { for (oe = ne.localShapeCollection, oe.releaseShapes(), this.m === 2 && v > 1 ? (ue = this.calculateShapeEdges(l, u, ne.totalShapeLength, le, Q), le += ne.totalShapeLength) : ue = [[ae, se]], F = ue.length, I = 0; I < F; I += 1) { ae = ue[I][0], se = ue[I][1], re.length = 0, se <= 1 ? re.push({ s: ne.totalShapeLength * ae, e: ne.totalShapeLength * se }) : ae >= 1 ? re.push({ s: ne.totalShapeLength * (ae - 1), e: ne.totalShapeLength * (se - 1) }) : (re.push({ s: ne.totalShapeLength * ae, e: ne.totalShapeLength }), re.push({ s: 0, e: ne.totalShapeLength * (se - 1) })); var he = this.addShapes(ne, re[0]); if (re[0].s !== re[0].e) { if (re.length > 1) { var pe = ne.shape.paths.shapes[ne.shape.paths._length - 1]; if (pe.c) { var ve = he.pop(); this.addPaths(he, oe), he = this.addShapes(ne, re[1], ve) } else this.addPaths(he, oe), he = this.addShapes(ne, re[1]) } this.addPaths(he, oe) } } ne.shape.paths = oe } } }, TrimModifier.prototype.addPaths = function (o, l) { var u, f = o.length; for (u = 0; u < f; u += 1)l.addShape(o[u]) }, TrimModifier.prototype.addSegment = function (o, l, u, f, p, d, m) { p.setXYAt(l[0], l[1], "o", d), p.setXYAt(u[0], u[1], "i", d + 1), m && p.setXYAt(o[0], o[1], "v", d), p.setXYAt(f[0], f[1], "v", d + 1) }, TrimModifier.prototype.addSegmentFromArray = function (o, l, u, f) { l.setXYAt(o[1], o[5], "o", u), l.setXYAt(o[2], o[6], "i", u + 1), f && l.setXYAt(o[0], o[4], "v", u), l.setXYAt(o[3], o[7], "v", u + 1) }, TrimModifier.prototype.addShapes = function (o, l, u) { var f = o.pathsData, p = o.shape.paths.shapes, d, m = o.shape.paths._length, v, I, F = 0, B, W, Z, Q, re = [], ne, oe = !0; for (u ? (W = u._length, ne = u._length) : (u = shapePool.newElement(), W = 0, ne = 0), re.push(u), d = 0; d < m; d += 1) { for (Z = f[d].lengths, u.c = p[d].c, I = p[d].c ? Z.length : Z.length + 1, v = 1; v < I; v += 1)if (B = Z[v - 1], F + B.addedLength < l.s) F += B.addedLength, u.c = !1; else if (F > l.e) { u.c = !1; break } else l.s <= F && l.e >= F + B.addedLength ? (this.addSegment(p[d].v[v - 1], p[d].o[v - 1], p[d].i[v], p[d].v[v], u, W, oe), oe = !1) : (Q = bez.getNewSegment(p[d].v[v - 1], p[d].v[v], p[d].o[v - 1], p[d].i[v], (l.s - F) / B.addedLength, (l.e - F) / B.addedLength, Z[v - 1]), this.addSegmentFromArray(Q, u, W, oe), oe = !1, u.c = !1), F += B.addedLength, W += 1; if (p[d].c && Z.length) { if (B = Z[v - 1], F <= l.e) { var ae = Z[v - 1].addedLength; l.s <= F && l.e >= F + ae ? (this.addSegment(p[d].v[v - 1], p[d].o[v - 1], p[d].i[0], p[d].v[0], u, W, oe), oe = !1) : (Q = bez.getNewSegment(p[d].v[v - 1], p[d].v[0], p[d].o[v - 1], p[d].i[0], (l.s - F) / ae, (l.e - F) / ae, Z[v - 1]), this.addSegmentFromArray(Q, u, W, oe), oe = !1, u.c = !1) } else u.c = !1; F += B.addedLength, W += 1 } if (u._length && (u.setXYAt(u.v[ne][0], u.v[ne][1], "i", ne), u.setXYAt(u.v[u._length - 1][0], u.v[u._length - 1][1], "o", u._length - 1)), F > l.e) break; d < m - 1 && (u = shapePool.newElement(), oe = !0, re.push(u), W = 0) } return re }; function PuckerAndBloatModifier() { } extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (o, l) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(o, l.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length }, PuckerAndBloatModifier.prototype.processPath = function (o, l) { var u = l / 100, f = [0, 0], p = o._length, d = 0; for (d = 0; d < p; d += 1)f[0] += o.v[d][0], f[1] += o.v[d][1]; f[0] /= p, f[1] /= p; var m = shapePool.newElement(); m.c = o.c; var v, I, F, B, W, Z; for (d = 0; d < p; d += 1)v = o.v[d][0] + (f[0] - o.v[d][0]) * u, I = o.v[d][1] + (f[1] - o.v[d][1]) * u, F = o.o[d][0] + (f[0] - o.o[d][0]) * -u, B = o.o[d][1] + (f[1] - o.o[d][1]) * -u, W = o.i[d][0] + (f[0] - o.i[d][0]) * -u, Z = o.i[d][1] + (f[1] - o.i[d][1]) * -u, m.setTripleAt(v, I, F, B, W, Z, d); return m }, PuckerAndBloatModifier.prototype.processShapes = function (o) { var l, u, f = this.shapes.length, p, d, m = this.amount.v; if (m !== 0) { var v, I; for (u = 0; u < f; u += 1) { if (v = this.shapes[u], I = v.localShapeCollection, !(!v.shape._mdf && !this._mdf && !o)) for (I.releaseShapes(), v.shape._mdf = !0, l = v.shape.paths.shapes, d = v.shape.paths._length, p = 0; p < d; p += 1)I.addShape(this.processPath(l[p], m)); v.shape.paths = v.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; var TransformPropertyFactory = function () { var o = [0, 0]; function l(I) { var F = this._mdf; this.iterateDynamicProperties(), this._mdf = this._mdf || F, this.a && I.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && I.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && I.skewFromAxis(-this.sk.v, this.sa.v), this.r ? I.rotate(-this.r.v) : I.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? I.translate(this.px.v, this.py.v, -this.pz.v) : I.translate(this.px.v, this.py.v, 0) : I.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } function u(I) { if (this.elem.globalData.frameId !== this.frameId) { if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || I) { var F; if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) { var B, W; if (F = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (B = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / F, 0), W = this.p.getValueAtTime(this.p.keyframes[0].t / F, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (B = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / F, 0), W = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / F, 0)) : (B = this.p.pv, W = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / F, this.p.offsetTime)); else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) { B = [], W = []; var Z = this.px, Q = this.py; Z._caching.lastFrame + Z.offsetTime <= Z.keyframes[0].t ? (B[0] = Z.getValueAtTime((Z.keyframes[0].t + .01) / F, 0), B[1] = Q.getValueAtTime((Q.keyframes[0].t + .01) / F, 0), W[0] = Z.getValueAtTime(Z.keyframes[0].t / F, 0), W[1] = Q.getValueAtTime(Q.keyframes[0].t / F, 0)) : Z._caching.lastFrame + Z.offsetTime >= Z.keyframes[Z.keyframes.length - 1].t ? (B[0] = Z.getValueAtTime(Z.keyframes[Z.keyframes.length - 1].t / F, 0), B[1] = Q.getValueAtTime(Q.keyframes[Q.keyframes.length - 1].t / F, 0), W[0] = Z.getValueAtTime((Z.keyframes[Z.keyframes.length - 1].t - .01) / F, 0), W[1] = Q.getValueAtTime((Q.keyframes[Q.keyframes.length - 1].t - .01) / F, 0)) : (B = [Z.pv, Q.pv], W[0] = Z.getValueAtTime((Z._caching.lastFrame + Z.offsetTime - .01) / F, Z.offsetTime), W[1] = Q.getValueAtTime((Q._caching.lastFrame + Q.offsetTime - .01) / F, Q.offsetTime)) } else W = o, B = W; this.v.rotate(-Math.atan2(B[1] - W[1], B[0] - W[0])) } this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } this.frameId = this.elem.globalData.frameId } } function f() { if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length) this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1; else return; if (!this.s.effectsSequence.length) this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2; else return; if (this.sk) if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3; else return; this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4) } function p() { } function d(I) { this._addDynamicProperty(I), this.elem.addDynamicProperty(I), this._isDirty = !0 } function m(I, F, B) { if (this.elem = I, this.frameId = -1, this.propType = "transform", this.data = F, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(B || I), F.p && F.p.s ? (this.px = PropertyFactory.getProp(I, F.p.x, 0, 0, this), this.py = PropertyFactory.getProp(I, F.p.y, 0, 0, this), F.p.z && (this.pz = PropertyFactory.getProp(I, F.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(I, F.p || { k: [0, 0, 0] }, 1, 0, this), F.rx) { if (this.rx = PropertyFactory.getProp(I, F.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(I, F.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(I, F.rz, 0, degToRads, this), F.or.k[0].ti) { var W, Z = F.or.k.length; for (W = 0; W < Z; W += 1)F.or.k[W].to = null, F.or.k[W].ti = null } this.or = PropertyFactory.getProp(I, F.or, 1, degToRads, this), this.or.sh = !0 } else this.r = PropertyFactory.getProp(I, F.r || { k: 0 }, 0, degToRads, this); F.sk && (this.sk = PropertyFactory.getProp(I, F.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(I, F.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(I, F.a || { k: [0, 0, 0] }, 1, 0, this), this.s = PropertyFactory.getProp(I, F.s || { k: [100, 100, 100] }, 1, .01, this), F.o ? this.o = PropertyFactory.getProp(I, F.o, 0, .01, I) : this.o = { _mdf: !1, v: 1 }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0) } m.prototype = { applyToMatrix: l, getValue: u, precalculateMatrix: f, autoOrient: p }, extendPrototype([DynamicPropertyContainer], m), m.prototype.addDynamicProperty = d, m.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty; function v(I, F, B) { return new m(I, F, B) } return { getTransformProperty: v } }(); function RepeaterModifier() { } extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (o, l) { this.getValue = this.processKeys, this.c = PropertyFactory.getProp(o, l.c, 0, null, this), this.o = PropertyFactory.getProp(o, l.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(o, l.tr, this), this.so = PropertyFactory.getProp(o, l.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(o, l.tr.eo, 0, .01, this), this.data = l, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix }, RepeaterModifier.prototype.applyTransforms = function (o, l, u, f, p, d) { var m = d ? -1 : 1, v = f.s.v[0] + (1 - f.s.v[0]) * (1 - p), I = f.s.v[1] + (1 - f.s.v[1]) * (1 - p); o.translate(f.p.v[0] * m * p, f.p.v[1] * m * p, f.p.v[2]), l.translate(-f.a.v[0], -f.a.v[1], f.a.v[2]), l.rotate(-f.r.v * m * p), l.translate(f.a.v[0], f.a.v[1], f.a.v[2]), u.translate(-f.a.v[0], -f.a.v[1], f.a.v[2]), u.scale(d ? 1 / v : v, d ? 1 / I : I), u.translate(f.a.v[0], f.a.v[1], f.a.v[2]) }, RepeaterModifier.prototype.init = function (o, l, u, f) { for (this.elem = o, this.arr = l, this.pos = u, this.elemsData = f, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(o), this.initModifierProperties(o, l[u]); u > 0;)u -= 1, this._elements.unshift(l[u]); this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, RepeaterModifier.prototype.resetElements = function (o) { var l, u = o.length; for (l = 0; l < u; l += 1)o[l]._processed = !1, o[l].ty === "gr" && this.resetElements(o[l].it) }, RepeaterModifier.prototype.cloneElements = function (o) { var l = JSON.parse(JSON.stringify(o)); return this.resetElements(l), l }, RepeaterModifier.prototype.changeGroupRender = function (o, l) { var u, f = o.length; for (u = 0; u < f; u += 1)o[u]._render = l, o[u].ty === "gr" && this.changeGroupRender(o[u].it, l) }, RepeaterModifier.prototype.processShapes = function (o) { var l, u, f, p, d, m = !1; if (this._mdf || o) { var v = Math.ceil(this.c.v); if (this._groups.length < v) { for (; this._groups.length < v;) { var I = { it: this.cloneElements(this._elements), ty: "gr" }; I.it.push({ a: { a: 0, ix: 1, k: [0, 0] }, nm: "Transform", o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: "tr" }), this.arr.splice(0, 0, I), this._groups.splice(0, 0, I), this._currentCopies += 1 } this.elem.reloadShapes(), m = !0 } d = 0; var F; for (f = 0; f <= this._groups.length - 1; f += 1) { if (F = d < v, this._groups[f]._render = F, this.changeGroupRender(this._groups[f].it, F), !F) { var B = this.elemsData[f].it, W = B[B.length - 1]; W.transform.op.v !== 0 ? (W.transform.op._mdf = !0, W.transform.op.v = 0) : W.transform.op._mdf = !1 } d += 1 } this._currentCopies = v; var Z = this.o.v, Q = Z % 1, re = Z > 0 ? Math.floor(Z) : Math.ceil(Z), ne = this.pMatrix.props, oe = this.rMatrix.props, ae = this.sMatrix.props; this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset(); var se = 0; if (Z > 0) { for (; se < re;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), se += 1; Q && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, Q, !1), se += Q) } else if (Z < 0) { for (; se > re;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), se -= 1; Q && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -Q, !0), se -= Q) } f = this.data.m === 1 ? 0 : this._currentCopies - 1, p = this.data.m === 1 ? 1 : -1, d = this._currentCopies; for (var le, ue; d;) { if (l = this.elemsData[f].it, u = l[l.length - 1].transform.mProps.v.props, ue = u.length, l[l.length - 1].transform.mProps._mdf = !0, l[l.length - 1].transform.op._mdf = !0, l[l.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (f / (this._currentCopies - 1)), se !== 0) { for ((f !== 0 && p === 1 || f !== this._currentCopies - 1 && p === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(oe[0], oe[1], oe[2], oe[3], oe[4], oe[5], oe[6], oe[7], oe[8], oe[9], oe[10], oe[11], oe[12], oe[13], oe[14], oe[15]), this.matrix.transform(ae[0], ae[1], ae[2], ae[3], ae[4], ae[5], ae[6], ae[7], ae[8], ae[9], ae[10], ae[11], ae[12], ae[13], ae[14], ae[15]), this.matrix.transform(ne[0], ne[1], ne[2], ne[3], ne[4], ne[5], ne[6], ne[7], ne[8], ne[9], ne[10], ne[11], ne[12], ne[13], ne[14], ne[15]), le = 0; le < ue; le += 1)u[le] = this.matrix.props[le]; this.matrix.reset() } else for (this.matrix.reset(), le = 0; le < ue; le += 1)u[le] = this.matrix.props[le]; se += 1, d -= 1, f += p } } else for (d = this._currentCopies, f = 0, p = 1; d;)l = this.elemsData[f].it, u = l[l.length - 1].transform.mProps.v.props, l[l.length - 1].transform.mProps._mdf = !1, l[l.length - 1].transform.op._mdf = !1, d -= 1, f += p; return m }, RepeaterModifier.prototype.addShape = function () { }; function RoundCornersModifier() { } extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (o, l) { this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(o, l.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length }, RoundCornersModifier.prototype.processPath = function (o, l) { var u = shapePool.newElement(); u.c = o.c; var f, p = o._length, d, m, v, I, F, B, W = 0, Z, Q, re, ne, oe, ae; for (f = 0; f < p; f += 1)d = o.v[f], v = o.o[f], m = o.i[f], d[0] === v[0] && d[1] === v[1] && d[0] === m[0] && d[1] === m[1] ? (f === 0 || f === p - 1) && !o.c ? (u.setTripleAt(d[0], d[1], v[0], v[1], m[0], m[1], W), W += 1) : (f === 0 ? I = o.v[p - 1] : I = o.v[f - 1], F = Math.sqrt(Math.pow(d[0] - I[0], 2) + Math.pow(d[1] - I[1], 2)), B = F ? Math.min(F / 2, l) / F : 0, oe = d[0] + (I[0] - d[0]) * B, Z = oe, ae = d[1] - (d[1] - I[1]) * B, Q = ae, re = Z - (Z - d[0]) * roundCorner, ne = Q - (Q - d[1]) * roundCorner, u.setTripleAt(Z, Q, re, ne, oe, ae, W), W += 1, f === p - 1 ? I = o.v[0] : I = o.v[f + 1], F = Math.sqrt(Math.pow(d[0] - I[0], 2) + Math.pow(d[1] - I[1], 2)), B = F ? Math.min(F / 2, l) / F : 0, re = d[0] + (I[0] - d[0]) * B, Z = re, ne = d[1] + (I[1] - d[1]) * B, Q = ne, oe = Z - (Z - d[0]) * roundCorner, ae = Q - (Q - d[1]) * roundCorner, u.setTripleAt(Z, Q, re, ne, oe, ae, W), W += 1) : (u.setTripleAt(o.v[f][0], o.v[f][1], o.o[f][0], o.o[f][1], o.i[f][0], o.i[f][1], W), W += 1); return u }, RoundCornersModifier.prototype.processShapes = function (o) { var l, u, f = this.shapes.length, p, d, m = this.rd.v; if (m !== 0) { var v, I; for (u = 0; u < f; u += 1) { if (v = this.shapes[u], I = v.localShapeCollection, !(!v.shape._mdf && !this._mdf && !o)) for (I.releaseShapes(), v.shape._mdf = !0, l = v.shape.paths.shapes, d = v.shape.paths._length, p = 0; p < d; p += 1)I.addShape(this.processPath(l[p], m)); v.shape.paths = v.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function floatEqual(o, l) { return Math.abs(o - l) * 1e5 <= Math.min(Math.abs(o), Math.abs(l)) } function floatZero(o) { return Math.abs(o) <= 1e-5 } function lerp(o, l, u) { return o * (1 - u) + l * u } function lerpPoint(o, l, u) { return [lerp(o[0], l[0], u), lerp(o[1], l[1], u)] } function quadRoots(o, l, u) { if (o === 0) return []; var f = l * l - 4 * o * u; if (f < 0) return []; var p = -l / (2 * o); if (f === 0) return [p]; var d = Math.sqrt(f) / (2 * o); return [p - d, p + d] } function polynomialCoefficients(o, l, u, f) { return [-o + 3 * l - 3 * u + f, 3 * o - 6 * l + 3 * u, -3 * o + 3 * l, o] } function singlePoint(o) { return new PolynomialBezier(o, o, o, o, !1) } function PolynomialBezier(o, l, u, f, p) { p && pointEqual(o, l) && (l = lerpPoint(o, f, 1 / 3)), p && pointEqual(u, f) && (u = lerpPoint(o, f, 2 / 3)); var d = polynomialCoefficients(o[0], l[0], u[0], f[0]), m = polynomialCoefficients(o[1], l[1], u[1], f[1]); this.a = [d[0], m[0]], this.b = [d[1], m[1]], this.c = [d[2], m[2]], this.d = [d[3], m[3]], this.points = [o, l, u, f] } PolynomialBezier.prototype.point = function (o) { return [((this.a[0] * o + this.b[0]) * o + this.c[0]) * o + this.d[0], ((this.a[1] * o + this.b[1]) * o + this.c[1]) * o + this.d[1]] }, PolynomialBezier.prototype.derivative = function (o) { return [(3 * o * this.a[0] + 2 * this.b[0]) * o + this.c[0], (3 * o * this.a[1] + 2 * this.b[1]) * o + this.c[1]] }, PolynomialBezier.prototype.tangentAngle = function (o) { var l = this.derivative(o); return Math.atan2(l[1], l[0]) }, PolynomialBezier.prototype.normalAngle = function (o) { var l = this.derivative(o); return Math.atan2(l[0], l[1]) }, PolynomialBezier.prototype.inflectionPoints = function () { var o = this.a[1] * this.b[0] - this.a[0] * this.b[1]; if (floatZero(o)) return []; var l = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / o, u = l * l - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / o; if (u < 0) return []; var f = Math.sqrt(u); return floatZero(f) ? f > 0 && f < 1 ? [l] : [] : [l - f, l + f].filter(function (p) { return p > 0 && p < 1 }) }, PolynomialBezier.prototype.split = function (o) { if (o <= 0) return [singlePoint(this.points[0]), this]; if (o >= 1) return [this, singlePoint(this.points[this.points.length - 1])]; var l = lerpPoint(this.points[0], this.points[1], o), u = lerpPoint(this.points[1], this.points[2], o), f = lerpPoint(this.points[2], this.points[3], o), p = lerpPoint(l, u, o), d = lerpPoint(u, f, o), m = lerpPoint(p, d, o); return [new PolynomialBezier(this.points[0], l, p, m, !0), new PolynomialBezier(m, d, f, this.points[3], !0)] }; function extrema(o, l) { var u = o.points[0][l], f = o.points[o.points.length - 1][l]; if (u > f) { var p = f; f = u, u = p } for (var d = quadRoots(3 * o.a[l], 2 * o.b[l], o.c[l]), m = 0; m < d.length; m += 1)if (d[m] > 0 && d[m] < 1) { var v = o.point(d[m])[l]; v < u ? u = v : v > f && (f = v) } return { min: u, max: f } } PolynomialBezier.prototype.bounds = function () { return { x: extrema(this, 0), y: extrema(this, 1) } }, PolynomialBezier.prototype.boundingBox = function () { var o = this.bounds(); return { left: o.x.min, right: o.x.max, top: o.y.min, bottom: o.y.max, width: o.x.max - o.x.min, height: o.y.max - o.y.min, cx: (o.x.max + o.x.min) / 2, cy: (o.y.max + o.y.min) / 2 } }; function intersectData(o, l, u) { var f = o.boundingBox(); return { cx: f.cx, cy: f.cy, width: f.width, height: f.height, bez: o, t: (l + u) / 2, t1: l, t2: u } } function splitData(o) { var l = o.bez.split(.5); return [intersectData(l[0], o.t1, o.t), intersectData(l[1], o.t, o.t2)] } function boxIntersect(o, l) { return Math.abs(o.cx - l.cx) * 2 < o.width + l.width && Math.abs(o.cy - l.cy) * 2 < o.height + l.height } function intersectsImpl(o, l, u, f, p, d) { if (boxIntersect(o, l)) { if (u >= d || o.width <= f && o.height <= f && l.width <= f && l.height <= f) { p.push([o.t, l.t]); return } var m = splitData(o), v = splitData(l); intersectsImpl(m[0], v[0], u + 1, f, p, d), intersectsImpl(m[0], v[1], u + 1, f, p, d), intersectsImpl(m[1], v[0], u + 1, f, p, d), intersectsImpl(m[1], v[1], u + 1, f, p, d) } } PolynomialBezier.prototype.intersections = function (o, l, u) { l === void 0 && (l = 2), u === void 0 && (u = 7); var f = []; return intersectsImpl(intersectData(this, 0, 1), intersectData(o, 0, 1), 0, l, f, u), f }, PolynomialBezier.shapeSegment = function (o, l) { var u = (l + 1) % o.length(); return new PolynomialBezier(o.v[l], o.o[l], o.i[u], o.v[u], !0) }, PolynomialBezier.shapeSegmentInverted = function (o, l) { var u = (l + 1) % o.length(); return new PolynomialBezier(o.v[u], o.i[u], o.o[l], o.v[l], !0) }; function crossProduct(o, l) { return [o[1] * l[2] - o[2] * l[1], o[2] * l[0] - o[0] * l[2], o[0] * l[1] - o[1] * l[0]] } function lineIntersection(o, l, u, f) { var p = [o[0], o[1], 1], d = [l[0], l[1], 1], m = [u[0], u[1], 1], v = [f[0], f[1], 1], I = crossProduct(crossProduct(p, d), crossProduct(m, v)); return floatZero(I[2]) ? null : [I[0] / I[2], I[1] / I[2]] } function polarOffset(o, l, u) { return [o[0] + Math.cos(l) * u, o[1] - Math.sin(l) * u] } function pointDistance(o, l) { return Math.hypot(o[0] - l[0], o[1] - l[1]) } function pointEqual(o, l) { return floatEqual(o[0], l[0]) && floatEqual(o[1], l[1]) } function ZigZagModifier() { } extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function (o, l) { this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(o, l.s, 0, null, this), this.frequency = PropertyFactory.getProp(o, l.r, 0, null, this), this.pointsType = PropertyFactory.getProp(o, l.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0 }; function setPoint(o, l, u, f, p, d, m) { var v = u - Math.PI / 2, I = u + Math.PI / 2, F = l[0] + Math.cos(u) * f * p, B = l[1] - Math.sin(u) * f * p; o.setTripleAt(F, B, F + Math.cos(v) * d, B - Math.sin(v) * d, F + Math.cos(I) * m, B - Math.sin(I) * m, o.length()) } function getPerpendicularVector(o, l) { var u = [l[0] - o[0], l[1] - o[1]], f = -Math.PI * .5, p = [Math.cos(f) * u[0] - Math.sin(f) * u[1], Math.sin(f) * u[0] + Math.cos(f) * u[1]]; return p } function getProjectingAngle(o, l) { var u = l === 0 ? o.length() - 1 : l - 1, f = (l + 1) % o.length(), p = o.v[u], d = o.v[f], m = getPerpendicularVector(p, d); return Math.atan2(0, 1) - Math.atan2(m[1], m[0]) } function zigZagCorner(o, l, u, f, p, d, m) { var v = getProjectingAngle(l, u), I = l.v[u % l._length], F = l.v[u === 0 ? l._length - 1 : u - 1], B = l.v[(u + 1) % l._length], W = d === 2 ? Math.sqrt(Math.pow(I[0] - F[0], 2) + Math.pow(I[1] - F[1], 2)) : 0, Z = d === 2 ? Math.sqrt(Math.pow(I[0] - B[0], 2) + Math.pow(I[1] - B[1], 2)) : 0; setPoint(o, l.v[u % l._length], v, m, f, Z / ((p + 1) * 2), W / ((p + 1) * 2)) } function zigZagSegment(o, l, u, f, p, d) { for (var m = 0; m < f; m += 1) { var v = (m + 1) / (f + 1), I = p === 2 ? Math.sqrt(Math.pow(l.points[3][0] - l.points[0][0], 2) + Math.pow(l.points[3][1] - l.points[0][1], 2)) : 0, F = l.normalAngle(v), B = l.point(v); setPoint(o, B, F, d, u, I / ((f + 1) * 2), I / ((f + 1) * 2)), d = -d } return d } ZigZagModifier.prototype.processPath = function (o, l, u, f) { var p = o._length, d = shapePool.newElement(); if (d.c = o.c, o.c || (p -= 1), p === 0) return d; var m = -1, v = PolynomialBezier.shapeSegment(o, 0); zigZagCorner(d, o, 0, l, u, f, m); for (var I = 0; I < p; I += 1)m = zigZagSegment(d, v, l, u, f, -m), I === p - 1 && !o.c ? v = null : v = PolynomialBezier.shapeSegment(o, (I + 1) % p), zigZagCorner(d, o, I + 1, l, u, f, m); return d }, ZigZagModifier.prototype.processShapes = function (o) { var l, u, f = this.shapes.length, p, d, m = this.amplitude.v, v = Math.max(0, Math.round(this.frequency.v)), I = this.pointsType.v; if (m !== 0) { var F, B; for (u = 0; u < f; u += 1) { if (F = this.shapes[u], B = F.localShapeCollection, !(!F.shape._mdf && !this._mdf && !o)) for (B.releaseShapes(), F.shape._mdf = !0, l = F.shape.paths.shapes, d = F.shape.paths._length, p = 0; p < d; p += 1)B.addShape(this.processPath(l[p], m, v, I)); F.shape.paths = F.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function linearOffset(o, l, u) { var f = Math.atan2(l[0] - o[0], l[1] - o[1]); return [polarOffset(o, f, u), polarOffset(l, f, u)] } function offsetSegment(o, l) { var u, f, p, d, m, v, I; I = linearOffset(o.points[0], o.points[1], l), u = I[0], f = I[1], I = linearOffset(o.points[1], o.points[2], l), p = I[0], d = I[1], I = linearOffset(o.points[2], o.points[3], l), m = I[0], v = I[1]; var F = lineIntersection(u, f, p, d); F === null && (F = f); var B = lineIntersection(m, v, p, d); return B === null && (B = m), new PolynomialBezier(u, F, B, v) } function joinLines(o, l, u, f, p) { var d = l.points[3], m = u.points[0]; if (f === 3 || pointEqual(d, m)) return d; if (f === 2) { var v = -l.tangentAngle(1), I = -u.tangentAngle(0) + Math.PI, F = lineIntersection(d, polarOffset(d, v + Math.PI / 2, 100), m, polarOffset(m, v + Math.PI / 2, 100)), B = F ? pointDistance(F, d) : pointDistance(d, m) / 2, W = polarOffset(d, v, 2 * B * roundCorner); return o.setXYAt(W[0], W[1], "o", o.length() - 1), W = polarOffset(m, I, 2 * B * roundCorner), o.setTripleAt(m[0], m[1], m[0], m[1], W[0], W[1], o.length()), m } var Z = pointEqual(d, l.points[2]) ? l.points[0] : l.points[2], Q = pointEqual(m, u.points[1]) ? u.points[3] : u.points[1], re = lineIntersection(Z, d, m, Q); return re && pointDistance(re, d) < p ? (o.setTripleAt(re[0], re[1], re[0], re[1], re[0], re[1], o.length()), re) : d } function getIntersection(o, l) { var u = o.intersections(l); return u.length && floatEqual(u[0][0], 1) && u.shift(), u.length ? u[0] : null } function pruneSegmentIntersection(o, l) { var u = o.slice(), f = l.slice(), p = getIntersection(o[o.length - 1], l[0]); return p && (u[o.length - 1] = o[o.length - 1].split(p[0])[0], f[0] = l[0].split(p[1])[1]), o.length > 1 && l.length > 1 && (p = getIntersection(o[0], l[l.length - 1]), p) ? [[o[0].split(p[0])[0]], [l[l.length - 1].split(p[1])[1]]] : [u, f] } function pruneIntersections(o) { for (var l, u = 1; u < o.length; u += 1)l = pruneSegmentIntersection(o[u - 1], o[u]), o[u - 1] = l[0], o[u] = l[1]; return o.length > 1 && (l = pruneSegmentIntersection(o[o.length - 1], o[0]), o[o.length - 1] = l[0], o[0] = l[1]), o } function offsetSegmentSplit(o, l) { var u = o.inflectionPoints(), f, p, d, m; if (u.length === 0) return [offsetSegment(o, l)]; if (u.length === 1 || floatEqual(u[1], 1)) return d = o.split(u[0]), f = d[0], p = d[1], [offsetSegment(f, l), offsetSegment(p, l)]; d = o.split(u[0]), f = d[0]; var v = (u[1] - u[0]) / (1 - u[0]); return d = d[1].split(v), m = d[0], p = d[1], [offsetSegment(f, l), offsetSegment(m, l), offsetSegment(p, l)] } function OffsetPathModifier() { } extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function (o, l) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(o, l.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(o, l.ml, 0, null, this), this.lineJoin = l.lj, this._isAnimated = this.amount.effectsSequence.length !== 0 }, OffsetPathModifier.prototype.processPath = function (o, l, u, f) { var p = shapePool.newElement(); p.c = o.c; var d = o.length(); o.c || (d -= 1); var m, v, I, F = []; for (m = 0; m < d; m += 1)I = PolynomialBezier.shapeSegment(o, m), F.push(offsetSegmentSplit(I, l)); if (!o.c) for (m = d - 1; m >= 0; m -= 1)I = PolynomialBezier.shapeSegmentInverted(o, m), F.push(offsetSegmentSplit(I, l)); F = pruneIntersections(F); var B = null, W = null; for (m = 0; m < F.length; m += 1) { var Z = F[m]; for (W && (B = joinLines(p, W, Z[0], u, f)), W = Z[Z.length - 1], v = 0; v < Z.length; v += 1)I = Z[v], B && pointEqual(I.points[0], B) ? p.setXYAt(I.points[1][0], I.points[1][1], "o", p.length() - 1) : p.setTripleAt(I.points[0][0], I.points[0][1], I.points[1][0], I.points[1][1], I.points[0][0], I.points[0][1], p.length()), p.setTripleAt(I.points[3][0], I.points[3][1], I.points[3][0], I.points[3][1], I.points[2][0], I.points[2][1], p.length()), B = I.points[3] } return F.length && joinLines(p, W, F[0][0], u, f), p }, OffsetPathModifier.prototype.processShapes = function (o) { var l, u, f = this.shapes.length, p, d, m = this.amount.v, v = this.miterLimit.v, I = this.lineJoin; if (m !== 0) { var F, B; for (u = 0; u < f; u += 1) { if (F = this.shapes[u], B = F.localShapeCollection, !(!F.shape._mdf && !this._mdf && !o)) for (B.releaseShapes(), F.shape._mdf = !0, l = F.shape.paths.shapes, d = F.shape.paths._length, p = 0; p < d; p += 1)B.addShape(this.processPath(l[p], m, I, v)); F.shape.paths = F.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function getFontProperties(o) { for (var l = o.fStyle ? o.fStyle.split(" ") : [], u = "normal", f = "normal", p = l.length, d, m = 0; m < p; m += 1)switch (d = l[m].toLowerCase(), d) { case "italic": f = "italic"; break; case "bold": u = "700"; break; case "black": u = "900"; break; case "medium": u = "500"; break; case "regular": case "normal": u = "400"; break; case "light": case "thin": u = "200"; break }return { style: f, weight: o.fWeight || u } } var FontManager = function () { var o = 5e3, l = { w: 0, size: 0, shapes: [], data: { shapes: [] } }, u = []; u = u.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]); var f = 127988, p = 917631, d = 917601, m = 917626, v = 65039, I = 8205, F = 127462, B = 127487, W = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"]; function Z(Y) { var te = Y.split(","), ee, G = te.length, y = []; for (ee = 0; ee < G; ee += 1)te[ee] !== "sans-serif" && te[ee] !== "monospace" && y.push(te[ee]); return y.join(",") } function Q(Y, te) { var ee = createTag("span"); ee.setAttribute("aria-hidden", !0), ee.style.fontFamily = te; var G = createTag("span"); G.innerText = "giItT1WQy@!-/#", ee.style.position = "absolute", ee.style.left = "-10000px", ee.style.top = "-10000px", ee.style.fontSize = "300px", ee.style.fontVariant = "normal", ee.style.fontStyle = "normal", ee.style.fontWeight = "normal", ee.style.letterSpacing = "0", ee.appendChild(G), document.body.appendChild(ee); var y = G.offsetWidth; return G.style.fontFamily = Z(Y) + ", " + te, { node: G, w: y, parent: ee } } function re() { var Y, te = this.fonts.length, ee, G, y = te; for (Y = 0; Y < te; Y += 1)this.fonts[Y].loaded ? y -= 1 : this.fonts[Y].fOrigin === "n" || this.fonts[Y].origin === 0 ? this.fonts[Y].loaded = !0 : (ee = this.fonts[Y].monoCase.node, G = this.fonts[Y].monoCase.w, ee.offsetWidth !== G ? (y -= 1, this.fonts[Y].loaded = !0) : (ee = this.fonts[Y].sansCase.node, G = this.fonts[Y].sansCase.w, ee.offsetWidth !== G && (y -= 1, this.fonts[Y].loaded = !0)), this.fonts[Y].loaded && (this.fonts[Y].sansCase.parent.parentNode.removeChild(this.fonts[Y].sansCase.parent), this.fonts[Y].monoCase.parent.parentNode.removeChild(this.fonts[Y].monoCase.parent))); y !== 0 && Date.now() - this.initTime < o ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10) } function ne(Y, te) { var ee = document.body && te ? "svg" : "canvas", G, y = getFontProperties(Y); if (ee === "svg") { var X = createNS("text"); X.style.fontSize = "100px", X.setAttribute("font-family", Y.fFamily), X.setAttribute("font-style", y.style), X.setAttribute("font-weight", y.weight), X.textContent = "1", Y.fClass ? (X.style.fontFamily = "inherit", X.setAttribute("class", Y.fClass)) : X.style.fontFamily = Y.fFamily, te.appendChild(X), G = X } else { var ce = new OffscreenCanvas(500, 500).getContext("2d"); ce.font = y.style + " " + y.weight + " 100px " + Y.fFamily, G = ce } function me(Ae) { return ee === "svg" ? (G.textContent = Ae, G.getComputedTextLength()) : G.measureText(Ae).width } return { measureText: me } } function oe(Y, te) { if (!Y) { this.isLoaded = !0; return } if (this.chars) { this.isLoaded = !0, this.fonts = Y.list; return } if (!document.body) { this.isLoaded = !0, Y.list.forEach(function (De) { De.helper = ne(De), De.cache = {} }), this.fonts = Y.list; return } var ee = Y.list, G, y = ee.length, X = y; for (G = 0; G < y; G += 1) { var ce = !0, me, Ae; if (ee[G].loaded = !1, ee[G].monoCase = Q(ee[G].fFamily, "monospace"), ee[G].sansCase = Q(ee[G].fFamily, "sans-serif"), !ee[G].fPath) ee[G].loaded = !0, X -= 1; else if (ee[G].fOrigin === "p" || ee[G].origin === 3) { if (me = document.querySelectorAll('style[f-forigin="p"][f-family="' + ee[G].fFamily + '"], style[f-origin="3"][f-family="' + ee[G].fFamily + '"]'), me.length > 0 && (ce = !1), ce) { var Ie = createTag("style"); Ie.setAttribute("f-forigin", ee[G].fOrigin), Ie.setAttribute("f-origin", ee[G].origin), Ie.setAttribute("f-family", ee[G].fFamily), Ie.type = "text/css", Ie.innerText = "@font-face {font-family: " + ee[G].fFamily + "; font-style: normal; src: url('" + ee[G].fPath + "');}", te.appendChild(Ie) } } else if (ee[G].fOrigin === "g" || ee[G].origin === 1) { for (me = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), Ae = 0; Ae < me.length; Ae += 1)me[Ae].href.indexOf(ee[G].fPath) !== -1 && (ce = !1); if (ce) { var Be = createTag("link"); Be.setAttribute("f-forigin", ee[G].fOrigin), Be.setAttribute("f-origin", ee[G].origin), Be.type = "text/css", Be.rel = "stylesheet", Be.href = ee[G].fPath, document.body.appendChild(Be) } } else if (ee[G].fOrigin === "t" || ee[G].origin === 2) { for (me = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), Ae = 0; Ae < me.length; Ae += 1)ee[G].fPath === me[Ae].src && (ce = !1); if (ce) { var Me = createTag("link"); Me.setAttribute("f-forigin", ee[G].fOrigin), Me.setAttribute("f-origin", ee[G].origin), Me.setAttribute("rel", "stylesheet"), Me.setAttribute("href", ee[G].fPath), te.appendChild(Me) } } ee[G].helper = ne(ee[G], te), ee[G].cache = {}, this.fonts.push(ee[G]) } X === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100) } function ae(Y) { if (Y) { this.chars || (this.chars = []); var te, ee = Y.length, G, y = this.chars.length, X; for (te = 0; te < ee; te += 1) { for (G = 0, X = !1; G < y;)this.chars[G].style === Y[te].style && this.chars[G].fFamily === Y[te].fFamily && this.chars[G].ch === Y[te].ch && (X = !0), G += 1; X || (this.chars.push(Y[te]), y += 1) } } } function se(Y, te, ee) { for (var G = 0, y = this.chars.length; G < y;) { if (this.chars[G].ch === Y && this.chars[G].style === te && this.chars[G].fFamily === ee) return this.chars[G]; G += 1 } return (typeof Y == "string" && Y.charCodeAt(0) !== 13 || !Y) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", Y, te, ee)), l } function le(Y, te, ee) { var G = this.getFontByName(te), y = Y; if (!G.cache[y]) { var X = G.helper; if (Y === " ") { var ce = X.measureText("|" + Y + "|"), me = X.measureText("||"); G.cache[y] = (ce - me) / 100 } else G.cache[y] = X.measureText(Y) / 100 } return G.cache[y] * ee } function ue(Y) { for (var te = 0, ee = this.fonts.length; te < ee;) { if (this.fonts[te].fName === Y) return this.fonts[te]; te += 1 } return this.fonts[0] } function he(Y) { var te = 0, ee = Y.charCodeAt(0); if (ee >= 55296 && ee <= 56319) { var G = Y.charCodeAt(1); G >= 56320 && G <= 57343 && (te = (ee - 55296) * 1024 + G - 56320 + 65536) } return te } function pe(Y, te) { var ee = Y.toString(16) + te.toString(16); return W.indexOf(ee) !== -1 } function ve(Y) { return Y === I } function _e(Y) { return Y === v } function Se(Y) { var te = he(Y); return te >= F && te <= B } function $e(Y) { return Se(Y.substr(0, 2)) && Se(Y.substr(2, 2)) } function ie(Y) { return u.indexOf(Y) !== -1 } function g(Y, te) { var ee = he(Y.substr(te, 2)); if (ee !== f) return !1; var G = 0; for (te += 2; G < 5;) { if (ee = he(Y.substr(te, 2)), ee < d || ee > m) return !1; G += 1, te += 2 } return he(Y.substr(te, 2)) === p } function P() { this.isLoaded = !0 } var U = function () { this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this) }; U.isModifier = pe, U.isZeroWidthJoiner = ve, U.isFlagEmoji = $e, U.isRegionalCode = Se, U.isCombinedCharacter = ie, U.isRegionalFlag = g, U.isVariationSelector = _e, U.BLACK_FLAG_CODE_POINT = f; var K = { addChars: ae, addFonts: oe, getCharData: se, getFontByName: ue, measureText: le, checkLoadedFonts: re, setIsLoaded: P }; return U.prototype = K, U }(); function SlotManager(o) { this.animationData = o } SlotManager.prototype.getProp = function (o) { return this.animationData.slots && this.animationData.slots[o.sid] ? Object.assign(o, this.animationData.slots[o.sid].p) : o }; function slotFactory(o) { return new SlotManager(o) } function RenderableElement() { } RenderableElement.prototype = { initRenderable: function () { this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [] }, addRenderableComponent: function (l) { this.renderableComponents.indexOf(l) === -1 && this.renderableComponents.push(l) }, removeRenderableComponent: function (l) { this.renderableComponents.indexOf(l) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(l), 1) }, prepareRenderableFrame: function (l) { this.checkLayerLimits(l) }, checkTransparency: function () { this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show()) }, checkLayerLimits: function (l) { this.data.ip - this.data.st <= l && this.data.op - this.data.st > l ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide()) }, renderRenderable: function () { var l, u = this.renderableComponents.length; for (l = 0; l < u; l += 1)this.renderableComponents[l].renderFrame(this._isFirstFrame) }, sourceRectAtTime: function () { return { top: 0, left: 0, width: 100, height: 100 } }, getLayerSize: function () { return this.data.ty === 5 ? { w: this.data.textData.width, h: this.data.textData.height } : { w: this.data.width, h: this.data.height } } }; var getBlendMode = function () { var o = { 0: "source-over", 1: "multiply", 2: "screen", 3: "overlay", 4: "darken", 5: "lighten", 6: "color-dodge", 7: "color-burn", 8: "hard-light", 9: "soft-light", 10: "difference", 11: "exclusion", 12: "hue", 13: "saturation", 14: "color", 15: "luminosity" }; return function (l) { return o[l] || "" } }(); function SliderEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 0, 0, u) } function AngleEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 0, 0, u) } function ColorEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 1, 0, u) } function PointEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 1, 0, u) } function LayerIndexEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 0, 0, u) } function MaskIndexEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 0, 0, u) } function CheckboxEffect(o, l, u) { this.p = PropertyFactory.getProp(l, o.v, 0, 0, u) } function NoValueEffect() { this.p = {} } function EffectsManager(o, l) { var u = o.ef || []; this.effectElements = []; var f, p = u.length, d; for (f = 0; f < p; f += 1)d = new GroupEffect(u[f], l), this.effectElements.push(d) } function GroupEffect(o, l) { this.init(o, l) } extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (o, l) { this.data = o, this.effectElements = [], this.initDynamicPropertyContainer(l); var u, f = this.data.ef.length, p, d = this.data.ef; for (u = 0; u < f; u += 1) { switch (p = null, d[u].ty) { case 0: p = new SliderEffect(d[u], l, this); break; case 1: p = new AngleEffect(d[u], l, this); break; case 2: p = new ColorEffect(d[u], l, this); break; case 3: p = new PointEffect(d[u], l, this); break; case 4: case 7: p = new CheckboxEffect(d[u], l, this); break; case 10: p = new LayerIndexEffect(d[u], l, this); break; case 11: p = new MaskIndexEffect(d[u], l, this); break; case 5: p = new EffectsManager(d[u], l); break; default: p = new NoValueEffect(d[u]); break }p && this.effectElements.push(p) } }; function BaseElement() { } BaseElement.prototype = { checkMasks: function () { if (!this.data.hasMask) return !1; for (var l = 0, u = this.data.masksProperties.length; l < u;) { if (this.data.masksProperties[l].mode !== "n" && this.data.masksProperties[l].cl !== !1) return !0; l += 1 } return !1 }, initExpressions: function () { var l = getExpressionInterfaces(); if (l) { var u = l("layer"), f = l("effects"), p = l("shape"), d = l("text"), m = l("comp"); this.layerInterface = u(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager); var v = f.createEffectsInterface(this, this.layerInterface); this.layerInterface.registerEffectsInterface(v), this.data.ty === 0 || this.data.xt ? this.compInterface = m(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = p(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = d(this), this.layerInterface.text = this.layerInterface.textInterface) } }, setBlendMode: function () { var l = getBlendMode(this.data.bm), u = this.baseElement || this.layerElement; u.style["mix-blend-mode"] = l }, initBaseData: function (l, u, f) { this.globalData = u, this.comp = f, this.data = l, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties) }, getType: function () { return this.type }, sourceRectAtTime: function () { } }; function FrameElement() { } FrameElement.prototype = { initFrame: function () { this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1 }, prepareProperties: function (l, u) { var f, p = this.dynamicProperties.length; for (f = 0; f < p; f += 1)(u || this._isParent && this.dynamicProperties[f].propType === "transform") && (this.dynamicProperties[f].getValue(), this.dynamicProperties[f]._mdf && (this.globalData._mdf = !0, this._mdf = !0)) }, addDynamicProperty: function (l) { this.dynamicProperties.indexOf(l) === -1 && this.dynamicProperties.push(l) } }; function FootageElement(o, l, u) { this.initFrame(), this.initRenderable(), this.assetData = l.getAssetData(o.refId), this.footageData = l.imageLoader.getAsset(this.assetData), this.initBaseData(o, l, u) } FootageElement.prototype.prepareFrame = function () { }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () { return null }, FootageElement.prototype.renderFrame = function () { }, FootageElement.prototype.destroy = function () { }, FootageElement.prototype.initExpressions = function () { var o = getExpressionInterfaces(); if (o) { var l = o("footage"); this.layerInterface = l(this) } }, FootageElement.prototype.getFootageData = function () { return this.footageData }; function AudioElement(o, l, u) { this.initFrame(), this.initRenderable(), this.assetData = l.getAssetData(o.refId), this.initBaseData(o, l, u), this._isPlaying = !1, this._canPlay = !1; var f = this.globalData.getAssetsPath(this.assetData); this.audio = this.globalData.audioController.createAudio(f), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = o.tm ? PropertyFactory.getProp(this, o.tm, 0, l.frameRate, this) : { _placeholder: !0 }, this.lv = PropertyFactory.getProp(this, o.au && o.au.lv ? o.au.lv : { k: [100] }, 1, .01, this) } AudioElement.prototype.prepareFrame = function (o) { if (this.prepareRenderableFrame(o, !0), this.prepareProperties(o, !0), this.tm._placeholder) this._currentTime = o / this.data.sr; else { var l = this.tm.v; this._currentTime = l } this._volume = this.lv.v[0]; var u = this._volume * this._volumeMultiplier; this._previousVolume !== u && (this._previousVolume = u, this.audio.volume(u)) }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () { this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0)) }, AudioElement.prototype.show = function () { }, AudioElement.prototype.hide = function () { this.audio.pause(), this._isPlaying = !1 }, AudioElement.prototype.pause = function () { this.audio.pause(), this._isPlaying = !1, this._canPlay = !1 }, AudioElement.prototype.resume = function () { this._canPlay = !0 }, AudioElement.prototype.setRate = function (o) { this.audio.rate(o) }, AudioElement.prototype.volume = function (o) { this._volumeMultiplier = o, this._previousVolume = o * this._volume, this.audio.volume(this._previousVolume) }, AudioElement.prototype.getBaseElement = function () { return null }, AudioElement.prototype.destroy = function () { }, AudioElement.prototype.sourceRectAtTime = function () { }, AudioElement.prototype.initExpressions = function () { }; function BaseRenderer() { } BaseRenderer.prototype.checkLayers = function (o) { var l, u = this.layers.length, f; for (this.completeLayers = !0, l = u - 1; l >= 0; l -= 1)this.elements[l] || (f = this.layers[l], f.ip - f.st <= o - this.layers[l].st && f.op - f.st > o - this.layers[l].st && this.buildItem(l)), this.completeLayers = this.elements[l] ? this.completeLayers : !1; this.checkPendingElements() }, BaseRenderer.prototype.createItem = function (o) { switch (o.ty) { case 2: return this.createImage(o); case 0: return this.createComp(o); case 1: return this.createSolid(o); case 3: return this.createNull(o); case 4: return this.createShape(o); case 5: return this.createText(o); case 6: return this.createAudio(o); case 13: return this.createCamera(o); case 15: return this.createFootage(o); default: return this.createNull(o) } }, BaseRenderer.prototype.createCamera = function () { throw new Error("You're using a 3d camera. Try the html renderer.") }, BaseRenderer.prototype.createAudio = function (o) { return new AudioElement(o, this.globalData, this) }, BaseRenderer.prototype.createFootage = function (o) { return new FootageElement(o, this.globalData, this) }, BaseRenderer.prototype.buildAllItems = function () { var o, l = this.layers.length; for (o = 0; o < l; o += 1)this.buildItem(o); this.checkPendingElements() }, BaseRenderer.prototype.includeLayers = function (o) { this.completeLayers = !1; var l, u = o.length, f, p = this.layers.length; for (l = 0; l < u; l += 1)for (f = 0; f < p;) { if (this.layers[f].id === o[l].id) { this.layers[f] = o[l]; break } f += 1 } }, BaseRenderer.prototype.setProjectInterface = function (o) { this.globalData.projectInterface = o }, BaseRenderer.prototype.initItems = function () { this.globalData.progressiveLoad || this.buildAllItems() }, BaseRenderer.prototype.buildElementParenting = function (o, l, u) { for (var f = this.elements, p = this.layers, d = 0, m = p.length; d < m;)p[d].ind == l && (!f[d] || f[d] === !0 ? (this.buildItem(d), this.addPendingElement(o)) : (u.push(f[d]), f[d].setAsParent(), p[d].parent !== void 0 ? this.buildElementParenting(o, p[d].parent, u) : o.setHierarchy(u))), d += 1 }, BaseRenderer.prototype.addPendingElement = function (o) { this.pendingElements.push(o) }, BaseRenderer.prototype.searchExtraCompositions = function (o) { var l, u = o.length; for (l = 0; l < u; l += 1)if (o[l].xt) { var f = this.createComp(o[l]); f.initExpressions(), this.globalData.projectInterface.registerComposition(f) } }, BaseRenderer.prototype.getElementById = function (o) { var l, u = this.elements.length; for (l = 0; l < u; l += 1)if (this.elements[l].data.ind === o) return this.elements[l]; return null }, BaseRenderer.prototype.getElementByPath = function (o) { var l = o.shift(), u; if (typeof l == "number") u = this.elements[l]; else { var f, p = this.elements.length; for (f = 0; f < p; f += 1)if (this.elements[f].data.nm === l) { u = this.elements[f]; break } } return o.length === 0 ? u : u.getElementByPath(o) }, BaseRenderer.prototype.setupGlobalData = function (o, l) { this.globalData.fontManager = new FontManager, this.globalData.slotManager = slotFactory(o), this.globalData.fontManager.addChars(o.chars), this.globalData.fontManager.addFonts(o.fonts, l), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = o.fr, this.globalData.nm = o.nm, this.globalData.compSize = { w: o.w, h: o.h } }; var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" }; function TransformElement() { } TransformElement.prototype = { initTransform: function () { var l = new Matrix; this.finalTransform = { mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 }, _matMdf: !1, _localMatMdf: !1, _opMdf: !1, mat: l, localMat: l, localOpacity: 1 }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty }, renderTransform: function () { if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) { var l, u = this.finalTransform.mat, f = 0, p = this.hierarchy.length; if (!this.finalTransform._matMdf) for (; f < p;) { if (this.hierarchy[f].finalTransform.mProp._mdf) { this.finalTransform._matMdf = !0; break } f += 1 } if (this.finalTransform._matMdf) for (l = this.finalTransform.mProp.v.props, u.cloneFromProps(l), f = 0; f < p; f += 1)u.multiply(this.hierarchy[f].finalTransform.mProp.v) } this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v) }, renderLocalTransform: function () { if (this.localTransforms) { var l = 0, u = this.localTransforms.length; if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf) for (; l < u;)this.localTransforms[l]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[l]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), l += 1; if (this.finalTransform._localMatMdf) { var f = this.finalTransform.localMat; for (this.localTransforms[0].matrix.clone(f), l = 1; l < u; l += 1) { var p = this.localTransforms[l].matrix; f.multiply(p) } f.multiply(this.finalTransform.mat) } if (this.finalTransform._opMdf) { var d = this.finalTransform.localOpacity; for (l = 0; l < u; l += 1)d *= this.localTransforms[l].opacity * .01; this.finalTransform.localOpacity = d } } }, searchEffectTransforms: function () { if (this.renderableEffectsManager) { var l = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT); if (l.length) { this.localTransforms = [], this.finalTransform.localMat = new Matrix; var u = 0, f = l.length; for (u = 0; u < f; u += 1)this.localTransforms.push(l[u]) } } }, globalToLocal: function (l) { var u = []; u.push(this.finalTransform); for (var f = !0, p = this.comp; f;)p.finalTransform ? (p.data.hasMask && u.splice(0, 0, p.finalTransform), p = p.comp) : f = !1; var d, m = u.length, v; for (d = 0; d < m; d += 1)v = u[d].mat.applyToPointArray(0, 0, 0), l = [l[0] - v[0], l[1] - v[1], 0]; return l }, mHelper: new Matrix }; function MaskElement(o, l, u) { this.data = o, this.element = l, this.globalData = u, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null; var f = this.globalData.defs, p, d = this.masksProperties ? this.masksProperties.length : 0; this.viewData = createSizedArray(d), this.solidPath = ""; var m, v = this.masksProperties, I = 0, F = [], B, W, Z = createElementID(), Q, re, ne, oe, ae = "clipPath", se = "clip-path"; for (p = 0; p < d; p += 1)if ((v[p].mode !== "a" && v[p].mode !== "n" || v[p].inv || v[p].o.k !== 100 || v[p].o.x) && (ae = "mask", se = "mask"), (v[p].mode === "s" || v[p].mode === "i") && I === 0 ? (Q = createNS("rect"), Q.setAttribute("fill", "#ffffff"), Q.setAttribute("width", this.element.comp.data.w || 0), Q.setAttribute("height", this.element.comp.data.h || 0), F.push(Q)) : Q = null, m = createNS("path"), v[p].mode === "n") this.viewData[p] = { op: PropertyFactory.getProp(this.element, v[p].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, v[p], 3), elem: m, lastPath: "" }, f.appendChild(m); else { I += 1, m.setAttribute("fill", v[p].mode === "s" ? "#000000" : "#ffffff"), m.setAttribute("clip-rule", "nonzero"); var le; if (v[p].x.k !== 0 ? (ae = "mask", se = "mask", oe = PropertyFactory.getProp(this.element, v[p].x, 0, null, this.element), le = createElementID(), re = createNS("filter"), re.setAttribute("id", le), ne = createNS("feMorphology"), ne.setAttribute("operator", "erode"), ne.setAttribute("in", "SourceGraphic"), ne.setAttribute("radius", "0"), re.appendChild(ne), f.appendChild(re), m.setAttribute("stroke", v[p].mode === "s" ? "#000000" : "#ffffff")) : (ne = null, oe = null), this.storedData[p] = { elem: m, x: oe, expan: ne, lastPath: "", lastOperator: "", filterId: le, lastRadius: 0 }, v[p].mode === "i") { W = F.length; var ue = createNS("g"); for (B = 0; B < W; B += 1)ue.appendChild(F[B]); var he = createNS("mask"); he.setAttribute("mask-type", "alpha"), he.setAttribute("id", Z + "_" + I), he.appendChild(m), f.appendChild(he), ue.setAttribute("mask", "url(" + getLocationHref() + "#" + Z + "_" + I + ")"), F.length = 0, F.push(ue) } else F.push(m); v[p].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[p] = { elem: m, lastPath: "", op: PropertyFactory.getProp(this.element, v[p].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, v[p], 3), invRect: Q }, this.viewData[p].prop.k || this.drawPath(v[p], this.viewData[p].prop.v, this.viewData[p]) } for (this.maskElement = createNS(ae), d = F.length, p = 0; p < d; p += 1)this.maskElement.appendChild(F[p]); I > 0 && (this.maskElement.setAttribute("id", Z), this.element.maskedElement.setAttribute(se, "url(" + getLocationHref() + "#" + Z + ")"), f.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this) } MaskElement.prototype.getMaskProperty = function (o) { return this.viewData[o].prop }, MaskElement.prototype.renderFrame = function (o) { var l = this.element.finalTransform.mat, u, f = this.masksProperties.length; for (u = 0; u < f; u += 1)if ((this.viewData[u].prop._mdf || o) && this.drawPath(this.masksProperties[u], this.viewData[u].prop.v, this.viewData[u]), (this.viewData[u].op._mdf || o) && this.viewData[u].elem.setAttribute("fill-opacity", this.viewData[u].op.v), this.masksProperties[u].mode !== "n" && (this.viewData[u].invRect && (this.element.finalTransform.mProp._mdf || o) && this.viewData[u].invRect.setAttribute("transform", l.getInverseMatrix().to2dCSS()), this.storedData[u].x && (this.storedData[u].x._mdf || o))) { var p = this.storedData[u].expan; this.storedData[u].x.v < 0 ? (this.storedData[u].lastOperator !== "erode" && (this.storedData[u].lastOperator = "erode", this.storedData[u].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[u].filterId + ")")), p.setAttribute("radius", -this.storedData[u].x.v)) : (this.storedData[u].lastOperator !== "dilate" && (this.storedData[u].lastOperator = "dilate", this.storedData[u].elem.setAttribute("filter", null)), this.storedData[u].elem.setAttribute("stroke-width", this.storedData[u].x.v * 2)) } }, MaskElement.prototype.getMaskelement = function () { return this.maskElement }, MaskElement.prototype.createLayerSolidPath = function () { var o = "M0,0 "; return o += " h" + this.globalData.compSize.w, o += " v" + this.globalData.compSize.h, o += " h-" + this.globalData.compSize.w, o += " v-" + this.globalData.compSize.h + " ", o }, MaskElement.prototype.drawPath = function (o, l, u) { var f = " M" + l.v[0][0] + "," + l.v[0][1], p, d; for (d = l._length, p = 1; p < d; p += 1)f += " C" + l.o[p - 1][0] + "," + l.o[p - 1][1] + " " + l.i[p][0] + "," + l.i[p][1] + " " + l.v[p][0] + "," + l.v[p][1]; if (l.c && d > 1 && (f += " C" + l.o[p - 1][0] + "," + l.o[p - 1][1] + " " + l.i[0][0] + "," + l.i[0][1] + " " + l.v[0][0] + "," + l.v[0][1]), u.lastPath !== f) { var m = ""; u.elem && (l.c && (m = o.inv ? this.solidPath + f : f), u.elem.setAttribute("d", m)), u.lastPath = f } }, MaskElement.prototype.destroy = function () { this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null }; var filtersFactory = function () { var o = {}; o.createFilter = l, o.createAlphaToLuminanceFilter = u; function l(f, p) { var d = createNS("filter"); return d.setAttribute("id", f), p !== !0 && (d.setAttribute("filterUnits", "objectBoundingBox"), d.setAttribute("x", "0%"), d.setAttribute("y", "0%"), d.setAttribute("width", "100%"), d.setAttribute("height", "100%")), d } function u() { var f = createNS("feColorMatrix"); return f.setAttribute("type", "matrix"), f.setAttribute("color-interpolation-filters", "sRGB"), f.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), f } return o }(), featureSupport = function () { var o = { maskType: !0, svgLumaHidden: !0, offscreenCanvas: typeof OffscreenCanvas < "u" }; return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (o.maskType = !1), /firefox/i.test(navigator.userAgent) && (o.svgLumaHidden = !1), o }(), registeredEffects$1 = {}, idPrefix = "filter_result_"; function SVGEffects(o) { var l, u = "SourceGraphic", f = o.data.ef ? o.data.ef.length : 0, p = createElementID(), d = filtersFactory.createFilter(p, !0), m = 0; this.filters = []; var v; for (l = 0; l < f; l += 1) { v = null; var I = o.data.ef[l].ty; if (registeredEffects$1[I]) { var F = registeredEffects$1[I].effect; v = new F(d, o.effectsManager.effectElements[l], o, idPrefix + m, u), u = idPrefix + m, registeredEffects$1[I].countsAsEffect && (m += 1) } v && this.filters.push(v) } m && (o.globalData.defs.appendChild(d), o.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + p + ")")), this.filters.length && o.addRenderableComponent(this) } SVGEffects.prototype.renderFrame = function (o) { var l, u = this.filters.length; for (l = 0; l < u; l += 1)this.filters[l].renderFrame(o) }, SVGEffects.prototype.getEffects = function (o) { var l, u = this.filters.length, f = []; for (l = 0; l < u; l += 1)this.filters[l].type === o && f.push(this.filters[l]); return f }; function registerEffect$1(o, l, u) { registeredEffects$1[o] = { effect: l, countsAsEffect: u } } function SVGBaseElement() { } SVGBaseElement.prototype = { initRendererElement: function () { this.layerElement = createNS("g") }, createContainerElements: function () { this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1; var l = null; if (this.data.td) { this.matteMasks = {}; var u = createNS("g"); u.setAttribute("id", this.layerId), u.appendChild(this.layerElement), l = u, this.globalData.defs.appendChild(u) } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), l = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement; if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) { var f = createNS("clipPath"), p = createNS("path"); p.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z"); var d = createElementID(); if (f.setAttribute("id", d), f.appendChild(p), this.globalData.defs.appendChild(f), this.checkMasks()) { var m = createNS("g"); m.setAttribute("clip-path", "url(" + getLocationHref() + "#" + d + ")"), m.appendChild(this.layerElement), this.transformedElement = m, l ? l.appendChild(this.transformedElement) : this.baseElement = this.transformedElement } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + d + ")") } this.data.bm !== 0 && this.setBlendMode() }, renderElement: function () { this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity) }, destroyBaseElement: function () { this.layerElement = null, this.matteElement = null, this.maskManager.destroy() }, getBaseElement: function () { return this.data.hd ? null : this.baseElement }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms() }, getMatte: function (l) { if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[l]) { var u = this.layerId + "_" + l, f, p, d, m; if (l === 1 || l === 3) { var v = createNS("mask"); v.setAttribute("id", u), v.setAttribute("mask-type", l === 3 ? "luminance" : "alpha"), d = createNS("use"), d.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), v.appendChild(d), this.globalData.defs.appendChild(v), !featureSupport.maskType && l === 1 && (v.setAttribute("mask-type", "luminance"), f = createElementID(), p = filtersFactory.createFilter(f), this.globalData.defs.appendChild(p), p.appendChild(filtersFactory.createAlphaToLuminanceFilter()), m = createNS("g"), m.appendChild(d), v.appendChild(m), m.setAttribute("filter", "url(" + getLocationHref() + "#" + f + ")")) } else if (l === 2) { var I = createNS("mask"); I.setAttribute("id", u), I.setAttribute("mask-type", "alpha"); var F = createNS("g"); I.appendChild(F), f = createElementID(), p = filtersFactory.createFilter(f); var B = createNS("feComponentTransfer"); B.setAttribute("in", "SourceGraphic"), p.appendChild(B); var W = createNS("feFuncA"); W.setAttribute("type", "table"), W.setAttribute("tableValues", "1.0 0.0"), B.appendChild(W), this.globalData.defs.appendChild(p); var Z = createNS("rect"); Z.setAttribute("width", this.comp.data.w), Z.setAttribute("height", this.comp.data.h), Z.setAttribute("x", "0"), Z.setAttribute("y", "0"), Z.setAttribute("fill", "#ffffff"), Z.setAttribute("opacity", "0"), F.setAttribute("filter", "url(" + getLocationHref() + "#" + f + ")"), F.appendChild(Z), d = createNS("use"), d.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), F.appendChild(d), featureSupport.maskType || (I.setAttribute("mask-type", "luminance"), p.appendChild(filtersFactory.createAlphaToLuminanceFilter()), m = createNS("g"), F.appendChild(Z), m.appendChild(this.layerElement), F.appendChild(m)), this.globalData.defs.appendChild(I) } this.matteMasks[l] = u } return this.matteMasks[l] }, setMatte: function (l) { this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + l + ")") } }; function HierarchyElement() { } HierarchyElement.prototype = { initHierarchy: function () { this.hierarchy = [], this._isParent = !1, this.checkParenting() }, setHierarchy: function (l) { this.hierarchy = l }, setAsParent: function () { this._isParent = !0 }, checkParenting: function () { this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, []) } }; function RenderableDOMElement() { } (function () { var o = { initElement: function (u, f, p) { this.initFrame(), this.initBaseData(u, f, p), this.initTransform(u, f, p), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide() }, hide: function () { if (!this.hidden && (!this.isInRange || this.isTransparent)) { var u = this.baseElement || this.layerElement; u.style.display = "none", this.hidden = !0 } }, show: function () { if (this.isInRange && !this.isTransparent) { if (!this.data.hd) { var u = this.baseElement || this.layerElement; u.style.display = "block" } this.hidden = !1, this._isFirstFrame = !0 } }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, renderInnerContent: function () { }, prepareFrame: function (u) { this._mdf = !1, this.prepareRenderableFrame(u), this.prepareProperties(u, this.isInRange), this.checkTransparency() }, destroy: function () { this.innerElem = null, this.destroyBaseElement() } }; extendPrototype([RenderableElement, createProxyFunction(o)], RenderableDOMElement) })(); function IImageElement(o, l, u) { this.assetData = l.getAssetData(o.refId), this.assetData && this.assetData.sid && (this.assetData = l.slotManager.getProp(this.assetData)), this.initElement(o, l, u), this.sourceRect = { top: 0, left: 0, width: this.assetData.w, height: this.assetData.h } } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () { var o = this.globalData.getAssetsPath(this.assetData); this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", o), this.layerElement.appendChild(this.innerElem) }, IImageElement.prototype.sourceRectAtTime = function () { return this.sourceRect }; function ProcessedElement(o, l) { this.elem = o, this.pos = l } function IShapeElement() { } IShapeElement.prototype = { addShapeToModifiers: function (l) { var u, f = this.shapeModifiers.length; for (u = 0; u < f; u += 1)this.shapeModifiers[u].addShape(l) }, isShapeInAnimatedModifiers: function (l) { for (var u = 0, f = this.shapeModifiers.length; u < f;)if (this.shapeModifiers[u].isAnimatedWithShape(l)) return !0; return !1 }, renderModifiers: function () { if (this.shapeModifiers.length) { var l, u = this.shapes.length; for (l = 0; l < u; l += 1)this.shapes[l].sh.reset(); u = this.shapeModifiers.length; var f; for (l = u - 1; l >= 0 && (f = this.shapeModifiers[l].processShapes(this._isFirstFrame), !f); l -= 1); } }, searchProcessedElement: function (l) { for (var u = this.processedElements, f = 0, p = u.length; f < p;) { if (u[f].elem === l) return u[f].pos; f += 1 } return 0 }, addProcessedElement: function (l, u) { for (var f = this.processedElements, p = f.length; p;)if (p -= 1, f[p].elem === l) { f[p].pos = u; return } f.push(new ProcessedElement(l, u)) }, prepareFrame: function (l) { this.prepareRenderableFrame(l), this.prepareProperties(l, this.isInRange) } }; var lineCapEnum = { 1: "butt", 2: "round", 3: "square" }, lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" }; function SVGShapeData(o, l, u) { this.caches = [], this.styles = [], this.transformers = o, this.lStr = "", this.sh = u, this.lvl = l, this._isAnimated = !!u.k; for (var f = 0, p = o.length; f < p;) { if (o[f].mProps.dynamicProperties.length) { this._isAnimated = !0; break } f += 1 } } SVGShapeData.prototype.setAsAnimated = function () { this._isAnimated = !0 }; function SVGStyleData(o, l) { this.data = o, this.type = o.ty, this.d = "", this.lvl = l, this._mdf = !1, this.closed = o.hd === !0, this.pElem = createNS("path"), this.msElem = null } SVGStyleData.prototype.reset = function () { this.d = "", this._mdf = !1 }; function DashProperty(o, l, u, f) { this.elem = o, this.frameId = -1, this.dataProps = createSizedArray(l.length), this.renderer = u, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", l.length ? l.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(f); var p, d = l.length || 0, m; for (p = 0; p < d; p += 1)m = PropertyFactory.getProp(o, l[p].v, 0, 0, this), this.k = m.k || this.k, this.dataProps[p] = { n: l[p].n, p: m }; this.k || this.getValue(!0), this._isAnimated = this.k } DashProperty.prototype.getValue = function (o) { if (!(this.elem.globalData.frameId === this.frameId && !o) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || o, this._mdf)) { var l = 0, u = this.dataProps.length; for (this.renderer === "svg" && (this.dashStr = ""), l = 0; l < u; l += 1)this.dataProps[l].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[l].p.v : this.dashArray[l] = this.dataProps[l].p.v : this.dashoffset[0] = this.dataProps[l].p.v } }, extendPrototype([DynamicPropertyContainer], DashProperty); function SVGStrokeStyleData(o, l, u) { this.initDynamicPropertyContainer(o), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(o, l.o, 0, .01, this), this.w = PropertyFactory.getProp(o, l.w, 0, null, this), this.d = new DashProperty(o, l.d || {}, "svg", this), this.c = PropertyFactory.getProp(o, l.c, 1, 255, this), this.style = u, this._isAnimated = !!this._isAnimated } extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData); function SVGFillStyleData(o, l, u) { this.initDynamicPropertyContainer(o), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(o, l.o, 0, .01, this), this.c = PropertyFactory.getProp(o, l.c, 1, 255, this), this.style = u } extendPrototype([DynamicPropertyContainer], SVGFillStyleData); function SVGNoStyleData(o, l, u) { this.initDynamicPropertyContainer(o), this.getValue = this.iterateDynamicProperties, this.style = u } extendPrototype([DynamicPropertyContainer], SVGNoStyleData); function GradientProperty(o, l, u) { this.data = l, this.c = createTypedArray("uint8c", l.p * 4); var f = l.k.k[0].s ? l.k.k[0].s.length - l.p * 4 : l.k.k.length - l.p * 4; this.o = createTypedArray("float32", f), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = f, this.initDynamicPropertyContainer(u), this.prop = PropertyFactory.getProp(o, l.k, 1, null, this), this.k = this.prop.k, this.getValue(!0) } GradientProperty.prototype.comparePoints = function (o, l) { for (var u = 0, f = this.o.length / 2, p; u < f;) { if (p = Math.abs(o[u * 4] - o[l * 4 + u * 2]), p > .01) return !1; u += 1 } return !0 }, GradientProperty.prototype.checkCollapsable = function () { if (this.o.length / 2 !== this.c.length / 4) return !1; if (this.data.k.k[0].s) for (var o = 0, l = this.data.k.k.length; o < l;) { if (!this.comparePoints(this.data.k.k[o].s, this.data.p)) return !1; o += 1 } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1; return !0 }, GradientProperty.prototype.getValue = function (o) { if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || o) { var l, u = this.data.p * 4, f, p; for (l = 0; l < u; l += 1)f = l % 4 === 0 ? 100 : 255, p = Math.round(this.prop.v[l] * f), this.c[l] !== p && (this.c[l] = p, this._cmdf = !o); if (this.o.length) for (u = this.prop.v.length, l = this.data.p * 4; l < u; l += 1)f = l % 2 === 0 ? 100 : 1, p = l % 2 === 0 ? Math.round(this.prop.v[l] * 100) : this.prop.v[l], this.o[l - this.data.p * 4] !== p && (this.o[l - this.data.p * 4] = p, this._omdf = !o); this._mdf = !o } }, extendPrototype([DynamicPropertyContainer], GradientProperty); function SVGGradientFillStyleData(o, l, u) { this.initDynamicPropertyContainer(o), this.getValue = this.iterateDynamicProperties, this.initGradientData(o, l, u) } SVGGradientFillStyleData.prototype.initGradientData = function (o, l, u) { this.o = PropertyFactory.getProp(o, l.o, 0, .01, this), this.s = PropertyFactory.getProp(o, l.s, 1, null, this), this.e = PropertyFactory.getProp(o, l.e, 1, null, this), this.h = PropertyFactory.getProp(o, l.h || { k: 0 }, 0, .01, this), this.a = PropertyFactory.getProp(o, l.a || { k: 0 }, 0, degToRads, this), this.g = new GradientProperty(o, l.g, this), this.style = u, this.stops = [], this.setGradientData(u.pElem, l), this.setGradientOpacity(l, u), this._isAnimated = !!this._isAnimated }, SVGGradientFillStyleData.prototype.setGradientData = function (o, l) { var u = createElementID(), f = createNS(l.t === 1 ? "linearGradient" : "radialGradient"); f.setAttribute("id", u), f.setAttribute("spreadMethod", "pad"), f.setAttribute("gradientUnits", "userSpaceOnUse"); var p = [], d, m, v; for (v = l.g.p * 4, m = 0; m < v; m += 4)d = createNS("stop"), f.appendChild(d), p.push(d); o.setAttribute(l.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + u + ")"), this.gf = f, this.cst = p }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (o, l) { if (this.g._hasOpacity && !this.g._collapsable) { var u, f, p, d = createNS("mask"), m = createNS("path"); d.appendChild(m); var v = createElementID(), I = createElementID(); d.setAttribute("id", I); var F = createNS(o.t === 1 ? "linearGradient" : "radialGradient"); F.setAttribute("id", v), F.setAttribute("spreadMethod", "pad"), F.setAttribute("gradientUnits", "userSpaceOnUse"), p = o.g.k.k[0].s ? o.g.k.k[0].s.length : o.g.k.k.length; var B = this.stops; for (f = o.g.p * 4; f < p; f += 2)u = createNS("stop"), u.setAttribute("stop-color", "rgb(255,255,255)"), F.appendChild(u), B.push(u); m.setAttribute(o.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + v + ")"), o.ty === "gs" && (m.setAttribute("stroke-linecap", lineCapEnum[o.lc || 2]), m.setAttribute("stroke-linejoin", lineJoinEnum[o.lj || 2]), o.lj === 1 && m.setAttribute("stroke-miterlimit", o.ml)), this.of = F, this.ms = d, this.ost = B, this.maskId = I, l.msElem = m } }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData); function SVGGradientStrokeStyleData(o, l, u) { this.initDynamicPropertyContainer(o), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(o, l.w, 0, null, this), this.d = new DashProperty(o, l.d || {}, "svg", this), this.initGradientData(o, l, u), this._isAnimated = !!this._isAnimated } extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData); function ShapeGroupData() { this.it = [], this.prevViewData = [], this.gr = createNS("g") } function SVGTransformData(o, l, u) { this.transform = { mProps: o, op: l, container: u }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length } var buildShapeString = function (l, u, f, p) { if (u === 0) return ""; var d = l.o, m = l.i, v = l.v, I, F = " M" + p.applyToPointStringified(v[0][0], v[0][1]); for (I = 1; I < u; I += 1)F += " C" + p.applyToPointStringified(d[I - 1][0], d[I - 1][1]) + " " + p.applyToPointStringified(m[I][0], m[I][1]) + " " + p.applyToPointStringified(v[I][0], v[I][1]); return f && u && (F += " C" + p.applyToPointStringified(d[I - 1][0], d[I - 1][1]) + " " + p.applyToPointStringified(m[0][0], m[0][1]) + " " + p.applyToPointStringified(v[0][0], v[0][1]), F += "z"), F }, SVGElementsRenderer = function () { var o = new Matrix, l = new Matrix, u = { createRenderFunction: f }; function f(W) { switch (W.ty) { case "fl": return v; case "gf": return F; case "gs": return I; case "st": return B; case "sh": case "el": case "rc": case "sr": return m; case "tr": return p; case "no": return d; default: return null } } function p(W, Z, Q) { (Q || Z.transform.op._mdf) && Z.transform.container.setAttribute("opacity", Z.transform.op.v), (Q || Z.transform.mProps._mdf) && Z.transform.container.setAttribute("transform", Z.transform.mProps.v.to2dCSS()) } function d() { } function m(W, Z, Q) { var re, ne, oe, ae, se, le, ue = Z.styles.length, he = Z.lvl, pe, ve, _e, Se; for (le = 0; le < ue; le += 1) { if (ae = Z.sh._mdf || Q, Z.styles[le].lvl < he) { for (ve = l.reset(), _e = he - Z.styles[le].lvl, Se = Z.transformers.length - 1; !ae && _e > 0;)ae = Z.transformers[Se].mProps._mdf || ae, _e -= 1, Se -= 1; if (ae) for (_e = he - Z.styles[le].lvl, Se = Z.transformers.length - 1; _e > 0;)ve.multiply(Z.transformers[Se].mProps.v), _e -= 1, Se -= 1 } else ve = o; if (pe = Z.sh.paths, ne = pe._length, ae) { for (oe = "", re = 0; re < ne; re += 1)se = pe.shapes[re], se && se._length && (oe += buildShapeString(se, se._length, se.c, ve)); Z.caches[le] = oe } else oe = Z.caches[le]; Z.styles[le].d += W.hd === !0 ? "" : oe, Z.styles[le]._mdf = ae || Z.styles[le]._mdf } } function v(W, Z, Q) { var re = Z.style; (Z.c._mdf || Q) && re.pElem.setAttribute("fill", "rgb(" + bmFloor(Z.c.v[0]) + "," + bmFloor(Z.c.v[1]) + "," + bmFloor(Z.c.v[2]) + ")"), (Z.o._mdf || Q) && re.pElem.setAttribute("fill-opacity", Z.o.v) } function I(W, Z, Q) { F(W, Z, Q), B(W, Z, Q) } function F(W, Z, Q) { var re = Z.gf, ne = Z.g._hasOpacity, oe = Z.s.v, ae = Z.e.v; if (Z.o._mdf || Q) { var se = W.ty === "gf" ? "fill-opacity" : "stroke-opacity"; Z.style.pElem.setAttribute(se, Z.o.v) } if (Z.s._mdf || Q) { var le = W.t === 1 ? "x1" : "cx", ue = le === "x1" ? "y1" : "cy"; re.setAttribute(le, oe[0]), re.setAttribute(ue, oe[1]), ne && !Z.g._collapsable && (Z.of.setAttribute(le, oe[0]), Z.of.setAttribute(ue, oe[1])) } var he, pe, ve, _e; if (Z.g._cmdf || Q) { he = Z.cst; var Se = Z.g.c; for (ve = he.length, pe = 0; pe < ve; pe += 1)_e = he[pe], _e.setAttribute("offset", Se[pe * 4] + "%"), _e.setAttribute("stop-color", "rgb(" + Se[pe * 4 + 1] + "," + Se[pe * 4 + 2] + "," + Se[pe * 4 + 3] + ")") } if (ne && (Z.g._omdf || Q)) { var $e = Z.g.o; for (Z.g._collapsable ? he = Z.cst : he = Z.ost, ve = he.length, pe = 0; pe < ve; pe += 1)_e = he[pe], Z.g._collapsable || _e.setAttribute("offset", $e[pe * 2] + "%"), _e.setAttribute("stop-opacity", $e[pe * 2 + 1]) } if (W.t === 1) (Z.e._mdf || Q) && (re.setAttribute("x2", ae[0]), re.setAttribute("y2", ae[1]), ne && !Z.g._collapsable && (Z.of.setAttribute("x2", ae[0]), Z.of.setAttribute("y2", ae[1]))); else { var ie; if ((Z.s._mdf || Z.e._mdf || Q) && (ie = Math.sqrt(Math.pow(oe[0] - ae[0], 2) + Math.pow(oe[1] - ae[1], 2)), re.setAttribute("r", ie), ne && !Z.g._collapsable && Z.of.setAttribute("r", ie)), Z.e._mdf || Z.h._mdf || Z.a._mdf || Q) { ie || (ie = Math.sqrt(Math.pow(oe[0] - ae[0], 2) + Math.pow(oe[1] - ae[1], 2))); var g = Math.atan2(ae[1] - oe[1], ae[0] - oe[0]), P = Z.h.v; P >= 1 ? P = .99 : P <= -1 && (P = -.99); var U = ie * P, K = Math.cos(g + Z.a.v) * U + oe[0], Y = Math.sin(g + Z.a.v) * U + oe[1]; re.setAttribute("fx", K), re.setAttribute("fy", Y), ne && !Z.g._collapsable && (Z.of.setAttribute("fx", K), Z.of.setAttribute("fy", Y)) } } } function B(W, Z, Q) { var re = Z.style, ne = Z.d; ne && (ne._mdf || Q) && ne.dashStr && (re.pElem.setAttribute("stroke-dasharray", ne.dashStr), re.pElem.setAttribute("stroke-dashoffset", ne.dashoffset[0])), Z.c && (Z.c._mdf || Q) && re.pElem.setAttribute("stroke", "rgb(" + bmFloor(Z.c.v[0]) + "," + bmFloor(Z.c.v[1]) + "," + bmFloor(Z.c.v[2]) + ")"), (Z.o._mdf || Q) && re.pElem.setAttribute("stroke-opacity", Z.o.v), (Z.w._mdf || Q) && (re.pElem.setAttribute("stroke-width", Z.w.v), re.msElem && re.msElem.setAttribute("stroke-width", Z.w.v)) } return u }(); function SVGShapeElement(o, l, u) { this.shapes = [], this.shapesData = o.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(o, l, u), this.prevViewData = [] } extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () { }, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () { }, SVGShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes() }, SVGShapeElement.prototype.filterUniqueShapes = function () { var o, l = this.shapes.length, u, f, p = this.stylesList.length, d, m = [], v = !1; for (f = 0; f < p; f += 1) { for (d = this.stylesList[f], v = !1, m.length = 0, o = 0; o < l; o += 1)u = this.shapes[o], u.styles.indexOf(d) !== -1 && (m.push(u), v = u._isAnimated || v); m.length > 1 && v && this.setShapesAsAnimated(m) } }, SVGShapeElement.prototype.setShapesAsAnimated = function (o) { var l, u = o.length; for (l = 0; l < u; l += 1)o[l].setAsAnimated() }, SVGShapeElement.prototype.createStyleElement = function (o, l) { var u, f = new SVGStyleData(o, l), p = f.pElem; if (o.ty === "st") u = new SVGStrokeStyleData(this, o, f); else if (o.ty === "fl") u = new SVGFillStyleData(this, o, f); else if (o.ty === "gf" || o.ty === "gs") { var d = o.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData; u = new d(this, o, f), this.globalData.defs.appendChild(u.gf), u.maskId && (this.globalData.defs.appendChild(u.ms), this.globalData.defs.appendChild(u.of), p.setAttribute("mask", "url(" + getLocationHref() + "#" + u.maskId + ")")) } else o.ty === "no" && (u = new SVGNoStyleData(this, o, f)); return (o.ty === "st" || o.ty === "gs") && (p.setAttribute("stroke-linecap", lineCapEnum[o.lc || 2]), p.setAttribute("stroke-linejoin", lineJoinEnum[o.lj || 2]), p.setAttribute("fill-opacity", "0"), o.lj === 1 && p.setAttribute("stroke-miterlimit", o.ml)), o.r === 2 && p.setAttribute("fill-rule", "evenodd"), o.ln && p.setAttribute("id", o.ln), o.cl && p.setAttribute("class", o.cl), o.bm && (p.style["mix-blend-mode"] = getBlendMode(o.bm)), this.stylesList.push(f), this.addToAnimatedContents(o, u), u }, SVGShapeElement.prototype.createGroupElement = function (o) { var l = new ShapeGroupData; return o.ln && l.gr.setAttribute("id", o.ln), o.cl && l.gr.setAttribute("class", o.cl), o.bm && (l.gr.style["mix-blend-mode"] = getBlendMode(o.bm)), l }, SVGShapeElement.prototype.createTransformElement = function (o, l) { var u = TransformPropertyFactory.getTransformProperty(this, o, this), f = new SVGTransformData(u, u.o, l); return this.addToAnimatedContents(o, f), f }, SVGShapeElement.prototype.createShapeElement = function (o, l, u) { var f = 4; o.ty === "rc" ? f = 5 : o.ty === "el" ? f = 6 : o.ty === "sr" && (f = 7); var p = ShapePropertyFactory.getShapeProp(this, o, f, this), d = new SVGShapeData(l, u, p); return this.shapes.push(d), this.addShapeToModifiers(d), this.addToAnimatedContents(o, d), d }, SVGShapeElement.prototype.addToAnimatedContents = function (o, l) { for (var u = 0, f = this.animatedContents.length; u < f;) { if (this.animatedContents[u].element === l) return; u += 1 } this.animatedContents.push({ fn: SVGElementsRenderer.createRenderFunction(o), element: l, data: o }) }, SVGShapeElement.prototype.setElementStyles = function (o) { var l = o.styles, u, f = this.stylesList.length; for (u = 0; u < f; u += 1)this.stylesList[u].closed || l.push(this.stylesList[u]) }, SVGShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; var o, l = this.itemsData.length; for (o = 0; o < l; o += 1)this.prevViewData[o] = this.itemsData[o]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), l = this.dynamicProperties.length, o = 0; o < l; o += 1)this.dynamicProperties[o].getValue(); this.renderModifiers() }, SVGShapeElement.prototype.searchShapes = function (o, l, u, f, p, d, m) { var v = [].concat(d), I, F = o.length - 1, B, W, Z = [], Q = [], re, ne, oe; for (I = F; I >= 0; I -= 1) { if (oe = this.searchProcessedElement(o[I]), oe ? l[I] = u[oe - 1] : o[I]._render = m, o[I].ty === "fl" || o[I].ty === "st" || o[I].ty === "gf" || o[I].ty === "gs" || o[I].ty === "no") oe ? l[I].style.closed = !1 : l[I] = this.createStyleElement(o[I], p), o[I]._render && l[I].style.pElem.parentNode !== f && f.appendChild(l[I].style.pElem), Z.push(l[I].style); else if (o[I].ty === "gr") { if (!oe) l[I] = this.createGroupElement(o[I]); else for (W = l[I].it.length, B = 0; B < W; B += 1)l[I].prevViewData[B] = l[I].it[B]; this.searchShapes(o[I].it, l[I].it, l[I].prevViewData, l[I].gr, p + 1, v, m), o[I]._render && l[I].gr.parentNode !== f && f.appendChild(l[I].gr) } else o[I].ty === "tr" ? (oe || (l[I] = this.createTransformElement(o[I], f)), re = l[I].transform, v.push(re)) : o[I].ty === "sh" || o[I].ty === "rc" || o[I].ty === "el" || o[I].ty === "sr" ? (oe || (l[I] = this.createShapeElement(o[I], v, p)), this.setElementStyles(l[I])) : o[I].ty === "tm" || o[I].ty === "rd" || o[I].ty === "ms" || o[I].ty === "pb" || o[I].ty === "zz" || o[I].ty === "op" ? (oe ? (ne = l[I], ne.closed = !1) : (ne = ShapeModifiers.getModifier(o[I].ty), ne.init(this, o[I]), l[I] = ne, this.shapeModifiers.push(ne)), Q.push(ne)) : o[I].ty === "rp" && (oe ? (ne = l[I], ne.closed = !0) : (ne = ShapeModifiers.getModifier(o[I].ty), l[I] = ne, ne.init(this, o, I, l), this.shapeModifiers.push(ne), m = !1), Q.push(ne)); this.addProcessedElement(o[I], I + 1) } for (F = Z.length, I = 0; I < F; I += 1)Z[I].closed = !0; for (F = Q.length, I = 0; I < F; I += 1)Q[I].closed = !0 }, SVGShapeElement.prototype.renderInnerContent = function () { this.renderModifiers(); var o, l = this.stylesList.length; for (o = 0; o < l; o += 1)this.stylesList[o].reset(); for (this.renderShape(), o = 0; o < l; o += 1)(this.stylesList[o]._mdf || this._isFirstFrame) && (this.stylesList[o].msElem && (this.stylesList[o].msElem.setAttribute("d", this.stylesList[o].d), this.stylesList[o].d = "M0 0" + this.stylesList[o].d), this.stylesList[o].pElem.setAttribute("d", this.stylesList[o].d || "M0 0")) }, SVGShapeElement.prototype.renderShape = function () { var o, l = this.animatedContents.length, u; for (o = 0; o < l; o += 1)u = this.animatedContents[o], (this._isFirstFrame || u.element._isAnimated) && u.data !== !0 && u.fn(u.data, u.element, this._isFirstFrame) }, SVGShapeElement.prototype.destroy = function () { this.destroyBaseElement(), this.shapesData = null, this.itemsData = null }; function LetterProps(o, l, u, f, p, d) { this.o = o, this.sw = l, this.sc = u, this.fc = f, this.m = p, this.p = d, this._mdf = { o: !0, sw: !!l, sc: !!u, fc: !!f, m: !0, p: !0 } } LetterProps.prototype.update = function (o, l, u, f, p, d) { this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1; var m = !1; return this.o !== o && (this.o = o, this._mdf.o = !0, m = !0), this.sw !== l && (this.sw = l, this._mdf.sw = !0, m = !0), this.sc !== u && (this.sc = u, this._mdf.sc = !0, m = !0), this.fc !== f && (this.fc = f, this._mdf.fc = !0, m = !0), this.m !== p && (this.m = p, this._mdf.m = !0, m = !0), d.length && (this.p[0] !== d[0] || this.p[1] !== d[1] || this.p[4] !== d[4] || this.p[5] !== d[5] || this.p[12] !== d[12] || this.p[13] !== d[13]) && (this.p = d, this._mdf.p = !0, m = !0), m }; function TextProperty(o, l) { this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, l.d && l.d.sid && (l.d = o.globalData.slotManager.getProp(l.d)), this.data = l, this.elem = o, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = { ascent: 0, boxWidth: this.defaultBoxWidth, f: "", fStyle: "", fWeight: "", fc: "", j: "", justifyOffset: "", l: [], lh: 0, lineWidths: [], ls: "", of: "", s: "", sc: "", sw: 0, t: 0, tr: 0, sz: 0, ps: null, fillColorAnim: !1, strokeColorAnim: !1, strokeWidthAnim: !1, yOffset: 0, finalSize: 0, finalText: [], finalLineHeight: 0, __complete: !1 }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData) } TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (o, l) { for (var u in l) Object.prototype.hasOwnProperty.call(l, u) && (o[u] = l[u]); return o }, TextProperty.prototype.setCurrentData = function (o) { o.__complete || this.completeTextData(o), this.currentData = o, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0 }, TextProperty.prototype.searchProperty = function () { return this.searchKeyframes() }, TextProperty.prototype.searchKeyframes = function () { return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf }, TextProperty.prototype.addEffect = function (o) { this.effectsSequence.push(o), this.elem.addDynamicProperty(this) }, TextProperty.prototype.getValue = function (o) { if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !o)) { this.currentData.t = this.data.d.k[this.keysIndex].s.t; var l = this.currentData, u = this.keysIndex; if (this.lock) { this.setCurrentData(this.currentData); return } this.lock = !0, this._mdf = !1; var f, p = this.effectsSequence.length, d = o || this.data.d.k[this.keysIndex].s; for (f = 0; f < p; f += 1)u !== this.keysIndex ? d = this.effectsSequence[f](d, d.t) : d = this.effectsSequence[f](this.currentData, d.t); l !== d && this.setCurrentData(d), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId } }, TextProperty.prototype.getKeyframeValue = function () { for (var o = this.data.d.k, l = this.elem.comp.renderedFrame, u = 0, f = o.length; u <= f - 1 && !(u === f - 1 || o[u + 1].t > l);)u += 1; return this.keysIndex !== u && (this.keysIndex = u), this.data.d.k[this.keysIndex].s }, TextProperty.prototype.buildFinalText = function (o) { for (var l = [], u = 0, f = o.length, p, d, m = !1, v = !1, I = ""; u < f;)m = v, v = !1, p = o.charCodeAt(u), I = o.charAt(u), FontManager.isCombinedCharacter(p) ? m = !0 : p >= 55296 && p <= 56319 ? FontManager.isRegionalFlag(o, u) ? I = o.substr(u, 14) : (d = o.charCodeAt(u + 1), d >= 56320 && d <= 57343 && (FontManager.isModifier(p, d) ? (I = o.substr(u, 2), m = !0) : FontManager.isFlagEmoji(o.substr(u, 4)) ? I = o.substr(u, 4) : I = o.substr(u, 2))) : p > 56319 ? (d = o.charCodeAt(u + 1), FontManager.isVariationSelector(p) && (m = !0)) : FontManager.isZeroWidthJoiner(p) && (m = !0, v = !0), m ? (l[l.length - 1] += I, m = !1) : l.push(I), u += I.length; return l }, TextProperty.prototype.completeTextData = function (o) { o.__complete = !0; var l = this.elem.globalData.fontManager, u = this.data, f = [], p, d, m, v = 0, I, F = u.m.g, B = 0, W = 0, Z = 0, Q = [], re = 0, ne = 0, oe, ae, se = l.getFontByName(o.f), le, ue = 0, he = getFontProperties(se); o.fWeight = he.weight, o.fStyle = he.style, o.finalSize = o.s, o.finalText = this.buildFinalText(o.t), d = o.finalText.length, o.finalLineHeight = o.lh; var pe = o.tr / 1e3 * o.finalSize, ve; if (o.sz) for (var _e = !0, Se = o.sz[0], $e = o.sz[1], ie, g; _e;) { g = this.buildFinalText(o.t), ie = 0, re = 0, d = g.length, pe = o.tr / 1e3 * o.finalSize; var P = -1; for (p = 0; p < d; p += 1)ve = g[p].charCodeAt(0), m = !1, g[p] === " " ? P = p : (ve === 13 || ve === 3) && (re = 0, m = !0, ie += o.finalLineHeight || o.finalSize * 1.2), l.chars ? (le = l.getCharData(g[p], se.fStyle, se.fFamily), ue = m ? 0 : le.w * o.finalSize / 100) : ue = l.measureText(g[p], o.f, o.finalSize), re + ue > Se && g[p] !== " " ? (P === -1 ? d += 1 : p = P, ie += o.finalLineHeight || o.finalSize * 1.2, g.splice(p, P === p ? 1 : 0, "\r"), P = -1, re = 0) : (re += ue, re += pe); ie += se.ascent * o.finalSize / 100, this.canResize && o.finalSize > this.minimumFontSize && $e < ie ? (o.finalSize -= 1, o.finalLineHeight = o.finalSize * o.lh / o.s) : (o.finalText = g, d = o.finalText.length, _e = !1) } re = -pe, ue = 0; var U = 0, K; for (p = 0; p < d; p += 1)if (m = !1, K = o.finalText[p], ve = K.charCodeAt(0), ve === 13 || ve === 3 ? (U = 0, Q.push(re), ne = re > ne ? re : ne, re = -2 * pe, I = "", m = !0, Z += 1) : I = K, l.chars ? (le = l.getCharData(K, se.fStyle, l.getFontByName(o.f).fFamily), ue = m ? 0 : le.w * o.finalSize / 100) : ue = l.measureText(I, o.f, o.finalSize), K === " " ? U += ue + pe : (re += ue + pe + U, U = 0), f.push({ l: ue, an: ue, add: B, n: m, anIndexes: [], val: I, line: Z, animatorJustifyOffset: 0 }), F == 2) { if (B += ue, I === "" || I === " " || p === d - 1) { for ((I === "" || I === " ") && (B -= ue); W <= p;)f[W].an = B, f[W].ind = v, f[W].extra = ue, W += 1; v += 1, B = 0 } } else if (F == 3) { if (B += ue, I === "" || p === d - 1) { for (I === "" && (B -= ue); W <= p;)f[W].an = B, f[W].ind = v, f[W].extra = ue, W += 1; B = 0, v += 1 } } else f[v].ind = v, f[v].extra = 0, v += 1; if (o.l = f, ne = re > ne ? re : ne, Q.push(re), o.sz) o.boxWidth = o.sz[0], o.justifyOffset = 0; else switch (o.boxWidth = ne, o.j) { case 1: o.justifyOffset = -o.boxWidth; break; case 2: o.justifyOffset = -o.boxWidth / 2; break; default: o.justifyOffset = 0 }o.lineWidths = Q; var Y = u.a, te, ee; ae = Y.length; var G, y, X = []; for (oe = 0; oe < ae; oe += 1) { for (te = Y[oe], te.a.sc && (o.strokeColorAnim = !0), te.a.sw && (o.strokeWidthAnim = !0), (te.a.fc || te.a.fh || te.a.fs || te.a.fb) && (o.fillColorAnim = !0), y = 0, G = te.s.b, p = 0; p < d; p += 1)ee = f[p], ee.anIndexes[oe] = y, (G == 1 && ee.val !== "" || G == 2 && ee.val !== "" && ee.val !== " " || G == 3 && (ee.n || ee.val == " " || p == d - 1) || G == 4 && (ee.n || p == d - 1)) && (te.s.rn === 1 && X.push(y), y += 1); u.a[oe].s.totalChars = y; var ce = -1, me; if (te.s.rn === 1) for (p = 0; p < d; p += 1)ee = f[p], ce != ee.anIndexes[oe] && (ce = ee.anIndexes[oe], me = X.splice(Math.floor(Math.random() * X.length), 1)[0]), ee.anIndexes[oe] = me } o.yOffset = o.finalLineHeight || o.finalSize * 1.2, o.ls = o.ls || 0, o.ascent = se.ascent * o.finalSize / 100 }, TextProperty.prototype.updateDocumentData = function (o, l) { l = l === void 0 ? this.keysIndex : l; var u = this.copyData({}, this.data.d.k[l].s); u = this.copyData(u, o), this.data.d.k[l].s = u, this.recalculate(l), this.setCurrentData(u), this.elem.addDynamicProperty(this) }, TextProperty.prototype.recalculate = function (o) { var l = this.data.d.k[o].s; l.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(l) }, TextProperty.prototype.canResizeFont = function (o) { this.canResize = o, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }, TextProperty.prototype.setMinimumFontSize = function (o) { this.minimumFontSize = Math.floor(o) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }; var TextSelectorProp = function () { var o = Math.max, l = Math.min, u = Math.floor; function f(d, m) { this._currentTextLength = -1, this.k = !1, this.data = m, this.elem = d, this.comp = d.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(d), this.s = PropertyFactory.getProp(d, m.s || { k: 0 }, 0, 0, this), "e" in m ? this.e = PropertyFactory.getProp(d, m.e, 0, 0, this) : this.e = { v: 100 }, this.o = PropertyFactory.getProp(d, m.o || { k: 0 }, 0, 0, this), this.xe = PropertyFactory.getProp(d, m.xe || { k: 0 }, 0, 0, this), this.ne = PropertyFactory.getProp(d, m.ne || { k: 0 }, 0, 0, this), this.sm = PropertyFactory.getProp(d, m.sm || { k: 100 }, 0, 0, this), this.a = PropertyFactory.getProp(d, m.a, 0, .01, this), this.dynamicProperties.length || this.getValue() } f.prototype = { getMult: function (m) { this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue(); var v = 0, I = 0, F = 1, B = 1; this.ne.v > 0 ? v = this.ne.v / 100 : I = -this.ne.v / 100, this.xe.v > 0 ? F = 1 - this.xe.v / 100 : B = 1 + this.xe.v / 100; var W = BezierFactory.getBezierEasing(v, I, F, B).get, Z = 0, Q = this.finalS, re = this.finalE, ne = this.data.sh; if (ne === 2) re === Q ? Z = m >= re ? 1 : 0 : Z = o(0, l(.5 / (re - Q) + (m - Q) / (re - Q), 1)), Z = W(Z); else if (ne === 3) re === Q ? Z = m >= re ? 0 : 1 : Z = 1 - o(0, l(.5 / (re - Q) + (m - Q) / (re - Q), 1)), Z = W(Z); else if (ne === 4) re === Q ? Z = 0 : (Z = o(0, l(.5 / (re - Q) + (m - Q) / (re - Q), 1)), Z < .5 ? Z *= 2 : Z = 1 - 2 * (Z - .5)), Z = W(Z); else if (ne === 5) { if (re === Q) Z = 0; else { var oe = re - Q; m = l(o(0, m + .5 - Q), re - Q); var ae = -oe / 2 + m, se = oe / 2; Z = Math.sqrt(1 - ae * ae / (se * se)) } Z = W(Z) } else ne === 6 ? (re === Q ? Z = 0 : (m = l(o(0, m + .5 - Q), re - Q), Z = (1 + Math.cos(Math.PI + Math.PI * 2 * m / (re - Q))) / 2), Z = W(Z)) : (m >= u(Q) && (m - Q < 0 ? Z = o(0, l(l(re, 1) - (Q - m), 1)) : Z = o(0, l(re - m, 1))), Z = W(Z)); if (this.sm.v !== 100) { var le = this.sm.v * .01; le === 0 && (le = 1e-8); var ue = .5 - le * .5; Z < ue ? Z = 0 : (Z = (Z - ue) / le, Z > 1 && (Z = 1)) } return Z * this.a.v }, getValue: function (m) { this.iterateDynamicProperties(), this._mdf = m || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, m && this.data.r === 2 && (this.e.v = this._currentTextLength); var v = this.data.r === 2 ? 1 : 100 / this.data.totalChars, I = this.o.v / v, F = this.s.v / v + I, B = this.e.v / v + I; if (F > B) { var W = F; F = B, B = W } this.finalS = F, this.finalE = B } }, extendPrototype([DynamicPropertyContainer], f); function p(d, m, v) { return new f(d, m) } return { getTextSelectorProp: p } }(); function TextAnimatorDataProperty(o, l, u) { var f = { propType: !1 }, p = PropertyFactory.getProp, d = l.a; this.a = { r: d.r ? p(o, d.r, 0, degToRads, u) : f, rx: d.rx ? p(o, d.rx, 0, degToRads, u) : f, ry: d.ry ? p(o, d.ry, 0, degToRads, u) : f, sk: d.sk ? p(o, d.sk, 0, degToRads, u) : f, sa: d.sa ? p(o, d.sa, 0, degToRads, u) : f, s: d.s ? p(o, d.s, 1, .01, u) : f, a: d.a ? p(o, d.a, 1, 0, u) : f, o: d.o ? p(o, d.o, 0, .01, u) : f, p: d.p ? p(o, d.p, 1, 0, u) : f, sw: d.sw ? p(o, d.sw, 0, 0, u) : f, sc: d.sc ? p(o, d.sc, 1, 0, u) : f, fc: d.fc ? p(o, d.fc, 1, 0, u) : f, fh: d.fh ? p(o, d.fh, 0, 0, u) : f, fs: d.fs ? p(o, d.fs, 0, .01, u) : f, fb: d.fb ? p(o, d.fb, 0, .01, u) : f, t: d.t ? p(o, d.t, 0, 0, u) : f }, this.s = TextSelectorProp.getTextSelectorProp(o, l.s, u), this.s.t = l.s.t } function TextAnimatorProperty(o, l, u) { this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = o, this._renderType = l, this._elem = u, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = { alignment: {} }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(u) } TextAnimatorProperty.prototype.searchProperties = function () { var o, l = this._textData.a.length, u, f = PropertyFactory.getProp; for (o = 0; o < l; o += 1)u = this._textData.a[o], this._animatorsData[o] = new TextAnimatorDataProperty(this._elem, u, this); this._textData.p && "m" in this._textData.p ? (this._pathData = { a: f(this._elem, this._textData.p.a, 0, 0, this), f: f(this._elem, this._textData.p.f, 0, 0, this), l: f(this._elem, this._textData.p.l, 0, 0, this), r: f(this._elem, this._textData.p.r, 0, 0, this), p: f(this._elem, this._textData.p.p, 0, 0, this), m: this._elem.maskManager.getMaskProperty(this._textData.p.m) }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = f(this._elem, this._textData.m.a, 1, 0, this) }, TextAnimatorProperty.prototype.getMeasures = function (o, l) { if (this.lettersChangedFlag = l, !(!this._mdf && !this._isFirstFrame && !l && (!this._hasMaskedPath || !this._pathData.m._mdf))) { this._isFirstFrame = !1; var u = this._moreOptions.alignment.v, f = this._animatorsData, p = this._textData, d = this.mHelper, m = this._renderType, v = this.renderedLetters.length, I, F, B, W, Z = o.l, Q, re, ne, oe, ae, se, le, ue, he, pe, ve, _e, Se, $e, ie; if (this._hasMaskedPath) { if (ie = this._pathData.m, !this._pathData.n || this._pathData._mdf) { var g = ie.v; this._pathData.r.v && (g = g.reverse()), Q = { tLength: 0, segments: [] }, W = g._length - 1; var P; for (_e = 0, B = 0; B < W; B += 1)P = bez.buildBezierData(g.v[B], g.v[B + 1], [g.o[B][0] - g.v[B][0], g.o[B][1] - g.v[B][1]], [g.i[B + 1][0] - g.v[B + 1][0], g.i[B + 1][1] - g.v[B + 1][1]]), Q.tLength += P.segmentLength, Q.segments.push(P), _e += P.segmentLength; B = W, ie.v.c && (P = bez.buildBezierData(g.v[B], g.v[0], [g.o[B][0] - g.v[B][0], g.o[B][1] - g.v[B][1]], [g.i[0][0] - g.v[0][0], g.i[0][1] - g.v[0][1]]), Q.tLength += P.segmentLength, Q.segments.push(P), _e += P.segmentLength), this._pathData.pi = Q } if (Q = this._pathData.pi, re = this._pathData.f.v, le = 0, se = 1, oe = 0, ae = !0, pe = Q.segments, re < 0 && ie.v.c) for (Q.tLength < Math.abs(re) && (re = -Math.abs(re) % Q.tLength), le = pe.length - 1, he = pe[le].points, se = he.length - 1; re < 0;)re += he[se].partialLength, se -= 1, se < 0 && (le -= 1, he = pe[le].points, se = he.length - 1); he = pe[le].points, ue = he[se - 1], ne = he[se], ve = ne.partialLength } W = Z.length, I = 0, F = 0; var U = o.finalSize * 1.2 * .714, K = !0, Y, te, ee, G, y; G = f.length; var X, ce = -1, me, Ae, Ie, Be = re, Me = le, De = se, Ue = -1, Ke, Ve, ke, Je, dt, lt, ht, Bt, mt = "", et = this.defaultPropsArray, Gt; if (o.j === 2 || o.j === 1) { var pt = 0, _t = 0, zt = o.j === 2 ? -.5 : -1, bt = 0, We = !0; for (B = 0; B < W; B += 1)if (Z[B].n) { for (pt && (pt += _t); bt < B;)Z[bt].animatorJustifyOffset = pt, bt += 1; pt = 0, We = !0 } else { for (ee = 0; ee < G; ee += 1)Y = f[ee].a, Y.t.propType && (We && o.j === 2 && (_t += Y.t.v * zt), te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), X.length ? pt += Y.t.v * X[0] * zt : pt += Y.t.v * X * zt); We = !1 } for (pt && (pt += _t); bt < B;)Z[bt].animatorJustifyOffset = pt, bt += 1 } for (B = 0; B < W; B += 1) { if (d.reset(), Ke = 1, Z[B].n) I = 0, F += o.yOffset, F += K ? 1 : 0, re = Be, K = !1, this._hasMaskedPath && (le = Me, se = De, he = pe[le].points, ue = he[se - 1], ne = he[se], ve = ne.partialLength, oe = 0), mt = "", Bt = "", lt = "", Gt = "", et = this.defaultPropsArray; else { if (this._hasMaskedPath) { if (Ue !== Z[B].line) { switch (o.j) { case 1: re += _e - o.lineWidths[Z[B].line]; break; case 2: re += (_e - o.lineWidths[Z[B].line]) / 2; break }Ue = Z[B].line } ce !== Z[B].ind && (Z[ce] && (re += Z[ce].extra), re += Z[B].an / 2, ce = Z[B].ind), re += u[0] * Z[B].an * .005; var Ge = 0; for (ee = 0; ee < G; ee += 1)Y = f[ee].a, Y.p.propType && (te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), X.length ? Ge += Y.p.v[0] * X[0] : Ge += Y.p.v[0] * X), Y.a.propType && (te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), X.length ? Ge += Y.a.v[0] * X[0] : Ge += Y.a.v[0] * X); for (ae = !0, this._pathData.a.v && (re = Z[0].an * .5 + (_e - this._pathData.f.v - Z[0].an * .5 - Z[Z.length - 1].an * .5) * ce / (W - 1), re += this._pathData.f.v); ae;)oe + ve >= re + Ge || !he ? (Se = (re + Ge - oe) / ne.partialLength, Ae = ue.point[0] + (ne.point[0] - ue.point[0]) * Se, Ie = ue.point[1] + (ne.point[1] - ue.point[1]) * Se, d.translate(-u[0] * Z[B].an * .005, -(u[1] * U) * .01), ae = !1) : he && (oe += ne.partialLength, se += 1, se >= he.length && (se = 0, le += 1, pe[le] ? he = pe[le].points : ie.v.c ? (se = 0, le = 0, he = pe[le].points) : (oe -= ne.partialLength, he = null)), he && (ue = ne, ne = he[se], ve = ne.partialLength)); me = Z[B].an / 2 - Z[B].add, d.translate(-me, 0, 0) } else me = Z[B].an / 2 - Z[B].add, d.translate(-me, 0, 0), d.translate(-u[0] * Z[B].an * .005, -u[1] * U * .01, 0); for (ee = 0; ee < G; ee += 1)Y = f[ee].a, Y.t.propType && (te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), (I !== 0 || o.j !== 0) && (this._hasMaskedPath ? X.length ? re += Y.t.v * X[0] : re += Y.t.v * X : X.length ? I += Y.t.v * X[0] : I += Y.t.v * X)); for (o.strokeWidthAnim && (ke = o.sw || 0), o.strokeColorAnim && (o.sc ? Ve = [o.sc[0], o.sc[1], o.sc[2]] : Ve = [0, 0, 0]), o.fillColorAnim && o.fc && (Je = [o.fc[0], o.fc[1], o.fc[2]]), ee = 0; ee < G; ee += 1)Y = f[ee].a, Y.a.propType && (te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), X.length ? d.translate(-Y.a.v[0] * X[0], -Y.a.v[1] * X[1], Y.a.v[2] * X[2]) : d.translate(-Y.a.v[0] * X, -Y.a.v[1] * X, Y.a.v[2] * X)); for (ee = 0; ee < G; ee += 1)Y = f[ee].a, Y.s.propType && (te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), X.length ? d.scale(1 + (Y.s.v[0] - 1) * X[0], 1 + (Y.s.v[1] - 1) * X[1], 1) : d.scale(1 + (Y.s.v[0] - 1) * X, 1 + (Y.s.v[1] - 1) * X, 1)); for (ee = 0; ee < G; ee += 1) { if (Y = f[ee].a, te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), Y.sk.propType && (X.length ? d.skewFromAxis(-Y.sk.v * X[0], Y.sa.v * X[1]) : d.skewFromAxis(-Y.sk.v * X, Y.sa.v * X)), Y.r.propType && (X.length ? d.rotateZ(-Y.r.v * X[2]) : d.rotateZ(-Y.r.v * X)), Y.ry.propType && (X.length ? d.rotateY(Y.ry.v * X[1]) : d.rotateY(Y.ry.v * X)), Y.rx.propType && (X.length ? d.rotateX(Y.rx.v * X[0]) : d.rotateX(Y.rx.v * X)), Y.o.propType && (X.length ? Ke += (Y.o.v * X[0] - Ke) * X[0] : Ke += (Y.o.v * X - Ke) * X), o.strokeWidthAnim && Y.sw.propType && (X.length ? ke += Y.sw.v * X[0] : ke += Y.sw.v * X), o.strokeColorAnim && Y.sc.propType) for (dt = 0; dt < 3; dt += 1)X.length ? Ve[dt] += (Y.sc.v[dt] - Ve[dt]) * X[0] : Ve[dt] += (Y.sc.v[dt] - Ve[dt]) * X; if (o.fillColorAnim && o.fc) { if (Y.fc.propType) for (dt = 0; dt < 3; dt += 1)X.length ? Je[dt] += (Y.fc.v[dt] - Je[dt]) * X[0] : Je[dt] += (Y.fc.v[dt] - Je[dt]) * X; Y.fh.propType && (X.length ? Je = addHueToRGB(Je, Y.fh.v * X[0]) : Je = addHueToRGB(Je, Y.fh.v * X)), Y.fs.propType && (X.length ? Je = addSaturationToRGB(Je, Y.fs.v * X[0]) : Je = addSaturationToRGB(Je, Y.fs.v * X)), Y.fb.propType && (X.length ? Je = addBrightnessToRGB(Je, Y.fb.v * X[0]) : Je = addBrightnessToRGB(Je, Y.fb.v * X)) } } for (ee = 0; ee < G; ee += 1)Y = f[ee].a, Y.p.propType && (te = f[ee].s, X = te.getMult(Z[B].anIndexes[ee], p.a[ee].s.totalChars), this._hasMaskedPath ? X.length ? d.translate(0, Y.p.v[1] * X[0], -Y.p.v[2] * X[1]) : d.translate(0, Y.p.v[1] * X, -Y.p.v[2] * X) : X.length ? d.translate(Y.p.v[0] * X[0], Y.p.v[1] * X[1], -Y.p.v[2] * X[2]) : d.translate(Y.p.v[0] * X, Y.p.v[1] * X, -Y.p.v[2] * X)); if (o.strokeWidthAnim && (lt = ke < 0 ? 0 : ke), o.strokeColorAnim && (ht = "rgb(" + Math.round(Ve[0] * 255) + "," + Math.round(Ve[1] * 255) + "," + Math.round(Ve[2] * 255) + ")"), o.fillColorAnim && o.fc && (Bt = "rgb(" + Math.round(Je[0] * 255) + "," + Math.round(Je[1] * 255) + "," + Math.round(Je[2] * 255) + ")"), this._hasMaskedPath) { if (d.translate(0, -o.ls), d.translate(0, u[1] * U * .01 + F, 0), this._pathData.p.v) { $e = (ne.point[1] - ue.point[1]) / (ne.point[0] - ue.point[0]); var ze = Math.atan($e) * 180 / Math.PI; ne.point[0] < ue.point[0] && (ze += 180), d.rotate(-ze * Math.PI / 180) } d.translate(Ae, Ie, 0), re -= u[0] * Z[B].an * .005, Z[B + 1] && ce !== Z[B + 1].ind && (re += Z[B].an / 2, re += o.tr * .001 * o.finalSize) } else { switch (d.translate(I, F, 0), o.ps && d.translate(o.ps[0], o.ps[1] + o.ascent, 0), o.j) { case 1: d.translate(Z[B].animatorJustifyOffset + o.justifyOffset + (o.boxWidth - o.lineWidths[Z[B].line]), 0, 0); break; case 2: d.translate(Z[B].animatorJustifyOffset + o.justifyOffset + (o.boxWidth - o.lineWidths[Z[B].line]) / 2, 0, 0); break }d.translate(0, -o.ls), d.translate(me, 0, 0), d.translate(u[0] * Z[B].an * .005, u[1] * U * .01, 0), I += Z[B].l + o.tr * .001 * o.finalSize } m === "html" ? mt = d.toCSS() : m === "svg" ? mt = d.to2dCSS() : et = [d.props[0], d.props[1], d.props[2], d.props[3], d.props[4], d.props[5], d.props[6], d.props[7], d.props[8], d.props[9], d.props[10], d.props[11], d.props[12], d.props[13], d.props[14], d.props[15]], Gt = Ke } v <= B ? (y = new LetterProps(Gt, lt, ht, Bt, mt, et), this.renderedLetters.push(y), v += 1, this.lettersChangedFlag = !0) : (y = this.renderedLetters[B], this.lettersChangedFlag = y.update(Gt, lt, ht, Bt, mt, et) || this.lettersChangedFlag) } } }, TextAnimatorProperty.prototype.getValue = function () { this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties()) }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty); function ITextElement() { } ITextElement.prototype.initElement = function (o, l, u) { this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(o, l, u), this.textProperty = new TextProperty(this, o.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(o.t, this.renderType, this), this.initTransform(o, l, u), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties) }, ITextElement.prototype.prepareFrame = function (o) { this._mdf = !1, this.prepareRenderableFrame(o), this.prepareProperties(o, this.isInRange) }, ITextElement.prototype.createPathShape = function (o, l) { var u, f = l.length, p, d = ""; for (u = 0; u < f; u += 1)l[u].ty === "sh" && (p = l[u].ks.k, d += buildShapeString(p, p.i.length, !0, o)); return d }, ITextElement.prototype.updateDocumentData = function (o, l) { this.textProperty.updateDocumentData(o, l) }, ITextElement.prototype.canResizeFont = function (o) { this.textProperty.canResizeFont(o) }, ITextElement.prototype.setMinimumFontSize = function (o) { this.textProperty.setMinimumFontSize(o) }, ITextElement.prototype.applyTextPropertiesToMatrix = function (o, l, u, f, p) { switch (o.ps && l.translate(o.ps[0], o.ps[1] + o.ascent, 0), l.translate(0, -o.ls, 0), o.j) { case 1: l.translate(o.justifyOffset + (o.boxWidth - o.lineWidths[u]), 0, 0); break; case 2: l.translate(o.justifyOffset + (o.boxWidth - o.lineWidths[u]) / 2, 0, 0); break }l.translate(f, p, 0) }, ITextElement.prototype.buildColor = function (o) { return "rgb(" + Math.round(o[0] * 255) + "," + Math.round(o[1] * 255) + "," + Math.round(o[2] * 255) + ")" }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () { }, ITextElement.prototype.validateText = function () { (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1) }; var emptyShapeData = { shapes: [] }; function SVGTextLottieElement(o, l, u) { this.textSpans = [], this.renderType = "svg", this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () { this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text")) }, SVGTextLottieElement.prototype.buildTextContents = function (o) { for (var l = 0, u = o.length, f = [], p = ""; l < u;)o[l] === "\r" || o[l] === "" ? (f.push(p), p = "") : p += o[l], l += 1; return f.push(p), f }, SVGTextLottieElement.prototype.buildShapeData = function (o, l) { if (o.shapes && o.shapes.length) { var u = o.shapes[0]; if (u.it) { var f = u.it[u.it.length - 1]; f.s && (f.s.k[0] = l, f.s.k[1] = l) } } return o }, SVGTextLottieElement.prototype.buildNewText = function () { this.addDynamicProperty(this); var o, l, u = this.textProperty.currentData; this.renderedLetters = createSizedArray(u ? u.l.length : 0), u.fc ? this.layerElement.setAttribute("fill", this.buildColor(u.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), u.sc && (this.layerElement.setAttribute("stroke", this.buildColor(u.sc)), this.layerElement.setAttribute("stroke-width", u.sw)), this.layerElement.setAttribute("font-size", u.finalSize); var f = this.globalData.fontManager.getFontByName(u.f); if (f.fClass) this.layerElement.setAttribute("class", f.fClass); else { this.layerElement.setAttribute("font-family", f.fFamily); var p = u.fWeight, d = u.fStyle; this.layerElement.setAttribute("font-style", d), this.layerElement.setAttribute("font-weight", p) } this.layerElement.setAttribute("aria-label", u.t); var m = u.l || [], v = !!this.globalData.fontManager.chars; l = m.length; var I, F = this.mHelper, B = "", W = this.data.singleShape, Z = 0, Q = 0, re = !0, ne = u.tr * .001 * u.finalSize; if (W && !v && !u.sz) { var oe = this.textContainer, ae = "start"; switch (u.j) { case 1: ae = "end"; break; case 2: ae = "middle"; break; default: ae = "start"; break }oe.setAttribute("text-anchor", ae), oe.setAttribute("letter-spacing", ne); var se = this.buildTextContents(u.finalText); for (l = se.length, Q = u.ps ? u.ps[1] + u.ascent : 0, o = 0; o < l; o += 1)I = this.textSpans[o].span || createNS("tspan"), I.textContent = se[o], I.setAttribute("x", 0), I.setAttribute("y", Q), I.style.display = "inherit", oe.appendChild(I), this.textSpans[o] || (this.textSpans[o] = { span: null, glyph: null }), this.textSpans[o].span = I, Q += u.finalLineHeight; this.layerElement.appendChild(oe) } else { var le = this.textSpans.length, ue; for (o = 0; o < l; o += 1) { if (this.textSpans[o] || (this.textSpans[o] = { span: null, childSpan: null, glyph: null }), !v || !W || o === 0) { if (I = le > o ? this.textSpans[o].span : createNS(v ? "g" : "text"), le <= o) { if (I.setAttribute("stroke-linecap", "butt"), I.setAttribute("stroke-linejoin", "round"), I.setAttribute("stroke-miterlimit", "4"), this.textSpans[o].span = I, v) { var he = createNS("g"); I.appendChild(he), this.textSpans[o].childSpan = he } this.textSpans[o].span = I, this.layerElement.appendChild(I) } I.style.display = "inherit" } if (F.reset(), W && (m[o].n && (Z = -ne, Q += u.yOffset, Q += re ? 1 : 0, re = !1), this.applyTextPropertiesToMatrix(u, F, m[o].line, Z, Q), Z += m[o].l || 0, Z += ne), v) { ue = this.globalData.fontManager.getCharData(u.finalText[o], f.fStyle, this.globalData.fontManager.getFontByName(u.f).fFamily); var pe; if (ue.t === 1) pe = new SVGCompElement(ue.data, this.globalData, this); else { var ve = emptyShapeData; ue.data && ue.data.shapes && (ve = this.buildShapeData(ue.data, u.finalSize)), pe = new SVGShapeElement(ve, this.globalData, this) } if (this.textSpans[o].glyph) { var _e = this.textSpans[o].glyph; this.textSpans[o].childSpan.removeChild(_e.layerElement), _e.destroy() } this.textSpans[o].glyph = pe, pe._debug = !0, pe.prepareFrame(0), pe.renderFrame(), this.textSpans[o].childSpan.appendChild(pe.layerElement), ue.t === 1 && this.textSpans[o].childSpan.setAttribute("transform", "scale(" + u.finalSize / 100 + "," + u.finalSize / 100 + ")") } else W && I.setAttribute("transform", "translate(" + F.props[12] + "," + F.props[13] + ")"), I.textContent = m[o].val, I.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve") } W && I && I.setAttribute("d", B) } for (; o < this.textSpans.length;)this.textSpans[o].span.style.display = "none", o += 1; this._sizeChanged = !0 }, SVGTextLottieElement.prototype.sourceRectAtTime = function () { if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) { this._sizeChanged = !1; var o = this.layerElement.getBBox(); this.bbox = { top: o.y, left: o.x, width: o.width, height: o.height } } return this.bbox }, SVGTextLottieElement.prototype.getValue = function () { var o, l = this.textSpans.length, u; for (this.renderedFrame = this.comp.renderedFrame, o = 0; o < l; o += 1)u = this.textSpans[o].glyph, u && (u.prepareFrame(this.comp.renderedFrame - this.data.st), u._mdf && (this._mdf = !0)) }, SVGTextLottieElement.prototype.renderInnerContent = function () { if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) { this._sizeChanged = !0; var o, l, u = this.textAnimator.renderedLetters, f = this.textProperty.currentData.l; l = f.length; var p, d, m; for (o = 0; o < l; o += 1)f[o].n || (p = u[o], d = this.textSpans[o].span, m = this.textSpans[o].glyph, m && m.renderFrame(), p._mdf.m && d.setAttribute("transform", p.m), p._mdf.o && d.setAttribute("opacity", p.o), p._mdf.sw && d.setAttribute("stroke-width", p.sw), p._mdf.sc && d.setAttribute("stroke", p.sc), p._mdf.fc && d.setAttribute("fill", p.fc)) } }; function ISolidElement(o, l, u) { this.initElement(o, l, u) } extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () { var o = createNS("rect"); o.setAttribute("width", this.data.sw), o.setAttribute("height", this.data.sh), o.setAttribute("fill", this.data.sc), this.layerElement.appendChild(o) }; function NullElement(o, l, u) { this.initFrame(), this.initBaseData(o, l, u), this.initFrame(), this.initTransform(o, l, u), this.initHierarchy() } NullElement.prototype.prepareFrame = function (o) { this.prepareProperties(o, !0) }, NullElement.prototype.renderFrame = function () { }, NullElement.prototype.getBaseElement = function () { return null }, NullElement.prototype.destroy = function () { }, NullElement.prototype.sourceRectAtTime = function () { }, NullElement.prototype.hide = function () { }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement); function SVGRendererBase() { } extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function (o) { return new NullElement(o, this.globalData, this) }, SVGRendererBase.prototype.createShape = function (o) { return new SVGShapeElement(o, this.globalData, this) }, SVGRendererBase.prototype.createText = function (o) { return new SVGTextLottieElement(o, this.globalData, this) }, SVGRendererBase.prototype.createImage = function (o) { return new IImageElement(o, this.globalData, this) }, SVGRendererBase.prototype.createSolid = function (o) { return new ISolidElement(o, this.globalData, this) }, SVGRendererBase.prototype.configAnimation = function (o) { this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + o.w + " " + o.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", o.w), this.svgElement.setAttribute("height", o.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement); var l = this.globalData.defs; this.setupGlobalData(o, l), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = o; var u = createNS("clipPath"), f = createNS("rect"); f.setAttribute("width", o.w), f.setAttribute("height", o.h), f.setAttribute("x", 0), f.setAttribute("y", 0); var p = createElementID(); u.setAttribute("id", p), u.appendChild(f), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + p + ")"), l.appendChild(u), this.layers = o.layers, this.elements = createSizedArray(o.layers.length) }, SVGRendererBase.prototype.destroy = function () { this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null; var o, l = this.layers ? this.layers.length : 0; for (o = 0; o < l; o += 1)this.elements[o] && this.elements[o].destroy && this.elements[o].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, SVGRendererBase.prototype.updateContainerSize = function () { }, SVGRendererBase.prototype.findIndexByInd = function (o) { var l = 0, u = this.layers.length; for (l = 0; l < u; l += 1)if (this.layers[l].ind === o) return l; return -1 }, SVGRendererBase.prototype.buildItem = function (o) { var l = this.elements; if (!(l[o] || this.layers[o].ty === 99)) { l[o] = !0; var u = this.createItem(this.layers[o]); if (l[o] = u, getExpressionsPlugin() && (this.layers[o].ty === 0 && this.globalData.projectInterface.registerComposition(u), u.initExpressions()), this.appendElementInPos(u, o), this.layers[o].tt) { var f = "tp" in this.layers[o] ? this.findIndexByInd(this.layers[o].tp) : o - 1; if (f === -1) return; if (!this.elements[f] || this.elements[f] === !0) this.buildItem(f), this.addPendingElement(u); else { var p = l[f], d = p.getMatte(this.layers[o].tt); u.setMatte(d) } } } }, SVGRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var o = this.pendingElements.pop(); if (o.checkParenting(), o.data.tt) for (var l = 0, u = this.elements.length; l < u;) { if (this.elements[l] === o) { var f = "tp" in o.data ? this.findIndexByInd(o.data.tp) : l - 1, p = this.elements[f], d = p.getMatte(this.layers[l].tt); o.setMatte(d); break } l += 1 } } }, SVGRendererBase.prototype.renderFrame = function (o) { if (!(this.renderedFrame === o || this.destroyed)) { o === null ? o = this.renderedFrame : this.renderedFrame = o, this.globalData.frameNum = o, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = o, this.globalData._mdf = !1; var l, u = this.layers.length; for (this.completeLayers || this.checkLayers(o), l = u - 1; l >= 0; l -= 1)(this.completeLayers || this.elements[l]) && this.elements[l].prepareFrame(o - this.layers[l].st); if (this.globalData._mdf) for (l = 0; l < u; l += 1)(this.completeLayers || this.elements[l]) && this.elements[l].renderFrame() } }, SVGRendererBase.prototype.appendElementInPos = function (o, l) { var u = o.getBaseElement(); if (u) { for (var f = 0, p; f < l;)this.elements[f] && this.elements[f] !== !0 && this.elements[f].getBaseElement() && (p = this.elements[f].getBaseElement()), f += 1; p ? this.layerElement.insertBefore(u, p) : this.layerElement.appendChild(u) } }, SVGRendererBase.prototype.hide = function () { this.layerElement.style.display = "none" }, SVGRendererBase.prototype.show = function () { this.layerElement.style.display = "block" }; function ICompElement() { } extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (o, l, u) { this.initFrame(), this.initBaseData(o, l, u), this.initTransform(o, l, u), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !l.progressiveLoad) && this.buildAllItems(), this.hide() }, ICompElement.prototype.prepareFrame = function (o) { if (this._mdf = !1, this.prepareRenderableFrame(o), this.prepareProperties(o, this.isInRange), !(!this.isInRange && !this.data.xt)) { if (this.tm._placeholder) this.renderedFrame = o / this.data.sr; else { var l = this.tm.v; l === this.data.op && (l = this.data.op - 1), this.renderedFrame = l } var u, f = this.elements.length; for (this.completeLayers || this.checkLayers(this.renderedFrame), u = f - 1; u >= 0; u -= 1)(this.completeLayers || this.elements[u]) && (this.elements[u].prepareFrame(this.renderedFrame - this.layers[u].st), this.elements[u]._mdf && (this._mdf = !0)) } }, ICompElement.prototype.renderInnerContent = function () { var o, l = this.layers.length; for (o = 0; o < l; o += 1)(this.completeLayers || this.elements[o]) && this.elements[o].renderFrame() }, ICompElement.prototype.setElements = function (o) { this.elements = o }, ICompElement.prototype.getElements = function () { return this.elements }, ICompElement.prototype.destroyElements = function () { var o, l = this.layers.length; for (o = 0; o < l; o += 1)this.elements[o] && this.elements[o].destroy() }, ICompElement.prototype.destroy = function () { this.destroyElements(), this.destroyBaseElement() }; function SVGCompElement(o, l, u) { this.layers = o.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(o, l, u), this.tm = o.tm ? PropertyFactory.getProp(this, o.tm, 0, l.frameRate, this) : { _placeholder: !0 } } extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function (o) { return new SVGCompElement(o, this.globalData, this) }; function SVGRenderer(o, l) { this.animationItem = o, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg"); var u = ""; if (l && l.title) { var f = createNS("title"), p = createElementID(); f.setAttribute("id", p), f.textContent = l.title, this.svgElement.appendChild(f), u += p } if (l && l.description) { var d = createNS("desc"), m = createElementID(); d.setAttribute("id", m), d.textContent = l.description, this.svgElement.appendChild(d), u += " " + m } u && this.svgElement.setAttribute("aria-labelledby", u); var v = createNS("defs"); this.svgElement.appendChild(v); var I = createNS("g"); this.svgElement.appendChild(I), this.layerElement = I, this.renderConfig = { preserveAspectRatio: l && l.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: l && l.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: l && l.contentVisibility || "visible", progressiveLoad: l && l.progressiveLoad || !1, hideOnTransparent: !(l && l.hideOnTransparent === !1), viewBoxOnly: l && l.viewBoxOnly || !1, viewBoxSize: l && l.viewBoxSize || !1, className: l && l.className || "", id: l && l.id || "", focusable: l && l.focusable, filterSize: { width: l && l.filterSize && l.filterSize.width || "100%", height: l && l.filterSize && l.filterSize.height || "100%", x: l && l.filterSize && l.filterSize.x || "0%", y: l && l.filterSize && l.filterSize.y || "0%" }, width: l && l.width, height: l && l.height, runExpressions: !l || l.runExpressions === void 0 || l.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, defs: v, renderConfig: this.renderConfig }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg" } extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function (o) { return new SVGCompElement(o, this.globalData, this) }; function ShapeTransformManager() { this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0 } ShapeTransformManager.prototype = { addTransformSequence: function (l) { var u, f = l.length, p = "_"; for (u = 0; u < f; u += 1)p += l[u].transform.key + "_"; var d = this.sequences[p]; return d || (d = { transforms: [].concat(l), finalTransform: new Matrix, _mdf: !1 }, this.sequences[p] = d, this.sequenceList.push(d)), d }, processSequence: function (l, u) { for (var f = 0, p = l.transforms.length, d = u; f < p && !u;) { if (l.transforms[f].transform.mProps._mdf) { d = !0; break } f += 1 } if (d) for (l.finalTransform.reset(), f = p - 1; f >= 0; f -= 1)l.finalTransform.multiply(l.transforms[f].transform.mProps.v); l._mdf = d }, processSequences: function (l) { var u, f = this.sequenceList.length; for (u = 0; u < f; u += 1)this.processSequence(this.sequenceList[u], l) }, getNewKey: function () { return this.transform_key_count += 1, "_" + this.transform_key_count } }; var lumaLoader = function () { var l = "__lottie_element_luma_buffer", u = null, f = null, p = null; function d() { var I = createNS("svg"), F = createNS("filter"), B = createNS("feColorMatrix"); return F.setAttribute("id", l), B.setAttribute("type", "matrix"), B.setAttribute("color-interpolation-filters", "sRGB"), B.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), F.appendChild(B), I.appendChild(F), I.setAttribute("id", l + "_svg"), featureSupport.svgLumaHidden && (I.style.display = "none"), I } function m() { u || (p = d(), document.body.appendChild(p), u = createTag("canvas"), f = u.getContext("2d"), f.filter = "url(#" + l + ")", f.fillStyle = "rgba(0,0,0,0)", f.fillRect(0, 0, 1, 1)) } function v(I) { return u || m(), u.width = I.width, u.height = I.height, f.filter = "url(#" + l + ")", u } return { load: m, get: v } }; function createCanvas(o, l) { if (featureSupport.offscreenCanvas) return new OffscreenCanvas(o, l); var u = createTag("canvas"); return u.width = o, u.height = l, u } var assetLoader = function () { return { loadLumaCanvas: lumaLoader.load, getLumaCanvas: lumaLoader.get, createCanvas } }(), registeredEffects = {}; function CVEffects(o) { var l, u = o.data.ef ? o.data.ef.length : 0; this.filters = []; var f; for (l = 0; l < u; l += 1) { f = null; var p = o.data.ef[l].ty; if (registeredEffects[p]) { var d = registeredEffects[p].effect; f = new d(o.effectsManager.effectElements[l], o) } f && this.filters.push(f) } this.filters.length && o.addRenderableComponent(this) } CVEffects.prototype.renderFrame = function (o) { var l, u = this.filters.length; for (l = 0; l < u; l += 1)this.filters[l].renderFrame(o) }, CVEffects.prototype.getEffects = function (o) { var l, u = this.filters.length, f = []; for (l = 0; l < u; l += 1)this.filters[l].type === o && f.push(this.filters[l]); return f }; function registerEffect(o, l) { registeredEffects[o] = { effect: l } } function CVMaskElement(o, l) { this.data = o, this.element = l, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length); var u, f = this.masksProperties.length, p = !1; for (u = 0; u < f; u += 1)this.masksProperties[u].mode !== "n" && (p = !0), this.viewData[u] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[u], 3); this.hasMasks = p, p && this.element.addRenderableComponent(this) } CVMaskElement.prototype.renderFrame = function () { if (this.hasMasks) { var o = this.element.finalTransform.mat, l = this.element.canvasContext, u, f = this.masksProperties.length, p, d, m; for (l.beginPath(), u = 0; u < f; u += 1)if (this.masksProperties[u].mode !== "n") { this.masksProperties[u].inv && (l.moveTo(0, 0), l.lineTo(this.element.globalData.compSize.w, 0), l.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), l.lineTo(0, this.element.globalData.compSize.h), l.lineTo(0, 0)), m = this.viewData[u].v, p = o.applyToPointArray(m.v[0][0], m.v[0][1], 0), l.moveTo(p[0], p[1]); var v, I = m._length; for (v = 1; v < I; v += 1)d = o.applyToTriplePoints(m.o[v - 1], m.i[v], m.v[v]), l.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5]); d = o.applyToTriplePoints(m.o[v - 1], m.i[0], m.v[0]), l.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5]) } this.element.globalData.renderer.save(!0), l.clip() } }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () { this.element = null }; function CVBaseElement() { } var operationsMap = { 1: "source-in", 2: "source-out", 3: "source-in", 4: "source-out" }; CVBaseElement.prototype = { createElements: function () { }, initRendererElement: function () { }, createContainerElements: function () { if (this.data.tt >= 1) { this.buffers = []; var l = this.globalData.canvasContext, u = assetLoader.createCanvas(l.canvas.width, l.canvas.height); this.buffers.push(u); var f = assetLoader.createCanvas(l.canvas.width, l.canvas.height); this.buffers.push(f), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas() } this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms() }, createContent: function () { }, setBlendMode: function () { var l = this.globalData; if (l.blendMode !== this.data.bm) { l.blendMode = this.data.bm; var u = getBlendMode(this.data.bm); l.canvasContext.globalCompositeOperation = u } }, createRenderableComponents: function () { this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT) }, hideElement: function () { !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0) }, showElement: function () { this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0) }, clearCanvas: function (l) { l.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy) }, prepareLayer: function () { if (this.data.tt >= 1) { var l = this.buffers[0], u = l.getContext("2d"); this.clearCanvas(u), u.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform) } }, exitLayer: function () { if (this.data.tt >= 1) { var l = this.buffers[1], u = l.getContext("2d"); this.clearCanvas(u), u.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform); var f = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1); if (f.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) { var p = assetLoader.getLumaCanvas(this.canvasContext.canvas), d = p.getContext("2d"); d.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(p, 0, 0) } this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(l, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over" } }, renderFrame: function (l) { if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !l)) { this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode(); var u = this.data.ty === 0; this.prepareLayer(), this.globalData.renderer.save(u), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(u), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1) } }, destroy: function () { this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy() }, mHelper: new Matrix }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement; function CVShapeData(o, l, u, f) { this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0]; var p = 4; l.ty === "rc" ? p = 5 : l.ty === "el" ? p = 6 : l.ty === "sr" && (p = 7), this.sh = ShapePropertyFactory.getShapeProp(o, l, p, o); var d, m = u.length, v; for (d = 0; d < m; d += 1)u[d].closed || (v = { transforms: f.addTransformSequence(u[d].transforms), trNodes: [] }, this.styledShapes.push(v), u[d].elements.push(v)) } CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated; function CVShapeElement(o, l, u) { this.shapes = [], this.shapesData = o.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []) }, CVShapeElement.prototype.createStyleElement = function (o, l) { var u = { data: o, type: o.ty, preTransforms: this.transformsManager.addTransformSequence(l), transforms: [], elements: [], closed: o.hd === !0 }, f = {}; if (o.ty === "fl" || o.ty === "st" ? (f.c = PropertyFactory.getProp(this, o.c, 1, 255, this), f.c.k || (u.co = "rgb(" + bmFloor(f.c.v[0]) + "," + bmFloor(f.c.v[1]) + "," + bmFloor(f.c.v[2]) + ")")) : (o.ty === "gf" || o.ty === "gs") && (f.s = PropertyFactory.getProp(this, o.s, 1, null, this), f.e = PropertyFactory.getProp(this, o.e, 1, null, this), f.h = PropertyFactory.getProp(this, o.h || { k: 0 }, 0, .01, this), f.a = PropertyFactory.getProp(this, o.a || { k: 0 }, 0, degToRads, this), f.g = new GradientProperty(this, o.g, this)), f.o = PropertyFactory.getProp(this, o.o, 0, .01, this), o.ty === "st" || o.ty === "gs") { if (u.lc = lineCapEnum[o.lc || 2], u.lj = lineJoinEnum[o.lj || 2], o.lj == 1 && (u.ml = o.ml), f.w = PropertyFactory.getProp(this, o.w, 0, null, this), f.w.k || (u.wi = f.w.v), o.d) { var p = new DashProperty(this, o.d, "canvas", this); f.d = p, f.d.k || (u.da = f.d.dashArray, u.do = f.d.dashoffset[0]) } } else u.r = o.r === 2 ? "evenodd" : "nonzero"; return this.stylesList.push(u), f.style = u, f }, CVShapeElement.prototype.createGroupElement = function () { var o = { it: [], prevViewData: [] }; return o }, CVShapeElement.prototype.createTransformElement = function (o) { var l = { transform: { opacity: 1, _opMdf: !1, key: this.transformsManager.getNewKey(), op: PropertyFactory.getProp(this, o.o, 0, .01, this), mProps: TransformPropertyFactory.getTransformProperty(this, o, this) } }; return l }, CVShapeElement.prototype.createShapeElement = function (o) { var l = new CVShapeData(this, o, this.stylesList, this.transformsManager); return this.shapes.push(l), this.addShapeToModifiers(l), l }, CVShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; var o, l = this.itemsData.length; for (o = 0; o < l; o += 1)this.prevViewData[o] = this.itemsData[o]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), l = this.dynamicProperties.length, o = 0; o < l; o += 1)this.dynamicProperties[o].getValue(); this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame) }, CVShapeElement.prototype.addTransformToStyleList = function (o) { var l, u = this.stylesList.length; for (l = 0; l < u; l += 1)this.stylesList[l].closed || this.stylesList[l].transforms.push(o) }, CVShapeElement.prototype.removeTransformFromStyleList = function () { var o, l = this.stylesList.length; for (o = 0; o < l; o += 1)this.stylesList[o].closed || this.stylesList[o].transforms.pop() }, CVShapeElement.prototype.closeStyles = function (o) { var l, u = o.length; for (l = 0; l < u; l += 1)o[l].closed = !0 }, CVShapeElement.prototype.searchShapes = function (o, l, u, f, p) { var d, m = o.length - 1, v, I, F = [], B = [], W, Z, Q, re = [].concat(p); for (d = m; d >= 0; d -= 1) { if (W = this.searchProcessedElement(o[d]), W ? l[d] = u[W - 1] : o[d]._shouldRender = f, o[d].ty === "fl" || o[d].ty === "st" || o[d].ty === "gf" || o[d].ty === "gs") W ? l[d].style.closed = !1 : l[d] = this.createStyleElement(o[d], re), F.push(l[d].style); else if (o[d].ty === "gr") { if (!W) l[d] = this.createGroupElement(o[d]); else for (I = l[d].it.length, v = 0; v < I; v += 1)l[d].prevViewData[v] = l[d].it[v]; this.searchShapes(o[d].it, l[d].it, l[d].prevViewData, f, re) } else o[d].ty === "tr" ? (W || (Q = this.createTransformElement(o[d]), l[d] = Q), re.push(l[d]), this.addTransformToStyleList(l[d])) : o[d].ty === "sh" || o[d].ty === "rc" || o[d].ty === "el" || o[d].ty === "sr" ? W || (l[d] = this.createShapeElement(o[d])) : o[d].ty === "tm" || o[d].ty === "rd" || o[d].ty === "pb" || o[d].ty === "zz" || o[d].ty === "op" ? (W ? (Z = l[d], Z.closed = !1) : (Z = ShapeModifiers.getModifier(o[d].ty), Z.init(this, o[d]), l[d] = Z, this.shapeModifiers.push(Z)), B.push(Z)) : o[d].ty === "rp" && (W ? (Z = l[d], Z.closed = !0) : (Z = ShapeModifiers.getModifier(o[d].ty), l[d] = Z, Z.init(this, o, d, l), this.shapeModifiers.push(Z), f = !1), B.push(Z)); this.addProcessedElement(o[d], d + 1) } for (this.removeTransformFromStyleList(), this.closeStyles(F), m = B.length, d = 0; d < m; d += 1)B[d].closed = !0 }, CVShapeElement.prototype.renderInnerContent = function () { this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0) }, CVShapeElement.prototype.renderShapeTransform = function (o, l) { (o._opMdf || l.op._mdf || this._isFirstFrame) && (l.opacity = o.opacity, l.opacity *= l.op.v, l._opMdf = !0) }, CVShapeElement.prototype.drawLayer = function () { var o, l = this.stylesList.length, u, f, p, d, m, v, I = this.globalData.renderer, F = this.globalData.canvasContext, B, W; for (o = 0; o < l; o += 1)if (W = this.stylesList[o], B = W.type, !((B === "st" || B === "gs") && W.wi === 0 || !W.data._shouldRender || W.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) { for (I.save(), m = W.elements, B === "st" || B === "gs" ? (I.ctxStrokeStyle(B === "st" ? W.co : W.grd), I.ctxLineWidth(W.wi), I.ctxLineCap(W.lc), I.ctxLineJoin(W.lj), I.ctxMiterLimit(W.ml || 0)) : I.ctxFillStyle(B === "fl" ? W.co : W.grd), I.ctxOpacity(W.coOp), B !== "st" && B !== "gs" && F.beginPath(), I.ctxTransform(W.preTransforms.finalTransform.props), f = m.length, u = 0; u < f; u += 1) { for ((B === "st" || B === "gs") && (F.beginPath(), W.da && (F.setLineDash(W.da), F.lineDashOffset = W.do)), v = m[u].trNodes, d = v.length, p = 0; p < d; p += 1)v[p].t === "m" ? F.moveTo(v[p].p[0], v[p].p[1]) : v[p].t === "c" ? F.bezierCurveTo(v[p].pts[0], v[p].pts[1], v[p].pts[2], v[p].pts[3], v[p].pts[4], v[p].pts[5]) : F.closePath(); (B === "st" || B === "gs") && (I.ctxStroke(), W.da && F.setLineDash(this.dashResetter)) } B !== "st" && B !== "gs" && this.globalData.renderer.ctxFill(W.r), I.restore() } }, CVShapeElement.prototype.renderShape = function (o, l, u, f) { var p, d = l.length - 1, m; for (m = o, p = d; p >= 0; p -= 1)l[p].ty === "tr" ? (m = u[p].transform, this.renderShapeTransform(o, m)) : l[p].ty === "sh" || l[p].ty === "el" || l[p].ty === "rc" || l[p].ty === "sr" ? this.renderPath(l[p], u[p]) : l[p].ty === "fl" ? this.renderFill(l[p], u[p], m) : l[p].ty === "st" ? this.renderStroke(l[p], u[p], m) : l[p].ty === "gf" || l[p].ty === "gs" ? this.renderGradientFill(l[p], u[p], m) : l[p].ty === "gr" ? this.renderShape(m, l[p].it, u[p].it) : l[p].ty; f && this.drawLayer() }, CVShapeElement.prototype.renderStyledShape = function (o, l) { if (this._isFirstFrame || l._mdf || o.transforms._mdf) { var u = o.trNodes, f = l.paths, p, d, m, v = f._length; u.length = 0; var I = o.transforms.finalTransform; for (m = 0; m < v; m += 1) { var F = f.shapes[m]; if (F && F.v) { for (d = F._length, p = 1; p < d; p += 1)p === 1 && u.push({ t: "m", p: I.applyToPointArray(F.v[0][0], F.v[0][1], 0) }), u.push({ t: "c", pts: I.applyToTriplePoints(F.o[p - 1], F.i[p], F.v[p]) }); d === 1 && u.push({ t: "m", p: I.applyToPointArray(F.v[0][0], F.v[0][1], 0) }), F.c && d && (u.push({ t: "c", pts: I.applyToTriplePoints(F.o[p - 1], F.i[0], F.v[0]) }), u.push({ t: "z" })) } } o.trNodes = u } }, CVShapeElement.prototype.renderPath = function (o, l) { if (o.hd !== !0 && o._shouldRender) { var u, f = l.styledShapes.length; for (u = 0; u < f; u += 1)this.renderStyledShape(l.styledShapes[u], l.sh) } }, CVShapeElement.prototype.renderFill = function (o, l, u) { var f = l.style; (l.c._mdf || this._isFirstFrame) && (f.co = "rgb(" + bmFloor(l.c.v[0]) + "," + bmFloor(l.c.v[1]) + "," + bmFloor(l.c.v[2]) + ")"), (l.o._mdf || u._opMdf || this._isFirstFrame) && (f.coOp = l.o.v * u.opacity) }, CVShapeElement.prototype.renderGradientFill = function (o, l, u) { var f = l.style, p; if (!f.grd || l.g._mdf || l.s._mdf || l.e._mdf || o.t !== 1 && (l.h._mdf || l.a._mdf)) { var d = this.globalData.canvasContext, m = l.s.v, v = l.e.v; if (o.t === 1) p = d.createLinearGradient(m[0], m[1], v[0], v[1]); else { var I = Math.sqrt(Math.pow(m[0] - v[0], 2) + Math.pow(m[1] - v[1], 2)), F = Math.atan2(v[1] - m[1], v[0] - m[0]), B = l.h.v; B >= 1 ? B = .99 : B <= -1 && (B = -.99); var W = I * B, Z = Math.cos(F + l.a.v) * W + m[0], Q = Math.sin(F + l.a.v) * W + m[1]; p = d.createRadialGradient(Z, Q, 0, m[0], m[1], I) } var re, ne = o.g.p, oe = l.g.c, ae = 1; for (re = 0; re < ne; re += 1)l.g._hasOpacity && l.g._collapsable && (ae = l.g.o[re * 2 + 1]), p.addColorStop(oe[re * 4] / 100, "rgba(" + oe[re * 4 + 1] + "," + oe[re * 4 + 2] + "," + oe[re * 4 + 3] + "," + ae + ")"); f.grd = p } f.coOp = l.o.v * u.opacity }, CVShapeElement.prototype.renderStroke = function (o, l, u) { var f = l.style, p = l.d; p && (p._mdf || this._isFirstFrame) && (f.da = p.dashArray, f.do = p.dashoffset[0]), (l.c._mdf || this._isFirstFrame) && (f.co = "rgb(" + bmFloor(l.c.v[0]) + "," + bmFloor(l.c.v[1]) + "," + bmFloor(l.c.v[2]) + ")"), (l.o._mdf || u._opMdf || this._isFirstFrame) && (f.coOp = l.o.v * u.opacity), (l.w._mdf || this._isFirstFrame) && (f.wi = l.w.v) }, CVShapeElement.prototype.destroy = function () { this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0 }; function CVTextElement(o, l, u) { this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = { fill: "rgba(0,0,0,0)", stroke: "rgba(0,0,0,0)", sWidth: 0, fValue: "" }, this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () { var o = this.textProperty.currentData; this.renderedLetters = createSizedArray(o.l ? o.l.length : 0); var l = !1; o.fc ? (l = !0, this.values.fill = this.buildColor(o.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = l; var u = !1; o.sc && (u = !0, this.values.stroke = this.buildColor(o.sc), this.values.sWidth = o.sw); var f = this.globalData.fontManager.getFontByName(o.f), p, d, m = o.l, v = this.mHelper; this.stroke = u, this.values.fValue = o.finalSize + "px " + this.globalData.fontManager.getFontByName(o.f).fFamily, d = o.finalText.length; var I, F, B, W, Z, Q, re, ne, oe, ae, se = this.data.singleShape, le = o.tr * .001 * o.finalSize, ue = 0, he = 0, pe = !0, ve = 0; for (p = 0; p < d; p += 1) { I = this.globalData.fontManager.getCharData(o.finalText[p], f.fStyle, this.globalData.fontManager.getFontByName(o.f).fFamily), F = I && I.data || {}, v.reset(), se && m[p].n && (ue = -le, he += o.yOffset, he += pe ? 1 : 0, pe = !1), Z = F.shapes ? F.shapes[0].it : [], re = Z.length, v.scale(o.finalSize / 100, o.finalSize / 100), se && this.applyTextPropertiesToMatrix(o, v, m[p].line, ue, he), oe = createSizedArray(re - 1); var _e = 0; for (Q = 0; Q < re; Q += 1)if (Z[Q].ty === "sh") { for (W = Z[Q].ks.k.i.length, ne = Z[Q].ks.k, ae = [], B = 1; B < W; B += 1)B === 1 && ae.push(v.applyToX(ne.v[0][0], ne.v[0][1], 0), v.applyToY(ne.v[0][0], ne.v[0][1], 0)), ae.push(v.applyToX(ne.o[B - 1][0], ne.o[B - 1][1], 0), v.applyToY(ne.o[B - 1][0], ne.o[B - 1][1], 0), v.applyToX(ne.i[B][0], ne.i[B][1], 0), v.applyToY(ne.i[B][0], ne.i[B][1], 0), v.applyToX(ne.v[B][0], ne.v[B][1], 0), v.applyToY(ne.v[B][0], ne.v[B][1], 0)); ae.push(v.applyToX(ne.o[B - 1][0], ne.o[B - 1][1], 0), v.applyToY(ne.o[B - 1][0], ne.o[B - 1][1], 0), v.applyToX(ne.i[0][0], ne.i[0][1], 0), v.applyToY(ne.i[0][0], ne.i[0][1], 0), v.applyToX(ne.v[0][0], ne.v[0][1], 0), v.applyToY(ne.v[0][0], ne.v[0][1], 0)), oe[_e] = ae, _e += 1 } se && (ue += m[p].l, ue += le), this.textSpans[ve] ? this.textSpans[ve].elem = oe : this.textSpans[ve] = { elem: oe }, ve += 1 } }, CVTextElement.prototype.renderInnerContent = function () { this.validateText(); var o = this.canvasContext; o.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag); var l, u, f, p, d, m, v = this.textAnimator.renderedLetters, I = this.textProperty.currentData.l; u = I.length; var F, B = null, W = null, Z = null, Q, re, ne = this.globalData.renderer; for (l = 0; l < u; l += 1)if (!I[l].n) { if (F = v[l], F && (ne.save(), ne.ctxTransform(F.p), ne.ctxOpacity(F.o)), this.fill) { for (F && F.fc ? B !== F.fc && (ne.ctxFillStyle(F.fc), B = F.fc) : B !== this.values.fill && (B = this.values.fill, ne.ctxFillStyle(this.values.fill)), Q = this.textSpans[l].elem, p = Q.length, this.globalData.canvasContext.beginPath(), f = 0; f < p; f += 1)for (re = Q[f], m = re.length, this.globalData.canvasContext.moveTo(re[0], re[1]), d = 2; d < m; d += 6)this.globalData.canvasContext.bezierCurveTo(re[d], re[d + 1], re[d + 2], re[d + 3], re[d + 4], re[d + 5]); this.globalData.canvasContext.closePath(), ne.ctxFill() } if (this.stroke) { for (F && F.sw ? Z !== F.sw && (Z = F.sw, ne.ctxLineWidth(F.sw)) : Z !== this.values.sWidth && (Z = this.values.sWidth, ne.ctxLineWidth(this.values.sWidth)), F && F.sc ? W !== F.sc && (W = F.sc, ne.ctxStrokeStyle(F.sc)) : W !== this.values.stroke && (W = this.values.stroke, ne.ctxStrokeStyle(this.values.stroke)), Q = this.textSpans[l].elem, p = Q.length, this.globalData.canvasContext.beginPath(), f = 0; f < p; f += 1)for (re = Q[f], m = re.length, this.globalData.canvasContext.moveTo(re[0], re[1]), d = 2; d < m; d += 6)this.globalData.canvasContext.bezierCurveTo(re[d], re[d + 1], re[d + 2], re[d + 3], re[d + 4], re[d + 5]); this.globalData.canvasContext.closePath(), ne.ctxStroke() } F && this.globalData.renderer.restore() } }; function CVImageElement(o, l, u) { this.assetData = l.getAssetData(o.refId), this.img = l.imageLoader.getAsset(this.assetData), this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () { if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) { var o = createTag("canvas"); o.width = this.assetData.w, o.height = this.assetData.h; var l = o.getContext("2d"), u = this.img.width, f = this.img.height, p = u / f, d = this.assetData.w / this.assetData.h, m, v, I = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio; p > d && I === "xMidYMid slice" || p < d && I !== "xMidYMid slice" ? (v = f, m = v * d) : (m = u, v = m / d), l.drawImage(this.img, (u - m) / 2, (f - v) / 2, m, v, 0, 0, this.assetData.w, this.assetData.h), this.img = o } }, CVImageElement.prototype.renderInnerContent = function () { this.canvasContext.drawImage(this.img, 0, 0) }, CVImageElement.prototype.destroy = function () { this.img = null }; function CVSolidElement(o, l, u) { this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () { this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh) }; function CanvasRendererBase() { } extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function (o) { return new CVShapeElement(o, this.globalData, this) }, CanvasRendererBase.prototype.createText = function (o) { return new CVTextElement(o, this.globalData, this) }, CanvasRendererBase.prototype.createImage = function (o) { return new CVImageElement(o, this.globalData, this) }, CanvasRendererBase.prototype.createSolid = function (o) { return new CVSolidElement(o, this.globalData, this) }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function (o) { o[0] === 1 && o[1] === 0 && o[4] === 0 && o[5] === 1 && o[12] === 0 && o[13] === 0 || this.canvasContext.transform(o[0], o[1], o[4], o[5], o[12], o[13]) }, CanvasRendererBase.prototype.ctxOpacity = function (o) { this.canvasContext.globalAlpha *= o < 0 ? 0 : o }, CanvasRendererBase.prototype.ctxFillStyle = function (o) { this.canvasContext.fillStyle = o }, CanvasRendererBase.prototype.ctxStrokeStyle = function (o) { this.canvasContext.strokeStyle = o }, CanvasRendererBase.prototype.ctxLineWidth = function (o) { this.canvasContext.lineWidth = o }, CanvasRendererBase.prototype.ctxLineCap = function (o) { this.canvasContext.lineCap = o }, CanvasRendererBase.prototype.ctxLineJoin = function (o) { this.canvasContext.lineJoin = o }, CanvasRendererBase.prototype.ctxMiterLimit = function (o) { this.canvasContext.miterLimit = o }, CanvasRendererBase.prototype.ctxFill = function (o) { this.canvasContext.fill(o) }, CanvasRendererBase.prototype.ctxFillRect = function (o, l, u, f) { this.canvasContext.fillRect(o, l, u, f) }, CanvasRendererBase.prototype.ctxStroke = function () { this.canvasContext.stroke() }, CanvasRendererBase.prototype.reset = function () { if (!this.renderConfig.clearCanvas) { this.canvasContext.restore(); return } this.contextData.reset() }, CanvasRendererBase.prototype.save = function () { this.canvasContext.save() }, CanvasRendererBase.prototype.restore = function (o) { if (!this.renderConfig.clearCanvas) { this.canvasContext.restore(); return } o && (this.globalData.blendMode = "source-over"), this.contextData.restore(o) }, CanvasRendererBase.prototype.configAnimation = function (o) { if (this.animationItem.wrapper) { this.animationItem.container = createTag("canvas"); var l = this.animationItem.container.style; l.width = "100%", l.height = "100%"; var u = "0px 0px 0px"; l.transformOrigin = u, l.mozTransformOrigin = u, l.webkitTransformOrigin = u, l["-webkit-transform"] = u, l.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id) } else this.canvasContext = this.renderConfig.context; this.contextData.setContext(this.canvasContext), this.data = o, this.layers = o.layers, this.transformCanvas = { w: o.w, h: o.h, sx: 0, sy: 0, tx: 0, ty: 0 }, this.setupGlobalData(o, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(o.layers.length), this.updateContainerSize() }, CanvasRendererBase.prototype.updateContainerSize = function (o, l) { this.reset(); var u, f; o ? (u = o, f = l, this.canvasContext.canvas.width = u, this.canvasContext.canvas.height = f) : (this.animationItem.wrapper && this.animationItem.container ? (u = this.animationItem.wrapper.offsetWidth, f = this.animationItem.wrapper.offsetHeight) : (u = this.canvasContext.canvas.width, f = this.canvasContext.canvas.height), this.canvasContext.canvas.width = u * this.renderConfig.dpr, this.canvasContext.canvas.height = f * this.renderConfig.dpr); var p, d; if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) { var m = this.renderConfig.preserveAspectRatio.split(" "), v = m[1] || "meet", I = m[0] || "xMidYMid", F = I.substr(0, 4), B = I.substr(4); p = u / f, d = this.transformCanvas.w / this.transformCanvas.h, d > p && v === "meet" || d < p && v === "slice" ? (this.transformCanvas.sx = u / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = u / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = f / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = f / (this.transformCanvas.h / this.renderConfig.dpr)), F === "xMid" && (d < p && v === "meet" || d > p && v === "slice") ? this.transformCanvas.tx = (u - this.transformCanvas.w * (f / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : F === "xMax" && (d < p && v === "meet" || d > p && v === "slice") ? this.transformCanvas.tx = (u - this.transformCanvas.w * (f / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, B === "YMid" && (d > p && v === "meet" || d < p && v === "slice") ? this.transformCanvas.ty = (f - this.transformCanvas.h * (u / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : B === "YMax" && (d > p && v === "meet" || d < p && v === "slice") ? this.transformCanvas.ty = (f - this.transformCanvas.h * (u / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0 } else this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = u / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = f / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0); this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0) }, CanvasRendererBase.prototype.destroy = function () { this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""); var o, l = this.layers ? this.layers.length : 0; for (o = l - 1; o >= 0; o -= 1)this.elements[o] && this.elements[o].destroy && this.elements[o].destroy(); this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0 }, CanvasRendererBase.prototype.renderFrame = function (o, l) { if (!(this.renderedFrame === o && this.renderConfig.clearCanvas === !0 && !l || this.destroyed || o === -1)) { this.renderedFrame = o, this.globalData.frameNum = o - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || l, this.globalData.projectInterface.currentFrame = o; var u, f = this.layers.length; for (this.completeLayers || this.checkLayers(o), u = f - 1; u >= 0; u -= 1)(this.completeLayers || this.elements[u]) && this.elements[u].prepareFrame(o - this.layers[u].st); if (this.globalData._mdf) { for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), u = f - 1; u >= 0; u -= 1)(this.completeLayers || this.elements[u]) && this.elements[u].renderFrame(); this.renderConfig.clearCanvas !== !0 && this.restore() } } }, CanvasRendererBase.prototype.buildItem = function (o) { var l = this.elements; if (!(l[o] || this.layers[o].ty === 99)) { var u = this.createItem(this.layers[o], this, this.globalData); l[o] = u, u.initExpressions() } }, CanvasRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var o = this.pendingElements.pop(); o.checkParenting() } }, CanvasRendererBase.prototype.hide = function () { this.animationItem.container.style.display = "none" }, CanvasRendererBase.prototype.show = function () { this.animationItem.container.style.display = "block" }; function CanvasContext() { this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random() } function CVContextData() { this.stack = [], this.cArrPos = 0, this.cTr = new Matrix; var o, l = 15; for (o = 0; o < l; o += 1) { var u = new CanvasContext; this.stack[o] = u } this._length = l, this.nativeContext = null, this.transformMat = new Matrix, this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = "" } CVContextData.prototype.duplicate = function () { var o = this._length * 2, l = 0; for (l = this._length; l < o; l += 1)this.stack[l] = new CanvasContext; this._length = o }, CVContextData.prototype.reset = function () { this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1 }, CVContextData.prototype.restore = function (o) { this.cArrPos -= 1; var l = this.stack[this.cArrPos], u = l.transform, f, p = this.cTr.props; for (f = 0; f < 16; f += 1)p[f] = u[f]; if (o) { this.nativeContext.restore(); var d = this.stack[this.cArrPos + 1]; this.appliedFillStyle = d.fillStyle, this.appliedStrokeStyle = d.strokeStyle, this.appliedLineWidth = d.lineWidth, this.appliedLineCap = d.lineCap, this.appliedLineJoin = d.lineJoin, this.appliedMiterLimit = d.miterLimit } this.nativeContext.setTransform(u[0], u[1], u[4], u[5], u[12], u[13]), (o || l.opacity !== -1 && this.currentOpacity !== l.opacity) && (this.nativeContext.globalAlpha = l.opacity, this.currentOpacity = l.opacity), this.currentFillStyle = l.fillStyle, this.currentStrokeStyle = l.strokeStyle, this.currentLineWidth = l.lineWidth, this.currentLineCap = l.lineCap, this.currentLineJoin = l.lineJoin, this.currentMiterLimit = l.miterLimit }, CVContextData.prototype.save = function (o) { o && this.nativeContext.save(); var l = this.cTr.props; this._length <= this.cArrPos && this.duplicate(); var u = this.stack[this.cArrPos], f; for (f = 0; f < 16; f += 1)u.transform[f] = l[f]; this.cArrPos += 1; var p = this.stack[this.cArrPos]; p.opacity = u.opacity, p.fillStyle = u.fillStyle, p.strokeStyle = u.strokeStyle, p.lineWidth = u.lineWidth, p.lineCap = u.lineCap, p.lineJoin = u.lineJoin, p.miterLimit = u.miterLimit }, CVContextData.prototype.setOpacity = function (o) { this.stack[this.cArrPos].opacity = o }, CVContextData.prototype.setContext = function (o) { this.nativeContext = o }, CVContextData.prototype.fillStyle = function (o) { this.stack[this.cArrPos].fillStyle !== o && (this.currentFillStyle = o, this.stack[this.cArrPos].fillStyle = o) }, CVContextData.prototype.strokeStyle = function (o) { this.stack[this.cArrPos].strokeStyle !== o && (this.currentStrokeStyle = o, this.stack[this.cArrPos].strokeStyle = o) }, CVContextData.prototype.lineWidth = function (o) { this.stack[this.cArrPos].lineWidth !== o && (this.currentLineWidth = o, this.stack[this.cArrPos].lineWidth = o) }, CVContextData.prototype.lineCap = function (o) { this.stack[this.cArrPos].lineCap !== o && (this.currentLineCap = o, this.stack[this.cArrPos].lineCap = o) }, CVContextData.prototype.lineJoin = function (o) { this.stack[this.cArrPos].lineJoin !== o && (this.currentLineJoin = o, this.stack[this.cArrPos].lineJoin = o) }, CVContextData.prototype.miterLimit = function (o) { this.stack[this.cArrPos].miterLimit !== o && (this.currentMiterLimit = o, this.stack[this.cArrPos].miterLimit = o) }, CVContextData.prototype.transform = function (o) { this.transformMat.cloneFromProps(o); var l = this.cTr; this.transformMat.multiply(l), l.cloneFromProps(this.transformMat.props); var u = l.props; this.nativeContext.setTransform(u[0], u[1], u[4], u[5], u[12], u[13]) }, CVContextData.prototype.opacity = function (o) { var l = this.stack[this.cArrPos].opacity; l *= o < 0 ? 0 : o, this.stack[this.cArrPos].opacity !== l && (this.currentOpacity !== o && (this.nativeContext.globalAlpha = o, this.currentOpacity = o), this.stack[this.cArrPos].opacity = l) }, CVContextData.prototype.fill = function (o) { this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(o) }, CVContextData.prototype.fillRect = function (o, l, u, f) { this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(o, l, u, f) }, CVContextData.prototype.stroke = function () { this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke() }; function CVCompElement(o, l, u) { this.completeLayers = !1, this.layers = o.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(o, l, u), this.tm = o.tm ? PropertyFactory.getProp(this, o.tm, 0, l.frameRate, this) : { _placeholder: !0 } } extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () { var o = this.canvasContext; o.beginPath(), o.moveTo(0, 0), o.lineTo(this.data.w, 0), o.lineTo(this.data.w, this.data.h), o.lineTo(0, this.data.h), o.lineTo(0, 0), o.clip(); var l, u = this.layers.length; for (l = u - 1; l >= 0; l -= 1)(this.completeLayers || this.elements[l]) && this.elements[l].renderFrame() }, CVCompElement.prototype.destroy = function () { var o, l = this.layers.length; for (o = l - 1; o >= 0; o -= 1)this.elements[o] && this.elements[o].destroy(); this.layers = null, this.elements = null }, CVCompElement.prototype.createComp = function (o) { return new CVCompElement(o, this.globalData, this) }; function CanvasRenderer(o, l) { this.animationItem = o, this.renderConfig = { clearCanvas: l && l.clearCanvas !== void 0 ? l.clearCanvas : !0, context: l && l.context || null, progressiveLoad: l && l.progressiveLoad || !1, preserveAspectRatio: l && l.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: l && l.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: l && l.contentVisibility || "visible", className: l && l.className || "", id: l && l.id || "", runExpressions: !l || l.runExpressions === void 0 || l.runExpressions }, this.renderConfig.dpr = l && l.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = l && l.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = { frameNum: -1, _mdf: !1, renderConfig: this.renderConfig, currentGlobalAlpha: -1 }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData)) } extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function (o) { return new CVCompElement(o, this.globalData, this) }; function HBaseElement() { } HBaseElement.prototype = { checkBlendMode: function () { }, initRendererElement: function () { this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement) }, createContainerElements: function () { this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode() }, renderElement: function () { var l = this.transformedElement ? this.transformedElement.style : {}; if (this.finalTransform._matMdf) { var u = this.finalTransform.mat.toCSS(); l.transform = u, l.webkitTransform = u } this.finalTransform._opMdf && (l.opacity = this.finalTransform.mProp.o.v) }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, destroy: function () { this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null) }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData) }, addEffects: function () { }, setMatte: function () { } }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting; function HSolidElement(o, l, u) { this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () { var o; this.data.hasMask ? (o = createNS("rect"), o.setAttribute("width", this.data.sw), o.setAttribute("height", this.data.sh), o.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (o = createTag("div"), o.style.width = this.data.sw + "px", o.style.height = this.data.sh + "px", o.style.backgroundColor = this.data.sc), this.layerElement.appendChild(o) }; function HShapeElement(o, l, u) { this.shapes = [], this.shapesData = o.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(o, l, u), this.prevViewData = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 } } extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () { var o; if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), o = this.svgElement; else { o = createNS("svg"); var l = this.comp.data ? this.comp.data : this.globalData.compSize; o.setAttribute("width", l.w), o.setAttribute("height", l.h), o.appendChild(this.shapesContainer), this.layerElement.appendChild(o) } this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = o }, HShapeElement.prototype.getTransformedPoint = function (o, l) { var u, f = o.length; for (u = 0; u < f; u += 1)l = o[u].mProps.v.applyToPointArray(l[0], l[1], 0); return l }, HShapeElement.prototype.calculateShapeBoundingBox = function (o, l) { var u = o.sh.v, f = o.transformers, p, d = u._length, m, v, I, F; if (!(d <= 1)) { for (p = 0; p < d - 1; p += 1)m = this.getTransformedPoint(f, u.v[p]), v = this.getTransformedPoint(f, u.o[p]), I = this.getTransformedPoint(f, u.i[p + 1]), F = this.getTransformedPoint(f, u.v[p + 1]), this.checkBounds(m, v, I, F, l); u.c && (m = this.getTransformedPoint(f, u.v[p]), v = this.getTransformedPoint(f, u.o[p]), I = this.getTransformedPoint(f, u.i[0]), F = this.getTransformedPoint(f, u.v[0]), this.checkBounds(m, v, I, F, l)) } }, HShapeElement.prototype.checkBounds = function (o, l, u, f, p) { this.getBoundsOfCurve(o, l, u, f); var d = this.shapeBoundingBox; p.x = bmMin(d.left, p.x), p.xMax = bmMax(d.right, p.xMax), p.y = bmMin(d.top, p.y), p.yMax = bmMax(d.bottom, p.yMax) }, HShapeElement.prototype.shapeBoundingBox = { left: 0, right: 0, top: 0, bottom: 0 }, HShapeElement.prototype.tempBoundingBox = { x: 0, xMax: 0, y: 0, yMax: 0, width: 0, height: 0 }, HShapeElement.prototype.getBoundsOfCurve = function (o, l, u, f) { for (var p = [[o[0], f[0]], [o[1], f[1]]], d, m, v, I, F, B, W, Z = 0; Z < 2; ++Z)m = 6 * o[Z] - 12 * l[Z] + 6 * u[Z], d = -3 * o[Z] + 9 * l[Z] - 9 * u[Z] + 3 * f[Z], v = 3 * l[Z] - 3 * o[Z], m |= 0, d |= 0, v |= 0, d === 0 && m === 0 || (d === 0 ? (I = -v / m, I > 0 && I < 1 && p[Z].push(this.calculateF(I, o, l, u, f, Z))) : (F = m * m - 4 * v * d, F >= 0 && (B = (-m + bmSqrt(F)) / (2 * d), B > 0 && B < 1 && p[Z].push(this.calculateF(B, o, l, u, f, Z)), W = (-m - bmSqrt(F)) / (2 * d), W > 0 && W < 1 && p[Z].push(this.calculateF(W, o, l, u, f, Z))))); this.shapeBoundingBox.left = bmMin.apply(null, p[0]), this.shapeBoundingBox.top = bmMin.apply(null, p[1]), this.shapeBoundingBox.right = bmMax.apply(null, p[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, p[1]) }, HShapeElement.prototype.calculateF = function (o, l, u, f, p, d) { return bmPow(1 - o, 3) * l[d] + 3 * bmPow(1 - o, 2) * o * u[d] + 3 * (1 - o) * bmPow(o, 2) * f[d] + bmPow(o, 3) * p[d] }, HShapeElement.prototype.calculateBoundingBox = function (o, l) { var u, f = o.length; for (u = 0; u < f; u += 1)o[u] && o[u].sh ? this.calculateShapeBoundingBox(o[u], l) : o[u] && o[u].it ? this.calculateBoundingBox(o[u].it, l) : o[u] && o[u].style && o[u].w && this.expandStrokeBoundingBox(o[u].w, l) }, HShapeElement.prototype.expandStrokeBoundingBox = function (o, l) { var u = 0; if (o.keyframes) { for (var f = 0; f < o.keyframes.length; f += 1) { var p = o.keyframes[f].s; p > u && (u = p) } u *= o.mult } else u = o.v * o.mult; l.x -= u, l.xMax += u, l.y -= u, l.yMax += u }, HShapeElement.prototype.currentBoxContains = function (o) { return this.currentBBox.x <= o.x && this.currentBBox.y <= o.y && this.currentBBox.width + this.currentBBox.x >= o.x + o.width && this.currentBBox.height + this.currentBBox.y >= o.y + o.height }, HShapeElement.prototype.renderInnerContent = function () { if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) { var o = this.tempBoundingBox, l = 999999; if (o.x = l, o.xMax = -l, o.y = l, o.yMax = -l, this.calculateBoundingBox(this.itemsData, o), o.width = o.xMax < o.x ? 0 : o.xMax - o.x, o.height = o.yMax < o.y ? 0 : o.yMax - o.y, this.currentBoxContains(o)) return; var u = !1; if (this.currentBBox.w !== o.width && (this.currentBBox.w = o.width, this.shapeCont.setAttribute("width", o.width), u = !0), this.currentBBox.h !== o.height && (this.currentBBox.h = o.height, this.shapeCont.setAttribute("height", o.height), u = !0), u || this.currentBBox.x !== o.x || this.currentBBox.y !== o.y) { this.currentBBox.w = o.width, this.currentBBox.h = o.height, this.currentBBox.x = o.x, this.currentBBox.y = o.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h); var f = this.shapeCont.style, p = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; f.transform = p, f.webkitTransform = p } } }; function HTextElement(o, l, u) { this.textSpans = [], this.textPaths = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }, this.renderType = "svg", this.isMasked = !1, this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () { if (this.isMasked = this.checkMasks(), this.isMasked) { this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH); var o = createNS("g"); this.maskedElement.appendChild(o), this.innerElem = o } else this.renderType = "html", this.innerElem = this.layerElement; this.checkParenting() }, HTextElement.prototype.buildNewText = function () { var o = this.textProperty.currentData; this.renderedLetters = createSizedArray(o.l ? o.l.length : 0); var l = this.innerElem.style, u = o.fc ? this.buildColor(o.fc) : "rgba(0,0,0,0)"; l.fill = u, l.color = u, o.sc && (l.stroke = this.buildColor(o.sc), l.strokeWidth = o.sw + "px"); var f = this.globalData.fontManager.getFontByName(o.f); if (!this.globalData.fontManager.chars) if (l.fontSize = o.finalSize + "px", l.lineHeight = o.finalSize + "px", f.fClass) this.innerElem.className = f.fClass; else { l.fontFamily = f.fFamily; var p = o.fWeight, d = o.fStyle; l.fontStyle = d, l.fontWeight = p } var m, v, I = o.l; v = I.length; var F, B, W, Z = this.mHelper, Q, re = "", ne = 0; for (m = 0; m < v; m += 1) { if (this.globalData.fontManager.chars ? (this.textPaths[ne] ? F = this.textPaths[ne] : (F = createNS("path"), F.setAttribute("stroke-linecap", lineCapEnum[1]), F.setAttribute("stroke-linejoin", lineJoinEnum[2]), F.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[ne] ? (B = this.textSpans[ne], W = B.children[0]) : (B = createTag("div"), B.style.lineHeight = 0, W = createNS("svg"), W.appendChild(F), styleDiv(B)))) : this.isMasked ? F = this.textPaths[ne] ? this.textPaths[ne] : createNS("text") : this.textSpans[ne] ? (B = this.textSpans[ne], F = this.textPaths[ne]) : (B = createTag("span"), styleDiv(B), F = createTag("span"), styleDiv(F), B.appendChild(F)), this.globalData.fontManager.chars) { var oe = this.globalData.fontManager.getCharData(o.finalText[m], f.fStyle, this.globalData.fontManager.getFontByName(o.f).fFamily), ae; if (oe ? ae = oe.data : ae = null, Z.reset(), ae && ae.shapes && ae.shapes.length && (Q = ae.shapes[0].it, Z.scale(o.finalSize / 100, o.finalSize / 100), re = this.createPathShape(Z, Q), F.setAttribute("d", re)), this.isMasked) this.innerElem.appendChild(F); else { if (this.innerElem.appendChild(B), ae && ae.shapes) { document.body.appendChild(W); var se = W.getBBox(); W.setAttribute("width", se.width + 2), W.setAttribute("height", se.height + 2), W.setAttribute("viewBox", se.x - 1 + " " + (se.y - 1) + " " + (se.width + 2) + " " + (se.height + 2)); var le = W.style, ue = "translate(" + (se.x - 1) + "px," + (se.y - 1) + "px)"; le.transform = ue, le.webkitTransform = ue, I[m].yOffset = se.y - 1 } else W.setAttribute("width", 1), W.setAttribute("height", 1); B.appendChild(W) } } else if (F.textContent = I[m].val, F.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(F); else { this.innerElem.appendChild(B); var he = F.style, pe = "translate3d(0," + -o.finalSize / 1.2 + "px,0)"; he.transform = pe, he.webkitTransform = pe } this.isMasked ? this.textSpans[ne] = F : this.textSpans[ne] = B, this.textSpans[ne].style.display = "block", this.textPaths[ne] = F, ne += 1 } for (; ne < this.textSpans.length;)this.textSpans[ne].style.display = "none", ne += 1 }, HTextElement.prototype.renderInnerContent = function () { this.validateText(); var o; if (this.data.singleShape) { if (!this._isFirstFrame && !this.lettersChangedFlag) return; if (this.isMasked && this.finalTransform._matMdf) { this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), o = this.svgElement.style; var l = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)"; o.transform = l, o.webkitTransform = l } } if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) { var u, f, p = 0, d = this.textAnimator.renderedLetters, m = this.textProperty.currentData.l; f = m.length; var v, I, F; for (u = 0; u < f; u += 1)m[u].n ? p += 1 : (I = this.textSpans[u], F = this.textPaths[u], v = d[p], p += 1, v._mdf.m && (this.isMasked ? I.setAttribute("transform", v.m) : (I.style.webkitTransform = v.m, I.style.transform = v.m)), I.style.opacity = v.o, v.sw && v._mdf.sw && F.setAttribute("stroke-width", v.sw), v.sc && v._mdf.sc && F.setAttribute("stroke", v.sc), v.fc && v._mdf.fc && (F.setAttribute("fill", v.fc), F.style.color = v.fc)); if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) { var B = this.innerElem.getBBox(); this.currentBBox.w !== B.width && (this.currentBBox.w = B.width, this.svgElement.setAttribute("width", B.width)), this.currentBBox.h !== B.height && (this.currentBBox.h = B.height, this.svgElement.setAttribute("height", B.height)); var W = 1; if (this.currentBBox.w !== B.width + W * 2 || this.currentBBox.h !== B.height + W * 2 || this.currentBBox.x !== B.x - W || this.currentBBox.y !== B.y - W) { this.currentBBox.w = B.width + W * 2, this.currentBBox.h = B.height + W * 2, this.currentBBox.x = B.x - W, this.currentBBox.y = B.y - W, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), o = this.svgElement.style; var Z = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; o.transform = Z, o.webkitTransform = Z } } } }; function HCameraElement(o, l, u) { this.initFrame(), this.initBaseData(o, l, u), this.initHierarchy(); var f = PropertyFactory.getProp; if (this.pe = f(this, o.pe, 0, 0, this), o.ks.p.s ? (this.px = f(this, o.ks.p.x, 1, 0, this), this.py = f(this, o.ks.p.y, 1, 0, this), this.pz = f(this, o.ks.p.z, 1, 0, this)) : this.p = f(this, o.ks.p, 1, 0, this), o.ks.a && (this.a = f(this, o.ks.a, 1, 0, this)), o.ks.or.k.length && o.ks.or.k[0].to) { var p, d = o.ks.or.k.length; for (p = 0; p < d; p += 1)o.ks.or.k[p].to = null, o.ks.or.k[p].ti = null } this.or = f(this, o.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = f(this, o.ks.rx, 0, degToRads, this), this.ry = f(this, o.ks.ry, 0, degToRads, this), this.rz = f(this, o.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = { mProp: this } } extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () { var o, l = this.comp.threeDElements.length, u, f, p; for (o = 0; o < l; o += 1)if (u = this.comp.threeDElements[o], u.type === "3d") { f = u.perspectiveElem.style, p = u.container.style; var d = this.pe.v + "px", m = "0px 0px 0px", v = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; f.perspective = d, f.webkitPerspective = d, p.transformOrigin = m, p.mozTransformOrigin = m, p.webkitTransformOrigin = m, f.transform = v, f.webkitTransform = v } }, HCameraElement.prototype.createElements = function () { }, HCameraElement.prototype.hide = function () { }, HCameraElement.prototype.renderFrame = function () { var o = this._isFirstFrame, l, u; if (this.hierarchy) for (u = this.hierarchy.length, l = 0; l < u; l += 1)o = this.hierarchy[l].finalTransform.mProp._mdf || o; if (o || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) { if (this.mat.reset(), this.hierarchy) for (u = this.hierarchy.length - 1, l = u; l >= 0; l -= 1) { var f = this.hierarchy[l].finalTransform.mProp; this.mat.translate(-f.p.v[0], -f.p.v[1], f.p.v[2]), this.mat.rotateX(-f.or.v[0]).rotateY(-f.or.v[1]).rotateZ(f.or.v[2]), this.mat.rotateX(-f.rx.v).rotateY(-f.ry.v).rotateZ(f.rz.v), this.mat.scale(1 / f.s.v[0], 1 / f.s.v[1], 1 / f.s.v[2]), this.mat.translate(f.a.v[0], f.a.v[1], f.a.v[2]) } if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) { var p; this.p ? p = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : p = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]]; var d = Math.sqrt(Math.pow(p[0], 2) + Math.pow(p[1], 2) + Math.pow(p[2], 2)), m = [p[0] / d, p[1] / d, p[2] / d], v = Math.sqrt(m[2] * m[2] + m[0] * m[0]), I = Math.atan2(m[1], v), F = Math.atan2(m[0], -m[2]); this.mat.rotateY(F).rotateX(-I) } this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v); var B = !this._prevMat.equals(this.mat); if ((B || this.pe._mdf) && this.comp.threeDElements) { u = this.comp.threeDElements.length; var W, Z, Q; for (l = 0; l < u; l += 1)if (W = this.comp.threeDElements[l], W.type === "3d") { if (B) { var re = this.mat.toCSS(); Q = W.container.style, Q.transform = re, Q.webkitTransform = re } this.pe._mdf && (Z = W.perspectiveElem.style, Z.perspective = this.pe.v + "px", Z.webkitPerspective = this.pe.v + "px") } this.mat.clone(this._prevMat) } } this._isFirstFrame = !1 }, HCameraElement.prototype.prepareFrame = function (o) { this.prepareProperties(o, !0) }, HCameraElement.prototype.destroy = function () { }, HCameraElement.prototype.getBaseElement = function () { return null }; function HImageElement(o, l, u) { this.assetData = l.getAssetData(o.refId), this.initElement(o, l, u) } extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () { var o = this.globalData.getAssetsPath(this.assetData), l = new Image; this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", o), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(l), l.crossOrigin = "anonymous", l.src = o, this.data.ln && this.baseElement.setAttribute("id", this.data.ln) }; function HybridRendererBase(o, l) { this.animationItem = o, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: l && l.className || "", imagePreserveAspectRatio: l && l.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(l && l.hideOnTransparent === !1), filterSize: { width: l && l.filterSize && l.filterSize.width || "400%", height: l && l.filterSize && l.filterSize.height || "400%", x: l && l.filterSize && l.filterSize.x || "-100%", y: l && l.filterSize && l.filterSize.y || "-100%" } }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var o = this.pendingElements.pop(); o.checkParenting() } }, HybridRendererBase.prototype.appendElementInPos = function (o, l) { var u = o.getBaseElement(); if (u) { var f = this.layers[l]; if (!f.ddd || !this.supports3d) if (this.threeDElements) this.addTo3dContainer(u, l); else { for (var p = 0, d, m, v; p < l;)this.elements[p] && this.elements[p] !== !0 && this.elements[p].getBaseElement && (m = this.elements[p], v = this.layers[p].ddd ? this.getThreeDContainerByPos(p) : m.getBaseElement(), d = v || d), p += 1; d ? (!f.ddd || !this.supports3d) && this.layerElement.insertBefore(u, d) : (!f.ddd || !this.supports3d) && this.layerElement.appendChild(u) } else this.addTo3dContainer(u, l) } }, HybridRendererBase.prototype.createShape = function (o) { return this.supports3d ? new HShapeElement(o, this.globalData, this) : new SVGShapeElement(o, this.globalData, this) }, HybridRendererBase.prototype.createText = function (o) { return this.supports3d ? new HTextElement(o, this.globalData, this) : new SVGTextLottieElement(o, this.globalData, this) }, HybridRendererBase.prototype.createCamera = function (o) { return this.camera = new HCameraElement(o, this.globalData, this), this.camera }, HybridRendererBase.prototype.createImage = function (o) { return this.supports3d ? new HImageElement(o, this.globalData, this) : new IImageElement(o, this.globalData, this) }, HybridRendererBase.prototype.createSolid = function (o) { return this.supports3d ? new HSolidElement(o, this.globalData, this) : new ISolidElement(o, this.globalData, this) }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function (o) { for (var l = 0, u = this.threeDElements.length; l < u;) { if (this.threeDElements[l].startPos <= o && this.threeDElements[l].endPos >= o) return this.threeDElements[l].perspectiveElem; l += 1 } return null }, HybridRendererBase.prototype.createThreeDContainer = function (o, l) { var u = createTag("div"), f, p; styleDiv(u); var d = createTag("div"); if (styleDiv(d), l === "3d") { f = u.style, f.width = this.globalData.compSize.w + "px", f.height = this.globalData.compSize.h + "px"; var m = "50% 50%"; f.webkitTransformOrigin = m, f.mozTransformOrigin = m, f.transformOrigin = m, p = d.style; var v = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; p.transform = v, p.webkitTransform = v } u.appendChild(d); var I = { container: d, perspectiveElem: u, startPos: o, endPos: o, type: l }; return this.threeDElements.push(I), I }, HybridRendererBase.prototype.build3dContainers = function () { var o, l = this.layers.length, u, f = ""; for (o = 0; o < l; o += 1)this.layers[o].ddd && this.layers[o].ty !== 3 ? (f !== "3d" && (f = "3d", u = this.createThreeDContainer(o, "3d")), u.endPos = Math.max(u.endPos, o)) : (f !== "2d" && (f = "2d", u = this.createThreeDContainer(o, "2d")), u.endPos = Math.max(u.endPos, o)); for (l = this.threeDElements.length, o = l - 1; o >= 0; o -= 1)this.resizerElem.appendChild(this.threeDElements[o].perspectiveElem) }, HybridRendererBase.prototype.addTo3dContainer = function (o, l) { for (var u = 0, f = this.threeDElements.length; u < f;) { if (l <= this.threeDElements[u].endPos) { for (var p = this.threeDElements[u].startPos, d; p < l;)this.elements[p] && this.elements[p].getBaseElement && (d = this.elements[p].getBaseElement()), p += 1; d ? this.threeDElements[u].container.insertBefore(o, d) : this.threeDElements[u].container.appendChild(o); break } u += 1 } }, HybridRendererBase.prototype.configAnimation = function (o) { var l = createTag("div"), u = this.animationItem.wrapper, f = l.style; f.width = o.w + "px", f.height = o.h + "px", this.resizerElem = l, styleDiv(l), f.transformStyle = "flat", f.mozTransformStyle = "flat", f.webkitTransformStyle = "flat", this.renderConfig.className && l.setAttribute("class", this.renderConfig.className), u.appendChild(l), f.overflow = "hidden"; var p = createNS("svg"); p.setAttribute("width", "1"), p.setAttribute("height", "1"), styleDiv(p), this.resizerElem.appendChild(p); var d = createNS("defs"); p.appendChild(d), this.data = o, this.setupGlobalData(o, p), this.globalData.defs = d, this.layers = o.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize() }, HybridRendererBase.prototype.destroy = function () { this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null; var o, l = this.layers ? this.layers.length : 0; for (o = 0; o < l; o += 1)this.elements[o] && this.elements[o].destroy && this.elements[o].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, HybridRendererBase.prototype.updateContainerSize = function () { var o = this.animationItem.wrapper.offsetWidth, l = this.animationItem.wrapper.offsetHeight, u = o / l, f = this.globalData.compSize.w / this.globalData.compSize.h, p, d, m, v; f > u ? (p = o / this.globalData.compSize.w, d = o / this.globalData.compSize.w, m = 0, v = (l - this.globalData.compSize.h * (o / this.globalData.compSize.w)) / 2) : (p = l / this.globalData.compSize.h, d = l / this.globalData.compSize.h, m = (o - this.globalData.compSize.w * (l / this.globalData.compSize.h)) / 2, v = 0); var I = this.resizerElem.style; I.webkitTransform = "matrix3d(" + p + ",0,0,0,0," + d + ",0,0,0,0,1,0," + m + "," + v + ",0,1)", I.transform = I.webkitTransform }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function () { this.resizerElem.style.display = "none" }, HybridRendererBase.prototype.show = function () { this.resizerElem.style.display = "block" }, HybridRendererBase.prototype.initItems = function () { if (this.buildAllItems(), this.camera) this.camera.setup(); else { var o = this.globalData.compSize.w, l = this.globalData.compSize.h, u, f = this.threeDElements.length; for (u = 0; u < f; u += 1) { var p = this.threeDElements[u].perspectiveElem.style; p.webkitPerspective = Math.sqrt(Math.pow(o, 2) + Math.pow(l, 2)) + "px", p.perspective = p.webkitPerspective } } }, HybridRendererBase.prototype.searchExtraCompositions = function (o) { var l, u = o.length, f = createTag("div"); for (l = 0; l < u; l += 1)if (o[l].xt) { var p = this.createComp(o[l], f, this.globalData.comp, null); p.initExpressions(), this.globalData.projectInterface.registerComposition(p) } }; function HCompElement(o, l, u) { this.layers = o.layers, this.supports3d = !o.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(o, l, u), this.tm = o.tm ? PropertyFactory.getProp(this, o.tm, 0, l.frameRate, this) : { _placeholder: !0 } } extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () { this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement }, HCompElement.prototype.addTo3dContainer = function (o, l) { for (var u = 0, f; u < l;)this.elements[u] && this.elements[u].getBaseElement && (f = this.elements[u].getBaseElement()), u += 1; f ? this.layerElement.insertBefore(o, f) : this.layerElement.appendChild(o) }, HCompElement.prototype.createComp = function (o) { return this.supports3d ? new HCompElement(o, this.globalData, this) : new SVGCompElement(o, this.globalData, this) }; function HybridRenderer(o, l) { this.animationItem = o, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: l && l.className || "", imagePreserveAspectRatio: l && l.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(l && l.hideOnTransparent === !1), filterSize: { width: l && l.filterSize && l.filterSize.width || "400%", height: l && l.filterSize && l.filterSize.height || "400%", x: l && l.filterSize && l.filterSize.x || "-100%", y: l && l.filterSize && l.filterSize.y || "-100%" }, runExpressions: !l || l.runExpressions === void 0 || l.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function (o) { return this.supports3d ? new HCompElement(o, this.globalData, this) : new SVGCompElement(o, this.globalData, this) }; var CompExpressionInterface = function () { return function (o) { function l(u) { for (var f = 0, p = o.layers.length; f < p;) { if (o.layers[f].nm === u || o.layers[f].ind === u) return o.elements[f].layerInterface; f += 1 } return null } return Object.defineProperty(l, "_name", { value: o.data.nm }), l.layer = l, l.pixelAspect = 1, l.height = o.data.h || o.globalData.compSize.h, l.width = o.data.w || o.globalData.compSize.w, l.pixelAspect = 1, l.frameDuration = 1 / o.globalData.frameRate, l.displayStartTime = 0, l.numLayers = o.layers.length, l } }(); function _typeof$2(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function (u) { return typeof u } : _typeof$2 = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof$2(o) } function seedRandom(o, l) { var u = this, f = 256, p = 6, d = 52, m = "random", v = l.pow(f, p), I = l.pow(2, d), F = I * 2, B = f - 1, W; function Z(le, ue, he) { var pe = []; ue = ue === !0 ? { entropy: !0 } : ue || {}; var ve = oe(ne(ue.entropy ? [le, se(o)] : le === null ? ae() : le, 3), pe), _e = new Q(pe), Se = function () { for (var ie = _e.g(p), g = v, P = 0; ie < I;)ie = (ie + P) * f, g *= f, P = _e.g(1); for (; ie >= F;)ie /= 2, g /= 2, P >>>= 1; return (ie + P) / g }; return Se.int32 = function () { return _e.g(4) | 0 }, Se.quick = function () { return _e.g(4) / 4294967296 }, Se.double = Se, oe(se(_e.S), o), (ue.pass || he || function ($e, ie, g, P) { return P && (P.S && re(P, _e), $e.state = function () { return re(_e, {}) }), g ? (l[m] = $e, ie) : $e })(Se, ve, "global" in ue ? ue.global : this == l, ue.state) } l["seed" + m] = Z; function Q(le) { var ue, he = le.length, pe = this, ve = 0, _e = pe.i = pe.j = 0, Se = pe.S = []; for (he || (le = [he++]); ve < f;)Se[ve] = ve++; for (ve = 0; ve < f; ve++)Se[ve] = Se[_e = B & _e + le[ve % he] + (ue = Se[ve])], Se[_e] = ue; pe.g = function ($e) { for (var ie, g = 0, P = pe.i, U = pe.j, K = pe.S; $e--;)ie = K[P = B & P + 1], g = g * f + K[B & (K[P] = K[U = B & U + ie]) + (K[U] = ie)]; return pe.i = P, pe.j = U, g } } function re(le, ue) { return ue.i = le.i, ue.j = le.j, ue.S = le.S.slice(), ue } function ne(le, ue) { var he = [], pe = _typeof$2(le), ve; if (ue && pe == "object") for (ve in le) try { he.push(ne(le[ve], ue - 1)) } catch { } return he.length ? he : pe == "string" ? le : le + "\0" } function oe(le, ue) { for (var he = le + "", pe, ve = 0; ve < he.length;)ue[B & ve] = B & (pe ^= ue[B & ve] * 19) + he.charCodeAt(ve++); return se(ue) } function ae() { try { var le = new Uint8Array(f); return (u.crypto || u.msCrypto).getRandomValues(le), se(le) } catch { var ue = u.navigator, he = ue && ue.plugins; return [+new Date, u, he, u.screen, se(o)] } } function se(le) { return String.fromCharCode.apply(0, le) } oe(l.random(), o) } function initialize$2(o) { seedRandom([], o) } var propTypes = { SHAPE: "shape" }; function _typeof$1(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function (u) { return typeof u } : _typeof$1 = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof$1(o) } var ExpressionManager = function () { var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null, _lottieGlobal = {}; initialize$2(BMMath); function resetFrame() { _lottieGlobal = {} } function $bm_isInstanceOfArray(o) { return o.constructor === Array || o.constructor === Float32Array } function isNumerable(o, l) { return o === "number" || l instanceof Number || o === "boolean" || o === "string" } function $bm_neg(o) { var l = _typeof$1(o); if (l === "number" || o instanceof Number || l === "boolean") return -o; if ($bm_isInstanceOfArray(o)) { var u, f = o.length, p = []; for (u = 0; u < f; u += 1)p[u] = -o[u]; return p } return o.propType ? o.v : -o } var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get; function sum(o, l) { var u = _typeof$1(o), f = _typeof$1(l); if (isNumerable(u, o) && isNumerable(f, l) || u === "string" || f === "string") return o + l; if ($bm_isInstanceOfArray(o) && isNumerable(f, l)) return o = o.slice(0), o[0] += l, o; if (isNumerable(u, o) && $bm_isInstanceOfArray(l)) return l = l.slice(0), l[0] = o + l[0], l; if ($bm_isInstanceOfArray(o) && $bm_isInstanceOfArray(l)) { for (var p = 0, d = o.length, m = l.length, v = []; p < d || p < m;)(typeof o[p] == "number" || o[p] instanceof Number) && (typeof l[p] == "number" || l[p] instanceof Number) ? v[p] = o[p] + l[p] : v[p] = l[p] === void 0 ? o[p] : o[p] || l[p], p += 1; return v } return 0 } var add = sum; function sub(o, l) { var u = _typeof$1(o), f = _typeof$1(l); if (isNumerable(u, o) && isNumerable(f, l)) return u === "string" && (o = parseInt(o, 10)), f === "string" && (l = parseInt(l, 10)), o - l; if ($bm_isInstanceOfArray(o) && isNumerable(f, l)) return o = o.slice(0), o[0] -= l, o; if (isNumerable(u, o) && $bm_isInstanceOfArray(l)) return l = l.slice(0), l[0] = o - l[0], l; if ($bm_isInstanceOfArray(o) && $bm_isInstanceOfArray(l)) { for (var p = 0, d = o.length, m = l.length, v = []; p < d || p < m;)(typeof o[p] == "number" || o[p] instanceof Number) && (typeof l[p] == "number" || l[p] instanceof Number) ? v[p] = o[p] - l[p] : v[p] = l[p] === void 0 ? o[p] : o[p] || l[p], p += 1; return v } return 0 } function mul(o, l) { var u = _typeof$1(o), f = _typeof$1(l), p; if (isNumerable(u, o) && isNumerable(f, l)) return o * l; var d, m; if ($bm_isInstanceOfArray(o) && isNumerable(f, l)) { for (m = o.length, p = createTypedArray("float32", m), d = 0; d < m; d += 1)p[d] = o[d] * l; return p } if (isNumerable(u, o) && $bm_isInstanceOfArray(l)) { for (m = l.length, p = createTypedArray("float32", m), d = 0; d < m; d += 1)p[d] = o * l[d]; return p } return 0 } function div(o, l) { var u = _typeof$1(o), f = _typeof$1(l), p; if (isNumerable(u, o) && isNumerable(f, l)) return o / l; var d, m; if ($bm_isInstanceOfArray(o) && isNumerable(f, l)) { for (m = o.length, p = createTypedArray("float32", m), d = 0; d < m; d += 1)p[d] = o[d] / l; return p } if (isNumerable(u, o) && $bm_isInstanceOfArray(l)) { for (m = l.length, p = createTypedArray("float32", m), d = 0; d < m; d += 1)p[d] = o / l[d]; return p } return 0 } function mod(o, l) { return typeof o == "string" && (o = parseInt(o, 10)), typeof l == "string" && (l = parseInt(l, 10)), o % l } var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod; function clamp(o, l, u) { if (l > u) { var f = u; u = l, l = f } return Math.min(Math.max(o, l), u) } function radiansToDegrees(o) { return o / degToRads } var radians_to_degrees = radiansToDegrees; function degreesToRadians(o) { return o * degToRads } var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0]; function length(o, l) { if (typeof o == "number" || o instanceof Number) return l = l || 0, Math.abs(o - l); l || (l = helperLengthArray); var u, f = Math.min(o.length, l.length), p = 0; for (u = 0; u < f; u += 1)p += Math.pow(l[u] - o[u], 2); return Math.sqrt(p) } function normalize(o) { return div(o, length(o)) } function rgbToHsl(o) { var l = o[0], u = o[1], f = o[2], p = Math.max(l, u, f), d = Math.min(l, u, f), m, v, I = (p + d) / 2; if (p === d) m = 0, v = 0; else { var F = p - d; switch (v = I > .5 ? F / (2 - p - d) : F / (p + d), p) { case l: m = (u - f) / F + (u < f ? 6 : 0); break; case u: m = (f - l) / F + 2; break; case f: m = (l - u) / F + 4; break }m /= 6 } return [m, v, I, o[3]] } function hue2rgb(o, l, u) { return u < 0 && (u += 1), u > 1 && (u -= 1), u < 1 / 6 ? o + (l - o) * 6 * u : u < 1 / 2 ? l : u < 2 / 3 ? o + (l - o) * (2 / 3 - u) * 6 : o } function hslToRgb(o) { var l = o[0], u = o[1], f = o[2], p, d, m; if (u === 0) p = f, m = f, d = f; else { var v = f < .5 ? f * (1 + u) : f + u - f * u, I = 2 * f - v; p = hue2rgb(I, v, l + 1 / 3), d = hue2rgb(I, v, l), m = hue2rgb(I, v, l - 1 / 3) } return [p, d, m, o[3]] } function linear(o, l, u, f, p) { if ((f === void 0 || p === void 0) && (f = l, p = u, l = 0, u = 1), u < l) { var d = u; u = l, l = d } if (o <= l) return f; if (o >= u) return p; var m = u === l ? 0 : (o - l) / (u - l); if (!f.length) return f + (p - f) * m; var v, I = f.length, F = createTypedArray("float32", I); for (v = 0; v < I; v += 1)F[v] = f[v] + (p[v] - f[v]) * m; return F } function random(o, l) { if (l === void 0 && (o === void 0 ? (o = 0, l = 1) : (l = o, o = void 0)), l.length) { var u, f = l.length; o || (o = createTypedArray("float32", f)); var p = createTypedArray("float32", f), d = BMMath.random(); for (u = 0; u < f; u += 1)p[u] = o[u] + d * (l[u] - o[u]); return p } o === void 0 && (o = 0); var m = BMMath.random(); return o + m * (l - o) } function createPath(o, l, u, f) { var p, d = o.length, m = shapePool.newElement(); m.setPathData(!!f, d); var v = [0, 0], I, F; for (p = 0; p < d; p += 1)I = l && l[p] ? l[p] : v, F = u && u[p] ? u[p] : v, m.setTripleAt(o[p][0], o[p][1], F[0] + o[p][0], F[1] + o[p][1], I[0] + o[p][0], I[1] + o[p][1], p, !0); return m } function initiateExpression(elem, data, property) { function noOp(o) { return o } if (!elem.globalData.renderConfig.runExpressions) return noOp; var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property; thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", { get: function () { return thisProperty.v } }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0; var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function o(l, u) { var f, p, d = this.pv.length ? this.pv.length : 1, m = createTypedArray("float32", d); l = 5; var v = Math.floor(time * l); for (f = 0, p = 0; f < v;) { for (p = 0; p < d; p += 1)m[p] += -u + u * 2 * BMMath.random(); f += 1 } var I = time * l, F = I - Math.floor(I), B = createTypedArray("float32", d); if (d > 1) { for (p = 0; p < d; p += 1)B[p] = this.pv[p] + m[p] + (-u + u * 2 * BMMath.random()) * F; return B } return this.pv + m[0] + (-u + u * 2 * BMMath.random()) * F }).bind(this); thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)); function loopInDuration(o, l) { return loopIn(o, l, !0) } function loopOutDuration(o, l) { return loopOut(o, l, !0) } this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this)); var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface); function lookAt(o, l) { var u = [l[0] - o[0], l[1] - o[1], l[2] - o[2]], f = Math.atan2(u[0], Math.sqrt(u[1] * u[1] + u[2] * u[2])) / degToRads, p = -Math.atan2(u[1], u[2]) / degToRads; return [p, f, 0] } function easeOut(o, l, u, f, p) { return applyEase(easeOutBez, o, l, u, f, p) } function easeIn(o, l, u, f, p) { return applyEase(easeInBez, o, l, u, f, p) } function ease(o, l, u, f, p) { return applyEase(easeInOutBez, o, l, u, f, p) } function applyEase(o, l, u, f, p, d) { p === void 0 ? (p = u, d = f) : l = (l - u) / (f - u), l > 1 ? l = 1 : l < 0 && (l = 0); var m = o(l); if ($bm_isInstanceOfArray(p)) { var v, I = p.length, F = createTypedArray("float32", I); for (v = 0; v < I; v += 1)F[v] = (d[v] - p[v]) * m + p[v]; return F } return (d - p) * m + p } function nearestKey(o) { var l, u = data.k.length, f, p; if (!data.k.length || typeof data.k[0] == "number") f = 0, p = 0; else if (f = -1, o *= elem.comp.globalData.frameRate, o < data.k[0].t) f = 1, p = data.k[0].t; else { for (l = 0; l < u - 1; l += 1)if (o === data.k[l].t) { f = l + 1, p = data.k[l].t; break } else if (o > data.k[l].t && o < data.k[l + 1].t) { o - data.k[l].t > data.k[l + 1].t - o ? (f = l + 2, p = data.k[l + 1].t) : (f = l + 1, p = data.k[l].t); break } f === -1 && (f = l + 1, p = data.k[l].t) } var d = {}; return d.index = f, d.time = p / elem.comp.globalData.frameRate, d } function key(o) { var l, u, f; if (!data.k.length || typeof data.k[0] == "number") throw new Error("The property has no keyframe at index " + o); o -= 1, l = { time: data.k[o].t / elem.comp.globalData.frameRate, value: [] }; var p = Object.prototype.hasOwnProperty.call(data.k[o], "s") ? data.k[o].s : data.k[o - 1].e; for (f = p.length, u = 0; u < f; u += 1)l[u] = p[u], l.value[u] = p[u]; return l } function framesToTime(o, l) { return l || (l = elem.comp.globalData.frameRate), o / l } function timeToFrames(o, l) { return !o && o !== 0 && (o = time), l || (l = elem.comp.globalData.frameRate), o * l } function seedRandom(o) { BMMath.seedrandom(randSeed + o) } function sourceRectAtTime() { return elem.sourceRectAtTime() } function substring(o, l) { return typeof value == "string" ? l === void 0 ? value.substring(o) : value.substring(o, l) : "" } function substr(o, l) { return typeof value == "string" ? l === void 0 ? value.substr(o) : value.substr(o, l) : "" } function posterizeTime(o) { time = o === 0 ? 0 : Math.floor(time * o) / o, value = valueAtTime(time) } var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData; function executeExpression(o) { return value = o, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt) } return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression } return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob }(), Expressions = function () { var o = {}; o.initExpressions = l, o.resetFrame = ExpressionManager.resetFrame; function l(u) { var f = 0, p = []; function d() { f += 1 } function m() { f -= 1, f === 0 && I() } function v(F) { p.indexOf(F) === -1 && p.push(F) } function I() { var F, B = p.length; for (F = 0; F < B; F += 1)p[F].release(); p.length = 0 } u.renderer.compInterface = CompExpressionInterface(u.renderer), u.renderer.globalData.projectInterface.registerComposition(u.renderer), u.renderer.globalData.pushExpression = d, u.renderer.globalData.popExpression = m, u.renderer.globalData.registerExpressionProperty = v } return o }(), MaskManagerInterface = function () { function o(u, f) { this._mask = u, this._data = f } Object.defineProperty(o.prototype, "maskPath", { get: function () { return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop } }), Object.defineProperty(o.prototype, "maskOpacity", { get: function () { return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100 } }); var l = function (f) { var p = createSizedArray(f.viewData.length), d, m = f.viewData.length; for (d = 0; d < m; d += 1)p[d] = new o(f.viewData[d], f.masksProperties[d]); var v = function (F) { for (d = 0; d < m;) { if (f.masksProperties[d].nm === F) return p[d]; d += 1 } return null }; return v }; return l }(), ExpressionPropertyInterface = function () { var o = { pv: 0, v: 0, mult: 1 }, l = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }; function u(m, v, I) { Object.defineProperty(m, "velocity", { get: function () { return v.getVelocityAtTime(v.comp.currentFrame) } }), m.numKeys = v.keyframes ? v.keyframes.length : 0, m.key = function (F) { if (!m.numKeys) return 0; var B = ""; "s" in v.keyframes[F - 1] ? B = v.keyframes[F - 1].s : "e" in v.keyframes[F - 2] ? B = v.keyframes[F - 2].e : B = v.keyframes[F - 2].s; var W = I === "unidimensional" ? new Number(B) : Object.assign({}, B); return W.time = v.keyframes[F - 1].t / v.elem.comp.globalData.frameRate, W.value = I === "unidimensional" ? B[0] : B, W }, m.valueAtTime = v.getValueAtTime, m.speedAtTime = v.getSpeedAtTime, m.velocityAtTime = v.getVelocityAtTime, m.propertyGroup = v.propertyGroup } function f(m) { (!m || !("pv" in m)) && (m = o); var v = 1 / m.mult, I = m.pv * v, F = new Number(I); return F.value = I, u(F, m, "unidimensional"), function () { return m.k && m.getValue(), I = m.v * v, F.value !== I && (F = new Number(I), F.value = I, u(F, m, "unidimensional")), F } } function p(m) { (!m || !("pv" in m)) && (m = l); var v = 1 / m.mult, I = m.data && m.data.l || m.pv.length, F = createTypedArray("float32", I), B = createTypedArray("float32", I); return F.value = B, u(F, m, "multidimensional"), function () { m.k && m.getValue(); for (var W = 0; W < I; W += 1)B[W] = m.v[W] * v, F[W] = B[W]; return F } } function d() { return o } return function (m) { return m ? m.propType === "unidimensional" ? f(m) : p(m) : d } }(), TransformExpressionInterface = function () { return function (o) { function l(m) { switch (m) { case "scale": case "Scale": case "ADBE Scale": case 6: return l.scale; case "rotation": case "Rotation": case "ADBE Rotation": case "ADBE Rotate Z": case 10: return l.rotation; case "ADBE Rotate X": return l.xRotation; case "ADBE Rotate Y": return l.yRotation; case "position": case "Position": case "ADBE Position": case 2: return l.position; case "ADBE Position_0": return l.xPosition; case "ADBE Position_1": return l.yPosition; case "ADBE Position_2": return l.zPosition; case "anchorPoint": case "AnchorPoint": case "Anchor Point": case "ADBE AnchorPoint": case 1: return l.anchorPoint; case "opacity": case "Opacity": case 11: return l.opacity; default: return null } } Object.defineProperty(l, "rotation", { get: ExpressionPropertyInterface(o.r || o.rz) }), Object.defineProperty(l, "zRotation", { get: ExpressionPropertyInterface(o.rz || o.r) }), Object.defineProperty(l, "xRotation", { get: ExpressionPropertyInterface(o.rx) }), Object.defineProperty(l, "yRotation", { get: ExpressionPropertyInterface(o.ry) }), Object.defineProperty(l, "scale", { get: ExpressionPropertyInterface(o.s) }); var u, f, p, d; return o.p ? d = ExpressionPropertyInterface(o.p) : (u = ExpressionPropertyInterface(o.px), f = ExpressionPropertyInterface(o.py), o.pz && (p = ExpressionPropertyInterface(o.pz))), Object.defineProperty(l, "position", { get: function () { return o.p ? d() : [u(), f(), p ? p() : 0] } }), Object.defineProperty(l, "xPosition", { get: ExpressionPropertyInterface(o.px) }), Object.defineProperty(l, "yPosition", { get: ExpressionPropertyInterface(o.py) }), Object.defineProperty(l, "zPosition", { get: ExpressionPropertyInterface(o.pz) }), Object.defineProperty(l, "anchorPoint", { get: ExpressionPropertyInterface(o.a) }), Object.defineProperty(l, "opacity", { get: ExpressionPropertyInterface(o.o) }), Object.defineProperty(l, "skew", { get: ExpressionPropertyInterface(o.sk) }), Object.defineProperty(l, "skewAxis", { get: ExpressionPropertyInterface(o.sa) }), Object.defineProperty(l, "orientation", { get: ExpressionPropertyInterface(o.or) }), l } }(), LayerExpressionInterface = function () { function o(F) { var B = new Matrix; if (F !== void 0) { var W = this._elem.finalTransform.mProp.getValueAtTime(F); W.clone(B) } else { var Z = this._elem.finalTransform.mProp; Z.applyToMatrix(B) } return B } function l(F, B) { var W = this.getMatrix(B); return W.props[12] = 0, W.props[13] = 0, W.props[14] = 0, this.applyPoint(W, F) } function u(F, B) { var W = this.getMatrix(B); return this.applyPoint(W, F) } function f(F, B) { var W = this.getMatrix(B); return W.props[12] = 0, W.props[13] = 0, W.props[14] = 0, this.invertPoint(W, F) } function p(F, B) { var W = this.getMatrix(B); return this.invertPoint(W, F) } function d(F, B) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var W, Z = this._elem.hierarchy.length; for (W = 0; W < Z; W += 1)this._elem.hierarchy[W].finalTransform.mProp.applyToMatrix(F) } return F.applyToPointArray(B[0], B[1], B[2] || 0) } function m(F, B) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var W, Z = this._elem.hierarchy.length; for (W = 0; W < Z; W += 1)this._elem.hierarchy[W].finalTransform.mProp.applyToMatrix(F) } return F.inversePoint(B) } function v(F) { var B = new Matrix; if (B.reset(), this._elem.finalTransform.mProp.applyToMatrix(B), this._elem.hierarchy && this._elem.hierarchy.length) { var W, Z = this._elem.hierarchy.length; for (W = 0; W < Z; W += 1)this._elem.hierarchy[W].finalTransform.mProp.applyToMatrix(B); return B.inversePoint(F) } return B.inversePoint(F) } function I() { return [1, 1, 1, 1] } return function (F) { var B; function W(ne) { Q.mask = new MaskManagerInterface(ne, F) } function Z(ne) { Q.effect = ne } function Q(ne) { switch (ne) { case "ADBE Root Vectors Group": case "Contents": case 2: return Q.shapeInterface; case 1: case 6: case "Transform": case "transform": case "ADBE Transform Group": return B; case 4: case "ADBE Effect Parade": case "effects": case "Effects": return Q.effect; case "ADBE Text Properties": return Q.textInterface; default: return null } } Q.getMatrix = o, Q.invertPoint = m, Q.applyPoint = d, Q.toWorld = u, Q.toWorldVec = l, Q.fromWorld = p, Q.fromWorldVec = f, Q.toComp = u, Q.fromComp = v, Q.sampleImage = I, Q.sourceRectAtTime = F.sourceRectAtTime.bind(F), Q._elem = F, B = TransformExpressionInterface(F.finalTransform.mProp); var re = getDescriptor(B, "anchorPoint"); return Object.defineProperties(Q, { hasParent: { get: function () { return F.hierarchy.length } }, parent: { get: function () { return F.hierarchy[0].layerInterface } }, rotation: getDescriptor(B, "rotation"), scale: getDescriptor(B, "scale"), position: getDescriptor(B, "position"), opacity: getDescriptor(B, "opacity"), anchorPoint: re, anchor_point: re, transform: { get: function () { return B } }, active: { get: function () { return F.isInRange } } }), Q.startTime = F.data.st, Q.index = F.data.ind, Q.source = F.data.refId, Q.height = F.data.ty === 0 ? F.data.h : 100, Q.width = F.data.ty === 0 ? F.data.w : 100, Q.inPoint = F.data.ip / F.comp.globalData.frameRate, Q.outPoint = F.data.op / F.comp.globalData.frameRate, Q._name = F.data.nm, Q.registerMaskInterface = W, Q.registerEffectsInterface = Z, Q } }(), propertyGroupFactory = function () { return function (o, l) { return function (u) { return u = u === void 0 ? 1 : u, u <= 0 ? o : l(u - 1) } } }(), PropertyInterface = function () { return function (o, l) { var u = { _name: o }; function f(p) { return p = p === void 0 ? 1 : p, p <= 0 ? u : l(p - 1) } return f } }(), EffectsExpressionInterface = function () { var o = { createEffectsInterface: l }; function l(p, d) { if (p.effectsManager) { var m = [], v = p.data.ef, I, F = p.effectsManager.effectElements.length; for (I = 0; I < F; I += 1)m.push(u(v[I], p.effectsManager.effectElements[I], d, p)); var B = p.data.ef || [], W = function (Q) { for (I = 0, F = B.length; I < F;) { if (Q === B[I].nm || Q === B[I].mn || Q === B[I].ix) return m[I]; I += 1 } return null }; return Object.defineProperty(W, "numProperties", { get: function () { return B.length } }), W } return null } function u(p, d, m, v) { function I(Q) { for (var re = p.ef, ne = 0, oe = re.length; ne < oe;) { if (Q === re[ne].nm || Q === re[ne].mn || Q === re[ne].ix) return re[ne].ty === 5 ? B[ne] : B[ne](); ne += 1 } throw new Error } var F = propertyGroupFactory(I, m), B = [], W, Z = p.ef.length; for (W = 0; W < Z; W += 1)p.ef[W].ty === 5 ? B.push(u(p.ef[W], d.effectElements[W], d.effectElements[W].propertyGroup, v)) : B.push(f(d.effectElements[W], p.ef[W].ty, v, F)); return p.mn === "ADBE Color Control" && Object.defineProperty(I, "color", { get: function () { return B[0]() } }), Object.defineProperties(I, { numProperties: { get: function () { return p.np } }, _name: { value: p.nm }, propertyGroup: { value: F } }), I.enabled = p.en !== 0, I.active = I.enabled, I } function f(p, d, m, v) { var I = ExpressionPropertyInterface(p.p); function F() { return d === 10 ? m.comp.compInterface(p.p.v) : I() } return p.p.setGroupProperty && p.p.setGroupProperty(PropertyInterface("", v)), F } return o }(), ShapePathInterface = function () { return function (l, u, f) { var p = u.sh; function d(v) { return v === "Shape" || v === "shape" || v === "Path" || v === "path" || v === "ADBE Vector Shape" || v === 2 ? d.path : null } var m = propertyGroupFactory(d, f); return p.setGroupProperty(PropertyInterface("Path", m)), Object.defineProperties(d, { path: { get: function () { return p.k && p.getValue(), p } }, shape: { get: function () { return p.k && p.getValue(), p } }, _name: { value: l.nm }, ix: { value: l.ix }, propertyIndex: { value: l.ix }, mn: { value: l.mn }, propertyGroup: { value: f } }), d } }(), ShapeExpressionInterface = function () { function o(re, ne, oe) { var ae = [], se, le = re ? re.length : 0; for (se = 0; se < le; se += 1)re[se].ty === "gr" ? ae.push(u(re[se], ne[se], oe)) : re[se].ty === "fl" ? ae.push(f(re[se], ne[se], oe)) : re[se].ty === "st" ? ae.push(m(re[se], ne[se], oe)) : re[se].ty === "tm" ? ae.push(v(re[se], ne[se], oe)) : re[se].ty === "tr" || (re[se].ty === "el" ? ae.push(F(re[se], ne[se], oe)) : re[se].ty === "sr" ? ae.push(B(re[se], ne[se], oe)) : re[se].ty === "sh" ? ae.push(ShapePathInterface(re[se], ne[se], oe)) : re[se].ty === "rc" ? ae.push(W(re[se], ne[se], oe)) : re[se].ty === "rd" ? ae.push(Z(re[se], ne[se], oe)) : re[se].ty === "rp" ? ae.push(Q(re[se], ne[se], oe)) : re[se].ty === "gf" ? ae.push(p(re[se], ne[se], oe)) : ae.push(d(re[se], ne[se]))); return ae } function l(re, ne, oe) { var ae, se = function (he) { for (var pe = 0, ve = ae.length; pe < ve;) { if (ae[pe]._name === he || ae[pe].mn === he || ae[pe].propertyIndex === he || ae[pe].ix === he || ae[pe].ind === he) return ae[pe]; pe += 1 } return typeof he == "number" ? ae[he - 1] : null }; se.propertyGroup = propertyGroupFactory(se, oe), ae = o(re.it, ne.it, se.propertyGroup), se.numProperties = ae.length; var le = I(re.it[re.it.length - 1], ne.it[ne.it.length - 1], se.propertyGroup); return se.transform = le, se.propertyIndex = re.cix, se._name = re.nm, se } function u(re, ne, oe) { var ae = function (he) { switch (he) { case "ADBE Vectors Group": case "Contents": case 2: return ae.content; default: return ae.transform } }; ae.propertyGroup = propertyGroupFactory(ae, oe); var se = l(re, ne, ae.propertyGroup), le = I(re.it[re.it.length - 1], ne.it[ne.it.length - 1], ae.propertyGroup); return ae.content = se, ae.transform = le, Object.defineProperty(ae, "_name", { get: function () { return re.nm } }), ae.numProperties = re.np, ae.propertyIndex = re.ix, ae.nm = re.nm, ae.mn = re.mn, ae } function f(re, ne, oe) { function ae(se) { return se === "Color" || se === "color" ? ae.color : se === "Opacity" || se === "opacity" ? ae.opacity : null } return Object.defineProperties(ae, { color: { get: ExpressionPropertyInterface(ne.c) }, opacity: { get: ExpressionPropertyInterface(ne.o) }, _name: { value: re.nm }, mn: { value: re.mn } }), ne.c.setGroupProperty(PropertyInterface("Color", oe)), ne.o.setGroupProperty(PropertyInterface("Opacity", oe)), ae } function p(re, ne, oe) { function ae(se) { return se === "Start Point" || se === "start point" ? ae.startPoint : se === "End Point" || se === "end point" ? ae.endPoint : se === "Opacity" || se === "opacity" ? ae.opacity : null } return Object.defineProperties(ae, { startPoint: { get: ExpressionPropertyInterface(ne.s) }, endPoint: { get: ExpressionPropertyInterface(ne.e) }, opacity: { get: ExpressionPropertyInterface(ne.o) }, type: { get: function () { return "a" } }, _name: { value: re.nm }, mn: { value: re.mn } }), ne.s.setGroupProperty(PropertyInterface("Start Point", oe)), ne.e.setGroupProperty(PropertyInterface("End Point", oe)), ne.o.setGroupProperty(PropertyInterface("Opacity", oe)), ae } function d() { function re() { return null } return re } function m(re, ne, oe) { var ae = propertyGroupFactory(ve, oe), se = propertyGroupFactory(pe, ae); function le(_e) { Object.defineProperty(pe, re.d[_e].nm, { get: ExpressionPropertyInterface(ne.d.dataProps[_e].p) }) } var ue, he = re.d ? re.d.length : 0, pe = {}; for (ue = 0; ue < he; ue += 1)le(ue), ne.d.dataProps[ue].p.setGroupProperty(se); function ve(_e) { return _e === "Color" || _e === "color" ? ve.color : _e === "Opacity" || _e === "opacity" ? ve.opacity : _e === "Stroke Width" || _e === "stroke width" ? ve.strokeWidth : null } return Object.defineProperties(ve, { color: { get: ExpressionPropertyInterface(ne.c) }, opacity: { get: ExpressionPropertyInterface(ne.o) }, strokeWidth: { get: ExpressionPropertyInterface(ne.w) }, dash: { get: function () { return pe } }, _name: { value: re.nm }, mn: { value: re.mn } }), ne.c.setGroupProperty(PropertyInterface("Color", ae)), ne.o.setGroupProperty(PropertyInterface("Opacity", ae)), ne.w.setGroupProperty(PropertyInterface("Stroke Width", ae)), ve } function v(re, ne, oe) { function ae(le) { return le === re.e.ix || le === "End" || le === "end" ? ae.end : le === re.s.ix ? ae.start : le === re.o.ix ? ae.offset : null } var se = propertyGroupFactory(ae, oe); return ae.propertyIndex = re.ix, ne.s.setGroupProperty(PropertyInterface("Start", se)), ne.e.setGroupProperty(PropertyInterface("End", se)), ne.o.setGroupProperty(PropertyInterface("Offset", se)), ae.propertyIndex = re.ix, ae.propertyGroup = oe, Object.defineProperties(ae, { start: { get: ExpressionPropertyInterface(ne.s) }, end: { get: ExpressionPropertyInterface(ne.e) }, offset: { get: ExpressionPropertyInterface(ne.o) }, _name: { value: re.nm } }), ae.mn = re.mn, ae } function I(re, ne, oe) { function ae(le) { return re.a.ix === le || le === "Anchor Point" ? ae.anchorPoint : re.o.ix === le || le === "Opacity" ? ae.opacity : re.p.ix === le || le === "Position" ? ae.position : re.r.ix === le || le === "Rotation" || le === "ADBE Vector Rotation" ? ae.rotation : re.s.ix === le || le === "Scale" ? ae.scale : re.sk && re.sk.ix === le || le === "Skew" ? ae.skew : re.sa && re.sa.ix === le || le === "Skew Axis" ? ae.skewAxis : null } var se = propertyGroupFactory(ae, oe); return ne.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", se)), ne.transform.mProps.p.setGroupProperty(PropertyInterface("Position", se)), ne.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", se)), ne.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", se)), ne.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", se)), ne.transform.mProps.sk && (ne.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", se)), ne.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", se))), ne.transform.op.setGroupProperty(PropertyInterface("Opacity", se)), Object.defineProperties(ae, { opacity: { get: ExpressionPropertyInterface(ne.transform.mProps.o) }, position: { get: ExpressionPropertyInterface(ne.transform.mProps.p) }, anchorPoint: { get: ExpressionPropertyInterface(ne.transform.mProps.a) }, scale: { get: ExpressionPropertyInterface(ne.transform.mProps.s) }, rotation: { get: ExpressionPropertyInterface(ne.transform.mProps.r) }, skew: { get: ExpressionPropertyInterface(ne.transform.mProps.sk) }, skewAxis: { get: ExpressionPropertyInterface(ne.transform.mProps.sa) }, _name: { value: re.nm } }), ae.ty = "tr", ae.mn = re.mn, ae.propertyGroup = oe, ae } function F(re, ne, oe) { function ae(ue) { return re.p.ix === ue ? ae.position : re.s.ix === ue ? ae.size : null } var se = propertyGroupFactory(ae, oe); ae.propertyIndex = re.ix; var le = ne.sh.ty === "tm" ? ne.sh.prop : ne.sh; return le.s.setGroupProperty(PropertyInterface("Size", se)), le.p.setGroupProperty(PropertyInterface("Position", se)), Object.defineProperties(ae, { size: { get: ExpressionPropertyInterface(le.s) }, position: { get: ExpressionPropertyInterface(le.p) }, _name: { value: re.nm } }), ae.mn = re.mn, ae } function B(re, ne, oe) { function ae(ue) { return re.p.ix === ue ? ae.position : re.r.ix === ue ? ae.rotation : re.pt.ix === ue ? ae.points : re.or.ix === ue || ue === "ADBE Vector Star Outer Radius" ? ae.outerRadius : re.os.ix === ue ? ae.outerRoundness : re.ir && (re.ir.ix === ue || ue === "ADBE Vector Star Inner Radius") ? ae.innerRadius : re.is && re.is.ix === ue ? ae.innerRoundness : null } var se = propertyGroupFactory(ae, oe), le = ne.sh.ty === "tm" ? ne.sh.prop : ne.sh; return ae.propertyIndex = re.ix, le.or.setGroupProperty(PropertyInterface("Outer Radius", se)), le.os.setGroupProperty(PropertyInterface("Outer Roundness", se)), le.pt.setGroupProperty(PropertyInterface("Points", se)), le.p.setGroupProperty(PropertyInterface("Position", se)), le.r.setGroupProperty(PropertyInterface("Rotation", se)), re.ir && (le.ir.setGroupProperty(PropertyInterface("Inner Radius", se)), le.is.setGroupProperty(PropertyInterface("Inner Roundness", se))), Object.defineProperties(ae, { position: { get: ExpressionPropertyInterface(le.p) }, rotation: { get: ExpressionPropertyInterface(le.r) }, points: { get: ExpressionPropertyInterface(le.pt) }, outerRadius: { get: ExpressionPropertyInterface(le.or) }, outerRoundness: { get: ExpressionPropertyInterface(le.os) }, innerRadius: { get: ExpressionPropertyInterface(le.ir) }, innerRoundness: { get: ExpressionPropertyInterface(le.is) }, _name: { value: re.nm } }), ae.mn = re.mn, ae } function W(re, ne, oe) { function ae(ue) { return re.p.ix === ue ? ae.position : re.r.ix === ue ? ae.roundness : re.s.ix === ue || ue === "Size" || ue === "ADBE Vector Rect Size" ? ae.size : null } var se = propertyGroupFactory(ae, oe), le = ne.sh.ty === "tm" ? ne.sh.prop : ne.sh; return ae.propertyIndex = re.ix, le.p.setGroupProperty(PropertyInterface("Position", se)), le.s.setGroupProperty(PropertyInterface("Size", se)), le.r.setGroupProperty(PropertyInterface("Rotation", se)), Object.defineProperties(ae, { position: { get: ExpressionPropertyInterface(le.p) }, roundness: { get: ExpressionPropertyInterface(le.r) }, size: { get: ExpressionPropertyInterface(le.s) }, _name: { value: re.nm } }), ae.mn = re.mn, ae } function Z(re, ne, oe) { function ae(ue) { return re.r.ix === ue || ue === "Round Corners 1" ? ae.radius : null } var se = propertyGroupFactory(ae, oe), le = ne; return ae.propertyIndex = re.ix, le.rd.setGroupProperty(PropertyInterface("Radius", se)), Object.defineProperties(ae, { radius: { get: ExpressionPropertyInterface(le.rd) }, _name: { value: re.nm } }), ae.mn = re.mn, ae } function Q(re, ne, oe) { function ae(ue) { return re.c.ix === ue || ue === "Copies" ? ae.copies : re.o.ix === ue || ue === "Offset" ? ae.offset : null } var se = propertyGroupFactory(ae, oe), le = ne; return ae.propertyIndex = re.ix, le.c.setGroupProperty(PropertyInterface("Copies", se)), le.o.setGroupProperty(PropertyInterface("Offset", se)), Object.defineProperties(ae, { copies: { get: ExpressionPropertyInterface(le.c) }, offset: { get: ExpressionPropertyInterface(le.o) }, _name: { value: re.nm } }), ae.mn = re.mn, ae } return function (re, ne, oe) { var ae; function se(ue) { if (typeof ue == "number") return ue = ue === void 0 ? 1 : ue, ue === 0 ? oe : ae[ue - 1]; for (var he = 0, pe = ae.length; he < pe;) { if (ae[he]._name === ue) return ae[he]; he += 1 } return null } function le() { return oe } return se.propertyGroup = propertyGroupFactory(se, le), ae = o(re, ne, se.propertyGroup), se.numProperties = ae.length, se._name = "Contents", se } }(), TextExpressionInterface = function () { return function (o) { var l; function u(f) { switch (f) { case "ADBE Text Document": return u.sourceText; default: return null } } return Object.defineProperty(u, "sourceText", { get: function () { o.textProperty.getValue(); var p = o.textProperty.currentData.t; return (!l || p !== l.value) && (l = new String(p), l.value = p || new String(p), Object.defineProperty(l, "style", { get: function () { return { fillColor: o.textProperty.currentData.fc } } })), l } }), u } }(); function _typeof(o) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function (u) { return typeof u } : _typeof = function (u) { return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u }, _typeof(o) } var FootageInterface = function () { var o = function (f) { var p = "", d = f.getFootageData(); function m() { return p = "", d = f.getFootageData(), v } function v(I) { if (d[I]) return p = I, d = d[I], _typeof(d) === "object" ? v : d; var F = I.indexOf(p); if (F !== -1) { var B = parseInt(I.substr(F + p.length), 10); return d = d[B], _typeof(d) === "object" ? v : d } return "" } return m }, l = function (f) { function p(d) { return d === "Outline" ? p.outlineInterface() : null } return p._name = "Outline", p.outlineInterface = o(f), p }; return function (u) { function f(p) { return p === "Data" ? f.dataInterface : null } return f._name = "Data", f.dataInterface = l(u), f } }(), interfaces = { layer: LayerExpressionInterface, effects: EffectsExpressionInterface, comp: CompExpressionInterface, shape: ShapeExpressionInterface, text: TextExpressionInterface, footage: FootageInterface }; function getInterface(o) { return interfaces[o] || null } var expressionHelpers = function () { function o(m, v, I) { v.x && (I.k = !0, I.x = !0, I.initiateExpression = ExpressionManager.initiateExpression, I.effectsSequence.push(I.initiateExpression(m, v, I).bind(I))) } function l(m) { return m *= this.elem.globalData.frameRate, m -= this.offsetTime, m !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < m ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(m, this._cachingAtTime), this._cachingAtTime.lastFrame = m), this._cachingAtTime.value } function u(m) { var v = -.01, I = this.getValueAtTime(m), F = this.getValueAtTime(m + v), B = 0; if (I.length) { var W; for (W = 0; W < I.length; W += 1)B += Math.pow(F[W] - I[W], 2); B = Math.sqrt(B) * 100 } else B = 0; return B } function f(m) { if (this.vel !== void 0) return this.vel; var v = -.001, I = this.getValueAtTime(m), F = this.getValueAtTime(m + v), B; if (I.length) { B = createTypedArray("float32", I.length); var W; for (W = 0; W < I.length; W += 1)B[W] = (F[W] - I[W]) / v } else B = (F - I) / v; return B } function p() { return this.pv } function d(m) { this.propertyGroup = m } return { searchExpressions: o, getSpeedAtTime: u, getVelocityAtTime: f, getValueAtTime: l, getStaticValueAtTime: p, setGroupProperty: d } }(); function addPropertyDecorator() { function o(Z, Q, re) { if (!this.k || !this.keyframes) return this.pv; Z = Z ? Z.toLowerCase() : ""; var ne = this.comp.renderedFrame, oe = this.keyframes, ae = oe[oe.length - 1].t; if (ne <= ae) return this.pv; var se, le; re ? (Q ? se = Math.abs(ae - this.elem.comp.globalData.frameRate * Q) : se = Math.max(0, ae - this.elem.data.ip), le = ae - se) : ((!Q || Q > oe.length - 1) && (Q = oe.length - 1), le = oe[oe.length - 1 - Q].t, se = ae - le); var ue, he, pe; if (Z === "pingpong") { var ve = Math.floor((ne - le) / se); if (ve % 2 !== 0) return this.getValueAtTime((se - (ne - le) % se + le) / this.comp.globalData.frameRate, 0) } else if (Z === "offset") { var _e = this.getValueAtTime(le / this.comp.globalData.frameRate, 0), Se = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), $e = this.getValueAtTime(((ne - le) % se + le) / this.comp.globalData.frameRate, 0), ie = Math.floor((ne - le) / se); if (this.pv.length) { for (pe = new Array(_e.length), he = pe.length, ue = 0; ue < he; ue += 1)pe[ue] = (Se[ue] - _e[ue]) * ie + $e[ue]; return pe } return (Se - _e) * ie + $e } else if (Z === "continue") { var g = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), P = this.getValueAtTime((ae - .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (pe = new Array(g.length), he = pe.length, ue = 0; ue < he; ue += 1)pe[ue] = g[ue] + (g[ue] - P[ue]) * ((ne - ae) / this.comp.globalData.frameRate) / 5e-4; return pe } return g + (g - P) * ((ne - ae) / .001) } return this.getValueAtTime(((ne - le) % se + le) / this.comp.globalData.frameRate, 0) } function l(Z, Q, re) { if (!this.k) return this.pv; Z = Z ? Z.toLowerCase() : ""; var ne = this.comp.renderedFrame, oe = this.keyframes, ae = oe[0].t; if (ne >= ae) return this.pv; var se, le; re ? (Q ? se = Math.abs(this.elem.comp.globalData.frameRate * Q) : se = Math.max(0, this.elem.data.op - ae), le = ae + se) : ((!Q || Q > oe.length - 1) && (Q = oe.length - 1), le = oe[Q].t, se = le - ae); var ue, he, pe; if (Z === "pingpong") { var ve = Math.floor((ae - ne) / se); if (ve % 2 === 0) return this.getValueAtTime(((ae - ne) % se + ae) / this.comp.globalData.frameRate, 0) } else if (Z === "offset") { var _e = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), Se = this.getValueAtTime(le / this.comp.globalData.frameRate, 0), $e = this.getValueAtTime((se - (ae - ne) % se + ae) / this.comp.globalData.frameRate, 0), ie = Math.floor((ae - ne) / se) + 1; if (this.pv.length) { for (pe = new Array(_e.length), he = pe.length, ue = 0; ue < he; ue += 1)pe[ue] = $e[ue] - (Se[ue] - _e[ue]) * ie; return pe } return $e - (Se - _e) * ie } else if (Z === "continue") { var g = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), P = this.getValueAtTime((ae + .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (pe = new Array(g.length), he = pe.length, ue = 0; ue < he; ue += 1)pe[ue] = g[ue] + (g[ue] - P[ue]) * (ae - ne) / .001; return pe } return g + (g - P) * (ae - ne) / .001 } return this.getValueAtTime((se - ((ae - ne) % se + ae)) / this.comp.globalData.frameRate, 0) } function u(Z, Q) { if (!this.k) return this.pv; if (Z = (Z || .4) * .5, Q = Math.floor(Q || 5), Q <= 1) return this.pv; var re = this.comp.renderedFrame / this.comp.globalData.frameRate, ne = re - Z, oe = re + Z, ae = Q > 1 ? (oe - ne) / (Q - 1) : 1, se = 0, le = 0, ue; this.pv.length ? ue = createTypedArray("float32", this.pv.length) : ue = 0; for (var he; se < Q;) { if (he = this.getValueAtTime(ne + se * ae), this.pv.length) for (le = 0; le < this.pv.length; le += 1)ue[le] += he[le]; else ue += he; se += 1 } if (this.pv.length) for (le = 0; le < this.pv.length; le += 1)ue[le] /= Q; else ue /= Q; return ue } function f(Z) { this._transformCachingAtTime || (this._transformCachingAtTime = { v: new Matrix }); var Q = this._transformCachingAtTime.v; if (Q.cloneFromProps(this.pre.props), this.appliedTransformations < 1) { var re = this.a.getValueAtTime(Z); Q.translate(-re[0] * this.a.mult, -re[1] * this.a.mult, re[2] * this.a.mult) } if (this.appliedTransformations < 2) { var ne = this.s.getValueAtTime(Z); Q.scale(ne[0] * this.s.mult, ne[1] * this.s.mult, ne[2] * this.s.mult) } if (this.sk && this.appliedTransformations < 3) { var oe = this.sk.getValueAtTime(Z), ae = this.sa.getValueAtTime(Z); Q.skewFromAxis(-oe * this.sk.mult, ae * this.sa.mult) } if (this.r && this.appliedTransformations < 4) { var se = this.r.getValueAtTime(Z); Q.rotate(-se * this.r.mult) } else if (!this.r && this.appliedTransformations < 4) { var le = this.rz.getValueAtTime(Z), ue = this.ry.getValueAtTime(Z), he = this.rx.getValueAtTime(Z), pe = this.or.getValueAtTime(Z); Q.rotateZ(-le * this.rz.mult).rotateY(ue * this.ry.mult).rotateX(he * this.rx.mult).rotateZ(-pe[2] * this.or.mult).rotateY(pe[1] * this.or.mult).rotateX(pe[0] * this.or.mult) } if (this.data.p && this.data.p.s) { var ve = this.px.getValueAtTime(Z), _e = this.py.getValueAtTime(Z); if (this.data.p.z) { var Se = this.pz.getValueAtTime(Z); Q.translate(ve * this.px.mult, _e * this.py.mult, -Se * this.pz.mult) } else Q.translate(ve * this.px.mult, _e * this.py.mult, 0) } else { var $e = this.p.getValueAtTime(Z); Q.translate($e[0] * this.p.mult, $e[1] * this.p.mult, -$e[2] * this.p.mult) } return Q } function p() { return this.v.clone(new Matrix) } var d = TransformPropertyFactory.getTransformProperty; TransformPropertyFactory.getTransformProperty = function (Z, Q, re) { var ne = d(Z, Q, re); return ne.dynamicProperties.length ? ne.getValueAtTime = f.bind(ne) : ne.getValueAtTime = p.bind(ne), ne.setGroupProperty = expressionHelpers.setGroupProperty, ne }; var m = PropertyFactory.getProp; PropertyFactory.getProp = function (Z, Q, re, ne, oe) { var ae = m(Z, Q, re, ne, oe); ae.kf ? ae.getValueAtTime = expressionHelpers.getValueAtTime.bind(ae) : ae.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(ae), ae.setGroupProperty = expressionHelpers.setGroupProperty, ae.loopOut = o, ae.loopIn = l, ae.smooth = u, ae.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(ae), ae.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(ae), ae.numKeys = Q.a === 1 ? Q.k.length : 0, ae.propertyIndex = Q.ix; var se = 0; return re !== 0 && (se = createTypedArray("float32", Q.a === 1 ? Q.k[0].s.length : Q.k.length)), ae._cachingAtTime = { lastFrame: initialDefaultFrame, lastIndex: 0, value: se }, expressionHelpers.searchExpressions(Z, Q, ae), ae.k && oe.addDynamicProperty(ae), ae }; function v(Z) { return this._cachingAtTime || (this._cachingAtTime = { shapeValue: shapePool.clone(this.pv), lastIndex: 0, lastTime: initialDefaultFrame }), Z *= this.elem.globalData.frameRate, Z -= this.offsetTime, Z !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < Z ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = Z, this.interpolateShape(Z, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue } var I = ShapePropertyFactory.getConstructorFunction(), F = ShapePropertyFactory.getKeyframedConstructorFunction(); function B() { } B.prototype = { vertices: function (Q, re) { this.k && this.getValue(); var ne = this.v; re !== void 0 && (ne = this.getValueAtTime(re, 0)); var oe, ae = ne._length, se = ne[Q], le = ne.v, ue = createSizedArray(ae); for (oe = 0; oe < ae; oe += 1)Q === "i" || Q === "o" ? ue[oe] = [se[oe][0] - le[oe][0], se[oe][1] - le[oe][1]] : ue[oe] = [se[oe][0], se[oe][1]]; return ue }, points: function (Q) { return this.vertices("v", Q) }, inTangents: function (Q) { return this.vertices("i", Q) }, outTangents: function (Q) { return this.vertices("o", Q) }, isClosed: function () { return this.v.c }, pointOnPath: function (Q, re) { var ne = this.v; re !== void 0 && (ne = this.getValueAtTime(re, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(ne)); for (var oe = this._segmentsLength, ae = oe.lengths, se = oe.totalLength * Q, le = 0, ue = ae.length, he = 0, pe; le < ue;) { if (he + ae[le].addedLength > se) { var ve = le, _e = ne.c && le === ue - 1 ? 0 : le + 1, Se = (se - he) / ae[le].addedLength; pe = bez.getPointInSegment(ne.v[ve], ne.v[_e], ne.o[ve], ne.i[_e], Se, ae[le]); break } else he += ae[le].addedLength; le += 1 } return pe || (pe = ne.c ? [ne.v[0][0], ne.v[0][1]] : [ne.v[ne._length - 1][0], ne.v[ne._length - 1][1]]), pe }, vectorOnPath: function (Q, re, ne) { Q == 1 ? Q = this.v.c : Q == 0 && (Q = .999); var oe = this.pointOnPath(Q, re), ae = this.pointOnPath(Q + .001, re), se = ae[0] - oe[0], le = ae[1] - oe[1], ue = Math.sqrt(Math.pow(se, 2) + Math.pow(le, 2)); if (ue === 0) return [0, 0]; var he = ne === "tangent" ? [se / ue, le / ue] : [-le / ue, se / ue]; return he }, tangentOnPath: function (Q, re) { return this.vectorOnPath(Q, re, "tangent") }, normalOnPath: function (Q, re) { return this.vectorOnPath(Q, re, "normal") }, setGroupProperty: expressionHelpers.setGroupProperty, getValueAtTime: expressionHelpers.getStaticValueAtTime }, extendPrototype([B], I), extendPrototype([B], F), F.prototype.getValueAtTime = v, F.prototype.initiateExpression = ExpressionManager.initiateExpression; var W = ShapePropertyFactory.getShapeProp; ShapePropertyFactory.getShapeProp = function (Z, Q, re, ne, oe) { var ae = W(Z, Q, re, ne, oe); return ae.propertyIndex = Q.ix, ae.lock = !1, re === 3 ? expressionHelpers.searchExpressions(Z, Q.pt, ae) : re === 4 && expressionHelpers.searchExpressions(Z, Q.ks, ae), ae.k && Z.addDynamicProperty(ae), ae } } function initialize$1() { addPropertyDecorator() } function addDecorator() { function o() { return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null } TextProperty.prototype.getExpressionValue = function (l, u) { var f = this.calculateExpression(u); if (l.t !== f) { var p = {}; return this.copyData(p, l), p.t = f.toString(), p.__complete = !1, p } return l }, TextProperty.prototype.searchProperty = function () { var l = this.searchKeyframes(), u = this.searchExpressions(); return this.kf = l || u, this.kf }, TextProperty.prototype.searchExpressions = o } function initialize() { addDecorator() } function SVGComposableEffect() { } SVGComposableEffect.prototype = { createMergeNode: function o(l, u) { var f = createNS("feMerge"); f.setAttribute("result", l); var p, d; for (d = 0; d < u.length; d += 1)p = createNS("feMergeNode"), p.setAttribute("in", u[d]), f.appendChild(p), f.appendChild(p); return f } }; var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0"; function SVGTintFilter(o, l, u, f, p) { this.filterManager = l; var d = createNS("feColorMatrix"); d.setAttribute("type", "matrix"), d.setAttribute("color-interpolation-filters", "linearRGB"), d.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = d, d.setAttribute("result", f + "_tint_1"), o.appendChild(d), d = createNS("feColorMatrix"), d.setAttribute("type", "matrix"), d.setAttribute("color-interpolation-filters", "sRGB"), d.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), d.setAttribute("result", f + "_tint_2"), o.appendChild(d), this.matrixFilter = d; var m = this.createMergeNode(f, [p, f + "_tint_1", f + "_tint_2"]); o.appendChild(m) } extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function (o) { if (o || this.filterManager._mdf) { var l = this.filterManager.effectElements[0].p.v, u = this.filterManager.effectElements[1].p.v, f = this.filterManager.effectElements[2].p.v / 100; this.linearFilter.setAttribute("values", linearFilterValue + " " + f + " 0"), this.matrixFilter.setAttribute("values", u[0] - l[0] + " 0 0 0 " + l[0] + " " + (u[1] - l[1]) + " 0 0 0 " + l[1] + " " + (u[2] - l[2]) + " 0 0 0 " + l[2] + " 0 0 0 1 0") } }; function SVGFillFilter(o, l, u, f) { this.filterManager = l; var p = createNS("feColorMatrix"); p.setAttribute("type", "matrix"), p.setAttribute("color-interpolation-filters", "sRGB"), p.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), p.setAttribute("result", f), o.appendChild(p), this.matrixFilter = p } SVGFillFilter.prototype.renderFrame = function (o) { if (o || this.filterManager._mdf) { var l = this.filterManager.effectElements[2].p.v, u = this.filterManager.effectElements[6].p.v; this.matrixFilter.setAttribute("values", "0 0 0 0 " + l[0] + " 0 0 0 0 " + l[1] + " 0 0 0 0 " + l[2] + " 0 0 0 " + u + " 0") } }; function SVGStrokeEffect(o, l, u) { this.initialized = !1, this.filterManager = l, this.elem = u, this.paths = [] } SVGStrokeEffect.prototype.initialize = function () { var o = this.elem.layerElement.children || this.elem.layerElement.childNodes, l, u, f, p; for (this.filterManager.effectElements[1].p.v === 1 ? (p = this.elem.maskManager.masksProperties.length, f = 0) : (f = this.filterManager.effectElements[0].p.v - 1, p = f + 1), u = createNS("g"), u.setAttribute("fill", "none"), u.setAttribute("stroke-linecap", "round"), u.setAttribute("stroke-dashoffset", 1), f; f < p; f += 1)l = createNS("path"), u.appendChild(l), this.paths.push({ p: l, m: f }); if (this.filterManager.effectElements[10].p.v === 3) { var d = createNS("mask"), m = createElementID(); d.setAttribute("id", m), d.setAttribute("mask-type", "alpha"), d.appendChild(u), this.elem.globalData.defs.appendChild(d); var v = createNS("g"); for (v.setAttribute("mask", "url(" + getLocationHref() + "#" + m + ")"); o[0];)v.appendChild(o[0]); this.elem.layerElement.appendChild(v), this.masker = d, u.setAttribute("stroke", "#fff") } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) { if (this.filterManager.effectElements[10].p.v === 2) for (o = this.elem.layerElement.children || this.elem.layerElement.childNodes; o.length;)this.elem.layerElement.removeChild(o[0]); this.elem.layerElement.appendChild(u), this.elem.layerElement.removeAttribute("mask"), u.setAttribute("stroke", "#fff") } this.initialized = !0, this.pathMasker = u }, SVGStrokeEffect.prototype.renderFrame = function (o) { this.initialized || this.initialize(); var l, u = this.paths.length, f, p; for (l = 0; l < u; l += 1)if (this.paths[l].m !== -1 && (f = this.elem.maskManager.viewData[this.paths[l].m], p = this.paths[l].p, (o || this.filterManager._mdf || f.prop._mdf) && p.setAttribute("d", f.lastPath), o || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || f.prop._mdf)) { var d; if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) { var m = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01, v = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01, I = p.getTotalLength(); d = "0 0 0 " + I * m + " "; var F = I * (v - m), B = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, W = Math.floor(F / B), Z; for (Z = 0; Z < W; Z += 1)d += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " "; d += "0 " + I * 10 + " 0 0" } else d = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01; p.setAttribute("stroke-dasharray", d) } if ((o || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (o || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (o || this.filterManager.effectElements[3].p._mdf)) { var Q = this.filterManager.effectElements[3].p.v; this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(Q[0] * 255) + "," + bmFloor(Q[1] * 255) + "," + bmFloor(Q[2] * 255) + ")") } }; function SVGTritoneFilter(o, l, u, f) { this.filterManager = l; var p = createNS("feColorMatrix"); p.setAttribute("type", "matrix"), p.setAttribute("color-interpolation-filters", "linearRGB"), p.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), o.appendChild(p); var d = createNS("feComponentTransfer"); d.setAttribute("color-interpolation-filters", "sRGB"), d.setAttribute("result", f), this.matrixFilter = d; var m = createNS("feFuncR"); m.setAttribute("type", "table"), d.appendChild(m), this.feFuncR = m; var v = createNS("feFuncG"); v.setAttribute("type", "table"), d.appendChild(v), this.feFuncG = v; var I = createNS("feFuncB"); I.setAttribute("type", "table"), d.appendChild(I), this.feFuncB = I, o.appendChild(d) } SVGTritoneFilter.prototype.renderFrame = function (o) { if (o || this.filterManager._mdf) { var l = this.filterManager.effectElements[0].p.v, u = this.filterManager.effectElements[1].p.v, f = this.filterManager.effectElements[2].p.v, p = f[0] + " " + u[0] + " " + l[0], d = f[1] + " " + u[1] + " " + l[1], m = f[2] + " " + u[2] + " " + l[2]; this.feFuncR.setAttribute("tableValues", p), this.feFuncG.setAttribute("tableValues", d), this.feFuncB.setAttribute("tableValues", m) } }; function SVGProLevelsFilter(o, l, u, f) { this.filterManager = l; var p = this.filterManager.effectElements, d = createNS("feComponentTransfer"); (p[10].p.k || p[10].p.v !== 0 || p[11].p.k || p[11].p.v !== 1 || p[12].p.k || p[12].p.v !== 1 || p[13].p.k || p[13].p.v !== 0 || p[14].p.k || p[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", d)), (p[17].p.k || p[17].p.v !== 0 || p[18].p.k || p[18].p.v !== 1 || p[19].p.k || p[19].p.v !== 1 || p[20].p.k || p[20].p.v !== 0 || p[21].p.k || p[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", d)), (p[24].p.k || p[24].p.v !== 0 || p[25].p.k || p[25].p.v !== 1 || p[26].p.k || p[26].p.v !== 1 || p[27].p.k || p[27].p.v !== 0 || p[28].p.k || p[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", d)), (p[31].p.k || p[31].p.v !== 0 || p[32].p.k || p[32].p.v !== 1 || p[33].p.k || p[33].p.v !== 1 || p[34].p.k || p[34].p.v !== 0 || p[35].p.k || p[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", d)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (d.setAttribute("color-interpolation-filters", "sRGB"), o.appendChild(d)), (p[3].p.k || p[3].p.v !== 0 || p[4].p.k || p[4].p.v !== 1 || p[5].p.k || p[5].p.v !== 1 || p[6].p.k || p[6].p.v !== 0 || p[7].p.k || p[7].p.v !== 1) && (d = createNS("feComponentTransfer"), d.setAttribute("color-interpolation-filters", "sRGB"), d.setAttribute("result", f), o.appendChild(d), this.feFuncRComposed = this.createFeFunc("feFuncR", d), this.feFuncGComposed = this.createFeFunc("feFuncG", d), this.feFuncBComposed = this.createFeFunc("feFuncB", d)) } SVGProLevelsFilter.prototype.createFeFunc = function (o, l) { var u = createNS(o); return u.setAttribute("type", "table"), l.appendChild(u), u }, SVGProLevelsFilter.prototype.getTableValue = function (o, l, u, f, p) { for (var d = 0, m = 256, v, I = Math.min(o, l), F = Math.max(o, l), B = Array.call(null, { length: m }), W, Z = 0, Q = p - f, re = l - o; d <= 256;)v = d / 256, v <= I ? W = re < 0 ? p : f : v >= F ? W = re < 0 ? f : p : W = f + Q * Math.pow((v - o) / re, 1 / u), B[Z] = W, Z += 1, d += 256 / (m - 1); return B.join(" ") }, SVGProLevelsFilter.prototype.renderFrame = function (o) { if (o || this.filterManager._mdf) { var l, u = this.filterManager.effectElements; this.feFuncRComposed && (o || u[3].p._mdf || u[4].p._mdf || u[5].p._mdf || u[6].p._mdf || u[7].p._mdf) && (l = this.getTableValue(u[3].p.v, u[4].p.v, u[5].p.v, u[6].p.v, u[7].p.v), this.feFuncRComposed.setAttribute("tableValues", l), this.feFuncGComposed.setAttribute("tableValues", l), this.feFuncBComposed.setAttribute("tableValues", l)), this.feFuncR && (o || u[10].p._mdf || u[11].p._mdf || u[12].p._mdf || u[13].p._mdf || u[14].p._mdf) && (l = this.getTableValue(u[10].p.v, u[11].p.v, u[12].p.v, u[13].p.v, u[14].p.v), this.feFuncR.setAttribute("tableValues", l)), this.feFuncG && (o || u[17].p._mdf || u[18].p._mdf || u[19].p._mdf || u[20].p._mdf || u[21].p._mdf) && (l = this.getTableValue(u[17].p.v, u[18].p.v, u[19].p.v, u[20].p.v, u[21].p.v), this.feFuncG.setAttribute("tableValues", l)), this.feFuncB && (o || u[24].p._mdf || u[25].p._mdf || u[26].p._mdf || u[27].p._mdf || u[28].p._mdf) && (l = this.getTableValue(u[24].p.v, u[25].p.v, u[26].p.v, u[27].p.v, u[28].p.v), this.feFuncB.setAttribute("tableValues", l)), this.feFuncA && (o || u[31].p._mdf || u[32].p._mdf || u[33].p._mdf || u[34].p._mdf || u[35].p._mdf) && (l = this.getTableValue(u[31].p.v, u[32].p.v, u[33].p.v, u[34].p.v, u[35].p.v), this.feFuncA.setAttribute("tableValues", l)) } }; function SVGDropShadowEffect(o, l, u, f, p) { var d = l.container.globalData.renderConfig.filterSize, m = l.data.fs || d; o.setAttribute("x", m.x || d.x), o.setAttribute("y", m.y || d.y), o.setAttribute("width", m.width || d.width), o.setAttribute("height", m.height || d.height), this.filterManager = l; var v = createNS("feGaussianBlur"); v.setAttribute("in", "SourceAlpha"), v.setAttribute("result", f + "_drop_shadow_1"), v.setAttribute("stdDeviation", "0"), this.feGaussianBlur = v, o.appendChild(v); var I = createNS("feOffset"); I.setAttribute("dx", "25"), I.setAttribute("dy", "0"), I.setAttribute("in", f + "_drop_shadow_1"), I.setAttribute("result", f + "_drop_shadow_2"), this.feOffset = I, o.appendChild(I); var F = createNS("feFlood"); F.setAttribute("flood-color", "#00ff00"), F.setAttribute("flood-opacity", "1"), F.setAttribute("result", f + "_drop_shadow_3"), this.feFlood = F, o.appendChild(F); var B = createNS("feComposite"); B.setAttribute("in", f + "_drop_shadow_3"), B.setAttribute("in2", f + "_drop_shadow_2"), B.setAttribute("operator", "in"), B.setAttribute("result", f + "_drop_shadow_4"), o.appendChild(B); var W = this.createMergeNode(f, [f + "_drop_shadow_4", p]); o.appendChild(W) } extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function (o) { if (o || this.filterManager._mdf) { if ((o || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), o || this.filterManager.effectElements[0].p._mdf) { var l = this.filterManager.effectElements[0].p.v; this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(l[0] * 255), Math.round(l[1] * 255), Math.round(l[2] * 255))) } if ((o || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), o || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) { var u = this.filterManager.effectElements[3].p.v, f = (this.filterManager.effectElements[2].p.v - 90) * degToRads, p = u * Math.cos(f), d = u * Math.sin(f); this.feOffset.setAttribute("dx", p), this.feOffset.setAttribute("dy", d) } } }; var _svgMatteSymbols = []; function SVGMatte3Effect(o, l, u) { this.initialized = !1, this.filterManager = l, this.filterElem = o, this.elem = u, u.matteElement = createNS("g"), u.matteElement.appendChild(u.layerElement), u.matteElement.appendChild(u.transformedElement), u.baseElement = u.matteElement } SVGMatte3Effect.prototype.findSymbol = function (o) { for (var l = 0, u = _svgMatteSymbols.length; l < u;) { if (_svgMatteSymbols[l] === o) return _svgMatteSymbols[l]; l += 1 } return null }, SVGMatte3Effect.prototype.replaceInParent = function (o, l) { var u = o.layerElement.parentNode; if (u) { for (var f = u.children, p = 0, d = f.length; p < d && f[p] !== o.layerElement;)p += 1; var m; p <= d - 2 && (m = f[p + 1]); var v = createNS("use"); v.setAttribute("href", "#" + l), m ? u.insertBefore(v, m) : u.appendChild(v) } }, SVGMatte3Effect.prototype.setElementAsMask = function (o, l) { if (!this.findSymbol(l)) { var u = createElementID(), f = createNS("mask"); f.setAttribute("id", l.layerId), f.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(l); var p = o.globalData.defs; p.appendChild(f); var d = createNS("symbol"); d.setAttribute("id", u), this.replaceInParent(l, u), d.appendChild(l.layerElement), p.appendChild(d); var m = createNS("use"); m.setAttribute("href", "#" + u), f.appendChild(m), l.data.hd = !1, l.show() } o.setMatte(l.layerId) }, SVGMatte3Effect.prototype.initialize = function () { for (var o = this.filterManager.effectElements[0].p.v, l = this.elem.comp.elements, u = 0, f = l.length; u < f;)l[u] && l[u].data.ind === o && this.setElementAsMask(this.elem, l[u]), u += 1; this.initialized = !0 }, SVGMatte3Effect.prototype.renderFrame = function () { this.initialized || this.initialize() }; function SVGGaussianBlurEffect(o, l, u, f) { o.setAttribute("x", "-100%"), o.setAttribute("y", "-100%"), o.setAttribute("width", "300%"), o.setAttribute("height", "300%"), this.filterManager = l; var p = createNS("feGaussianBlur"); p.setAttribute("result", f), o.appendChild(p), this.feGaussianBlur = p } SVGGaussianBlurEffect.prototype.renderFrame = function (o) { if (o || this.filterManager._mdf) { var l = .3, u = this.filterManager.effectElements[0].p.v * l, f = this.filterManager.effectElements[1].p.v, p = f == 3 ? 0 : u, d = f == 2 ? 0 : u; this.feGaussianBlur.setAttribute("stdDeviation", p + " " + d); var m = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate"; this.feGaussianBlur.setAttribute("edgeMode", m) } }; function TransformEffect() { } TransformEffect.prototype.init = function (o) { this.effectsManager = o, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix, this.opacity = -1, this._mdf = !1, this._opMdf = !1 }, TransformEffect.prototype.renderFrame = function (o) { if (this._opMdf = !1, this._mdf = !1, o || this.effectsManager._mdf) { var l = this.effectsManager.effectElements, u = l[0].p.v, f = l[1].p.v, p = l[2].p.v === 1, d = l[3].p.v, m = p ? d : l[4].p.v, v = l[5].p.v, I = l[6].p.v, F = l[7].p.v; this.matrix.reset(), this.matrix.translate(-u[0], -u[1], u[2]), this.matrix.scale(m * .01, d * .01, 1), this.matrix.rotate(-F * degToRads), this.matrix.skewFromAxis(-v * degToRads, (I + 90) * degToRads), this.matrix.translate(f[0], f[1], 0), this._mdf = !0, this.opacity !== l[8].p.v && (this.opacity = l[8].p.v, this._opMdf = !0) } }; function SVGTransformEffect(o, l) { this.init(l) } extendPrototype([TransformEffect], SVGTransformEffect); function CVTransformEffect(o) { this.init(o) } return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie
    })
  }(lottie$2, lottie$2.exports)), lottie$2.exports
} var lottieExports = requireLottie(); const lottie = getDefaultExportFromCjs$1(lottieExports); if (!reactExports.useState) throw new Error("mobx-react-lite requires React with Hooks support"); if (!makeObservable) throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available"); var reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredScheduler_production_min; function requireScheduler_production_min() { return hasRequiredScheduler_production_min || (hasRequiredScheduler_production_min = 1, function (o) { function l(ee, G) { var y = ee.length; ee.push(G); e: for (; 0 < y;) { var X = y - 1 >>> 1, ce = ee[X]; if (0 < p(ce, G)) ee[X] = G, ee[y] = ce, y = X; else break e } } function u(ee) { return ee.length === 0 ? null : ee[0] } function f(ee) { if (ee.length === 0) return null; var G = ee[0], y = ee.pop(); if (y !== G) { ee[0] = y; e: for (var X = 0, ce = ee.length, me = ce >>> 1; X < me;) { var Ae = 2 * (X + 1) - 1, Ie = ee[Ae], Be = Ae + 1, Me = ee[Be]; if (0 > p(Ie, y)) Be < ce && 0 > p(Me, Ie) ? (ee[X] = Me, ee[Be] = y, X = Be) : (ee[X] = Ie, ee[Ae] = y, X = Ae); else if (Be < ce && 0 > p(Me, y)) ee[X] = Me, ee[Be] = y, X = Be; else break e } } return G } function p(ee, G) { var y = ee.sortIndex - G.sortIndex; return y !== 0 ? y : ee.id - G.id } if (typeof performance == "object" && typeof performance.now == "function") { var d = performance; o.unstable_now = function () { return d.now() } } else { var m = Date, v = m.now(); o.unstable_now = function () { return m.now() - v } } var I = [], F = [], B = 1, W = null, Z = 3, Q = !1, re = !1, ne = !1, oe = typeof setTimeout == "function" ? setTimeout : null, ae = typeof clearTimeout == "function" ? clearTimeout : null, se = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function le(ee) { for (var G = u(F); G !== null;) { if (G.callback === null) f(F); else if (G.startTime <= ee) f(F), G.sortIndex = G.expirationTime, l(I, G); else break; G = u(F) } } function ue(ee) { if (ne = !1, le(ee), !re) if (u(I) !== null) re = !0, Y(he); else { var G = u(F); G !== null && te(ue, G.startTime - ee) } } function he(ee, G) { re = !1, ne && (ne = !1, ae(_e), _e = -1), Q = !0; var y = Z; try { for (le(G), W = u(I); W !== null && (!(W.expirationTime > G) || ee && !ie());) { var X = W.callback; if (typeof X == "function") { W.callback = null, Z = W.priorityLevel; var ce = X(W.expirationTime <= G); G = o.unstable_now(), typeof ce == "function" ? W.callback = ce : W === u(I) && f(I), le(G) } else f(I); W = u(I) } if (W !== null) var me = !0; else { var Ae = u(F); Ae !== null && te(ue, Ae.startTime - G), me = !1 } return me } finally { W = null, Z = y, Q = !1 } } var pe = !1, ve = null, _e = -1, Se = 5, $e = -1; function ie() { return !(o.unstable_now() - $e < Se) } function g() { if (ve !== null) { var ee = o.unstable_now(); $e = ee; var G = !0; try { G = ve(!0, ee) } finally { G ? P() : (pe = !1, ve = null) } } else pe = !1 } var P; if (typeof se == "function") P = function () { se(g) }; else if (typeof MessageChannel < "u") { var U = new MessageChannel, K = U.port2; U.port1.onmessage = g, P = function () { K.postMessage(null) } } else P = function () { oe(g, 0) }; function Y(ee) { ve = ee, pe || (pe = !0, P()) } function te(ee, G) { _e = oe(function () { ee(o.unstable_now()) }, G) } o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function (ee) { ee.callback = null }, o.unstable_continueExecution = function () { re || Q || (re = !0, Y(he)) }, o.unstable_forceFrameRate = function (ee) { 0 > ee || 125 < ee ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Se = 0 < ee ? Math.floor(1e3 / ee) : 5 }, o.unstable_getCurrentPriorityLevel = function () { return Z }, o.unstable_getFirstCallbackNode = function () { return u(I) }, o.unstable_next = function (ee) { switch (Z) { case 1: case 2: case 3: var G = 3; break; default: G = Z }var y = Z; Z = G; try { return ee() } finally { Z = y } }, o.unstable_pauseExecution = function () { }, o.unstable_requestPaint = function () { }, o.unstable_runWithPriority = function (ee, G) { switch (ee) { case 1: case 2: case 3: case 4: case 5: break; default: ee = 3 }var y = Z; Z = ee; try { return G() } finally { Z = y } }, o.unstable_scheduleCallback = function (ee, G, y) { var X = o.unstable_now(); switch (typeof y == "object" && y !== null ? (y = y.delay, y = typeof y == "number" && 0 < y ? X + y : X) : y = X, ee) { case 1: var ce = -1; break; case 2: ce = 250; break; case 5: ce = 1073741823; break; case 4: ce = 1e4; break; default: ce = 5e3 }return ce = y + ce, ee = { id: B++, callback: G, priorityLevel: ee, startTime: y, expirationTime: ce, sortIndex: -1 }, y > X ? (ee.sortIndex = y, l(F, ee), u(I) === null && ee === u(F) && (ne ? (ae(_e), _e = -1) : ne = !0, te(ue, y - X))) : (ee.sortIndex = ce, l(I, ee), re || Q || (re = !0, Y(he))), ee }, o.unstable_shouldYield = ie, o.unstable_wrapCallback = function (ee) { var G = Z; return function () { var y = Z; Z = G; try { return ee.apply(this, arguments) } finally { Z = y } } } }(scheduler_production_min)), scheduler_production_min } var hasRequiredScheduler; function requireScheduler() { return hasRequiredScheduler || (hasRequiredScheduler = 1, scheduler.exports = requireScheduler_production_min()), scheduler.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDom_production_min; function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min; hasRequiredReactDom_production_min = 1; var o = requireReact(), l = requireScheduler(); function u(V) { for (var J = "https://reactjs.org/docs/error-decoder.html?invariant=" + V, fe = 1; fe < arguments.length; fe++)J += "&args[]=" + encodeURIComponent(arguments[fe]); return "Minified React error #" + V + "; visit " + J + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var f = new Set, p = {}; function d(V, J) { m(V, J), m(V + "Capture", J) } function m(V, J) { for (p[V] = J, V = 0; V < J.length; V++)f.add(J[V]) } var v = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), I = Object.prototype.hasOwnProperty, F = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, B = {}, W = {}; function Z(V) { return I.call(W, V) ? !0 : I.call(B, V) ? !1 : F.test(V) ? W[V] = !0 : (B[V] = !0, !1) } function Q(V, J, fe, de) { if (fe !== null && fe.type === 0) return !1; switch (typeof J) { case "function": case "symbol": return !0; case "boolean": return de ? !1 : fe !== null ? !fe.acceptsBooleans : (V = V.toLowerCase().slice(0, 5), V !== "data-" && V !== "aria-"); default: return !1 } } function re(V, J, fe, de) { if (J === null || typeof J > "u" || Q(V, J, fe, de)) return !0; if (de) return !1; if (fe !== null) switch (fe.type) { case 3: return !J; case 4: return J === !1; case 5: return isNaN(J); case 6: return isNaN(J) || 1 > J }return !1 } function ne(V, J, fe, de, we, Te, He) { this.acceptsBooleans = J === 2 || J === 3 || J === 4, this.attributeName = de, this.attributeNamespace = we, this.mustUseProperty = fe, this.propertyName = V, this.type = J, this.sanitizeURL = Te, this.removeEmptyString = He } var oe = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (V) { oe[V] = new ne(V, 0, !1, V, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (V) { var J = V[0]; oe[J] = new ne(J, 1, !1, V[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (V) { oe[V] = new ne(V, 2, !1, V.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (V) { oe[V] = new ne(V, 2, !1, V, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (V) { oe[V] = new ne(V, 3, !1, V.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (V) { oe[V] = new ne(V, 3, !0, V, null, !1, !1) }), ["capture", "download"].forEach(function (V) { oe[V] = new ne(V, 4, !1, V, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (V) { oe[V] = new ne(V, 6, !1, V, null, !1, !1) }), ["rowSpan", "start"].forEach(function (V) { oe[V] = new ne(V, 5, !1, V.toLowerCase(), null, !1, !1) }); var ae = /[\-:]([a-z])/g; function se(V) { return V[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (V) { var J = V.replace(ae, se); oe[J] = new ne(J, 1, !1, V, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (V) { var J = V.replace(ae, se); oe[J] = new ne(J, 1, !1, V, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (V) { var J = V.replace(ae, se); oe[J] = new ne(J, 1, !1, V, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (V) { oe[V] = new ne(V, 1, !1, V.toLowerCase(), null, !1, !1) }), oe.xlinkHref = new ne("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (V) { oe[V] = new ne(V, 1, !1, V.toLowerCase(), null, !0, !0) }); function le(V, J, fe, de) { var we = oe.hasOwnProperty(J) ? oe[J] : null; (we !== null ? we.type !== 0 : de || !(2 < J.length) || J[0] !== "o" && J[0] !== "O" || J[1] !== "n" && J[1] !== "N") && (re(J, fe, we, de) && (fe = null), de || we === null ? Z(J) && (fe === null ? V.removeAttribute(J) : V.setAttribute(J, "" + fe)) : we.mustUseProperty ? V[we.propertyName] = fe === null ? we.type === 3 ? !1 : "" : fe : (J = we.attributeName, de = we.attributeNamespace, fe === null ? V.removeAttribute(J) : (we = we.type, fe = we === 3 || we === 4 && fe === !0 ? "" : "" + fe, de ? V.setAttributeNS(de, J, fe) : V.setAttribute(J, fe)))) } var ue = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, he = Symbol.for("react.element"), pe = Symbol.for("react.portal"), ve = Symbol.for("react.fragment"), _e = Symbol.for("react.strict_mode"), Se = Symbol.for("react.profiler"), $e = Symbol.for("react.provider"), ie = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), P = Symbol.for("react.suspense"), U = Symbol.for("react.suspense_list"), K = Symbol.for("react.memo"), Y = Symbol.for("react.lazy"), te = Symbol.for("react.offscreen"), ee = Symbol.iterator; function G(V) { return V === null || typeof V != "object" ? null : (V = ee && V[ee] || V["@@iterator"], typeof V == "function" ? V : null) } var y = Object.assign, X; function ce(V) {
    if (X === void 0) try { throw Error() } catch (fe) { var J = fe.stack.trim().match(/\n( *(at )?)/); X = J && J[1] || "" } return `
`+ X + V
  } var me = !1; function Ae(V, J) {
    if (!V || me) return ""; me = !0; var fe = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (J) if (J = function () { throw Error() }, Object.defineProperty(J.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(J, []) } catch (Pt) { var de = Pt } Reflect.construct(V, [], J) } else { try { J.call() } catch (Pt) { de = Pt } V.call(J.prototype) } else { try { throw Error() } catch (Pt) { de = Pt } V() } } catch (Pt) {
      if (Pt && de && typeof Pt.stack == "string") {
        for (var we = Pt.stack.split(`
`), Te = de.stack.split(`
`), He = we.length - 1, ot = Te.length - 1; 1 <= He && 0 <= ot && we[He] !== Te[ot];)ot--; for (; 1 <= He && 0 <= ot; He--, ot--)if (we[He] !== Te[ot]) {
          if (He !== 1 || ot !== 1) do if (He--, ot--, 0 > ot || we[He] !== Te[ot]) {
            var vt = `
`+ we[He].replace(" at new ", " at "); return V.displayName && vt.includes("<anonymous>") && (vt = vt.replace("<anonymous>", V.displayName)), vt
          } while (1 <= He && 0 <= ot); break
        }
      }
    } finally { me = !1, Error.prepareStackTrace = fe } return (V = V ? V.displayName || V.name : "") ? ce(V) : ""
  } function Ie(V) { switch (V.tag) { case 5: return ce(V.type); case 16: return ce("Lazy"); case 13: return ce("Suspense"); case 19: return ce("SuspenseList"); case 0: case 2: case 15: return V = Ae(V.type, !1), V; case 11: return V = Ae(V.type.render, !1), V; case 1: return V = Ae(V.type, !0), V; default: return "" } } function Be(V) { if (V == null) return null; if (typeof V == "function") return V.displayName || V.name || null; if (typeof V == "string") return V; switch (V) { case ve: return "Fragment"; case pe: return "Portal"; case Se: return "Profiler"; case _e: return "StrictMode"; case P: return "Suspense"; case U: return "SuspenseList" }if (typeof V == "object") switch (V.$$typeof) { case ie: return (V.displayName || "Context") + ".Consumer"; case $e: return (V._context.displayName || "Context") + ".Provider"; case g: var J = V.render; return V = V.displayName, V || (V = J.displayName || J.name || "", V = V !== "" ? "ForwardRef(" + V + ")" : "ForwardRef"), V; case K: return J = V.displayName || null, J !== null ? J : Be(V.type) || "Memo"; case Y: J = V._payload, V = V._init; try { return Be(V(J)) } catch { } }return null } function Me(V) { var J = V.type; switch (V.tag) { case 24: return "Cache"; case 9: return (J.displayName || "Context") + ".Consumer"; case 10: return (J._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return V = J.render, V = V.displayName || V.name || "", J.displayName || (V !== "" ? "ForwardRef(" + V + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return J; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Be(J); case 8: return J === _e ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof J == "function") return J.displayName || J.name || null; if (typeof J == "string") return J }return null } function De(V) { switch (typeof V) { case "boolean": case "number": case "string": case "undefined": return V; case "object": return V; default: return "" } } function Ue(V) { var J = V.type; return (V = V.nodeName) && V.toLowerCase() === "input" && (J === "checkbox" || J === "radio") } function Ke(V) { var J = Ue(V) ? "checked" : "value", fe = Object.getOwnPropertyDescriptor(V.constructor.prototype, J), de = "" + V[J]; if (!V.hasOwnProperty(J) && typeof fe < "u" && typeof fe.get == "function" && typeof fe.set == "function") { var we = fe.get, Te = fe.set; return Object.defineProperty(V, J, { configurable: !0, get: function () { return we.call(this) }, set: function (He) { de = "" + He, Te.call(this, He) } }), Object.defineProperty(V, J, { enumerable: fe.enumerable }), { getValue: function () { return de }, setValue: function (He) { de = "" + He }, stopTracking: function () { V._valueTracker = null, delete V[J] } } } } function Ve(V) { V._valueTracker || (V._valueTracker = Ke(V)) } function ke(V) { if (!V) return !1; var J = V._valueTracker; if (!J) return !0; var fe = J.getValue(), de = ""; return V && (de = Ue(V) ? V.checked ? "true" : "false" : V.value), V = de, V !== fe ? (J.setValue(V), !0) : !1 } function Je(V) { if (V = V || (typeof document < "u" ? document : void 0), typeof V > "u") return null; try { return V.activeElement || V.body } catch { return V.body } } function dt(V, J) { var fe = J.checked; return y({}, J, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: fe ?? V._wrapperState.initialChecked }) } function lt(V, J) { var fe = J.defaultValue == null ? "" : J.defaultValue, de = J.checked != null ? J.checked : J.defaultChecked; fe = De(J.value != null ? J.value : fe), V._wrapperState = { initialChecked: de, initialValue: fe, controlled: J.type === "checkbox" || J.type === "radio" ? J.checked != null : J.value != null } } function ht(V, J) { J = J.checked, J != null && le(V, "checked", J, !1) } function Bt(V, J) { ht(V, J); var fe = De(J.value), de = J.type; if (fe != null) de === "number" ? (fe === 0 && V.value === "" || V.value != fe) && (V.value = "" + fe) : V.value !== "" + fe && (V.value = "" + fe); else if (de === "submit" || de === "reset") { V.removeAttribute("value"); return } J.hasOwnProperty("value") ? et(V, J.type, fe) : J.hasOwnProperty("defaultValue") && et(V, J.type, De(J.defaultValue)), J.checked == null && J.defaultChecked != null && (V.defaultChecked = !!J.defaultChecked) } function mt(V, J, fe) { if (J.hasOwnProperty("value") || J.hasOwnProperty("defaultValue")) { var de = J.type; if (!(de !== "submit" && de !== "reset" || J.value !== void 0 && J.value !== null)) return; J = "" + V._wrapperState.initialValue, fe || J === V.value || (V.value = J), V.defaultValue = J } fe = V.name, fe !== "" && (V.name = ""), V.defaultChecked = !!V._wrapperState.initialChecked, fe !== "" && (V.name = fe) } function et(V, J, fe) { (J !== "number" || Je(V.ownerDocument) !== V) && (fe == null ? V.defaultValue = "" + V._wrapperState.initialValue : V.defaultValue !== "" + fe && (V.defaultValue = "" + fe)) } var Gt = Array.isArray; function pt(V, J, fe, de) { if (V = V.options, J) { J = {}; for (var we = 0; we < fe.length; we++)J["$" + fe[we]] = !0; for (fe = 0; fe < V.length; fe++)we = J.hasOwnProperty("$" + V[fe].value), V[fe].selected !== we && (V[fe].selected = we), we && de && (V[fe].defaultSelected = !0) } else { for (fe = "" + De(fe), J = null, we = 0; we < V.length; we++) { if (V[we].value === fe) { V[we].selected = !0, de && (V[we].defaultSelected = !0); return } J !== null || V[we].disabled || (J = V[we]) } J !== null && (J.selected = !0) } } function _t(V, J) { if (J.dangerouslySetInnerHTML != null) throw Error(u(91)); return y({}, J, { value: void 0, defaultValue: void 0, children: "" + V._wrapperState.initialValue }) } function zt(V, J) { var fe = J.value; if (fe == null) { if (fe = J.children, J = J.defaultValue, fe != null) { if (J != null) throw Error(u(92)); if (Gt(fe)) { if (1 < fe.length) throw Error(u(93)); fe = fe[0] } J = fe } J == null && (J = ""), fe = J } V._wrapperState = { initialValue: De(fe) } } function bt(V, J) { var fe = De(J.value), de = De(J.defaultValue); fe != null && (fe = "" + fe, fe !== V.value && (V.value = fe), J.defaultValue == null && V.defaultValue !== fe && (V.defaultValue = fe)), de != null && (V.defaultValue = "" + de) } function We(V) { var J = V.textContent; J === V._wrapperState.initialValue && J !== "" && J !== null && (V.value = J) } function Ge(V) { switch (V) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function ze(V, J) { return V == null || V === "http://www.w3.org/1999/xhtml" ? Ge(J) : V === "http://www.w3.org/2000/svg" && J === "foreignObject" ? "http://www.w3.org/1999/xhtml" : V } var Ze, ut = function (V) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (J, fe, de, we) { MSApp.execUnsafeLocalFunction(function () { return V(J, fe, de, we) }) } : V }(function (V, J) { if (V.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in V) V.innerHTML = J; else { for (Ze = Ze || document.createElement("div"), Ze.innerHTML = "<svg>" + J.valueOf().toString() + "</svg>", J = Ze.firstChild; V.firstChild;)V.removeChild(V.firstChild); for (; J.firstChild;)V.appendChild(J.firstChild) } }); function ye(V, J) { if (J) { var fe = V.firstChild; if (fe && fe === V.lastChild && fe.nodeType === 3) { fe.nodeValue = J; return } } V.textContent = J } var ge = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Ee = ["Webkit", "ms", "Moz", "O"]; Object.keys(ge).forEach(function (V) { Ee.forEach(function (J) { J = J + V.charAt(0).toUpperCase() + V.substring(1), ge[J] = ge[V] }) }); function Oe(V, J, fe) { return J == null || typeof J == "boolean" || J === "" ? "" : fe || typeof J != "number" || J === 0 || ge.hasOwnProperty(V) && ge[V] ? ("" + J).trim() : J + "px" } function je(V, J) { V = V.style; for (var fe in J) if (J.hasOwnProperty(fe)) { var de = fe.indexOf("--") === 0, we = Oe(fe, J[fe], de); fe === "float" && (fe = "cssFloat"), de ? V.setProperty(fe, we) : V[fe] = we } } var nt = y({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Xe(V, J) { if (J) { if (nt[V] && (J.children != null || J.dangerouslySetInnerHTML != null)) throw Error(u(137, V)); if (J.dangerouslySetInnerHTML != null) { if (J.children != null) throw Error(u(60)); if (typeof J.dangerouslySetInnerHTML != "object" || !("__html" in J.dangerouslySetInnerHTML)) throw Error(u(61)) } if (J.style != null && typeof J.style != "object") throw Error(u(62)) } } function it(V, J) { if (V.indexOf("-") === -1) return typeof J.is == "string"; switch (V) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Tt = null; function tt(V) { return V = V.target || V.srcElement || window, V.correspondingUseElement && (V = V.correspondingUseElement), V.nodeType === 3 ? V.parentNode : V } var yt = null, kt = null, wt = null; function Mt(V) { if (V = aa(V)) { if (typeof yt != "function") throw Error(u(280)); var J = V.stateNode; J && (J = Da(J), yt(V.stateNode, V.type, J)) } } function tr(V) { kt ? wt ? wt.push(V) : wt = [V] : kt = V } function St() { if (kt) { var V = kt, J = wt; if (wt = kt = null, Mt(V), J) for (V = 0; V < J.length; V++)Mt(J[V]) } } function gt(V, J) { return V(J) } function rr() { } var Le = !1; function xe(V, J, fe) { if (Le) return V(J, fe); Le = !0; try { return gt(V, J, fe) } finally { Le = !1, (kt !== null || wt !== null) && (rr(), St()) } } function Ce(V, J) { var fe = V.stateNode; if (fe === null) return null; var de = Da(fe); if (de === null) return null; fe = de[J]; e: switch (J) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (de = !de.disabled) || (V = V.type, de = !(V === "button" || V === "input" || V === "select" || V === "textarea")), V = !de; break e; default: V = !1 }if (V) return null; if (fe && typeof fe != "function") throw Error(u(231, J, typeof fe)); return fe } var Ne = !1; if (v) try { var Ye = {}; Object.defineProperty(Ye, "passive", { get: function () { Ne = !0 } }), window.addEventListener("test", Ye, Ye), window.removeEventListener("test", Ye, Ye) } catch { Ne = !1 } function Re(V, J, fe, de, we, Te, He, ot, vt) { var Pt = Array.prototype.slice.call(arguments, 3); try { J.apply(fe, Pt) } catch (Vt) { this.onError(Vt) } } var Pe = !1, qe = null, be = !1, Fe = null, Qe = { onError: function (V) { Pe = !0, qe = V } }; function st(V, J, fe, de, we, Te, He, ot, vt) { Pe = !1, qe = null, Re.apply(Qe, arguments) } function rt(V, J, fe, de, we, Te, He, ot, vt) { if (st.apply(this, arguments), Pe) { if (Pe) { var Pt = qe; Pe = !1, qe = null } else throw Error(u(198)); be || (be = !0, Fe = Pt) } } function ct(V) { var J = V, fe = V; if (V.alternate) for (; J.return;)J = J.return; else { V = J; do J = V, (J.flags & 4098) !== 0 && (fe = J.return), V = J.return; while (V) } return J.tag === 3 ? fe : null } function Lt(V) { if (V.tag === 13) { var J = V.memoizedState; if (J === null && (V = V.alternate, V !== null && (J = V.memoizedState)), J !== null) return J.dehydrated } return null } function It(V) { if (ct(V) !== V) throw Error(u(188)) } function lr(V) { var J = V.alternate; if (!J) { if (J = ct(V), J === null) throw Error(u(188)); return J !== V ? null : V } for (var fe = V, de = J; ;) { var we = fe.return; if (we === null) break; var Te = we.alternate; if (Te === null) { if (de = we.return, de !== null) { fe = de; continue } break } if (we.child === Te.child) { for (Te = we.child; Te;) { if (Te === fe) return It(we), V; if (Te === de) return It(we), J; Te = Te.sibling } throw Error(u(188)) } if (fe.return !== de.return) fe = we, de = Te; else { for (var He = !1, ot = we.child; ot;) { if (ot === fe) { He = !0, fe = we, de = Te; break } if (ot === de) { He = !0, de = we, fe = Te; break } ot = ot.sibling } if (!He) { for (ot = Te.child; ot;) { if (ot === fe) { He = !0, fe = Te, de = we; break } if (ot === de) { He = !0, de = Te, fe = we; break } ot = ot.sibling } if (!He) throw Error(u(189)) } } if (fe.alternate !== de) throw Error(u(190)) } if (fe.tag !== 3) throw Error(u(188)); return fe.stateNode.current === fe ? V : J } function jt(V) { return V = lr(V), V !== null ? Ft(V) : null } function Ft(V) { if (V.tag === 5 || V.tag === 6) return V; for (V = V.child; V !== null;) { var J = Ft(V); if (J !== null) return J; V = V.sibling } return null } var er = l.unstable_scheduleCallback, ar = l.unstable_cancelCallback, nr = l.unstable_shouldYield, ir = l.unstable_requestPaint, Ht = l.unstable_now, sr = l.unstable_getCurrentPriorityLevel, Kt = l.unstable_ImmediatePriority, Qt = l.unstable_UserBlockingPriority, $t = l.unstable_NormalPriority, Yt = l.unstable_LowPriority, Xt = l.unstable_IdlePriority, Nt = null, Et = null; function At(V) { if (Et && typeof Et.onCommitFiberRoot == "function") try { Et.onCommitFiberRoot(Nt, V, void 0, (V.current.flags & 128) === 128) } catch { } } var qt = Math.clz32 ? Math.clz32 : Wt, Ot = Math.log, Dt = Math.LN2; function Wt(V) { return V >>>= 0, V === 0 ? 32 : 31 - (Ot(V) / Dt | 0) | 0 } var pr = 64, yr = 4194304; function br(V) { switch (V & -V) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return V & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return V & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return V } } function _r(V, J) { var fe = V.pendingLanes; if (fe === 0) return 0; var de = 0, we = V.suspendedLanes, Te = V.pingedLanes, He = fe & 268435455; if (He !== 0) { var ot = He & ~we; ot !== 0 ? de = br(ot) : (Te &= He, Te !== 0 && (de = br(Te))) } else He = fe & ~we, He !== 0 ? de = br(He) : Te !== 0 && (de = br(Te)); if (de === 0) return 0; if (J !== 0 && J !== de && (J & we) === 0 && (we = de & -de, Te = J & -J, we >= Te || we === 16 && (Te & 4194240) !== 0)) return J; if ((de & 4) !== 0 && (de |= fe & 16), J = V.entangledLanes, J !== 0) for (V = V.entanglements, J &= de; 0 < J;)fe = 31 - qt(J), we = 1 << fe, de |= V[fe], J &= ~we; return de } function ft(V, J) { switch (V) { case 1: case 2: case 4: return J + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return J + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Sr(V, J) { for (var fe = V.suspendedLanes, de = V.pingedLanes, we = V.expirationTimes, Te = V.pendingLanes; 0 < Te;) { var He = 31 - qt(Te), ot = 1 << He, vt = we[He]; vt === -1 ? ((ot & fe) === 0 || (ot & de) !== 0) && (we[He] = ft(ot, J)) : vt <= J && (V.expiredLanes |= ot), Te &= ~ot } } function Mr(V) { return V = V.pendingLanes & -1073741825, V !== 0 ? V : V & 1073741824 ? 1073741824 : 0 } function Ar() { var V = pr; return pr <<= 1, (pr & 4194240) === 0 && (pr = 64), V } function xr(V) { for (var J = [], fe = 0; 31 > fe; fe++)J.push(V); return J } function Er(V, J, fe) { V.pendingLanes |= J, J !== 536870912 && (V.suspendedLanes = 0, V.pingedLanes = 0), V = V.eventTimes, J = 31 - qt(J), V[J] = fe } function Rr(V, J) { var fe = V.pendingLanes & ~J; V.pendingLanes = J, V.suspendedLanes = 0, V.pingedLanes = 0, V.expiredLanes &= J, V.mutableReadLanes &= J, V.entangledLanes &= J, J = V.entanglements; var de = V.eventTimes; for (V = V.expirationTimes; 0 < fe;) { var we = 31 - qt(fe), Te = 1 << we; J[we] = 0, de[we] = -1, V[we] = -1, fe &= ~Te } } function Ir(V, J) { var fe = V.entangledLanes |= J; for (V = V.entanglements; fe;) { var de = 31 - qt(fe), we = 1 << de; we & J | V[de] & J && (V[de] |= J), fe &= ~we } } var dr = 0; function Br(V) { return V &= -V, 1 < V ? 4 < V ? (V & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var Or, Tr, $r, Hr, Gr, Vr = !1, wa = [], jn = null, Vn = null, zn = null, Vi = new Map, zi = new Map, Hn = [], Cf = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function nl(V, J) { switch (V) { case "focusin": case "focusout": jn = null; break; case "dragenter": case "dragleave": Vn = null; break; case "mouseover": case "mouseout": zn = null; break; case "pointerover": case "pointerout": Vi.delete(J.pointerId); break; case "gotpointercapture": case "lostpointercapture": zi.delete(J.pointerId) } } function Hi(V, J, fe, de, we, Te) { return V === null || V.nativeEvent !== Te ? (V = { blockedOn: J, domEventName: fe, eventSystemFlags: de, nativeEvent: Te, targetContainers: [we] }, J !== null && (J = aa(J), J !== null && Tr(J)), V) : (V.eventSystemFlags |= de, J = V.targetContainers, we !== null && J.indexOf(we) === -1 && J.push(we), V) } function Pf(V, J, fe, de, we) { switch (J) { case "focusin": return jn = Hi(jn, V, J, fe, de, we), !0; case "dragenter": return Vn = Hi(Vn, V, J, fe, de, we), !0; case "mouseover": return zn = Hi(zn, V, J, fe, de, we), !0; case "pointerover": var Te = we.pointerId; return Vi.set(Te, Hi(Vi.get(Te) || null, V, J, fe, de, we)), !0; case "gotpointercapture": return Te = we.pointerId, zi.set(Te, Hi(zi.get(Te) || null, V, J, fe, de, we)), !0 }return !1 } function il(V) { var J = ui(V.target); if (J !== null) { var fe = ct(J); if (fe !== null) { if (J = fe.tag, J === 13) { if (J = Lt(fe), J !== null) { V.blockedOn = J, Gr(V.priority, function () { $r(fe) }); return } } else if (J === 3 && fe.stateNode.current.memoizedState.isDehydrated) { V.blockedOn = fe.tag === 3 ? fe.stateNode.containerInfo : null; return } } } V.blockedOn = null } function xa(V) { if (V.blockedOn !== null) return !1; for (var J = V.targetContainers; 0 < J.length;) { var fe = Ms(V.domEventName, V.eventSystemFlags, J[0], V.nativeEvent); if (fe === null) { fe = V.nativeEvent; var de = new fe.constructor(fe.type, fe); Tt = de, fe.target.dispatchEvent(de), Tt = null } else return J = aa(fe), J !== null && Tr(J), V.blockedOn = fe, !1; J.shift() } return !0 } function al(V, J, fe) { xa(V) && fe.delete(J) } function Tf() { Vr = !1, jn !== null && xa(jn) && (jn = null), Vn !== null && xa(Vn) && (Vn = null), zn !== null && xa(zn) && (zn = null), Vi.forEach(al), zi.forEach(al) } function Gi(V, J) { V.blockedOn === J && (V.blockedOn = null, Vr || (Vr = !0, l.unstable_scheduleCallback(l.unstable_NormalPriority, Tf))) } function Ki(V) { function J(we) { return Gi(we, V) } if (0 < wa.length) { Gi(wa[0], V); for (var fe = 1; fe < wa.length; fe++) { var de = wa[fe]; de.blockedOn === V && (de.blockedOn = null) } } for (jn !== null && Gi(jn, V), Vn !== null && Gi(Vn, V), zn !== null && Gi(zn, V), Vi.forEach(J), zi.forEach(J), fe = 0; fe < Hn.length; fe++)de = Hn[fe], de.blockedOn === V && (de.blockedOn = null); for (; 0 < Hn.length && (fe = Hn[0], fe.blockedOn === null);)il(fe), fe.blockedOn === null && Hn.shift() } var wi = ue.ReactCurrentBatchConfig, Sa = !0; function kf(V, J, fe, de) { var we = dr, Te = wi.transition; wi.transition = null; try { dr = 1, Es(V, J, fe, de) } finally { dr = we, wi.transition = Te } } function If(V, J, fe, de) { var we = dr, Te = wi.transition; wi.transition = null; try { dr = 4, Es(V, J, fe, de) } finally { dr = we, wi.transition = Te } } function Es(V, J, fe, de) { if (Sa) { var we = Ms(V, J, fe, de); if (we === null) Vs(V, J, de, Ea, fe), nl(V, de); else if (Pf(we, V, J, fe, de)) de.stopPropagation(); else if (nl(V, de), J & 4 && -1 < Cf.indexOf(V)) { for (; we !== null;) { var Te = aa(we); if (Te !== null && Or(Te), Te = Ms(V, J, fe, de), Te === null && Vs(V, J, de, Ea, fe), Te === we) break; we = Te } we !== null && de.stopPropagation() } else Vs(V, J, de, null, fe) } } var Ea = null; function Ms(V, J, fe, de) { if (Ea = null, V = tt(de), V = ui(V), V !== null) if (J = ct(V), J === null) V = null; else if (fe = J.tag, fe === 13) { if (V = Lt(J), V !== null) return V; V = null } else if (fe === 3) { if (J.stateNode.current.memoizedState.isDehydrated) return J.tag === 3 ? J.stateNode.containerInfo : null; V = null } else J !== V && (V = null); return Ea = V, null } function sl(V) { switch (V) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (sr()) { case Kt: return 1; case Qt: return 4; case $t: case Yt: return 16; case Xt: return 536870912; default: return 16 }default: return 16 } } var Gn = null, As = null, Ma = null; function ol() { if (Ma) return Ma; var V, J = As, fe = J.length, de, we = "value" in Gn ? Gn.value : Gn.textContent, Te = we.length; for (V = 0; V < fe && J[V] === we[V]; V++); var He = fe - V; for (de = 1; de <= He && J[fe - de] === we[Te - de]; de++); return Ma = we.slice(V, 1 < de ? 1 - de : void 0) } function Aa(V) { var J = V.keyCode; return "charCode" in V ? (V = V.charCode, V === 0 && J === 13 && (V = 13)) : V = J, V === 10 && (V = 13), 32 <= V || V === 13 ? V : 0 } function Ra() { return !0 } function ll() { return !1 } function dn(V) { function J(fe, de, we, Te, He) { this._reactName = fe, this._targetInst = we, this.type = de, this.nativeEvent = Te, this.target = He, this.currentTarget = null; for (var ot in V) V.hasOwnProperty(ot) && (fe = V[ot], this[ot] = fe ? fe(Te) : Te[ot]); return this.isDefaultPrevented = (Te.defaultPrevented != null ? Te.defaultPrevented : Te.returnValue === !1) ? Ra : ll, this.isPropagationStopped = ll, this } return y(J.prototype, { preventDefault: function () { this.defaultPrevented = !0; var fe = this.nativeEvent; fe && (fe.preventDefault ? fe.preventDefault() : typeof fe.returnValue != "unknown" && (fe.returnValue = !1), this.isDefaultPrevented = Ra) }, stopPropagation: function () { var fe = this.nativeEvent; fe && (fe.stopPropagation ? fe.stopPropagation() : typeof fe.cancelBubble != "unknown" && (fe.cancelBubble = !0), this.isPropagationStopped = Ra) }, persist: function () { }, isPersistent: Ra }), J } var xi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (V) { return V.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Rs = dn(xi), Wi = y({}, xi, { view: 0, detail: 0 }), Bf = dn(Wi), Cs, Ps, Zi, Ca = y({}, Wi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ks, button: 0, buttons: 0, relatedTarget: function (V) { return V.relatedTarget === void 0 ? V.fromElement === V.srcElement ? V.toElement : V.fromElement : V.relatedTarget }, movementX: function (V) { return "movementX" in V ? V.movementX : (V !== Zi && (Zi && V.type === "mousemove" ? (Cs = V.screenX - Zi.screenX, Ps = V.screenY - Zi.screenY) : Ps = Cs = 0, Zi = V), Cs) }, movementY: function (V) { return "movementY" in V ? V.movementY : Ps } }), ul = dn(Ca), Of = y({}, Ca, { dataTransfer: 0 }), qf = dn(Of), Df = y({}, Wi, { relatedTarget: 0 }), Ts = dn(Df), Lf = y({}, xi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Ff = dn(Lf), Nf = y({}, xi, { clipboardData: function (V) { return "clipboardData" in V ? V.clipboardData : window.clipboardData } }), $f = dn(Nf), Uf = y({}, xi, { data: 0 }), fl = dn(Uf), jf = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Vf = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, zf = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Hf(V) { var J = this.nativeEvent; return J.getModifierState ? J.getModifierState(V) : (V = zf[V]) ? !!J[V] : !1 } function ks() { return Hf } var Gf = y({}, Wi, { key: function (V) { if (V.key) { var J = jf[V.key] || V.key; if (J !== "Unidentified") return J } return V.type === "keypress" ? (V = Aa(V), V === 13 ? "Enter" : String.fromCharCode(V)) : V.type === "keydown" || V.type === "keyup" ? Vf[V.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ks, charCode: function (V) { return V.type === "keypress" ? Aa(V) : 0 }, keyCode: function (V) { return V.type === "keydown" || V.type === "keyup" ? V.keyCode : 0 }, which: function (V) { return V.type === "keypress" ? Aa(V) : V.type === "keydown" || V.type === "keyup" ? V.keyCode : 0 } }), Kf = dn(Gf), Wf = y({}, Ca, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), cl = dn(Wf), Zf = y({}, Wi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ks }), Yf = dn(Zf), Xf = y({}, xi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Jf = dn(Xf), Qf = y({}, Ca, { deltaX: function (V) { return "deltaX" in V ? V.deltaX : "wheelDeltaX" in V ? -V.wheelDeltaX : 0 }, deltaY: function (V) { return "deltaY" in V ? V.deltaY : "wheelDeltaY" in V ? -V.wheelDeltaY : "wheelDelta" in V ? -V.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), tc = dn(Qf), rc = [9, 13, 27, 32], Is = v && "CompositionEvent" in window, Yi = null; v && "documentMode" in document && (Yi = document.documentMode); var nc = v && "TextEvent" in window && !Yi, hl = v && (!Is || Yi && 8 < Yi && 11 >= Yi), dl = " ", pl = !1; function ml(V, J) { switch (V) { case "keyup": return rc.indexOf(J.keyCode) !== -1; case "keydown": return J.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function gl(V) { return V = V.detail, typeof V == "object" && "data" in V ? V.data : null } var Si = !1; function ic(V, J) { switch (V) { case "compositionend": return gl(J); case "keypress": return J.which !== 32 ? null : (pl = !0, dl); case "textInput": return V = J.data, V === dl && pl ? null : V; default: return null } } function ac(V, J) { if (Si) return V === "compositionend" || !Is && ml(V, J) ? (V = ol(), Ma = As = Gn = null, Si = !1, V) : null; switch (V) { case "paste": return null; case "keypress": if (!(J.ctrlKey || J.altKey || J.metaKey) || J.ctrlKey && J.altKey) { if (J.char && 1 < J.char.length) return J.char; if (J.which) return String.fromCharCode(J.which) } return null; case "compositionend": return hl && J.locale !== "ko" ? null : J.data; default: return null } } var sc = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function vl(V) { var J = V && V.nodeName && V.nodeName.toLowerCase(); return J === "input" ? !!sc[V.type] : J === "textarea" } function yl(V, J, fe, de) { tr(de), J = Ba(J, "onChange"), 0 < J.length && (fe = new Rs("onChange", "change", null, fe, de), V.push({ event: fe, listeners: J })) } var Xi = null, Ji = null; function oc(V) { Dl(V, 0) } function Pa(V) { var J = Ci(V); if (ke(J)) return V } function lc(V, J) { if (V === "change") return J } var bl = !1; if (v) { var Bs; if (v) { var Os = "oninput" in document; if (!Os) { var _l = document.createElement("div"); _l.setAttribute("oninput", "return;"), Os = typeof _l.oninput == "function" } Bs = Os } else Bs = !1; bl = Bs && (!document.documentMode || 9 < document.documentMode) } function wl() { Xi && (Xi.detachEvent("onpropertychange", xl), Ji = Xi = null) } function xl(V) { if (V.propertyName === "value" && Pa(Ji)) { var J = []; yl(J, Ji, V, tt(V)), xe(oc, J) } } function uc(V, J, fe) { V === "focusin" ? (wl(), Xi = J, Ji = fe, Xi.attachEvent("onpropertychange", xl)) : V === "focusout" && wl() } function fc(V) { if (V === "selectionchange" || V === "keyup" || V === "keydown") return Pa(Ji) } function cc(V, J) { if (V === "click") return Pa(J) } function hc(V, J) { if (V === "input" || V === "change") return Pa(J) } function dc(V, J) { return V === J && (V !== 0 || 1 / V === 1 / J) || V !== V && J !== J } var En = typeof Object.is == "function" ? Object.is : dc; function Qi(V, J) { if (En(V, J)) return !0; if (typeof V != "object" || V === null || typeof J != "object" || J === null) return !1; var fe = Object.keys(V), de = Object.keys(J); if (fe.length !== de.length) return !1; for (de = 0; de < fe.length; de++) { var we = fe[de]; if (!I.call(J, we) || !En(V[we], J[we])) return !1 } return !0 } function Sl(V) { for (; V && V.firstChild;)V = V.firstChild; return V } function El(V, J) { var fe = Sl(V); V = 0; for (var de; fe;) { if (fe.nodeType === 3) { if (de = V + fe.textContent.length, V <= J && de >= J) return { node: fe, offset: J - V }; V = de } e: { for (; fe;) { if (fe.nextSibling) { fe = fe.nextSibling; break e } fe = fe.parentNode } fe = void 0 } fe = Sl(fe) } } function Ml(V, J) { return V && J ? V === J ? !0 : V && V.nodeType === 3 ? !1 : J && J.nodeType === 3 ? Ml(V, J.parentNode) : "contains" in V ? V.contains(J) : V.compareDocumentPosition ? !!(V.compareDocumentPosition(J) & 16) : !1 : !1 } function Al() { for (var V = window, J = Je(); J instanceof V.HTMLIFrameElement;) { try { var fe = typeof J.contentWindow.location.href == "string" } catch { fe = !1 } if (fe) V = J.contentWindow; else break; J = Je(V.document) } return J } function qs(V) { var J = V && V.nodeName && V.nodeName.toLowerCase(); return J && (J === "input" && (V.type === "text" || V.type === "search" || V.type === "tel" || V.type === "url" || V.type === "password") || J === "textarea" || V.contentEditable === "true") } function pc(V) { var J = Al(), fe = V.focusedElem, de = V.selectionRange; if (J !== fe && fe && fe.ownerDocument && Ml(fe.ownerDocument.documentElement, fe)) { if (de !== null && qs(fe)) { if (J = de.start, V = de.end, V === void 0 && (V = J), "selectionStart" in fe) fe.selectionStart = J, fe.selectionEnd = Math.min(V, fe.value.length); else if (V = (J = fe.ownerDocument || document) && J.defaultView || window, V.getSelection) { V = V.getSelection(); var we = fe.textContent.length, Te = Math.min(de.start, we); de = de.end === void 0 ? Te : Math.min(de.end, we), !V.extend && Te > de && (we = de, de = Te, Te = we), we = El(fe, Te); var He = El(fe, de); we && He && (V.rangeCount !== 1 || V.anchorNode !== we.node || V.anchorOffset !== we.offset || V.focusNode !== He.node || V.focusOffset !== He.offset) && (J = J.createRange(), J.setStart(we.node, we.offset), V.removeAllRanges(), Te > de ? (V.addRange(J), V.extend(He.node, He.offset)) : (J.setEnd(He.node, He.offset), V.addRange(J))) } } for (J = [], V = fe; V = V.parentNode;)V.nodeType === 1 && J.push({ element: V, left: V.scrollLeft, top: V.scrollTop }); for (typeof fe.focus == "function" && fe.focus(), fe = 0; fe < J.length; fe++)V = J[fe], V.element.scrollLeft = V.left, V.element.scrollTop = V.top } } var mc = v && "documentMode" in document && 11 >= document.documentMode, Ei = null, Ds = null, ea = null, Ls = !1; function Rl(V, J, fe) { var de = fe.window === fe ? fe.document : fe.nodeType === 9 ? fe : fe.ownerDocument; Ls || Ei == null || Ei !== Je(de) || (de = Ei, "selectionStart" in de && qs(de) ? de = { start: de.selectionStart, end: de.selectionEnd } : (de = (de.ownerDocument && de.ownerDocument.defaultView || window).getSelection(), de = { anchorNode: de.anchorNode, anchorOffset: de.anchorOffset, focusNode: de.focusNode, focusOffset: de.focusOffset }), ea && Qi(ea, de) || (ea = de, de = Ba(Ds, "onSelect"), 0 < de.length && (J = new Rs("onSelect", "select", null, J, fe), V.push({ event: J, listeners: de }), J.target = Ei))) } function Ta(V, J) { var fe = {}; return fe[V.toLowerCase()] = J.toLowerCase(), fe["Webkit" + V] = "webkit" + J, fe["Moz" + V] = "moz" + J, fe } var Mi = { animationend: Ta("Animation", "AnimationEnd"), animationiteration: Ta("Animation", "AnimationIteration"), animationstart: Ta("Animation", "AnimationStart"), transitionend: Ta("Transition", "TransitionEnd") }, Fs = {}, Cl = {}; v && (Cl = document.createElement("div").style, "AnimationEvent" in window || (delete Mi.animationend.animation, delete Mi.animationiteration.animation, delete Mi.animationstart.animation), "TransitionEvent" in window || delete Mi.transitionend.transition); function ka(V) { if (Fs[V]) return Fs[V]; if (!Mi[V]) return V; var J = Mi[V], fe; for (fe in J) if (J.hasOwnProperty(fe) && fe in Cl) return Fs[V] = J[fe]; return V } var Pl = ka("animationend"), Tl = ka("animationiteration"), kl = ka("animationstart"), Il = ka("transitionend"), Bl = new Map, Ol = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Kn(V, J) { Bl.set(V, J), d(J, [V]) } for (var Ns = 0; Ns < Ol.length; Ns++) { var $s = Ol[Ns], gc = $s.toLowerCase(), vc = $s[0].toUpperCase() + $s.slice(1); Kn(gc, "on" + vc) } Kn(Pl, "onAnimationEnd"), Kn(Tl, "onAnimationIteration"), Kn(kl, "onAnimationStart"), Kn("dblclick", "onDoubleClick"), Kn("focusin", "onFocus"), Kn("focusout", "onBlur"), Kn(Il, "onTransitionEnd"), m("onMouseEnter", ["mouseout", "mouseover"]), m("onMouseLeave", ["mouseout", "mouseover"]), m("onPointerEnter", ["pointerout", "pointerover"]), m("onPointerLeave", ["pointerout", "pointerover"]), d("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), d("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), d("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), d("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), d("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ta = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), yc = new Set("cancel close invalid load scroll toggle".split(" ").concat(ta)); function ql(V, J, fe) { var de = V.type || "unknown-event"; V.currentTarget = fe, rt(de, J, void 0, V), V.currentTarget = null } function Dl(V, J) { J = (J & 4) !== 0; for (var fe = 0; fe < V.length; fe++) { var de = V[fe], we = de.event; de = de.listeners; e: { var Te = void 0; if (J) for (var He = de.length - 1; 0 <= He; He--) { var ot = de[He], vt = ot.instance, Pt = ot.currentTarget; if (ot = ot.listener, vt !== Te && we.isPropagationStopped()) break e; ql(we, ot, Pt), Te = vt } else for (He = 0; He < de.length; He++) { if (ot = de[He], vt = ot.instance, Pt = ot.currentTarget, ot = ot.listener, vt !== Te && we.isPropagationStopped()) break e; ql(we, ot, Pt), Te = vt } } } if (be) throw V = Fe, be = !1, Fe = null, V } function qr(V, J) { var fe = J[Zs]; fe === void 0 && (fe = J[Zs] = new Set); var de = V + "__bubble"; fe.has(de) || (Ll(J, V, 2, !1), fe.add(de)) } function Us(V, J, fe) { var de = 0; J && (de |= 4), Ll(fe, V, de, J) } var Ia = "_reactListening" + Math.random().toString(36).slice(2); function ra(V) { if (!V[Ia]) { V[Ia] = !0, f.forEach(function (fe) { fe !== "selectionchange" && (yc.has(fe) || Us(fe, !1, V), Us(fe, !0, V)) }); var J = V.nodeType === 9 ? V : V.ownerDocument; J === null || J[Ia] || (J[Ia] = !0, Us("selectionchange", !1, J)) } } function Ll(V, J, fe, de) { switch (sl(J)) { case 1: var we = kf; break; case 4: we = If; break; default: we = Es }fe = we.bind(null, J, fe, V), we = void 0, !Ne || J !== "touchstart" && J !== "touchmove" && J !== "wheel" || (we = !0), de ? we !== void 0 ? V.addEventListener(J, fe, { capture: !0, passive: we }) : V.addEventListener(J, fe, !0) : we !== void 0 ? V.addEventListener(J, fe, { passive: we }) : V.addEventListener(J, fe, !1) } function Vs(V, J, fe, de, we) { var Te = de; if ((J & 1) === 0 && (J & 2) === 0 && de !== null) e: for (; ;) { if (de === null) return; var He = de.tag; if (He === 3 || He === 4) { var ot = de.stateNode.containerInfo; if (ot === we || ot.nodeType === 8 && ot.parentNode === we) break; if (He === 4) for (He = de.return; He !== null;) { var vt = He.tag; if ((vt === 3 || vt === 4) && (vt = He.stateNode.containerInfo, vt === we || vt.nodeType === 8 && vt.parentNode === we)) return; He = He.return } for (; ot !== null;) { if (He = ui(ot), He === null) return; if (vt = He.tag, vt === 5 || vt === 6) { de = Te = He; continue e } ot = ot.parentNode } } de = de.return } xe(function () { var Pt = Te, Vt = tt(fe), Zt = []; e: { var Ut = Bl.get(V); if (Ut !== void 0) { var or = Rs, fr = V; switch (V) { case "keypress": if (Aa(fe) === 0) break e; case "keydown": case "keyup": or = Kf; break; case "focusin": fr = "focus", or = Ts; break; case "focusout": fr = "blur", or = Ts; break; case "beforeblur": case "afterblur": or = Ts; break; case "click": if (fe.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": or = ul; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": or = qf; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": or = Yf; break; case Pl: case Tl: case kl: or = Ff; break; case Il: or = Jf; break; case "scroll": or = Bf; break; case "wheel": or = tc; break; case "copy": case "cut": case "paste": or = $f; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": or = cl }var cr = (J & 4) !== 0, jr = !cr && V === "scroll", Rt = cr ? Ut !== null ? Ut + "Capture" : null : Ut; cr = []; for (var xt = Pt, Ct; xt !== null;) { Ct = xt; var Jt = Ct.stateNode; if (Ct.tag === 5 && Jt !== null && (Ct = Jt, Rt !== null && (Jt = Ce(xt, Rt), Jt != null && cr.push(na(xt, Jt, Ct)))), jr) break; xt = xt.return } 0 < cr.length && (Ut = new or(Ut, fr, null, fe, Vt), Zt.push({ event: Ut, listeners: cr })) } } if ((J & 7) === 0) { e: { if (Ut = V === "mouseover" || V === "pointerover", or = V === "mouseout" || V === "pointerout", Ut && fe !== Tt && (fr = fe.relatedTarget || fe.fromElement) && (ui(fr) || fr[On])) break e; if ((or || Ut) && (Ut = Vt.window === Vt ? Vt : (Ut = Vt.ownerDocument) ? Ut.defaultView || Ut.parentWindow : window, or ? (fr = fe.relatedTarget || fe.toElement, or = Pt, fr = fr ? ui(fr) : null, fr !== null && (jr = ct(fr), fr !== jr || fr.tag !== 5 && fr.tag !== 6) && (fr = null)) : (or = null, fr = Pt), or !== fr)) { if (cr = ul, Jt = "onMouseLeave", Rt = "onMouseEnter", xt = "mouse", (V === "pointerout" || V === "pointerover") && (cr = cl, Jt = "onPointerLeave", Rt = "onPointerEnter", xt = "pointer"), jr = or == null ? Ut : Ci(or), Ct = fr == null ? Ut : Ci(fr), Ut = new cr(Jt, xt + "leave", or, fe, Vt), Ut.target = jr, Ut.relatedTarget = Ct, Jt = null, ui(Vt) === Pt && (cr = new cr(Rt, xt + "enter", fr, fe, Vt), cr.target = Ct, cr.relatedTarget = jr, Jt = cr), jr = Jt, or && fr) t: { for (cr = or, Rt = fr, xt = 0, Ct = cr; Ct; Ct = Ai(Ct))xt++; for (Ct = 0, Jt = Rt; Jt; Jt = Ai(Jt))Ct++; for (; 0 < xt - Ct;)cr = Ai(cr), xt--; for (; 0 < Ct - xt;)Rt = Ai(Rt), Ct--; for (; xt--;) { if (cr === Rt || Rt !== null && cr === Rt.alternate) break t; cr = Ai(cr), Rt = Ai(Rt) } cr = null } else cr = null; or !== null && Fl(Zt, Ut, or, cr, !1), fr !== null && jr !== null && Fl(Zt, jr, fr, cr, !0) } } e: { if (Ut = Pt ? Ci(Pt) : window, or = Ut.nodeName && Ut.nodeName.toLowerCase(), or === "select" || or === "input" && Ut.type === "file") var hr = lc; else if (vl(Ut)) if (bl) hr = hc; else { hr = fc; var gr = uc } else (or = Ut.nodeName) && or.toLowerCase() === "input" && (Ut.type === "checkbox" || Ut.type === "radio") && (hr = cc); if (hr && (hr = hr(V, Pt))) { yl(Zt, hr, fe, Vt); break e } gr && gr(V, Ut, Pt), V === "focusout" && (gr = Ut._wrapperState) && gr.controlled && Ut.type === "number" && et(Ut, "number", Ut.value) } switch (gr = Pt ? Ci(Pt) : window, V) { case "focusin": (vl(gr) || gr.contentEditable === "true") && (Ei = gr, Ds = Pt, ea = null); break; case "focusout": ea = Ds = Ei = null; break; case "mousedown": Ls = !0; break; case "contextmenu": case "mouseup": case "dragend": Ls = !1, Rl(Zt, fe, Vt); break; case "selectionchange": if (mc) break; case "keydown": case "keyup": Rl(Zt, fe, Vt) }var vr; if (Is) e: { switch (V) { case "compositionstart": var wr = "onCompositionStart"; break e; case "compositionend": wr = "onCompositionEnd"; break e; case "compositionupdate": wr = "onCompositionUpdate"; break e }wr = void 0 } else Si ? ml(V, fe) && (wr = "onCompositionEnd") : V === "keydown" && fe.keyCode === 229 && (wr = "onCompositionStart"); wr && (hl && fe.locale !== "ko" && (Si || wr !== "onCompositionStart" ? wr === "onCompositionEnd" && Si && (vr = ol()) : (Gn = Vt, As = "value" in Gn ? Gn.value : Gn.textContent, Si = !0)), gr = Ba(Pt, wr), 0 < gr.length && (wr = new fl(wr, V, null, fe, Vt), Zt.push({ event: wr, listeners: gr }), vr ? wr.data = vr : (vr = gl(fe), vr !== null && (wr.data = vr)))), (vr = nc ? ic(V, fe) : ac(V, fe)) && (Pt = Ba(Pt, "onBeforeInput"), 0 < Pt.length && (Vt = new fl("onBeforeInput", "beforeinput", null, fe, Vt), Zt.push({ event: Vt, listeners: Pt }), Vt.data = vr)) } Dl(Zt, J) }) } function na(V, J, fe) { return { instance: V, listener: J, currentTarget: fe } } function Ba(V, J) { for (var fe = J + "Capture", de = []; V !== null;) { var we = V, Te = we.stateNode; we.tag === 5 && Te !== null && (we = Te, Te = Ce(V, fe), Te != null && de.unshift(na(V, Te, we)), Te = Ce(V, J), Te != null && de.push(na(V, Te, we))), V = V.return } return de } function Ai(V) { if (V === null) return null; do V = V.return; while (V && V.tag !== 5); return V || null } function Fl(V, J, fe, de, we) { for (var Te = J._reactName, He = []; fe !== null && fe !== de;) { var ot = fe, vt = ot.alternate, Pt = ot.stateNode; if (vt !== null && vt === de) break; ot.tag === 5 && Pt !== null && (ot = Pt, we ? (vt = Ce(fe, Te), vt != null && He.unshift(na(fe, vt, ot))) : we || (vt = Ce(fe, Te), vt != null && He.push(na(fe, vt, ot)))), fe = fe.return } He.length !== 0 && V.push({ event: J, listeners: He }) } var bc = /\r\n?/g, _c = /\u0000|\uFFFD/g; function Nl(V) {
    return (typeof V == "string" ? V : "" + V).replace(bc, `
`).replace(_c, "")
  } function Oa(V, J, fe) { if (J = Nl(J), Nl(V) !== J && fe) throw Error(u(425)) } function qa() { } var zs = null, Hs = null; function Gs(V, J) { return V === "textarea" || V === "noscript" || typeof J.children == "string" || typeof J.children == "number" || typeof J.dangerouslySetInnerHTML == "object" && J.dangerouslySetInnerHTML !== null && J.dangerouslySetInnerHTML.__html != null } var Ks = typeof setTimeout == "function" ? setTimeout : void 0, wc = typeof clearTimeout == "function" ? clearTimeout : void 0, $l = typeof Promise == "function" ? Promise : void 0, xc = typeof queueMicrotask == "function" ? queueMicrotask : typeof $l < "u" ? function (V) { return $l.resolve(null).then(V).catch(Sc) } : Ks; function Sc(V) { setTimeout(function () { throw V }) } function Ws(V, J) { var fe = J, de = 0; do { var we = fe.nextSibling; if (V.removeChild(fe), we && we.nodeType === 8) if (fe = we.data, fe === "/$") { if (de === 0) { V.removeChild(we), Ki(J); return } de-- } else fe !== "$" && fe !== "$?" && fe !== "$!" || de++; fe = we } while (fe); Ki(J) } function Wn(V) { for (; V != null; V = V.nextSibling) { var J = V.nodeType; if (J === 1 || J === 3) break; if (J === 8) { if (J = V.data, J === "$" || J === "$!" || J === "$?") break; if (J === "/$") return null } } return V } function Ul(V) { V = V.previousSibling; for (var J = 0; V;) { if (V.nodeType === 8) { var fe = V.data; if (fe === "$" || fe === "$!" || fe === "$?") { if (J === 0) return V; J-- } else fe === "/$" && J++ } V = V.previousSibling } return null } var Ri = Math.random().toString(36).slice(2), Tn = "__reactFiber$" + Ri, ia = "__reactProps$" + Ri, On = "__reactContainer$" + Ri, Zs = "__reactEvents$" + Ri, Ec = "__reactListeners$" + Ri, Mc = "__reactHandles$" + Ri; function ui(V) { var J = V[Tn]; if (J) return J; for (var fe = V.parentNode; fe;) { if (J = fe[On] || fe[Tn]) { if (fe = J.alternate, J.child !== null || fe !== null && fe.child !== null) for (V = Ul(V); V !== null;) { if (fe = V[Tn]) return fe; V = Ul(V) } return J } V = fe, fe = V.parentNode } return null } function aa(V) { return V = V[Tn] || V[On], !V || V.tag !== 5 && V.tag !== 6 && V.tag !== 13 && V.tag !== 3 ? null : V } function Ci(V) { if (V.tag === 5 || V.tag === 6) return V.stateNode; throw Error(u(33)) } function Da(V) { return V[ia] || null } var Ys = [], Pi = -1; function Zn(V) { return { current: V } } function Dr(V) { 0 > Pi || (V.current = Ys[Pi], Ys[Pi] = null, Pi--) } function kr(V, J) { Pi++, Ys[Pi] = V.current, V.current = J } var Yn = {}, en = Zn(Yn), on = Zn(!1), fi = Yn; function Ti(V, J) { var fe = V.type.contextTypes; if (!fe) return Yn; var de = V.stateNode; if (de && de.__reactInternalMemoizedUnmaskedChildContext === J) return de.__reactInternalMemoizedMaskedChildContext; var we = {}, Te; for (Te in fe) we[Te] = J[Te]; return de && (V = V.stateNode, V.__reactInternalMemoizedUnmaskedChildContext = J, V.__reactInternalMemoizedMaskedChildContext = we), we } function ln(V) { return V = V.childContextTypes, V != null } function La() { Dr(on), Dr(en) } function jl(V, J, fe) { if (en.current !== Yn) throw Error(u(168)); kr(en, J), kr(on, fe) } function Vl(V, J, fe) { var de = V.stateNode; if (J = J.childContextTypes, typeof de.getChildContext != "function") return fe; de = de.getChildContext(); for (var we in de) if (!(we in J)) throw Error(u(108, Me(V) || "Unknown", we)); return y({}, fe, de) } function Fa(V) { return V = (V = V.stateNode) && V.__reactInternalMemoizedMergedChildContext || Yn, fi = en.current, kr(en, V), kr(on, on.current), !0 } function zl(V, J, fe) { var de = V.stateNode; if (!de) throw Error(u(169)); fe ? (V = Vl(V, J, fi), de.__reactInternalMemoizedMergedChildContext = V, Dr(on), Dr(en), kr(en, V)) : Dr(on), kr(on, fe) } var qn = null, Na = !1, Xs = !1; function Hl(V) { qn === null ? qn = [V] : qn.push(V) } function Ac(V) { Na = !0, Hl(V) } function Xn() { if (!Xs && qn !== null) { Xs = !0; var V = 0, J = dr; try { var fe = qn; for (dr = 1; V < fe.length; V++) { var de = fe[V]; do de = de(!0); while (de !== null) } qn = null, Na = !1 } catch (we) { throw qn !== null && (qn = qn.slice(V + 1)), er(Kt, Xn), we } finally { dr = J, Xs = !1 } } return null } var ki = [], Ii = 0, $a = null, Ua = 0, vn = [], yn = 0, ci = null, Dn = 1, Ln = ""; function hi(V, J) { ki[Ii++] = Ua, ki[Ii++] = $a, $a = V, Ua = J } function Gl(V, J, fe) { vn[yn++] = Dn, vn[yn++] = Ln, vn[yn++] = ci, ci = V; var de = Dn; V = Ln; var we = 32 - qt(de) - 1; de &= ~(1 << we), fe += 1; var Te = 32 - qt(J) + we; if (30 < Te) { var He = we - we % 5; Te = (de & (1 << He) - 1).toString(32), de >>= He, we -= He, Dn = 1 << 32 - qt(J) + we | fe << we | de, Ln = Te + V } else Dn = 1 << Te | fe << we | de, Ln = V } function Js(V) { V.return !== null && (hi(V, 1), Gl(V, 1, 0)) } function Qs(V) { for (; V === $a;)$a = ki[--Ii], ki[Ii] = null, Ua = ki[--Ii], ki[Ii] = null; for (; V === ci;)ci = vn[--yn], vn[yn] = null, Ln = vn[--yn], vn[yn] = null, Dn = vn[--yn], vn[yn] = null } var pn = null, mn = null, Lr = !1, Mn = null; function Kl(V, J) { var fe = Sn(5, null, null, 0); fe.elementType = "DELETED", fe.stateNode = J, fe.return = V, J = V.deletions, J === null ? (V.deletions = [fe], V.flags |= 16) : J.push(fe) } function Wl(V, J) { switch (V.tag) { case 5: var fe = V.type; return J = J.nodeType !== 1 || fe.toLowerCase() !== J.nodeName.toLowerCase() ? null : J, J !== null ? (V.stateNode = J, pn = V, mn = Wn(J.firstChild), !0) : !1; case 6: return J = V.pendingProps === "" || J.nodeType !== 3 ? null : J, J !== null ? (V.stateNode = J, pn = V, mn = null, !0) : !1; case 13: return J = J.nodeType !== 8 ? null : J, J !== null ? (fe = ci !== null ? { id: Dn, overflow: Ln } : null, V.memoizedState = { dehydrated: J, treeContext: fe, retryLane: 1073741824 }, fe = Sn(18, null, null, 0), fe.stateNode = J, fe.return = V, V.child = fe, pn = V, mn = null, !0) : !1; default: return !1 } } function eo(V) { return (V.mode & 1) !== 0 && (V.flags & 128) === 0 } function to(V) { if (Lr) { var J = mn; if (J) { var fe = J; if (!Wl(V, J)) { if (eo(V)) throw Error(u(418)); J = Wn(fe.nextSibling); var de = pn; J && Wl(V, J) ? Kl(de, fe) : (V.flags = V.flags & -4097 | 2, Lr = !1, pn = V) } } else { if (eo(V)) throw Error(u(418)); V.flags = V.flags & -4097 | 2, Lr = !1, pn = V } } } function Zl(V) { for (V = V.return; V !== null && V.tag !== 5 && V.tag !== 3 && V.tag !== 13;)V = V.return; pn = V } function ja(V) { if (V !== pn) return !1; if (!Lr) return Zl(V), Lr = !0, !1; var J; if ((J = V.tag !== 3) && !(J = V.tag !== 5) && (J = V.type, J = J !== "head" && J !== "body" && !Gs(V.type, V.memoizedProps)), J && (J = mn)) { if (eo(V)) throw Yl(), Error(u(418)); for (; J;)Kl(V, J), J = Wn(J.nextSibling) } if (Zl(V), V.tag === 13) { if (V = V.memoizedState, V = V !== null ? V.dehydrated : null, !V) throw Error(u(317)); e: { for (V = V.nextSibling, J = 0; V;) { if (V.nodeType === 8) { var fe = V.data; if (fe === "/$") { if (J === 0) { mn = Wn(V.nextSibling); break e } J-- } else fe !== "$" && fe !== "$!" && fe !== "$?" || J++ } V = V.nextSibling } mn = null } } else mn = pn ? Wn(V.stateNode.nextSibling) : null; return !0 } function Yl() { for (var V = mn; V;)V = Wn(V.nextSibling) } function Bi() { mn = pn = null, Lr = !1 } function ro(V) { Mn === null ? Mn = [V] : Mn.push(V) } var Rc = ue.ReactCurrentBatchConfig; function sa(V, J, fe) { if (V = fe.ref, V !== null && typeof V != "function" && typeof V != "object") { if (fe._owner) { if (fe = fe._owner, fe) { if (fe.tag !== 1) throw Error(u(309)); var de = fe.stateNode } if (!de) throw Error(u(147, V)); var we = de, Te = "" + V; return J !== null && J.ref !== null && typeof J.ref == "function" && J.ref._stringRef === Te ? J.ref : (J = function (He) { var ot = we.refs; He === null ? delete ot[Te] : ot[Te] = He }, J._stringRef = Te, J) } if (typeof V != "string") throw Error(u(284)); if (!fe._owner) throw Error(u(290, V)) } return V } function Va(V, J) { throw V = Object.prototype.toString.call(J), Error(u(31, V === "[object Object]" ? "object with keys {" + Object.keys(J).join(", ") + "}" : V)) } function Xl(V) { var J = V._init; return J(V._payload) } function Jl(V) { function J(Rt, xt) { if (V) { var Ct = Rt.deletions; Ct === null ? (Rt.deletions = [xt], Rt.flags |= 16) : Ct.push(xt) } } function fe(Rt, xt) { if (!V) return null; for (; xt !== null;)J(Rt, xt), xt = xt.sibling; return null } function de(Rt, xt) { for (Rt = new Map; xt !== null;)xt.key !== null ? Rt.set(xt.key, xt) : Rt.set(xt.index, xt), xt = xt.sibling; return Rt } function we(Rt, xt) { return Rt = ai(Rt, xt), Rt.index = 0, Rt.sibling = null, Rt } function Te(Rt, xt, Ct) { return Rt.index = Ct, V ? (Ct = Rt.alternate, Ct !== null ? (Ct = Ct.index, Ct < xt ? (Rt.flags |= 2, xt) : Ct) : (Rt.flags |= 2, xt)) : (Rt.flags |= 1048576, xt) } function He(Rt) { return V && Rt.alternate === null && (Rt.flags |= 2), Rt } function ot(Rt, xt, Ct, Jt) { return xt === null || xt.tag !== 6 ? (xt = Wo(Ct, Rt.mode, Jt), xt.return = Rt, xt) : (xt = we(xt, Ct), xt.return = Rt, xt) } function vt(Rt, xt, Ct, Jt) { var hr = Ct.type; return hr === ve ? Vt(Rt, xt, Ct.props.children, Jt, Ct.key) : xt !== null && (xt.elementType === hr || typeof hr == "object" && hr !== null && hr.$$typeof === Y && Xl(hr) === xt.type) ? (Jt = we(xt, Ct.props), Jt.ref = sa(Rt, xt, Ct), Jt.return = Rt, Jt) : (Jt = ps(Ct.type, Ct.key, Ct.props, null, Rt.mode, Jt), Jt.ref = sa(Rt, xt, Ct), Jt.return = Rt, Jt) } function Pt(Rt, xt, Ct, Jt) { return xt === null || xt.tag !== 4 || xt.stateNode.containerInfo !== Ct.containerInfo || xt.stateNode.implementation !== Ct.implementation ? (xt = Zo(Ct, Rt.mode, Jt), xt.return = Rt, xt) : (xt = we(xt, Ct.children || []), xt.return = Rt, xt) } function Vt(Rt, xt, Ct, Jt, hr) { return xt === null || xt.tag !== 7 ? (xt = _i(Ct, Rt.mode, Jt, hr), xt.return = Rt, xt) : (xt = we(xt, Ct), xt.return = Rt, xt) } function Zt(Rt, xt, Ct) { if (typeof xt == "string" && xt !== "" || typeof xt == "number") return xt = Wo("" + xt, Rt.mode, Ct), xt.return = Rt, xt; if (typeof xt == "object" && xt !== null) { switch (xt.$$typeof) { case he: return Ct = ps(xt.type, xt.key, xt.props, null, Rt.mode, Ct), Ct.ref = sa(Rt, null, xt), Ct.return = Rt, Ct; case pe: return xt = Zo(xt, Rt.mode, Ct), xt.return = Rt, xt; case Y: var Jt = xt._init; return Zt(Rt, Jt(xt._payload), Ct) }if (Gt(xt) || G(xt)) return xt = _i(xt, Rt.mode, Ct, null), xt.return = Rt, xt; Va(Rt, xt) } return null } function Ut(Rt, xt, Ct, Jt) { var hr = xt !== null ? xt.key : null; if (typeof Ct == "string" && Ct !== "" || typeof Ct == "number") return hr !== null ? null : ot(Rt, xt, "" + Ct, Jt); if (typeof Ct == "object" && Ct !== null) { switch (Ct.$$typeof) { case he: return Ct.key === hr ? vt(Rt, xt, Ct, Jt) : null; case pe: return Ct.key === hr ? Pt(Rt, xt, Ct, Jt) : null; case Y: return hr = Ct._init, Ut(Rt, xt, hr(Ct._payload), Jt) }if (Gt(Ct) || G(Ct)) return hr !== null ? null : Vt(Rt, xt, Ct, Jt, null); Va(Rt, Ct) } return null } function or(Rt, xt, Ct, Jt, hr) { if (typeof Jt == "string" && Jt !== "" || typeof Jt == "number") return Rt = Rt.get(Ct) || null, ot(xt, Rt, "" + Jt, hr); if (typeof Jt == "object" && Jt !== null) { switch (Jt.$$typeof) { case he: return Rt = Rt.get(Jt.key === null ? Ct : Jt.key) || null, vt(xt, Rt, Jt, hr); case pe: return Rt = Rt.get(Jt.key === null ? Ct : Jt.key) || null, Pt(xt, Rt, Jt, hr); case Y: var gr = Jt._init; return or(Rt, xt, Ct, gr(Jt._payload), hr) }if (Gt(Jt) || G(Jt)) return Rt = Rt.get(Ct) || null, Vt(xt, Rt, Jt, hr, null); Va(xt, Jt) } return null } function fr(Rt, xt, Ct, Jt) { for (var hr = null, gr = null, vr = xt, wr = xt = 0, Xr = null; vr !== null && wr < Ct.length; wr++) { vr.index > wr ? (Xr = vr, vr = null) : Xr = vr.sibling; var Pr = Ut(Rt, vr, Ct[wr], Jt); if (Pr === null) { vr === null && (vr = Xr); break } V && vr && Pr.alternate === null && J(Rt, vr), xt = Te(Pr, xt, wr), gr === null ? hr = Pr : gr.sibling = Pr, gr = Pr, vr = Xr } if (wr === Ct.length) return fe(Rt, vr), Lr && hi(Rt, wr), hr; if (vr === null) { for (; wr < Ct.length; wr++)vr = Zt(Rt, Ct[wr], Jt), vr !== null && (xt = Te(vr, xt, wr), gr === null ? hr = vr : gr.sibling = vr, gr = vr); return Lr && hi(Rt, wr), hr } for (vr = de(Rt, vr); wr < Ct.length; wr++)Xr = or(vr, Rt, wr, Ct[wr], Jt), Xr !== null && (V && Xr.alternate !== null && vr.delete(Xr.key === null ? wr : Xr.key), xt = Te(Xr, xt, wr), gr === null ? hr = Xr : gr.sibling = Xr, gr = Xr); return V && vr.forEach(function (si) { return J(Rt, si) }), Lr && hi(Rt, wr), hr } function cr(Rt, xt, Ct, Jt) { var hr = G(Ct); if (typeof hr != "function") throw Error(u(150)); if (Ct = hr.call(Ct), Ct == null) throw Error(u(151)); for (var gr = hr = null, vr = xt, wr = xt = 0, Xr = null, Pr = Ct.next(); vr !== null && !Pr.done; wr++, Pr = Ct.next()) { vr.index > wr ? (Xr = vr, vr = null) : Xr = vr.sibling; var si = Ut(Rt, vr, Pr.value, Jt); if (si === null) { vr === null && (vr = Xr); break } V && vr && si.alternate === null && J(Rt, vr), xt = Te(si, xt, wr), gr === null ? hr = si : gr.sibling = si, gr = si, vr = Xr } if (Pr.done) return fe(Rt, vr), Lr && hi(Rt, wr), hr; if (vr === null) { for (; !Pr.done; wr++, Pr = Ct.next())Pr = Zt(Rt, Pr.value, Jt), Pr !== null && (xt = Te(Pr, xt, wr), gr === null ? hr = Pr : gr.sibling = Pr, gr = Pr); return Lr && hi(Rt, wr), hr } for (vr = de(Rt, vr); !Pr.done; wr++, Pr = Ct.next())Pr = or(vr, Rt, wr, Pr.value, Jt), Pr !== null && (V && Pr.alternate !== null && vr.delete(Pr.key === null ? wr : Pr.key), xt = Te(Pr, xt, wr), gr === null ? hr = Pr : gr.sibling = Pr, gr = Pr); return V && vr.forEach(function (sh) { return J(Rt, sh) }), Lr && hi(Rt, wr), hr } function jr(Rt, xt, Ct, Jt) { if (typeof Ct == "object" && Ct !== null && Ct.type === ve && Ct.key === null && (Ct = Ct.props.children), typeof Ct == "object" && Ct !== null) { switch (Ct.$$typeof) { case he: e: { for (var hr = Ct.key, gr = xt; gr !== null;) { if (gr.key === hr) { if (hr = Ct.type, hr === ve) { if (gr.tag === 7) { fe(Rt, gr.sibling), xt = we(gr, Ct.props.children), xt.return = Rt, Rt = xt; break e } } else if (gr.elementType === hr || typeof hr == "object" && hr !== null && hr.$$typeof === Y && Xl(hr) === gr.type) { fe(Rt, gr.sibling), xt = we(gr, Ct.props), xt.ref = sa(Rt, gr, Ct), xt.return = Rt, Rt = xt; break e } fe(Rt, gr); break } else J(Rt, gr); gr = gr.sibling } Ct.type === ve ? (xt = _i(Ct.props.children, Rt.mode, Jt, Ct.key), xt.return = Rt, Rt = xt) : (Jt = ps(Ct.type, Ct.key, Ct.props, null, Rt.mode, Jt), Jt.ref = sa(Rt, xt, Ct), Jt.return = Rt, Rt = Jt) } return He(Rt); case pe: e: { for (gr = Ct.key; xt !== null;) { if (xt.key === gr) if (xt.tag === 4 && xt.stateNode.containerInfo === Ct.containerInfo && xt.stateNode.implementation === Ct.implementation) { fe(Rt, xt.sibling), xt = we(xt, Ct.children || []), xt.return = Rt, Rt = xt; break e } else { fe(Rt, xt); break } else J(Rt, xt); xt = xt.sibling } xt = Zo(Ct, Rt.mode, Jt), xt.return = Rt, Rt = xt } return He(Rt); case Y: return gr = Ct._init, jr(Rt, xt, gr(Ct._payload), Jt) }if (Gt(Ct)) return fr(Rt, xt, Ct, Jt); if (G(Ct)) return cr(Rt, xt, Ct, Jt); Va(Rt, Ct) } return typeof Ct == "string" && Ct !== "" || typeof Ct == "number" ? (Ct = "" + Ct, xt !== null && xt.tag === 6 ? (fe(Rt, xt.sibling), xt = we(xt, Ct), xt.return = Rt, Rt = xt) : (fe(Rt, xt), xt = Wo(Ct, Rt.mode, Jt), xt.return = Rt, Rt = xt), He(Rt)) : fe(Rt, xt) } return jr } var Oi = Jl(!0), Ql = Jl(!1), za = Zn(null), Ha = null, qi = null, no = null; function io() { no = qi = Ha = null } function ao(V) { var J = za.current; Dr(za), V._currentValue = J } function so(V, J, fe) { for (; V !== null;) { var de = V.alternate; if ((V.childLanes & J) !== J ? (V.childLanes |= J, de !== null && (de.childLanes |= J)) : de !== null && (de.childLanes & J) !== J && (de.childLanes |= J), V === fe) break; V = V.return } } function Di(V, J) { Ha = V, no = qi = null, V = V.dependencies, V !== null && V.firstContext !== null && ((V.lanes & J) !== 0 && (un = !0), V.firstContext = null) } function _n(V) { var J = V._currentValue; if (no !== V) if (V = { context: V, memoizedValue: J, next: null }, qi === null) { if (Ha === null) throw Error(u(308)); qi = V, Ha.dependencies = { lanes: 0, firstContext: V } } else qi = qi.next = V; return J } var di = null; function oo(V) { di === null ? di = [V] : di.push(V) } function eu(V, J, fe, de) { var we = J.interleaved; return we === null ? (fe.next = fe, oo(J)) : (fe.next = we.next, we.next = fe), J.interleaved = fe, Fn(V, de) } function Fn(V, J) { V.lanes |= J; var fe = V.alternate; for (fe !== null && (fe.lanes |= J), fe = V, V = V.return; V !== null;)V.childLanes |= J, fe = V.alternate, fe !== null && (fe.childLanes |= J), fe = V, V = V.return; return fe.tag === 3 ? fe.stateNode : null } var Jn = !1; function lo(V) { V.updateQueue = { baseState: V.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function tu(V, J) { V = V.updateQueue, J.updateQueue === V && (J.updateQueue = { baseState: V.baseState, firstBaseUpdate: V.firstBaseUpdate, lastBaseUpdate: V.lastBaseUpdate, shared: V.shared, effects: V.effects }) } function Nn(V, J) { return { eventTime: V, lane: J, tag: 0, payload: null, callback: null, next: null } } function Qn(V, J, fe) { var de = V.updateQueue; if (de === null) return null; if (de = de.shared, (Cr & 2) !== 0) { var we = de.pending; return we === null ? J.next = J : (J.next = we.next, we.next = J), de.pending = J, Fn(V, fe) } return we = de.interleaved, we === null ? (J.next = J, oo(de)) : (J.next = we.next, we.next = J), de.interleaved = J, Fn(V, fe) } function Ga(V, J, fe) { if (J = J.updateQueue, J !== null && (J = J.shared, (fe & 4194240) !== 0)) { var de = J.lanes; de &= V.pendingLanes, fe |= de, J.lanes = fe, Ir(V, fe) } } function ru(V, J) { var fe = V.updateQueue, de = V.alternate; if (de !== null && (de = de.updateQueue, fe === de)) { var we = null, Te = null; if (fe = fe.firstBaseUpdate, fe !== null) { do { var He = { eventTime: fe.eventTime, lane: fe.lane, tag: fe.tag, payload: fe.payload, callback: fe.callback, next: null }; Te === null ? we = Te = He : Te = Te.next = He, fe = fe.next } while (fe !== null); Te === null ? we = Te = J : Te = Te.next = J } else we = Te = J; fe = { baseState: de.baseState, firstBaseUpdate: we, lastBaseUpdate: Te, shared: de.shared, effects: de.effects }, V.updateQueue = fe; return } V = fe.lastBaseUpdate, V === null ? fe.firstBaseUpdate = J : V.next = J, fe.lastBaseUpdate = J } function Ka(V, J, fe, de) { var we = V.updateQueue; Jn = !1; var Te = we.firstBaseUpdate, He = we.lastBaseUpdate, ot = we.shared.pending; if (ot !== null) { we.shared.pending = null; var vt = ot, Pt = vt.next; vt.next = null, He === null ? Te = Pt : He.next = Pt, He = vt; var Vt = V.alternate; Vt !== null && (Vt = Vt.updateQueue, ot = Vt.lastBaseUpdate, ot !== He && (ot === null ? Vt.firstBaseUpdate = Pt : ot.next = Pt, Vt.lastBaseUpdate = vt)) } if (Te !== null) { var Zt = we.baseState; He = 0, Vt = Pt = vt = null, ot = Te; do { var Ut = ot.lane, or = ot.eventTime; if ((de & Ut) === Ut) { Vt !== null && (Vt = Vt.next = { eventTime: or, lane: 0, tag: ot.tag, payload: ot.payload, callback: ot.callback, next: null }); e: { var fr = V, cr = ot; switch (Ut = J, or = fe, cr.tag) { case 1: if (fr = cr.payload, typeof fr == "function") { Zt = fr.call(or, Zt, Ut); break e } Zt = fr; break e; case 3: fr.flags = fr.flags & -65537 | 128; case 0: if (fr = cr.payload, Ut = typeof fr == "function" ? fr.call(or, Zt, Ut) : fr, Ut == null) break e; Zt = y({}, Zt, Ut); break e; case 2: Jn = !0 } } ot.callback !== null && ot.lane !== 0 && (V.flags |= 64, Ut = we.effects, Ut === null ? we.effects = [ot] : Ut.push(ot)) } else or = { eventTime: or, lane: Ut, tag: ot.tag, payload: ot.payload, callback: ot.callback, next: null }, Vt === null ? (Pt = Vt = or, vt = Zt) : Vt = Vt.next = or, He |= Ut; if (ot = ot.next, ot === null) { if (ot = we.shared.pending, ot === null) break; Ut = ot, ot = Ut.next, Ut.next = null, we.lastBaseUpdate = Ut, we.shared.pending = null } } while (!0); if (Vt === null && (vt = Zt), we.baseState = vt, we.firstBaseUpdate = Pt, we.lastBaseUpdate = Vt, J = we.shared.interleaved, J !== null) { we = J; do He |= we.lane, we = we.next; while (we !== J) } else Te === null && (we.shared.lanes = 0); gi |= He, V.lanes = He, V.memoizedState = Zt } } function nu(V, J, fe) { if (V = J.effects, J.effects = null, V !== null) for (J = 0; J < V.length; J++) { var de = V[J], we = de.callback; if (we !== null) { if (de.callback = null, de = fe, typeof we != "function") throw Error(u(191, we)); we.call(de) } } } var oa = {}, kn = Zn(oa), la = Zn(oa), ua = Zn(oa); function pi(V) { if (V === oa) throw Error(u(174)); return V } function uo(V, J) { switch (kr(ua, J), kr(la, V), kr(kn, oa), V = J.nodeType, V) { case 9: case 11: J = (J = J.documentElement) ? J.namespaceURI : ze(null, ""); break; default: V = V === 8 ? J.parentNode : J, J = V.namespaceURI || null, V = V.tagName, J = ze(J, V) }Dr(kn), kr(kn, J) } function Li() { Dr(kn), Dr(la), Dr(ua) } function iu(V) { pi(ua.current); var J = pi(kn.current), fe = ze(J, V.type); J !== fe && (kr(la, V), kr(kn, fe)) } function fo(V) { la.current === V && (Dr(kn), Dr(la)) } var Fr = Zn(0); function Wa(V) { for (var J = V; J !== null;) { if (J.tag === 13) { var fe = J.memoizedState; if (fe !== null && (fe = fe.dehydrated, fe === null || fe.data === "$?" || fe.data === "$!")) return J } else if (J.tag === 19 && J.memoizedProps.revealOrder !== void 0) { if ((J.flags & 128) !== 0) return J } else if (J.child !== null) { J.child.return = J, J = J.child; continue } if (J === V) break; for (; J.sibling === null;) { if (J.return === null || J.return === V) return null; J = J.return } J.sibling.return = J.return, J = J.sibling } return null } var co = []; function ho() { for (var V = 0; V < co.length; V++)co[V]._workInProgressVersionPrimary = null; co.length = 0 } var Za = ue.ReactCurrentDispatcher, po = ue.ReactCurrentBatchConfig, mi = 0, Nr = null, Kr = null, Zr = null, Ya = !1, fa = !1, ca = 0, Cc = 0; function tn() { throw Error(u(321)) } function mo(V, J) { if (J === null) return !1; for (var fe = 0; fe < J.length && fe < V.length; fe++)if (!En(V[fe], J[fe])) return !1; return !0 } function go(V, J, fe, de, we, Te) { if (mi = Te, Nr = J, J.memoizedState = null, J.updateQueue = null, J.lanes = 0, Za.current = V === null || V.memoizedState === null ? Ic : Bc, V = fe(de, we), fa) { Te = 0; do { if (fa = !1, ca = 0, 25 <= Te) throw Error(u(301)); Te += 1, Zr = Kr = null, J.updateQueue = null, Za.current = Oc, V = fe(de, we) } while (fa) } if (Za.current = Qa, J = Kr !== null && Kr.next !== null, mi = 0, Zr = Kr = Nr = null, Ya = !1, J) throw Error(u(300)); return V } function vo() { var V = ca !== 0; return ca = 0, V } function In() { var V = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Zr === null ? Nr.memoizedState = Zr = V : Zr = Zr.next = V, Zr } function wn() { if (Kr === null) { var V = Nr.alternate; V = V !== null ? V.memoizedState : null } else V = Kr.next; var J = Zr === null ? Nr.memoizedState : Zr.next; if (J !== null) Zr = J, Kr = V; else { if (V === null) throw Error(u(310)); Kr = V, V = { memoizedState: Kr.memoizedState, baseState: Kr.baseState, baseQueue: Kr.baseQueue, queue: Kr.queue, next: null }, Zr === null ? Nr.memoizedState = Zr = V : Zr = Zr.next = V } return Zr } function ha(V, J) { return typeof J == "function" ? J(V) : J } function yo(V) { var J = wn(), fe = J.queue; if (fe === null) throw Error(u(311)); fe.lastRenderedReducer = V; var de = Kr, we = de.baseQueue, Te = fe.pending; if (Te !== null) { if (we !== null) { var He = we.next; we.next = Te.next, Te.next = He } de.baseQueue = we = Te, fe.pending = null } if (we !== null) { Te = we.next, de = de.baseState; var ot = He = null, vt = null, Pt = Te; do { var Vt = Pt.lane; if ((mi & Vt) === Vt) vt !== null && (vt = vt.next = { lane: 0, action: Pt.action, hasEagerState: Pt.hasEagerState, eagerState: Pt.eagerState, next: null }), de = Pt.hasEagerState ? Pt.eagerState : V(de, Pt.action); else { var Zt = { lane: Vt, action: Pt.action, hasEagerState: Pt.hasEagerState, eagerState: Pt.eagerState, next: null }; vt === null ? (ot = vt = Zt, He = de) : vt = vt.next = Zt, Nr.lanes |= Vt, gi |= Vt } Pt = Pt.next } while (Pt !== null && Pt !== Te); vt === null ? He = de : vt.next = ot, En(de, J.memoizedState) || (un = !0), J.memoizedState = de, J.baseState = He, J.baseQueue = vt, fe.lastRenderedState = de } if (V = fe.interleaved, V !== null) { we = V; do Te = we.lane, Nr.lanes |= Te, gi |= Te, we = we.next; while (we !== V) } else we === null && (fe.lanes = 0); return [J.memoizedState, fe.dispatch] } function bo(V) { var J = wn(), fe = J.queue; if (fe === null) throw Error(u(311)); fe.lastRenderedReducer = V; var de = fe.dispatch, we = fe.pending, Te = J.memoizedState; if (we !== null) { fe.pending = null; var He = we = we.next; do Te = V(Te, He.action), He = He.next; while (He !== we); En(Te, J.memoizedState) || (un = !0), J.memoizedState = Te, J.baseQueue === null && (J.baseState = Te), fe.lastRenderedState = Te } return [Te, de] } function au() { } function su(V, J) { var fe = Nr, de = wn(), we = J(), Te = !En(de.memoizedState, we); if (Te && (de.memoizedState = we, un = !0), de = de.queue, _o(uu.bind(null, fe, de, V), [V]), de.getSnapshot !== J || Te || Zr !== null && Zr.memoizedState.tag & 1) { if (fe.flags |= 2048, da(9, lu.bind(null, fe, de, we, J), void 0, null), Yr === null) throw Error(u(349)); (mi & 30) !== 0 || ou(fe, J, we) } return we } function ou(V, J, fe) { V.flags |= 16384, V = { getSnapshot: J, value: fe }, J = Nr.updateQueue, J === null ? (J = { lastEffect: null, stores: null }, Nr.updateQueue = J, J.stores = [V]) : (fe = J.stores, fe === null ? J.stores = [V] : fe.push(V)) } function lu(V, J, fe, de) { J.value = fe, J.getSnapshot = de, fu(J) && cu(V) } function uu(V, J, fe) { return fe(function () { fu(J) && cu(V) }) } function fu(V) { var J = V.getSnapshot; V = V.value; try { var fe = J(); return !En(V, fe) } catch { return !0 } } function cu(V) { var J = Fn(V, 1); J !== null && Pn(J, V, 1, -1) } function hu(V) { var J = In(); return typeof V == "function" && (V = V()), J.memoizedState = J.baseState = V, V = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ha, lastRenderedState: V }, J.queue = V, V = V.dispatch = kc.bind(null, Nr, V), [J.memoizedState, V] } function da(V, J, fe, de) { return V = { tag: V, create: J, destroy: fe, deps: de, next: null }, J = Nr.updateQueue, J === null ? (J = { lastEffect: null, stores: null }, Nr.updateQueue = J, J.lastEffect = V.next = V) : (fe = J.lastEffect, fe === null ? J.lastEffect = V.next = V : (de = fe.next, fe.next = V, V.next = de, J.lastEffect = V)), V } function du() { return wn().memoizedState } function Xa(V, J, fe, de) { var we = In(); Nr.flags |= V, we.memoizedState = da(1 | J, fe, void 0, de === void 0 ? null : de) } function Ja(V, J, fe, de) { var we = wn(); de = de === void 0 ? null : de; var Te = void 0; if (Kr !== null) { var He = Kr.memoizedState; if (Te = He.destroy, de !== null && mo(de, He.deps)) { we.memoizedState = da(J, fe, Te, de); return } } Nr.flags |= V, we.memoizedState = da(1 | J, fe, Te, de) } function pu(V, J) { return Xa(8390656, 8, V, J) } function _o(V, J) { return Ja(2048, 8, V, J) } function mu(V, J) { return Ja(4, 2, V, J) } function gu(V, J) { return Ja(4, 4, V, J) } function vu(V, J) { if (typeof J == "function") return V = V(), J(V), function () { J(null) }; if (J != null) return V = V(), J.current = V, function () { J.current = null } } function yu(V, J, fe) { return fe = fe != null ? fe.concat([V]) : null, Ja(4, 4, vu.bind(null, J, V), fe) } function wo() { } function bu(V, J) { var fe = wn(); J = J === void 0 ? null : J; var de = fe.memoizedState; return de !== null && J !== null && mo(J, de[1]) ? de[0] : (fe.memoizedState = [V, J], V) } function _u(V, J) { var fe = wn(); J = J === void 0 ? null : J; var de = fe.memoizedState; return de !== null && J !== null && mo(J, de[1]) ? de[0] : (V = V(), fe.memoizedState = [V, J], V) } function wu(V, J, fe) { return (mi & 21) === 0 ? (V.baseState && (V.baseState = !1, un = !0), V.memoizedState = fe) : (En(fe, J) || (fe = Ar(), Nr.lanes |= fe, gi |= fe, V.baseState = !0), J) } function Pc(V, J) { var fe = dr; dr = fe !== 0 && 4 > fe ? fe : 4, V(!0); var de = po.transition; po.transition = {}; try { V(!1), J() } finally { dr = fe, po.transition = de } } function xu() { return wn().memoizedState } function Tc(V, J, fe) { var de = ni(V); if (fe = { lane: de, action: fe, hasEagerState: !1, eagerState: null, next: null }, Su(V)) Eu(J, fe); else if (fe = eu(V, J, fe, de), fe !== null) { var we = sn(); Pn(fe, V, de, we), Mu(fe, J, de) } } function kc(V, J, fe) { var de = ni(V), we = { lane: de, action: fe, hasEagerState: !1, eagerState: null, next: null }; if (Su(V)) Eu(J, we); else { var Te = V.alternate; if (V.lanes === 0 && (Te === null || Te.lanes === 0) && (Te = J.lastRenderedReducer, Te !== null)) try { var He = J.lastRenderedState, ot = Te(He, fe); if (we.hasEagerState = !0, we.eagerState = ot, En(ot, He)) { var vt = J.interleaved; vt === null ? (we.next = we, oo(J)) : (we.next = vt.next, vt.next = we), J.interleaved = we; return } } catch { } finally { } fe = eu(V, J, we, de), fe !== null && (we = sn(), Pn(fe, V, de, we), Mu(fe, J, de)) } } function Su(V) { var J = V.alternate; return V === Nr || J !== null && J === Nr } function Eu(V, J) { fa = Ya = !0; var fe = V.pending; fe === null ? J.next = J : (J.next = fe.next, fe.next = J), V.pending = J } function Mu(V, J, fe) { if ((fe & 4194240) !== 0) { var de = J.lanes; de &= V.pendingLanes, fe |= de, J.lanes = fe, Ir(V, fe) } } var Qa = { readContext: _n, useCallback: tn, useContext: tn, useEffect: tn, useImperativeHandle: tn, useInsertionEffect: tn, useLayoutEffect: tn, useMemo: tn, useReducer: tn, useRef: tn, useState: tn, useDebugValue: tn, useDeferredValue: tn, useTransition: tn, useMutableSource: tn, useSyncExternalStore: tn, useId: tn, unstable_isNewReconciler: !1 }, Ic = { readContext: _n, useCallback: function (V, J) { return In().memoizedState = [V, J === void 0 ? null : J], V }, useContext: _n, useEffect: pu, useImperativeHandle: function (V, J, fe) { return fe = fe != null ? fe.concat([V]) : null, Xa(4194308, 4, vu.bind(null, J, V), fe) }, useLayoutEffect: function (V, J) { return Xa(4194308, 4, V, J) }, useInsertionEffect: function (V, J) { return Xa(4, 2, V, J) }, useMemo: function (V, J) { var fe = In(); return J = J === void 0 ? null : J, V = V(), fe.memoizedState = [V, J], V }, useReducer: function (V, J, fe) { var de = In(); return J = fe !== void 0 ? fe(J) : J, de.memoizedState = de.baseState = J, V = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: V, lastRenderedState: J }, de.queue = V, V = V.dispatch = Tc.bind(null, Nr, V), [de.memoizedState, V] }, useRef: function (V) { var J = In(); return V = { current: V }, J.memoizedState = V }, useState: hu, useDebugValue: wo, useDeferredValue: function (V) { return In().memoizedState = V }, useTransition: function () { var V = hu(!1), J = V[0]; return V = Pc.bind(null, V[1]), In().memoizedState = V, [J, V] }, useMutableSource: function () { }, useSyncExternalStore: function (V, J, fe) { var de = Nr, we = In(); if (Lr) { if (fe === void 0) throw Error(u(407)); fe = fe() } else { if (fe = J(), Yr === null) throw Error(u(349)); (mi & 30) !== 0 || ou(de, J, fe) } we.memoizedState = fe; var Te = { value: fe, getSnapshot: J }; return we.queue = Te, pu(uu.bind(null, de, Te, V), [V]), de.flags |= 2048, da(9, lu.bind(null, de, Te, fe, J), void 0, null), fe }, useId: function () { var V = In(), J = Yr.identifierPrefix; if (Lr) { var fe = Ln, de = Dn; fe = (de & ~(1 << 32 - qt(de) - 1)).toString(32) + fe, J = ":" + J + "R" + fe, fe = ca++, 0 < fe && (J += "H" + fe.toString(32)), J += ":" } else fe = Cc++, J = ":" + J + "r" + fe.toString(32) + ":"; return V.memoizedState = J }, unstable_isNewReconciler: !1 }, Bc = { readContext: _n, useCallback: bu, useContext: _n, useEffect: _o, useImperativeHandle: yu, useInsertionEffect: mu, useLayoutEffect: gu, useMemo: _u, useReducer: yo, useRef: du, useState: function () { return yo(ha) }, useDebugValue: wo, useDeferredValue: function (V) { var J = wn(); return wu(J, Kr.memoizedState, V) }, useTransition: function () { var V = yo(ha)[0], J = wn().memoizedState; return [V, J] }, useMutableSource: au, useSyncExternalStore: su, useId: xu, unstable_isNewReconciler: !1 }, Oc = { readContext: _n, useCallback: bu, useContext: _n, useEffect: _o, useImperativeHandle: yu, useInsertionEffect: mu, useLayoutEffect: gu, useMemo: _u, useReducer: bo, useRef: du, useState: function () { return bo(ha) }, useDebugValue: wo, useDeferredValue: function (V) { var J = wn(); return Kr === null ? J.memoizedState = V : wu(J, Kr.memoizedState, V) }, useTransition: function () { var V = bo(ha)[0], J = wn().memoizedState; return [V, J] }, useMutableSource: au, useSyncExternalStore: su, useId: xu, unstable_isNewReconciler: !1 }; function An(V, J) { if (V && V.defaultProps) { J = y({}, J), V = V.defaultProps; for (var fe in V) J[fe] === void 0 && (J[fe] = V[fe]); return J } return J } function xo(V, J, fe, de) { J = V.memoizedState, fe = fe(de, J), fe = fe == null ? J : y({}, J, fe), V.memoizedState = fe, V.lanes === 0 && (V.updateQueue.baseState = fe) } var es = { isMounted: function (V) { return (V = V._reactInternals) ? ct(V) === V : !1 }, enqueueSetState: function (V, J, fe) { V = V._reactInternals; var de = sn(), we = ni(V), Te = Nn(de, we); Te.payload = J, fe != null && (Te.callback = fe), J = Qn(V, Te, we), J !== null && (Pn(J, V, we, de), Ga(J, V, we)) }, enqueueReplaceState: function (V, J, fe) { V = V._reactInternals; var de = sn(), we = ni(V), Te = Nn(de, we); Te.tag = 1, Te.payload = J, fe != null && (Te.callback = fe), J = Qn(V, Te, we), J !== null && (Pn(J, V, we, de), Ga(J, V, we)) }, enqueueForceUpdate: function (V, J) { V = V._reactInternals; var fe = sn(), de = ni(V), we = Nn(fe, de); we.tag = 2, J != null && (we.callback = J), J = Qn(V, we, de), J !== null && (Pn(J, V, de, fe), Ga(J, V, de)) } }; function Au(V, J, fe, de, we, Te, He) { return V = V.stateNode, typeof V.shouldComponentUpdate == "function" ? V.shouldComponentUpdate(de, Te, He) : J.prototype && J.prototype.isPureReactComponent ? !Qi(fe, de) || !Qi(we, Te) : !0 } function Ru(V, J, fe) { var de = !1, we = Yn, Te = J.contextType; return typeof Te == "object" && Te !== null ? Te = _n(Te) : (we = ln(J) ? fi : en.current, de = J.contextTypes, Te = (de = de != null) ? Ti(V, we) : Yn), J = new J(fe, Te), V.memoizedState = J.state !== null && J.state !== void 0 ? J.state : null, J.updater = es, V.stateNode = J, J._reactInternals = V, de && (V = V.stateNode, V.__reactInternalMemoizedUnmaskedChildContext = we, V.__reactInternalMemoizedMaskedChildContext = Te), J } function Cu(V, J, fe, de) { V = J.state, typeof J.componentWillReceiveProps == "function" && J.componentWillReceiveProps(fe, de), typeof J.UNSAFE_componentWillReceiveProps == "function" && J.UNSAFE_componentWillReceiveProps(fe, de), J.state !== V && es.enqueueReplaceState(J, J.state, null) } function So(V, J, fe, de) { var we = V.stateNode; we.props = fe, we.state = V.memoizedState, we.refs = {}, lo(V); var Te = J.contextType; typeof Te == "object" && Te !== null ? we.context = _n(Te) : (Te = ln(J) ? fi : en.current, we.context = Ti(V, Te)), we.state = V.memoizedState, Te = J.getDerivedStateFromProps, typeof Te == "function" && (xo(V, J, Te, fe), we.state = V.memoizedState), typeof J.getDerivedStateFromProps == "function" || typeof we.getSnapshotBeforeUpdate == "function" || typeof we.UNSAFE_componentWillMount != "function" && typeof we.componentWillMount != "function" || (J = we.state, typeof we.componentWillMount == "function" && we.componentWillMount(), typeof we.UNSAFE_componentWillMount == "function" && we.UNSAFE_componentWillMount(), J !== we.state && es.enqueueReplaceState(we, we.state, null), Ka(V, fe, we, de), we.state = V.memoizedState), typeof we.componentDidMount == "function" && (V.flags |= 4194308) } function Fi(V, J) {
    try { var fe = "", de = J; do fe += Ie(de), de = de.return; while (de); var we = fe } catch (Te) {
      we = `
Error generating stack: `+ Te.message + `
`+ Te.stack
    } return { value: V, source: J, stack: we, digest: null }
  } function Eo(V, J, fe) { return { value: V, source: null, stack: fe ?? null, digest: J ?? null } } function Mo(V, J) { try { console.error(J.value) } catch (fe) { setTimeout(function () { throw fe }) } } var qc = typeof WeakMap == "function" ? WeakMap : Map; function Pu(V, J, fe) { fe = Nn(-1, fe), fe.tag = 3, fe.payload = { element: null }; var de = J.value; return fe.callback = function () { ls || (ls = !0, $o = de), Mo(V, J) }, fe } function Tu(V, J, fe) { fe = Nn(-1, fe), fe.tag = 3; var de = V.type.getDerivedStateFromError; if (typeof de == "function") { var we = J.value; fe.payload = function () { return de(we) }, fe.callback = function () { Mo(V, J) } } var Te = V.stateNode; return Te !== null && typeof Te.componentDidCatch == "function" && (fe.callback = function () { Mo(V, J), typeof de != "function" && (ti === null ? ti = new Set([this]) : ti.add(this)); var He = J.stack; this.componentDidCatch(J.value, { componentStack: He !== null ? He : "" }) }), fe } function ku(V, J, fe) { var de = V.pingCache; if (de === null) { de = V.pingCache = new qc; var we = new Set; de.set(J, we) } else we = de.get(J), we === void 0 && (we = new Set, de.set(J, we)); we.has(fe) || (we.add(fe), V = Zc.bind(null, V, J, fe), J.then(V, V)) } function Iu(V) { do { var J; if ((J = V.tag === 13) && (J = V.memoizedState, J = J !== null ? J.dehydrated !== null : !0), J) return V; V = V.return } while (V !== null); return null } function Bu(V, J, fe, de, we) { return (V.mode & 1) === 0 ? (V === J ? V.flags |= 65536 : (V.flags |= 128, fe.flags |= 131072, fe.flags &= -52805, fe.tag === 1 && (fe.alternate === null ? fe.tag = 17 : (J = Nn(-1, 1), J.tag = 2, Qn(fe, J, 1))), fe.lanes |= 1), V) : (V.flags |= 65536, V.lanes = we, V) } var Dc = ue.ReactCurrentOwner, un = !1; function an(V, J, fe, de) { J.child = V === null ? Ql(J, null, fe, de) : Oi(J, V.child, fe, de) } function Ou(V, J, fe, de, we) { fe = fe.render; var Te = J.ref; return Di(J, we), de = go(V, J, fe, de, Te, we), fe = vo(), V !== null && !un ? (J.updateQueue = V.updateQueue, J.flags &= -2053, V.lanes &= ~we, $n(V, J, we)) : (Lr && fe && Js(J), J.flags |= 1, an(V, J, de, we), J.child) } function qu(V, J, fe, de, we) { if (V === null) { var Te = fe.type; return typeof Te == "function" && !Ko(Te) && Te.defaultProps === void 0 && fe.compare === null && fe.defaultProps === void 0 ? (J.tag = 15, J.type = Te, Du(V, J, Te, de, we)) : (V = ps(fe.type, null, de, J, J.mode, we), V.ref = J.ref, V.return = J, J.child = V) } if (Te = V.child, (V.lanes & we) === 0) { var He = Te.memoizedProps; if (fe = fe.compare, fe = fe !== null ? fe : Qi, fe(He, de) && V.ref === J.ref) return $n(V, J, we) } return J.flags |= 1, V = ai(Te, de), V.ref = J.ref, V.return = J, J.child = V } function Du(V, J, fe, de, we) { if (V !== null) { var Te = V.memoizedProps; if (Qi(Te, de) && V.ref === J.ref) if (un = !1, J.pendingProps = de = Te, (V.lanes & we) !== 0) (V.flags & 131072) !== 0 && (un = !0); else return J.lanes = V.lanes, $n(V, J, we) } return Ao(V, J, fe, de, we) } function Lu(V, J, fe) { var de = J.pendingProps, we = de.children, Te = V !== null ? V.memoizedState : null; if (de.mode === "hidden") if ((J.mode & 1) === 0) J.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, kr($i, gn), gn |= fe; else { if ((fe & 1073741824) === 0) return V = Te !== null ? Te.baseLanes | fe : fe, J.lanes = J.childLanes = 1073741824, J.memoizedState = { baseLanes: V, cachePool: null, transitions: null }, J.updateQueue = null, kr($i, gn), gn |= V, null; J.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, de = Te !== null ? Te.baseLanes : fe, kr($i, gn), gn |= de } else Te !== null ? (de = Te.baseLanes | fe, J.memoizedState = null) : de = fe, kr($i, gn), gn |= de; return an(V, J, we, fe), J.child } function Fu(V, J) { var fe = J.ref; (V === null && fe !== null || V !== null && V.ref !== fe) && (J.flags |= 512, J.flags |= 2097152) } function Ao(V, J, fe, de, we) { var Te = ln(fe) ? fi : en.current; return Te = Ti(J, Te), Di(J, we), fe = go(V, J, fe, de, Te, we), de = vo(), V !== null && !un ? (J.updateQueue = V.updateQueue, J.flags &= -2053, V.lanes &= ~we, $n(V, J, we)) : (Lr && de && Js(J), J.flags |= 1, an(V, J, fe, we), J.child) } function Nu(V, J, fe, de, we) { if (ln(fe)) { var Te = !0; Fa(J) } else Te = !1; if (Di(J, we), J.stateNode === null) rs(V, J), Ru(J, fe, de), So(J, fe, de, we), de = !0; else if (V === null) { var He = J.stateNode, ot = J.memoizedProps; He.props = ot; var vt = He.context, Pt = fe.contextType; typeof Pt == "object" && Pt !== null ? Pt = _n(Pt) : (Pt = ln(fe) ? fi : en.current, Pt = Ti(J, Pt)); var Vt = fe.getDerivedStateFromProps, Zt = typeof Vt == "function" || typeof He.getSnapshotBeforeUpdate == "function"; Zt || typeof He.UNSAFE_componentWillReceiveProps != "function" && typeof He.componentWillReceiveProps != "function" || (ot !== de || vt !== Pt) && Cu(J, He, de, Pt), Jn = !1; var Ut = J.memoizedState; He.state = Ut, Ka(J, de, He, we), vt = J.memoizedState, ot !== de || Ut !== vt || on.current || Jn ? (typeof Vt == "function" && (xo(J, fe, Vt, de), vt = J.memoizedState), (ot = Jn || Au(J, fe, ot, de, Ut, vt, Pt)) ? (Zt || typeof He.UNSAFE_componentWillMount != "function" && typeof He.componentWillMount != "function" || (typeof He.componentWillMount == "function" && He.componentWillMount(), typeof He.UNSAFE_componentWillMount == "function" && He.UNSAFE_componentWillMount()), typeof He.componentDidMount == "function" && (J.flags |= 4194308)) : (typeof He.componentDidMount == "function" && (J.flags |= 4194308), J.memoizedProps = de, J.memoizedState = vt), He.props = de, He.state = vt, He.context = Pt, de = ot) : (typeof He.componentDidMount == "function" && (J.flags |= 4194308), de = !1) } else { He = J.stateNode, tu(V, J), ot = J.memoizedProps, Pt = J.type === J.elementType ? ot : An(J.type, ot), He.props = Pt, Zt = J.pendingProps, Ut = He.context, vt = fe.contextType, typeof vt == "object" && vt !== null ? vt = _n(vt) : (vt = ln(fe) ? fi : en.current, vt = Ti(J, vt)); var or = fe.getDerivedStateFromProps; (Vt = typeof or == "function" || typeof He.getSnapshotBeforeUpdate == "function") || typeof He.UNSAFE_componentWillReceiveProps != "function" && typeof He.componentWillReceiveProps != "function" || (ot !== Zt || Ut !== vt) && Cu(J, He, de, vt), Jn = !1, Ut = J.memoizedState, He.state = Ut, Ka(J, de, He, we); var fr = J.memoizedState; ot !== Zt || Ut !== fr || on.current || Jn ? (typeof or == "function" && (xo(J, fe, or, de), fr = J.memoizedState), (Pt = Jn || Au(J, fe, Pt, de, Ut, fr, vt) || !1) ? (Vt || typeof He.UNSAFE_componentWillUpdate != "function" && typeof He.componentWillUpdate != "function" || (typeof He.componentWillUpdate == "function" && He.componentWillUpdate(de, fr, vt), typeof He.UNSAFE_componentWillUpdate == "function" && He.UNSAFE_componentWillUpdate(de, fr, vt)), typeof He.componentDidUpdate == "function" && (J.flags |= 4), typeof He.getSnapshotBeforeUpdate == "function" && (J.flags |= 1024)) : (typeof He.componentDidUpdate != "function" || ot === V.memoizedProps && Ut === V.memoizedState || (J.flags |= 4), typeof He.getSnapshotBeforeUpdate != "function" || ot === V.memoizedProps && Ut === V.memoizedState || (J.flags |= 1024), J.memoizedProps = de, J.memoizedState = fr), He.props = de, He.state = fr, He.context = vt, de = Pt) : (typeof He.componentDidUpdate != "function" || ot === V.memoizedProps && Ut === V.memoizedState || (J.flags |= 4), typeof He.getSnapshotBeforeUpdate != "function" || ot === V.memoizedProps && Ut === V.memoizedState || (J.flags |= 1024), de = !1) } return Ro(V, J, fe, de, Te, we) } function Ro(V, J, fe, de, we, Te) { Fu(V, J); var He = (J.flags & 128) !== 0; if (!de && !He) return we && zl(J, fe, !1), $n(V, J, Te); de = J.stateNode, Dc.current = J; var ot = He && typeof fe.getDerivedStateFromError != "function" ? null : de.render(); return J.flags |= 1, V !== null && He ? (J.child = Oi(J, V.child, null, Te), J.child = Oi(J, null, ot, Te)) : an(V, J, ot, Te), J.memoizedState = de.state, we && zl(J, fe, !0), J.child } function $u(V) { var J = V.stateNode; J.pendingContext ? jl(V, J.pendingContext, J.pendingContext !== J.context) : J.context && jl(V, J.context, !1), uo(V, J.containerInfo) } function Uu(V, J, fe, de, we) { return Bi(), ro(we), J.flags |= 256, an(V, J, fe, de), J.child } var Co = { dehydrated: null, treeContext: null, retryLane: 0 }; function Po(V) { return { baseLanes: V, cachePool: null, transitions: null } } function ju(V, J, fe) { var de = J.pendingProps, we = Fr.current, Te = !1, He = (J.flags & 128) !== 0, ot; if ((ot = He) || (ot = V !== null && V.memoizedState === null ? !1 : (we & 2) !== 0), ot ? (Te = !0, J.flags &= -129) : (V === null || V.memoizedState !== null) && (we |= 1), kr(Fr, we & 1), V === null) return to(J), V = J.memoizedState, V !== null && (V = V.dehydrated, V !== null) ? ((J.mode & 1) === 0 ? J.lanes = 1 : V.data === "$!" ? J.lanes = 8 : J.lanes = 1073741824, null) : (He = de.children, V = de.fallback, Te ? (de = J.mode, Te = J.child, He = { mode: "hidden", children: He }, (de & 1) === 0 && Te !== null ? (Te.childLanes = 0, Te.pendingProps = He) : Te = gs(He, de, 0, null), V = _i(V, de, fe, null), Te.return = J, V.return = J, Te.sibling = V, J.child = Te, J.child.memoizedState = Po(fe), J.memoizedState = Co, V) : To(J, He)); if (we = V.memoizedState, we !== null && (ot = we.dehydrated, ot !== null)) return Lc(V, J, He, de, ot, we, fe); if (Te) { Te = de.fallback, He = J.mode, we = V.child, ot = we.sibling; var vt = { mode: "hidden", children: de.children }; return (He & 1) === 0 && J.child !== we ? (de = J.child, de.childLanes = 0, de.pendingProps = vt, J.deletions = null) : (de = ai(we, vt), de.subtreeFlags = we.subtreeFlags & 14680064), ot !== null ? Te = ai(ot, Te) : (Te = _i(Te, He, fe, null), Te.flags |= 2), Te.return = J, de.return = J, de.sibling = Te, J.child = de, de = Te, Te = J.child, He = V.child.memoizedState, He = He === null ? Po(fe) : { baseLanes: He.baseLanes | fe, cachePool: null, transitions: He.transitions }, Te.memoizedState = He, Te.childLanes = V.childLanes & ~fe, J.memoizedState = Co, de } return Te = V.child, V = Te.sibling, de = ai(Te, { mode: "visible", children: de.children }), (J.mode & 1) === 0 && (de.lanes = fe), de.return = J, de.sibling = null, V !== null && (fe = J.deletions, fe === null ? (J.deletions = [V], J.flags |= 16) : fe.push(V)), J.child = de, J.memoizedState = null, de } function To(V, J) { return J = gs({ mode: "visible", children: J }, V.mode, 0, null), J.return = V, V.child = J } function ts(V, J, fe, de) { return de !== null && ro(de), Oi(J, V.child, null, fe), V = To(J, J.pendingProps.children), V.flags |= 2, J.memoizedState = null, V } function Lc(V, J, fe, de, we, Te, He) { if (fe) return J.flags & 256 ? (J.flags &= -257, de = Eo(Error(u(422))), ts(V, J, He, de)) : J.memoizedState !== null ? (J.child = V.child, J.flags |= 128, null) : (Te = de.fallback, we = J.mode, de = gs({ mode: "visible", children: de.children }, we, 0, null), Te = _i(Te, we, He, null), Te.flags |= 2, de.return = J, Te.return = J, de.sibling = Te, J.child = de, (J.mode & 1) !== 0 && Oi(J, V.child, null, He), J.child.memoizedState = Po(He), J.memoizedState = Co, Te); if ((J.mode & 1) === 0) return ts(V, J, He, null); if (we.data === "$!") { if (de = we.nextSibling && we.nextSibling.dataset, de) var ot = de.dgst; return de = ot, Te = Error(u(419)), de = Eo(Te, de, void 0), ts(V, J, He, de) } if (ot = (He & V.childLanes) !== 0, un || ot) { if (de = Yr, de !== null) { switch (He & -He) { case 4: we = 2; break; case 16: we = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: we = 32; break; case 536870912: we = 268435456; break; default: we = 0 }we = (we & (de.suspendedLanes | He)) !== 0 ? 0 : we, we !== 0 && we !== Te.retryLane && (Te.retryLane = we, Fn(V, we), Pn(de, V, we, -1)) } return Go(), de = Eo(Error(u(421))), ts(V, J, He, de) } return we.data === "$?" ? (J.flags |= 128, J.child = V.child, J = Yc.bind(null, V), we._reactRetry = J, null) : (V = Te.treeContext, mn = Wn(we.nextSibling), pn = J, Lr = !0, Mn = null, V !== null && (vn[yn++] = Dn, vn[yn++] = Ln, vn[yn++] = ci, Dn = V.id, Ln = V.overflow, ci = J), J = To(J, de.children), J.flags |= 4096, J) } function Vu(V, J, fe) { V.lanes |= J; var de = V.alternate; de !== null && (de.lanes |= J), so(V.return, J, fe) } function ko(V, J, fe, de, we) { var Te = V.memoizedState; Te === null ? V.memoizedState = { isBackwards: J, rendering: null, renderingStartTime: 0, last: de, tail: fe, tailMode: we } : (Te.isBackwards = J, Te.rendering = null, Te.renderingStartTime = 0, Te.last = de, Te.tail = fe, Te.tailMode = we) } function zu(V, J, fe) { var de = J.pendingProps, we = de.revealOrder, Te = de.tail; if (an(V, J, de.children, fe), de = Fr.current, (de & 2) !== 0) de = de & 1 | 2, J.flags |= 128; else { if (V !== null && (V.flags & 128) !== 0) e: for (V = J.child; V !== null;) { if (V.tag === 13) V.memoizedState !== null && Vu(V, fe, J); else if (V.tag === 19) Vu(V, fe, J); else if (V.child !== null) { V.child.return = V, V = V.child; continue } if (V === J) break e; for (; V.sibling === null;) { if (V.return === null || V.return === J) break e; V = V.return } V.sibling.return = V.return, V = V.sibling } de &= 1 } if (kr(Fr, de), (J.mode & 1) === 0) J.memoizedState = null; else switch (we) { case "forwards": for (fe = J.child, we = null; fe !== null;)V = fe.alternate, V !== null && Wa(V) === null && (we = fe), fe = fe.sibling; fe = we, fe === null ? (we = J.child, J.child = null) : (we = fe.sibling, fe.sibling = null), ko(J, !1, we, fe, Te); break; case "backwards": for (fe = null, we = J.child, J.child = null; we !== null;) { if (V = we.alternate, V !== null && Wa(V) === null) { J.child = we; break } V = we.sibling, we.sibling = fe, fe = we, we = V } ko(J, !0, fe, null, Te); break; case "together": ko(J, !1, null, null, void 0); break; default: J.memoizedState = null }return J.child } function rs(V, J) { (J.mode & 1) === 0 && V !== null && (V.alternate = null, J.alternate = null, J.flags |= 2) } function $n(V, J, fe) { if (V !== null && (J.dependencies = V.dependencies), gi |= J.lanes, (fe & J.childLanes) === 0) return null; if (V !== null && J.child !== V.child) throw Error(u(153)); if (J.child !== null) { for (V = J.child, fe = ai(V, V.pendingProps), J.child = fe, fe.return = J; V.sibling !== null;)V = V.sibling, fe = fe.sibling = ai(V, V.pendingProps), fe.return = J; fe.sibling = null } return J.child } function Fc(V, J, fe) { switch (J.tag) { case 3: $u(J), Bi(); break; case 5: iu(J); break; case 1: ln(J.type) && Fa(J); break; case 4: uo(J, J.stateNode.containerInfo); break; case 10: var de = J.type._context, we = J.memoizedProps.value; kr(za, de._currentValue), de._currentValue = we; break; case 13: if (de = J.memoizedState, de !== null) return de.dehydrated !== null ? (kr(Fr, Fr.current & 1), J.flags |= 128, null) : (fe & J.child.childLanes) !== 0 ? ju(V, J, fe) : (kr(Fr, Fr.current & 1), V = $n(V, J, fe), V !== null ? V.sibling : null); kr(Fr, Fr.current & 1); break; case 19: if (de = (fe & J.childLanes) !== 0, (V.flags & 128) !== 0) { if (de) return zu(V, J, fe); J.flags |= 128 } if (we = J.memoizedState, we !== null && (we.rendering = null, we.tail = null, we.lastEffect = null), kr(Fr, Fr.current), de) break; return null; case 22: case 23: return J.lanes = 0, Lu(V, J, fe) }return $n(V, J, fe) } var Hu, Io, Gu, Ku; Hu = function (V, J) { for (var fe = J.child; fe !== null;) { if (fe.tag === 5 || fe.tag === 6) V.appendChild(fe.stateNode); else if (fe.tag !== 4 && fe.child !== null) { fe.child.return = fe, fe = fe.child; continue } if (fe === J) break; for (; fe.sibling === null;) { if (fe.return === null || fe.return === J) return; fe = fe.return } fe.sibling.return = fe.return, fe = fe.sibling } }, Io = function () { }, Gu = function (V, J, fe, de) { var we = V.memoizedProps; if (we !== de) { V = J.stateNode, pi(kn.current); var Te = null; switch (fe) { case "input": we = dt(V, we), de = dt(V, de), Te = []; break; case "select": we = y({}, we, { value: void 0 }), de = y({}, de, { value: void 0 }), Te = []; break; case "textarea": we = _t(V, we), de = _t(V, de), Te = []; break; default: typeof we.onClick != "function" && typeof de.onClick == "function" && (V.onclick = qa) }Xe(fe, de); var He; fe = null; for (Pt in we) if (!de.hasOwnProperty(Pt) && we.hasOwnProperty(Pt) && we[Pt] != null) if (Pt === "style") { var ot = we[Pt]; for (He in ot) ot.hasOwnProperty(He) && (fe || (fe = {}), fe[He] = "") } else Pt !== "dangerouslySetInnerHTML" && Pt !== "children" && Pt !== "suppressContentEditableWarning" && Pt !== "suppressHydrationWarning" && Pt !== "autoFocus" && (p.hasOwnProperty(Pt) ? Te || (Te = []) : (Te = Te || []).push(Pt, null)); for (Pt in de) { var vt = de[Pt]; if (ot = we != null ? we[Pt] : void 0, de.hasOwnProperty(Pt) && vt !== ot && (vt != null || ot != null)) if (Pt === "style") if (ot) { for (He in ot) !ot.hasOwnProperty(He) || vt && vt.hasOwnProperty(He) || (fe || (fe = {}), fe[He] = ""); for (He in vt) vt.hasOwnProperty(He) && ot[He] !== vt[He] && (fe || (fe = {}), fe[He] = vt[He]) } else fe || (Te || (Te = []), Te.push(Pt, fe)), fe = vt; else Pt === "dangerouslySetInnerHTML" ? (vt = vt ? vt.__html : void 0, ot = ot ? ot.__html : void 0, vt != null && ot !== vt && (Te = Te || []).push(Pt, vt)) : Pt === "children" ? typeof vt != "string" && typeof vt != "number" || (Te = Te || []).push(Pt, "" + vt) : Pt !== "suppressContentEditableWarning" && Pt !== "suppressHydrationWarning" && (p.hasOwnProperty(Pt) ? (vt != null && Pt === "onScroll" && qr("scroll", V), Te || ot === vt || (Te = [])) : (Te = Te || []).push(Pt, vt)) } fe && (Te = Te || []).push("style", fe); var Pt = Te; (J.updateQueue = Pt) && (J.flags |= 4) } }, Ku = function (V, J, fe, de) { fe !== de && (J.flags |= 4) }; function pa(V, J) { if (!Lr) switch (V.tailMode) { case "hidden": J = V.tail; for (var fe = null; J !== null;)J.alternate !== null && (fe = J), J = J.sibling; fe === null ? V.tail = null : fe.sibling = null; break; case "collapsed": fe = V.tail; for (var de = null; fe !== null;)fe.alternate !== null && (de = fe), fe = fe.sibling; de === null ? J || V.tail === null ? V.tail = null : V.tail.sibling = null : de.sibling = null } } function rn(V) { var J = V.alternate !== null && V.alternate.child === V.child, fe = 0, de = 0; if (J) for (var we = V.child; we !== null;)fe |= we.lanes | we.childLanes, de |= we.subtreeFlags & 14680064, de |= we.flags & 14680064, we.return = V, we = we.sibling; else for (we = V.child; we !== null;)fe |= we.lanes | we.childLanes, de |= we.subtreeFlags, de |= we.flags, we.return = V, we = we.sibling; return V.subtreeFlags |= de, V.childLanes = fe, J } function Nc(V, J, fe) { var de = J.pendingProps; switch (Qs(J), J.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return rn(J), null; case 1: return ln(J.type) && La(), rn(J), null; case 3: return de = J.stateNode, Li(), Dr(on), Dr(en), ho(), de.pendingContext && (de.context = de.pendingContext, de.pendingContext = null), (V === null || V.child === null) && (ja(J) ? J.flags |= 4 : V === null || V.memoizedState.isDehydrated && (J.flags & 256) === 0 || (J.flags |= 1024, Mn !== null && (Vo(Mn), Mn = null))), Io(V, J), rn(J), null; case 5: fo(J); var we = pi(ua.current); if (fe = J.type, V !== null && J.stateNode != null) Gu(V, J, fe, de, we), V.ref !== J.ref && (J.flags |= 512, J.flags |= 2097152); else { if (!de) { if (J.stateNode === null) throw Error(u(166)); return rn(J), null } if (V = pi(kn.current), ja(J)) { de = J.stateNode, fe = J.type; var Te = J.memoizedProps; switch (de[Tn] = J, de[ia] = Te, V = (J.mode & 1) !== 0, fe) { case "dialog": qr("cancel", de), qr("close", de); break; case "iframe": case "object": case "embed": qr("load", de); break; case "video": case "audio": for (we = 0; we < ta.length; we++)qr(ta[we], de); break; case "source": qr("error", de); break; case "img": case "image": case "link": qr("error", de), qr("load", de); break; case "details": qr("toggle", de); break; case "input": lt(de, Te), qr("invalid", de); break; case "select": de._wrapperState = { wasMultiple: !!Te.multiple }, qr("invalid", de); break; case "textarea": zt(de, Te), qr("invalid", de) }Xe(fe, Te), we = null; for (var He in Te) if (Te.hasOwnProperty(He)) { var ot = Te[He]; He === "children" ? typeof ot == "string" ? de.textContent !== ot && (Te.suppressHydrationWarning !== !0 && Oa(de.textContent, ot, V), we = ["children", ot]) : typeof ot == "number" && de.textContent !== "" + ot && (Te.suppressHydrationWarning !== !0 && Oa(de.textContent, ot, V), we = ["children", "" + ot]) : p.hasOwnProperty(He) && ot != null && He === "onScroll" && qr("scroll", de) } switch (fe) { case "input": Ve(de), mt(de, Te, !0); break; case "textarea": Ve(de), We(de); break; case "select": case "option": break; default: typeof Te.onClick == "function" && (de.onclick = qa) }de = we, J.updateQueue = de, de !== null && (J.flags |= 4) } else { He = we.nodeType === 9 ? we : we.ownerDocument, V === "http://www.w3.org/1999/xhtml" && (V = Ge(fe)), V === "http://www.w3.org/1999/xhtml" ? fe === "script" ? (V = He.createElement("div"), V.innerHTML = "<script><\/script>", V = V.removeChild(V.firstChild)) : typeof de.is == "string" ? V = He.createElement(fe, { is: de.is }) : (V = He.createElement(fe), fe === "select" && (He = V, de.multiple ? He.multiple = !0 : de.size && (He.size = de.size))) : V = He.createElementNS(V, fe), V[Tn] = J, V[ia] = de, Hu(V, J, !1, !1), J.stateNode = V; e: { switch (He = it(fe, de), fe) { case "dialog": qr("cancel", V), qr("close", V), we = de; break; case "iframe": case "object": case "embed": qr("load", V), we = de; break; case "video": case "audio": for (we = 0; we < ta.length; we++)qr(ta[we], V); we = de; break; case "source": qr("error", V), we = de; break; case "img": case "image": case "link": qr("error", V), qr("load", V), we = de; break; case "details": qr("toggle", V), we = de; break; case "input": lt(V, de), we = dt(V, de), qr("invalid", V); break; case "option": we = de; break; case "select": V._wrapperState = { wasMultiple: !!de.multiple }, we = y({}, de, { value: void 0 }), qr("invalid", V); break; case "textarea": zt(V, de), we = _t(V, de), qr("invalid", V); break; default: we = de }Xe(fe, we), ot = we; for (Te in ot) if (ot.hasOwnProperty(Te)) { var vt = ot[Te]; Te === "style" ? je(V, vt) : Te === "dangerouslySetInnerHTML" ? (vt = vt ? vt.__html : void 0, vt != null && ut(V, vt)) : Te === "children" ? typeof vt == "string" ? (fe !== "textarea" || vt !== "") && ye(V, vt) : typeof vt == "number" && ye(V, "" + vt) : Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && Te !== "autoFocus" && (p.hasOwnProperty(Te) ? vt != null && Te === "onScroll" && qr("scroll", V) : vt != null && le(V, Te, vt, He)) } switch (fe) { case "input": Ve(V), mt(V, de, !1); break; case "textarea": Ve(V), We(V); break; case "option": de.value != null && V.setAttribute("value", "" + De(de.value)); break; case "select": V.multiple = !!de.multiple, Te = de.value, Te != null ? pt(V, !!de.multiple, Te, !1) : de.defaultValue != null && pt(V, !!de.multiple, de.defaultValue, !0); break; default: typeof we.onClick == "function" && (V.onclick = qa) }switch (fe) { case "button": case "input": case "select": case "textarea": de = !!de.autoFocus; break e; case "img": de = !0; break e; default: de = !1 } } de && (J.flags |= 4) } J.ref !== null && (J.flags |= 512, J.flags |= 2097152) } return rn(J), null; case 6: if (V && J.stateNode != null) Ku(V, J, V.memoizedProps, de); else { if (typeof de != "string" && J.stateNode === null) throw Error(u(166)); if (fe = pi(ua.current), pi(kn.current), ja(J)) { if (de = J.stateNode, fe = J.memoizedProps, de[Tn] = J, (Te = de.nodeValue !== fe) && (V = pn, V !== null)) switch (V.tag) { case 3: Oa(de.nodeValue, fe, (V.mode & 1) !== 0); break; case 5: V.memoizedProps.suppressHydrationWarning !== !0 && Oa(de.nodeValue, fe, (V.mode & 1) !== 0) }Te && (J.flags |= 4) } else de = (fe.nodeType === 9 ? fe : fe.ownerDocument).createTextNode(de), de[Tn] = J, J.stateNode = de } return rn(J), null; case 13: if (Dr(Fr), de = J.memoizedState, V === null || V.memoizedState !== null && V.memoizedState.dehydrated !== null) { if (Lr && mn !== null && (J.mode & 1) !== 0 && (J.flags & 128) === 0) Yl(), Bi(), J.flags |= 98560, Te = !1; else if (Te = ja(J), de !== null && de.dehydrated !== null) { if (V === null) { if (!Te) throw Error(u(318)); if (Te = J.memoizedState, Te = Te !== null ? Te.dehydrated : null, !Te) throw Error(u(317)); Te[Tn] = J } else Bi(), (J.flags & 128) === 0 && (J.memoizedState = null), J.flags |= 4; rn(J), Te = !1 } else Mn !== null && (Vo(Mn), Mn = null), Te = !0; if (!Te) return J.flags & 65536 ? J : null } return (J.flags & 128) !== 0 ? (J.lanes = fe, J) : (de = de !== null, de !== (V !== null && V.memoizedState !== null) && de && (J.child.flags |= 8192, (J.mode & 1) !== 0 && (V === null || (Fr.current & 1) !== 0 ? Wr === 0 && (Wr = 3) : Go())), J.updateQueue !== null && (J.flags |= 4), rn(J), null); case 4: return Li(), Io(V, J), V === null && ra(J.stateNode.containerInfo), rn(J), null; case 10: return ao(J.type._context), rn(J), null; case 17: return ln(J.type) && La(), rn(J), null; case 19: if (Dr(Fr), Te = J.memoizedState, Te === null) return rn(J), null; if (de = (J.flags & 128) !== 0, He = Te.rendering, He === null) if (de) pa(Te, !1); else { if (Wr !== 0 || V !== null && (V.flags & 128) !== 0) for (V = J.child; V !== null;) { if (He = Wa(V), He !== null) { for (J.flags |= 128, pa(Te, !1), de = He.updateQueue, de !== null && (J.updateQueue = de, J.flags |= 4), J.subtreeFlags = 0, de = fe, fe = J.child; fe !== null;)Te = fe, V = de, Te.flags &= 14680066, He = Te.alternate, He === null ? (Te.childLanes = 0, Te.lanes = V, Te.child = null, Te.subtreeFlags = 0, Te.memoizedProps = null, Te.memoizedState = null, Te.updateQueue = null, Te.dependencies = null, Te.stateNode = null) : (Te.childLanes = He.childLanes, Te.lanes = He.lanes, Te.child = He.child, Te.subtreeFlags = 0, Te.deletions = null, Te.memoizedProps = He.memoizedProps, Te.memoizedState = He.memoizedState, Te.updateQueue = He.updateQueue, Te.type = He.type, V = He.dependencies, Te.dependencies = V === null ? null : { lanes: V.lanes, firstContext: V.firstContext }), fe = fe.sibling; return kr(Fr, Fr.current & 1 | 2), J.child } V = V.sibling } Te.tail !== null && Ht() > Ui && (J.flags |= 128, de = !0, pa(Te, !1), J.lanes = 4194304) } else { if (!de) if (V = Wa(He), V !== null) { if (J.flags |= 128, de = !0, fe = V.updateQueue, fe !== null && (J.updateQueue = fe, J.flags |= 4), pa(Te, !0), Te.tail === null && Te.tailMode === "hidden" && !He.alternate && !Lr) return rn(J), null } else 2 * Ht() - Te.renderingStartTime > Ui && fe !== 1073741824 && (J.flags |= 128, de = !0, pa(Te, !1), J.lanes = 4194304); Te.isBackwards ? (He.sibling = J.child, J.child = He) : (fe = Te.last, fe !== null ? fe.sibling = He : J.child = He, Te.last = He) } return Te.tail !== null ? (J = Te.tail, Te.rendering = J, Te.tail = J.sibling, Te.renderingStartTime = Ht(), J.sibling = null, fe = Fr.current, kr(Fr, de ? fe & 1 | 2 : fe & 1), J) : (rn(J), null); case 22: case 23: return Ho(), de = J.memoizedState !== null, V !== null && V.memoizedState !== null !== de && (J.flags |= 8192), de && (J.mode & 1) !== 0 ? (gn & 1073741824) !== 0 && (rn(J), J.subtreeFlags & 6 && (J.flags |= 8192)) : rn(J), null; case 24: return null; case 25: return null }throw Error(u(156, J.tag)) } function $c(V, J) { switch (Qs(J), J.tag) { case 1: return ln(J.type) && La(), V = J.flags, V & 65536 ? (J.flags = V & -65537 | 128, J) : null; case 3: return Li(), Dr(on), Dr(en), ho(), V = J.flags, (V & 65536) !== 0 && (V & 128) === 0 ? (J.flags = V & -65537 | 128, J) : null; case 5: return fo(J), null; case 13: if (Dr(Fr), V = J.memoizedState, V !== null && V.dehydrated !== null) { if (J.alternate === null) throw Error(u(340)); Bi() } return V = J.flags, V & 65536 ? (J.flags = V & -65537 | 128, J) : null; case 19: return Dr(Fr), null; case 4: return Li(), null; case 10: return ao(J.type._context), null; case 22: case 23: return Ho(), null; case 24: return null; default: return null } } var is = !1, nn = !1, Uc = typeof WeakSet == "function" ? WeakSet : Set, ur = null; function Ni(V, J) { var fe = V.ref; if (fe !== null) if (typeof fe == "function") try { fe(null) } catch (de) { Ur(V, J, de) } else fe.current = null } function Bo(V, J, fe) { try { fe() } catch (de) { Ur(V, J, de) } } var Wu = !1; function jc(V, J) { if (zs = Sa, V = Al(), qs(V)) { if ("selectionStart" in V) var fe = { start: V.selectionStart, end: V.selectionEnd }; else e: { fe = (fe = V.ownerDocument) && fe.defaultView || window; var de = fe.getSelection && fe.getSelection(); if (de && de.rangeCount !== 0) { fe = de.anchorNode; var we = de.anchorOffset, Te = de.focusNode; de = de.focusOffset; try { fe.nodeType, Te.nodeType } catch { fe = null; break e } var He = 0, ot = -1, vt = -1, Pt = 0, Vt = 0, Zt = V, Ut = null; t: for (; ;) { for (var or; Zt !== fe || we !== 0 && Zt.nodeType !== 3 || (ot = He + we), Zt !== Te || de !== 0 && Zt.nodeType !== 3 || (vt = He + de), Zt.nodeType === 3 && (He += Zt.nodeValue.length), (or = Zt.firstChild) !== null;)Ut = Zt, Zt = or; for (; ;) { if (Zt === V) break t; if (Ut === fe && ++Pt === we && (ot = He), Ut === Te && ++Vt === de && (vt = He), (or = Zt.nextSibling) !== null) break; Zt = Ut, Ut = Zt.parentNode } Zt = or } fe = ot === -1 || vt === -1 ? null : { start: ot, end: vt } } else fe = null } fe = fe || { start: 0, end: 0 } } else fe = null; for (Hs = { focusedElem: V, selectionRange: fe }, Sa = !1, ur = J; ur !== null;)if (J = ur, V = J.child, (J.subtreeFlags & 1028) !== 0 && V !== null) V.return = J, ur = V; else for (; ur !== null;) { J = ur; try { var fr = J.alternate; if ((J.flags & 1024) !== 0) switch (J.tag) { case 0: case 11: case 15: break; case 1: if (fr !== null) { var cr = fr.memoizedProps, jr = fr.memoizedState, Rt = J.stateNode, xt = Rt.getSnapshotBeforeUpdate(J.elementType === J.type ? cr : An(J.type, cr), jr); Rt.__reactInternalSnapshotBeforeUpdate = xt } break; case 3: var Ct = J.stateNode.containerInfo; Ct.nodeType === 1 ? Ct.textContent = "" : Ct.nodeType === 9 && Ct.documentElement && Ct.removeChild(Ct.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(u(163)) } } catch (Jt) { Ur(J, J.return, Jt) } if (V = J.sibling, V !== null) { V.return = J.return, ur = V; break } ur = J.return } return fr = Wu, Wu = !1, fr } function ma(V, J, fe) { var de = J.updateQueue; if (de = de !== null ? de.lastEffect : null, de !== null) { var we = de = de.next; do { if ((we.tag & V) === V) { var Te = we.destroy; we.destroy = void 0, Te !== void 0 && Bo(J, fe, Te) } we = we.next } while (we !== de) } } function as(V, J) { if (J = J.updateQueue, J = J !== null ? J.lastEffect : null, J !== null) { var fe = J = J.next; do { if ((fe.tag & V) === V) { var de = fe.create; fe.destroy = de() } fe = fe.next } while (fe !== J) } } function Oo(V) { var J = V.ref; if (J !== null) { var fe = V.stateNode; switch (V.tag) { case 5: V = fe; break; default: V = fe }typeof J == "function" ? J(V) : J.current = V } } function Zu(V) { var J = V.alternate; J !== null && (V.alternate = null, Zu(J)), V.child = null, V.deletions = null, V.sibling = null, V.tag === 5 && (J = V.stateNode, J !== null && (delete J[Tn], delete J[ia], delete J[Zs], delete J[Ec], delete J[Mc])), V.stateNode = null, V.return = null, V.dependencies = null, V.memoizedProps = null, V.memoizedState = null, V.pendingProps = null, V.stateNode = null, V.updateQueue = null } function Yu(V) { return V.tag === 5 || V.tag === 3 || V.tag === 4 } function Xu(V) { e: for (; ;) { for (; V.sibling === null;) { if (V.return === null || Yu(V.return)) return null; V = V.return } for (V.sibling.return = V.return, V = V.sibling; V.tag !== 5 && V.tag !== 6 && V.tag !== 18;) { if (V.flags & 2 || V.child === null || V.tag === 4) continue e; V.child.return = V, V = V.child } if (!(V.flags & 2)) return V.stateNode } } function qo(V, J, fe) { var de = V.tag; if (de === 5 || de === 6) V = V.stateNode, J ? fe.nodeType === 8 ? fe.parentNode.insertBefore(V, J) : fe.insertBefore(V, J) : (fe.nodeType === 8 ? (J = fe.parentNode, J.insertBefore(V, fe)) : (J = fe, J.appendChild(V)), fe = fe._reactRootContainer, fe != null || J.onclick !== null || (J.onclick = qa)); else if (de !== 4 && (V = V.child, V !== null)) for (qo(V, J, fe), V = V.sibling; V !== null;)qo(V, J, fe), V = V.sibling } function Do(V, J, fe) { var de = V.tag; if (de === 5 || de === 6) V = V.stateNode, J ? fe.insertBefore(V, J) : fe.appendChild(V); else if (de !== 4 && (V = V.child, V !== null)) for (Do(V, J, fe), V = V.sibling; V !== null;)Do(V, J, fe), V = V.sibling } var Jr = null, Rn = !1; function ei(V, J, fe) { for (fe = fe.child; fe !== null;)Ju(V, J, fe), fe = fe.sibling } function Ju(V, J, fe) { if (Et && typeof Et.onCommitFiberUnmount == "function") try { Et.onCommitFiberUnmount(Nt, fe) } catch { } switch (fe.tag) { case 5: nn || Ni(fe, J); case 6: var de = Jr, we = Rn; Jr = null, ei(V, J, fe), Jr = de, Rn = we, Jr !== null && (Rn ? (V = Jr, fe = fe.stateNode, V.nodeType === 8 ? V.parentNode.removeChild(fe) : V.removeChild(fe)) : Jr.removeChild(fe.stateNode)); break; case 18: Jr !== null && (Rn ? (V = Jr, fe = fe.stateNode, V.nodeType === 8 ? Ws(V.parentNode, fe) : V.nodeType === 1 && Ws(V, fe), Ki(V)) : Ws(Jr, fe.stateNode)); break; case 4: de = Jr, we = Rn, Jr = fe.stateNode.containerInfo, Rn = !0, ei(V, J, fe), Jr = de, Rn = we; break; case 0: case 11: case 14: case 15: if (!nn && (de = fe.updateQueue, de !== null && (de = de.lastEffect, de !== null))) { we = de = de.next; do { var Te = we, He = Te.destroy; Te = Te.tag, He !== void 0 && ((Te & 2) !== 0 || (Te & 4) !== 0) && Bo(fe, J, He), we = we.next } while (we !== de) } ei(V, J, fe); break; case 1: if (!nn && (Ni(fe, J), de = fe.stateNode, typeof de.componentWillUnmount == "function")) try { de.props = fe.memoizedProps, de.state = fe.memoizedState, de.componentWillUnmount() } catch (ot) { Ur(fe, J, ot) } ei(V, J, fe); break; case 21: ei(V, J, fe); break; case 22: fe.mode & 1 ? (nn = (de = nn) || fe.memoizedState !== null, ei(V, J, fe), nn = de) : ei(V, J, fe); break; default: ei(V, J, fe) } } function Qu(V) { var J = V.updateQueue; if (J !== null) { V.updateQueue = null; var fe = V.stateNode; fe === null && (fe = V.stateNode = new Uc), J.forEach(function (de) { var we = Xc.bind(null, V, de); fe.has(de) || (fe.add(de), de.then(we, we)) }) } } function Cn(V, J) { var fe = J.deletions; if (fe !== null) for (var de = 0; de < fe.length; de++) { var we = fe[de]; try { var Te = V, He = J, ot = He; e: for (; ot !== null;) { switch (ot.tag) { case 5: Jr = ot.stateNode, Rn = !1; break e; case 3: Jr = ot.stateNode.containerInfo, Rn = !0; break e; case 4: Jr = ot.stateNode.containerInfo, Rn = !0; break e }ot = ot.return } if (Jr === null) throw Error(u(160)); Ju(Te, He, we), Jr = null, Rn = !1; var vt = we.alternate; vt !== null && (vt.return = null), we.return = null } catch (Pt) { Ur(we, J, Pt) } } if (J.subtreeFlags & 12854) for (J = J.child; J !== null;)ef(J, V), J = J.sibling } function ef(V, J) { var fe = V.alternate, de = V.flags; switch (V.tag) { case 0: case 11: case 14: case 15: if (Cn(J, V), Bn(V), de & 4) { try { ma(3, V, V.return), as(3, V) } catch (cr) { Ur(V, V.return, cr) } try { ma(5, V, V.return) } catch (cr) { Ur(V, V.return, cr) } } break; case 1: Cn(J, V), Bn(V), de & 512 && fe !== null && Ni(fe, fe.return); break; case 5: if (Cn(J, V), Bn(V), de & 512 && fe !== null && Ni(fe, fe.return), V.flags & 32) { var we = V.stateNode; try { ye(we, "") } catch (cr) { Ur(V, V.return, cr) } } if (de & 4 && (we = V.stateNode, we != null)) { var Te = V.memoizedProps, He = fe !== null ? fe.memoizedProps : Te, ot = V.type, vt = V.updateQueue; if (V.updateQueue = null, vt !== null) try { ot === "input" && Te.type === "radio" && Te.name != null && ht(we, Te), it(ot, He); var Pt = it(ot, Te); for (He = 0; He < vt.length; He += 2) { var Vt = vt[He], Zt = vt[He + 1]; Vt === "style" ? je(we, Zt) : Vt === "dangerouslySetInnerHTML" ? ut(we, Zt) : Vt === "children" ? ye(we, Zt) : le(we, Vt, Zt, Pt) } switch (ot) { case "input": Bt(we, Te); break; case "textarea": bt(we, Te); break; case "select": var Ut = we._wrapperState.wasMultiple; we._wrapperState.wasMultiple = !!Te.multiple; var or = Te.value; or != null ? pt(we, !!Te.multiple, or, !1) : Ut !== !!Te.multiple && (Te.defaultValue != null ? pt(we, !!Te.multiple, Te.defaultValue, !0) : pt(we, !!Te.multiple, Te.multiple ? [] : "", !1)) }we[ia] = Te } catch (cr) { Ur(V, V.return, cr) } } break; case 6: if (Cn(J, V), Bn(V), de & 4) { if (V.stateNode === null) throw Error(u(162)); we = V.stateNode, Te = V.memoizedProps; try { we.nodeValue = Te } catch (cr) { Ur(V, V.return, cr) } } break; case 3: if (Cn(J, V), Bn(V), de & 4 && fe !== null && fe.memoizedState.isDehydrated) try { Ki(J.containerInfo) } catch (cr) { Ur(V, V.return, cr) } break; case 4: Cn(J, V), Bn(V); break; case 13: Cn(J, V), Bn(V), we = V.child, we.flags & 8192 && (Te = we.memoizedState !== null, we.stateNode.isHidden = Te, !Te || we.alternate !== null && we.alternate.memoizedState !== null || (No = Ht())), de & 4 && Qu(V); break; case 22: if (Vt = fe !== null && fe.memoizedState !== null, V.mode & 1 ? (nn = (Pt = nn) || Vt, Cn(J, V), nn = Pt) : Cn(J, V), Bn(V), de & 8192) { if (Pt = V.memoizedState !== null, (V.stateNode.isHidden = Pt) && !Vt && (V.mode & 1) !== 0) for (ur = V, Vt = V.child; Vt !== null;) { for (Zt = ur = Vt; ur !== null;) { switch (Ut = ur, or = Ut.child, Ut.tag) { case 0: case 11: case 14: case 15: ma(4, Ut, Ut.return); break; case 1: Ni(Ut, Ut.return); var fr = Ut.stateNode; if (typeof fr.componentWillUnmount == "function") { de = Ut, fe = Ut.return; try { J = de, fr.props = J.memoizedProps, fr.state = J.memoizedState, fr.componentWillUnmount() } catch (cr) { Ur(de, fe, cr) } } break; case 5: Ni(Ut, Ut.return); break; case 22: if (Ut.memoizedState !== null) { nf(Zt); continue } }or !== null ? (or.return = Ut, ur = or) : nf(Zt) } Vt = Vt.sibling } e: for (Vt = null, Zt = V; ;) { if (Zt.tag === 5) { if (Vt === null) { Vt = Zt; try { we = Zt.stateNode, Pt ? (Te = we.style, typeof Te.setProperty == "function" ? Te.setProperty("display", "none", "important") : Te.display = "none") : (ot = Zt.stateNode, vt = Zt.memoizedProps.style, He = vt != null && vt.hasOwnProperty("display") ? vt.display : null, ot.style.display = Oe("display", He)) } catch (cr) { Ur(V, V.return, cr) } } } else if (Zt.tag === 6) { if (Vt === null) try { Zt.stateNode.nodeValue = Pt ? "" : Zt.memoizedProps } catch (cr) { Ur(V, V.return, cr) } } else if ((Zt.tag !== 22 && Zt.tag !== 23 || Zt.memoizedState === null || Zt === V) && Zt.child !== null) { Zt.child.return = Zt, Zt = Zt.child; continue } if (Zt === V) break e; for (; Zt.sibling === null;) { if (Zt.return === null || Zt.return === V) break e; Vt === Zt && (Vt = null), Zt = Zt.return } Vt === Zt && (Vt = null), Zt.sibling.return = Zt.return, Zt = Zt.sibling } } break; case 19: Cn(J, V), Bn(V), de & 4 && Qu(V); break; case 21: break; default: Cn(J, V), Bn(V) } } function Bn(V) { var J = V.flags; if (J & 2) { try { e: { for (var fe = V.return; fe !== null;) { if (Yu(fe)) { var de = fe; break e } fe = fe.return } throw Error(u(160)) } switch (de.tag) { case 5: var we = de.stateNode; de.flags & 32 && (ye(we, ""), de.flags &= -33); var Te = Xu(V); Do(V, Te, we); break; case 3: case 4: var He = de.stateNode.containerInfo, ot = Xu(V); qo(V, ot, He); break; default: throw Error(u(161)) } } catch (vt) { Ur(V, V.return, vt) } V.flags &= -3 } J & 4096 && (V.flags &= -4097) } function Vc(V, J, fe) { ur = V, tf(V) } function tf(V, J, fe) { for (var de = (V.mode & 1) !== 0; ur !== null;) { var we = ur, Te = we.child; if (we.tag === 22 && de) { var He = we.memoizedState !== null || is; if (!He) { var ot = we.alternate, vt = ot !== null && ot.memoizedState !== null || nn; ot = is; var Pt = nn; if (is = He, (nn = vt) && !Pt) for (ur = we; ur !== null;)He = ur, vt = He.child, He.tag === 22 && He.memoizedState !== null ? af(we) : vt !== null ? (vt.return = He, ur = vt) : af(we); for (; Te !== null;)ur = Te, tf(Te), Te = Te.sibling; ur = we, is = ot, nn = Pt } rf(V) } else (we.subtreeFlags & 8772) !== 0 && Te !== null ? (Te.return = we, ur = Te) : rf(V) } } function rf(V) { for (; ur !== null;) { var J = ur; if ((J.flags & 8772) !== 0) { var fe = J.alternate; try { if ((J.flags & 8772) !== 0) switch (J.tag) { case 0: case 11: case 15: nn || as(5, J); break; case 1: var de = J.stateNode; if (J.flags & 4 && !nn) if (fe === null) de.componentDidMount(); else { var we = J.elementType === J.type ? fe.memoizedProps : An(J.type, fe.memoizedProps); de.componentDidUpdate(we, fe.memoizedState, de.__reactInternalSnapshotBeforeUpdate) } var Te = J.updateQueue; Te !== null && nu(J, Te, de); break; case 3: var He = J.updateQueue; if (He !== null) { if (fe = null, J.child !== null) switch (J.child.tag) { case 5: fe = J.child.stateNode; break; case 1: fe = J.child.stateNode }nu(J, He, fe) } break; case 5: var ot = J.stateNode; if (fe === null && J.flags & 4) { fe = ot; var vt = J.memoizedProps; switch (J.type) { case "button": case "input": case "select": case "textarea": vt.autoFocus && fe.focus(); break; case "img": vt.src && (fe.src = vt.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (J.memoizedState === null) { var Pt = J.alternate; if (Pt !== null) { var Vt = Pt.memoizedState; if (Vt !== null) { var Zt = Vt.dehydrated; Zt !== null && Ki(Zt) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(u(163)) }nn || J.flags & 512 && Oo(J) } catch (Ut) { Ur(J, J.return, Ut) } } if (J === V) { ur = null; break } if (fe = J.sibling, fe !== null) { fe.return = J.return, ur = fe; break } ur = J.return } } function nf(V) { for (; ur !== null;) { var J = ur; if (J === V) { ur = null; break } var fe = J.sibling; if (fe !== null) { fe.return = J.return, ur = fe; break } ur = J.return } } function af(V) { for (; ur !== null;) { var J = ur; try { switch (J.tag) { case 0: case 11: case 15: var fe = J.return; try { as(4, J) } catch (vt) { Ur(J, fe, vt) } break; case 1: var de = J.stateNode; if (typeof de.componentDidMount == "function") { var we = J.return; try { de.componentDidMount() } catch (vt) { Ur(J, we, vt) } } var Te = J.return; try { Oo(J) } catch (vt) { Ur(J, Te, vt) } break; case 5: var He = J.return; try { Oo(J) } catch (vt) { Ur(J, He, vt) } } } catch (vt) { Ur(J, J.return, vt) } if (J === V) { ur = null; break } var ot = J.sibling; if (ot !== null) { ot.return = J.return, ur = ot; break } ur = J.return } } var zc = Math.ceil, ss = ue.ReactCurrentDispatcher, Lo = ue.ReactCurrentOwner, xn = ue.ReactCurrentBatchConfig, Cr = 0, Yr = null, zr = null, Qr = 0, gn = 0, $i = Zn(0), Wr = 0, ga = null, gi = 0, os = 0, Fo = 0, va = null, fn = null, No = 0, Ui = 1 / 0, Un = null, ls = !1, $o = null, ti = null, us = !1, ri = null, fs = 0, ya = 0, Uo = null, cs = -1, hs = 0; function sn() { return (Cr & 6) !== 0 ? Ht() : cs !== -1 ? cs : cs = Ht() } function ni(V) { return (V.mode & 1) === 0 ? 1 : (Cr & 2) !== 0 && Qr !== 0 ? Qr & -Qr : Rc.transition !== null ? (hs === 0 && (hs = Ar()), hs) : (V = dr, V !== 0 || (V = window.event, V = V === void 0 ? 16 : sl(V.type)), V) } function Pn(V, J, fe, de) { if (50 < ya) throw ya = 0, Uo = null, Error(u(185)); Er(V, fe, de), ((Cr & 2) === 0 || V !== Yr) && (V === Yr && ((Cr & 2) === 0 && (os |= fe), Wr === 4 && ii(V, Qr)), hn(V, de), fe === 1 && Cr === 0 && (J.mode & 1) === 0 && (Ui = Ht() + 500, Na && Xn())) } function hn(V, J) { var fe = V.callbackNode; Sr(V, J); var de = _r(V, V === Yr ? Qr : 0); if (de === 0) fe !== null && ar(fe), V.callbackNode = null, V.callbackPriority = 0; else if (J = de & -de, V.callbackPriority !== J) { if (fe != null && ar(fe), J === 1) V.tag === 0 ? Ac(of.bind(null, V)) : Hl(of.bind(null, V)), xc(function () { (Cr & 6) === 0 && Xn() }), fe = null; else { switch (Br(de)) { case 1: fe = Kt; break; case 4: fe = Qt; break; case 16: fe = $t; break; case 536870912: fe = Xt; break; default: fe = $t }fe = mf(fe, sf.bind(null, V)) } V.callbackPriority = J, V.callbackNode = fe } } function sf(V, J) { if (cs = -1, hs = 0, (Cr & 6) !== 0) throw Error(u(327)); var fe = V.callbackNode; if (ji() && V.callbackNode !== fe) return null; var de = _r(V, V === Yr ? Qr : 0); if (de === 0) return null; if ((de & 30) !== 0 || (de & V.expiredLanes) !== 0 || J) J = ds(V, de); else { J = de; var we = Cr; Cr |= 2; var Te = uf(); (Yr !== V || Qr !== J) && (Un = null, Ui = Ht() + 500, yi(V, J)); do try { Kc(); break } catch (ot) { lf(V, ot) } while (!0); io(), ss.current = Te, Cr = we, zr !== null ? J = 0 : (Yr = null, Qr = 0, J = Wr) } if (J !== 0) { if (J === 2 && (we = Mr(V), we !== 0 && (de = we, J = jo(V, we))), J === 1) throw fe = ga, yi(V, 0), ii(V, de), hn(V, Ht()), fe; if (J === 6) ii(V, de); else { if (we = V.current.alternate, (de & 30) === 0 && !Hc(we) && (J = ds(V, de), J === 2 && (Te = Mr(V), Te !== 0 && (de = Te, J = jo(V, Te))), J === 1)) throw fe = ga, yi(V, 0), ii(V, de), hn(V, Ht()), fe; switch (V.finishedWork = we, V.finishedLanes = de, J) { case 0: case 1: throw Error(u(345)); case 2: bi(V, fn, Un); break; case 3: if (ii(V, de), (de & 130023424) === de && (J = No + 500 - Ht(), 10 < J)) { if (_r(V, 0) !== 0) break; if (we = V.suspendedLanes, (we & de) !== de) { sn(), V.pingedLanes |= V.suspendedLanes & we; break } V.timeoutHandle = Ks(bi.bind(null, V, fn, Un), J); break } bi(V, fn, Un); break; case 4: if (ii(V, de), (de & 4194240) === de) break; for (J = V.eventTimes, we = -1; 0 < de;) { var He = 31 - qt(de); Te = 1 << He, He = J[He], He > we && (we = He), de &= ~Te } if (de = we, de = Ht() - de, de = (120 > de ? 120 : 480 > de ? 480 : 1080 > de ? 1080 : 1920 > de ? 1920 : 3e3 > de ? 3e3 : 4320 > de ? 4320 : 1960 * zc(de / 1960)) - de, 10 < de) { V.timeoutHandle = Ks(bi.bind(null, V, fn, Un), de); break } bi(V, fn, Un); break; case 5: bi(V, fn, Un); break; default: throw Error(u(329)) } } } return hn(V, Ht()), V.callbackNode === fe ? sf.bind(null, V) : null } function jo(V, J) { var fe = va; return V.current.memoizedState.isDehydrated && (yi(V, J).flags |= 256), V = ds(V, J), V !== 2 && (J = fn, fn = fe, J !== null && Vo(J)), V } function Vo(V) { fn === null ? fn = V : fn.push.apply(fn, V) } function Hc(V) { for (var J = V; ;) { if (J.flags & 16384) { var fe = J.updateQueue; if (fe !== null && (fe = fe.stores, fe !== null)) for (var de = 0; de < fe.length; de++) { var we = fe[de], Te = we.getSnapshot; we = we.value; try { if (!En(Te(), we)) return !1 } catch { return !1 } } } if (fe = J.child, J.subtreeFlags & 16384 && fe !== null) fe.return = J, J = fe; else { if (J === V) break; for (; J.sibling === null;) { if (J.return === null || J.return === V) return !0; J = J.return } J.sibling.return = J.return, J = J.sibling } } return !0 } function ii(V, J) { for (J &= ~Fo, J &= ~os, V.suspendedLanes |= J, V.pingedLanes &= ~J, V = V.expirationTimes; 0 < J;) { var fe = 31 - qt(J), de = 1 << fe; V[fe] = -1, J &= ~de } } function of(V) { if ((Cr & 6) !== 0) throw Error(u(327)); ji(); var J = _r(V, 0); if ((J & 1) === 0) return hn(V, Ht()), null; var fe = ds(V, J); if (V.tag !== 0 && fe === 2) { var de = Mr(V); de !== 0 && (J = de, fe = jo(V, de)) } if (fe === 1) throw fe = ga, yi(V, 0), ii(V, J), hn(V, Ht()), fe; if (fe === 6) throw Error(u(345)); return V.finishedWork = V.current.alternate, V.finishedLanes = J, bi(V, fn, Un), hn(V, Ht()), null } function zo(V, J) { var fe = Cr; Cr |= 1; try { return V(J) } finally { Cr = fe, Cr === 0 && (Ui = Ht() + 500, Na && Xn()) } } function vi(V) { ri !== null && ri.tag === 0 && (Cr & 6) === 0 && ji(); var J = Cr; Cr |= 1; var fe = xn.transition, de = dr; try { if (xn.transition = null, dr = 1, V) return V() } finally { dr = de, xn.transition = fe, Cr = J, (Cr & 6) === 0 && Xn() } } function Ho() { gn = $i.current, Dr($i) } function yi(V, J) { V.finishedWork = null, V.finishedLanes = 0; var fe = V.timeoutHandle; if (fe !== -1 && (V.timeoutHandle = -1, wc(fe)), zr !== null) for (fe = zr.return; fe !== null;) { var de = fe; switch (Qs(de), de.tag) { case 1: de = de.type.childContextTypes, de != null && La(); break; case 3: Li(), Dr(on), Dr(en), ho(); break; case 5: fo(de); break; case 4: Li(); break; case 13: Dr(Fr); break; case 19: Dr(Fr); break; case 10: ao(de.type._context); break; case 22: case 23: Ho() }fe = fe.return } if (Yr = V, zr = V = ai(V.current, null), Qr = gn = J, Wr = 0, ga = null, Fo = os = gi = 0, fn = va = null, di !== null) { for (J = 0; J < di.length; J++)if (fe = di[J], de = fe.interleaved, de !== null) { fe.interleaved = null; var we = de.next, Te = fe.pending; if (Te !== null) { var He = Te.next; Te.next = we, de.next = He } fe.pending = de } di = null } return V } function lf(V, J) { do { var fe = zr; try { if (io(), Za.current = Qa, Ya) { for (var de = Nr.memoizedState; de !== null;) { var we = de.queue; we !== null && (we.pending = null), de = de.next } Ya = !1 } if (mi = 0, Zr = Kr = Nr = null, fa = !1, ca = 0, Lo.current = null, fe === null || fe.return === null) { Wr = 1, ga = J, zr = null; break } e: { var Te = V, He = fe.return, ot = fe, vt = J; if (J = Qr, ot.flags |= 32768, vt !== null && typeof vt == "object" && typeof vt.then == "function") { var Pt = vt, Vt = ot, Zt = Vt.tag; if ((Vt.mode & 1) === 0 && (Zt === 0 || Zt === 11 || Zt === 15)) { var Ut = Vt.alternate; Ut ? (Vt.updateQueue = Ut.updateQueue, Vt.memoizedState = Ut.memoizedState, Vt.lanes = Ut.lanes) : (Vt.updateQueue = null, Vt.memoizedState = null) } var or = Iu(He); if (or !== null) { or.flags &= -257, Bu(or, He, ot, Te, J), or.mode & 1 && ku(Te, Pt, J), J = or, vt = Pt; var fr = J.updateQueue; if (fr === null) { var cr = new Set; cr.add(vt), J.updateQueue = cr } else fr.add(vt); break e } else { if ((J & 1) === 0) { ku(Te, Pt, J), Go(); break e } vt = Error(u(426)) } } else if (Lr && ot.mode & 1) { var jr = Iu(He); if (jr !== null) { (jr.flags & 65536) === 0 && (jr.flags |= 256), Bu(jr, He, ot, Te, J), ro(Fi(vt, ot)); break e } } Te = vt = Fi(vt, ot), Wr !== 4 && (Wr = 2), va === null ? va = [Te] : va.push(Te), Te = He; do { switch (Te.tag) { case 3: Te.flags |= 65536, J &= -J, Te.lanes |= J; var Rt = Pu(Te, vt, J); ru(Te, Rt); break e; case 1: ot = vt; var xt = Te.type, Ct = Te.stateNode; if ((Te.flags & 128) === 0 && (typeof xt.getDerivedStateFromError == "function" || Ct !== null && typeof Ct.componentDidCatch == "function" && (ti === null || !ti.has(Ct)))) { Te.flags |= 65536, J &= -J, Te.lanes |= J; var Jt = Tu(Te, ot, J); ru(Te, Jt); break e } }Te = Te.return } while (Te !== null) } cf(fe) } catch (hr) { J = hr, zr === fe && fe !== null && (zr = fe = fe.return); continue } break } while (!0) } function uf() { var V = ss.current; return ss.current = Qa, V === null ? Qa : V } function Go() { (Wr === 0 || Wr === 3 || Wr === 2) && (Wr = 4), Yr === null || (gi & 268435455) === 0 && (os & 268435455) === 0 || ii(Yr, Qr) } function ds(V, J) { var fe = Cr; Cr |= 2; var de = uf(); (Yr !== V || Qr !== J) && (Un = null, yi(V, J)); do try { Gc(); break } catch (we) { lf(V, we) } while (!0); if (io(), Cr = fe, ss.current = de, zr !== null) throw Error(u(261)); return Yr = null, Qr = 0, Wr } function Gc() { for (; zr !== null;)ff(zr) } function Kc() { for (; zr !== null && !nr();)ff(zr) } function ff(V) { var J = pf(V.alternate, V, gn); V.memoizedProps = V.pendingProps, J === null ? cf(V) : zr = J, Lo.current = null } function cf(V) { var J = V; do { var fe = J.alternate; if (V = J.return, (J.flags & 32768) === 0) { if (fe = Nc(fe, J, gn), fe !== null) { zr = fe; return } } else { if (fe = $c(fe, J), fe !== null) { fe.flags &= 32767, zr = fe; return } if (V !== null) V.flags |= 32768, V.subtreeFlags = 0, V.deletions = null; else { Wr = 6, zr = null; return } } if (J = J.sibling, J !== null) { zr = J; return } zr = J = V } while (J !== null); Wr === 0 && (Wr = 5) } function bi(V, J, fe) { var de = dr, we = xn.transition; try { xn.transition = null, dr = 1, Wc(V, J, fe, de) } finally { xn.transition = we, dr = de } return null } function Wc(V, J, fe, de) { do ji(); while (ri !== null); if ((Cr & 6) !== 0) throw Error(u(327)); fe = V.finishedWork; var we = V.finishedLanes; if (fe === null) return null; if (V.finishedWork = null, V.finishedLanes = 0, fe === V.current) throw Error(u(177)); V.callbackNode = null, V.callbackPriority = 0; var Te = fe.lanes | fe.childLanes; if (Rr(V, Te), V === Yr && (zr = Yr = null, Qr = 0), (fe.subtreeFlags & 2064) === 0 && (fe.flags & 2064) === 0 || us || (us = !0, mf($t, function () { return ji(), null })), Te = (fe.flags & 15990) !== 0, (fe.subtreeFlags & 15990) !== 0 || Te) { Te = xn.transition, xn.transition = null; var He = dr; dr = 1; var ot = Cr; Cr |= 4, Lo.current = null, jc(V, fe), ef(fe, V), pc(Hs), Sa = !!zs, Hs = zs = null, V.current = fe, Vc(fe), ir(), Cr = ot, dr = He, xn.transition = Te } else V.current = fe; if (us && (us = !1, ri = V, fs = we), Te = V.pendingLanes, Te === 0 && (ti = null), At(fe.stateNode), hn(V, Ht()), J !== null) for (de = V.onRecoverableError, fe = 0; fe < J.length; fe++)we = J[fe], de(we.value, { componentStack: we.stack, digest: we.digest }); if (ls) throw ls = !1, V = $o, $o = null, V; return (fs & 1) !== 0 && V.tag !== 0 && ji(), Te = V.pendingLanes, (Te & 1) !== 0 ? V === Uo ? ya++ : (ya = 0, Uo = V) : ya = 0, Xn(), null } function ji() { if (ri !== null) { var V = Br(fs), J = xn.transition, fe = dr; try { if (xn.transition = null, dr = 16 > V ? 16 : V, ri === null) var de = !1; else { if (V = ri, ri = null, fs = 0, (Cr & 6) !== 0) throw Error(u(331)); var we = Cr; for (Cr |= 4, ur = V.current; ur !== null;) { var Te = ur, He = Te.child; if ((ur.flags & 16) !== 0) { var ot = Te.deletions; if (ot !== null) { for (var vt = 0; vt < ot.length; vt++) { var Pt = ot[vt]; for (ur = Pt; ur !== null;) { var Vt = ur; switch (Vt.tag) { case 0: case 11: case 15: ma(8, Vt, Te) }var Zt = Vt.child; if (Zt !== null) Zt.return = Vt, ur = Zt; else for (; ur !== null;) { Vt = ur; var Ut = Vt.sibling, or = Vt.return; if (Zu(Vt), Vt === Pt) { ur = null; break } if (Ut !== null) { Ut.return = or, ur = Ut; break } ur = or } } } var fr = Te.alternate; if (fr !== null) { var cr = fr.child; if (cr !== null) { fr.child = null; do { var jr = cr.sibling; cr.sibling = null, cr = jr } while (cr !== null) } } ur = Te } } if ((Te.subtreeFlags & 2064) !== 0 && He !== null) He.return = Te, ur = He; else e: for (; ur !== null;) { if (Te = ur, (Te.flags & 2048) !== 0) switch (Te.tag) { case 0: case 11: case 15: ma(9, Te, Te.return) }var Rt = Te.sibling; if (Rt !== null) { Rt.return = Te.return, ur = Rt; break e } ur = Te.return } } var xt = V.current; for (ur = xt; ur !== null;) { He = ur; var Ct = He.child; if ((He.subtreeFlags & 2064) !== 0 && Ct !== null) Ct.return = He, ur = Ct; else e: for (He = xt; ur !== null;) { if (ot = ur, (ot.flags & 2048) !== 0) try { switch (ot.tag) { case 0: case 11: case 15: as(9, ot) } } catch (hr) { Ur(ot, ot.return, hr) } if (ot === He) { ur = null; break e } var Jt = ot.sibling; if (Jt !== null) { Jt.return = ot.return, ur = Jt; break e } ur = ot.return } } if (Cr = we, Xn(), Et && typeof Et.onPostCommitFiberRoot == "function") try { Et.onPostCommitFiberRoot(Nt, V) } catch { } de = !0 } return de } finally { dr = fe, xn.transition = J } } return !1 } function hf(V, J, fe) { J = Fi(fe, J), J = Pu(V, J, 1), V = Qn(V, J, 1), J = sn(), V !== null && (Er(V, 1, J), hn(V, J)) } function Ur(V, J, fe) { if (V.tag === 3) hf(V, V, fe); else for (; J !== null;) { if (J.tag === 3) { hf(J, V, fe); break } else if (J.tag === 1) { var de = J.stateNode; if (typeof J.type.getDerivedStateFromError == "function" || typeof de.componentDidCatch == "function" && (ti === null || !ti.has(de))) { V = Fi(fe, V), V = Tu(J, V, 1), J = Qn(J, V, 1), V = sn(), J !== null && (Er(J, 1, V), hn(J, V)); break } } J = J.return } } function Zc(V, J, fe) { var de = V.pingCache; de !== null && de.delete(J), J = sn(), V.pingedLanes |= V.suspendedLanes & fe, Yr === V && (Qr & fe) === fe && (Wr === 4 || Wr === 3 && (Qr & 130023424) === Qr && 500 > Ht() - No ? yi(V, 0) : Fo |= fe), hn(V, J) } function df(V, J) { J === 0 && ((V.mode & 1) === 0 ? J = 1 : (J = yr, yr <<= 1, (yr & 130023424) === 0 && (yr = 4194304))); var fe = sn(); V = Fn(V, J), V !== null && (Er(V, J, fe), hn(V, fe)) } function Yc(V) { var J = V.memoizedState, fe = 0; J !== null && (fe = J.retryLane), df(V, fe) } function Xc(V, J) { var fe = 0; switch (V.tag) { case 13: var de = V.stateNode, we = V.memoizedState; we !== null && (fe = we.retryLane); break; case 19: de = V.stateNode; break; default: throw Error(u(314)) }de !== null && de.delete(J), df(V, fe) } var pf; pf = function (V, J, fe) { if (V !== null) if (V.memoizedProps !== J.pendingProps || on.current) un = !0; else { if ((V.lanes & fe) === 0 && (J.flags & 128) === 0) return un = !1, Fc(V, J, fe); un = (V.flags & 131072) !== 0 } else un = !1, Lr && (J.flags & 1048576) !== 0 && Gl(J, Ua, J.index); switch (J.lanes = 0, J.tag) { case 2: var de = J.type; rs(V, J), V = J.pendingProps; var we = Ti(J, en.current); Di(J, fe), we = go(null, J, de, V, we, fe); var Te = vo(); return J.flags |= 1, typeof we == "object" && we !== null && typeof we.render == "function" && we.$$typeof === void 0 ? (J.tag = 1, J.memoizedState = null, J.updateQueue = null, ln(de) ? (Te = !0, Fa(J)) : Te = !1, J.memoizedState = we.state !== null && we.state !== void 0 ? we.state : null, lo(J), we.updater = es, J.stateNode = we, we._reactInternals = J, So(J, de, V, fe), J = Ro(null, J, de, !0, Te, fe)) : (J.tag = 0, Lr && Te && Js(J), an(null, J, we, fe), J = J.child), J; case 16: de = J.elementType; e: { switch (rs(V, J), V = J.pendingProps, we = de._init, de = we(de._payload), J.type = de, we = J.tag = Qc(de), V = An(de, V), we) { case 0: J = Ao(null, J, de, V, fe); break e; case 1: J = Nu(null, J, de, V, fe); break e; case 11: J = Ou(null, J, de, V, fe); break e; case 14: J = qu(null, J, de, An(de.type, V), fe); break e }throw Error(u(306, de, "")) } return J; case 0: return de = J.type, we = J.pendingProps, we = J.elementType === de ? we : An(de, we), Ao(V, J, de, we, fe); case 1: return de = J.type, we = J.pendingProps, we = J.elementType === de ? we : An(de, we), Nu(V, J, de, we, fe); case 3: e: { if ($u(J), V === null) throw Error(u(387)); de = J.pendingProps, Te = J.memoizedState, we = Te.element, tu(V, J), Ka(J, de, null, fe); var He = J.memoizedState; if (de = He.element, Te.isDehydrated) if (Te = { element: de, isDehydrated: !1, cache: He.cache, pendingSuspenseBoundaries: He.pendingSuspenseBoundaries, transitions: He.transitions }, J.updateQueue.baseState = Te, J.memoizedState = Te, J.flags & 256) { we = Fi(Error(u(423)), J), J = Uu(V, J, de, fe, we); break e } else if (de !== we) { we = Fi(Error(u(424)), J), J = Uu(V, J, de, fe, we); break e } else for (mn = Wn(J.stateNode.containerInfo.firstChild), pn = J, Lr = !0, Mn = null, fe = Ql(J, null, de, fe), J.child = fe; fe;)fe.flags = fe.flags & -3 | 4096, fe = fe.sibling; else { if (Bi(), de === we) { J = $n(V, J, fe); break e } an(V, J, de, fe) } J = J.child } return J; case 5: return iu(J), V === null && to(J), de = J.type, we = J.pendingProps, Te = V !== null ? V.memoizedProps : null, He = we.children, Gs(de, we) ? He = null : Te !== null && Gs(de, Te) && (J.flags |= 32), Fu(V, J), an(V, J, He, fe), J.child; case 6: return V === null && to(J), null; case 13: return ju(V, J, fe); case 4: return uo(J, J.stateNode.containerInfo), de = J.pendingProps, V === null ? J.child = Oi(J, null, de, fe) : an(V, J, de, fe), J.child; case 11: return de = J.type, we = J.pendingProps, we = J.elementType === de ? we : An(de, we), Ou(V, J, de, we, fe); case 7: return an(V, J, J.pendingProps, fe), J.child; case 8: return an(V, J, J.pendingProps.children, fe), J.child; case 12: return an(V, J, J.pendingProps.children, fe), J.child; case 10: e: { if (de = J.type._context, we = J.pendingProps, Te = J.memoizedProps, He = we.value, kr(za, de._currentValue), de._currentValue = He, Te !== null) if (En(Te.value, He)) { if (Te.children === we.children && !on.current) { J = $n(V, J, fe); break e } } else for (Te = J.child, Te !== null && (Te.return = J); Te !== null;) { var ot = Te.dependencies; if (ot !== null) { He = Te.child; for (var vt = ot.firstContext; vt !== null;) { if (vt.context === de) { if (Te.tag === 1) { vt = Nn(-1, fe & -fe), vt.tag = 2; var Pt = Te.updateQueue; if (Pt !== null) { Pt = Pt.shared; var Vt = Pt.pending; Vt === null ? vt.next = vt : (vt.next = Vt.next, Vt.next = vt), Pt.pending = vt } } Te.lanes |= fe, vt = Te.alternate, vt !== null && (vt.lanes |= fe), so(Te.return, fe, J), ot.lanes |= fe; break } vt = vt.next } } else if (Te.tag === 10) He = Te.type === J.type ? null : Te.child; else if (Te.tag === 18) { if (He = Te.return, He === null) throw Error(u(341)); He.lanes |= fe, ot = He.alternate, ot !== null && (ot.lanes |= fe), so(He, fe, J), He = Te.sibling } else He = Te.child; if (He !== null) He.return = Te; else for (He = Te; He !== null;) { if (He === J) { He = null; break } if (Te = He.sibling, Te !== null) { Te.return = He.return, He = Te; break } He = He.return } Te = He } an(V, J, we.children, fe), J = J.child } return J; case 9: return we = J.type, de = J.pendingProps.children, Di(J, fe), we = _n(we), de = de(we), J.flags |= 1, an(V, J, de, fe), J.child; case 14: return de = J.type, we = An(de, J.pendingProps), we = An(de.type, we), qu(V, J, de, we, fe); case 15: return Du(V, J, J.type, J.pendingProps, fe); case 17: return de = J.type, we = J.pendingProps, we = J.elementType === de ? we : An(de, we), rs(V, J), J.tag = 1, ln(de) ? (V = !0, Fa(J)) : V = !1, Di(J, fe), Ru(J, de, we), So(J, de, we, fe), Ro(null, J, de, !0, V, fe); case 19: return zu(V, J, fe); case 22: return Lu(V, J, fe) }throw Error(u(156, J.tag)) }; function mf(V, J) { return er(V, J) } function Jc(V, J, fe, de) { this.tag = V, this.key = fe, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = J, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = de, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Sn(V, J, fe, de) { return new Jc(V, J, fe, de) } function Ko(V) { return V = V.prototype, !(!V || !V.isReactComponent) } function Qc(V) { if (typeof V == "function") return Ko(V) ? 1 : 0; if (V != null) { if (V = V.$$typeof, V === g) return 11; if (V === K) return 14 } return 2 } function ai(V, J) { var fe = V.alternate; return fe === null ? (fe = Sn(V.tag, J, V.key, V.mode), fe.elementType = V.elementType, fe.type = V.type, fe.stateNode = V.stateNode, fe.alternate = V, V.alternate = fe) : (fe.pendingProps = J, fe.type = V.type, fe.flags = 0, fe.subtreeFlags = 0, fe.deletions = null), fe.flags = V.flags & 14680064, fe.childLanes = V.childLanes, fe.lanes = V.lanes, fe.child = V.child, fe.memoizedProps = V.memoizedProps, fe.memoizedState = V.memoizedState, fe.updateQueue = V.updateQueue, J = V.dependencies, fe.dependencies = J === null ? null : { lanes: J.lanes, firstContext: J.firstContext }, fe.sibling = V.sibling, fe.index = V.index, fe.ref = V.ref, fe } function ps(V, J, fe, de, we, Te) { var He = 2; if (de = V, typeof V == "function") Ko(V) && (He = 1); else if (typeof V == "string") He = 5; else e: switch (V) { case ve: return _i(fe.children, we, Te, J); case _e: He = 8, we |= 8; break; case Se: return V = Sn(12, fe, J, we | 2), V.elementType = Se, V.lanes = Te, V; case P: return V = Sn(13, fe, J, we), V.elementType = P, V.lanes = Te, V; case U: return V = Sn(19, fe, J, we), V.elementType = U, V.lanes = Te, V; case te: return gs(fe, we, Te, J); default: if (typeof V == "object" && V !== null) switch (V.$$typeof) { case $e: He = 10; break e; case ie: He = 9; break e; case g: He = 11; break e; case K: He = 14; break e; case Y: He = 16, de = null; break e }throw Error(u(130, V == null ? V : typeof V, "")) }return J = Sn(He, fe, J, we), J.elementType = V, J.type = de, J.lanes = Te, J } function _i(V, J, fe, de) { return V = Sn(7, V, de, J), V.lanes = fe, V } function gs(V, J, fe, de) { return V = Sn(22, V, de, J), V.elementType = te, V.lanes = fe, V.stateNode = { isHidden: !1 }, V } function Wo(V, J, fe) { return V = Sn(6, V, null, J), V.lanes = fe, V } function Zo(V, J, fe) { return J = Sn(4, V.children !== null ? V.children : [], V.key, J), J.lanes = fe, J.stateNode = { containerInfo: V.containerInfo, pendingChildren: null, implementation: V.implementation }, J } function eh(V, J, fe, de, we) { this.tag = J, this.containerInfo = V, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = xr(0), this.expirationTimes = xr(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = xr(0), this.identifierPrefix = de, this.onRecoverableError = we, this.mutableSourceEagerHydrationData = null } function Yo(V, J, fe, de, we, Te, He, ot, vt) { return V = new eh(V, J, fe, ot, vt), J === 1 ? (J = 1, Te === !0 && (J |= 8)) : J = 0, Te = Sn(3, null, null, J), V.current = Te, Te.stateNode = V, Te.memoizedState = { element: de, isDehydrated: fe, cache: null, transitions: null, pendingSuspenseBoundaries: null }, lo(Te), V } function th(V, J, fe) { var de = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: pe, key: de == null ? null : "" + de, children: V, containerInfo: J, implementation: fe } } function gf(V) { if (!V) return Yn; V = V._reactInternals; e: { if (ct(V) !== V || V.tag !== 1) throw Error(u(170)); var J = V; do { switch (J.tag) { case 3: J = J.stateNode.context; break e; case 1: if (ln(J.type)) { J = J.stateNode.__reactInternalMemoizedMergedChildContext; break e } }J = J.return } while (J !== null); throw Error(u(171)) } if (V.tag === 1) { var fe = V.type; if (ln(fe)) return Vl(V, fe, J) } return J } function vf(V, J, fe, de, we, Te, He, ot, vt) { return V = Yo(fe, de, !0, V, we, Te, He, ot, vt), V.context = gf(null), fe = V.current, de = sn(), we = ni(fe), Te = Nn(de, we), Te.callback = J ?? null, Qn(fe, Te, we), V.current.lanes = we, Er(V, we, de), hn(V, de), V } function vs(V, J, fe, de) { var we = J.current, Te = sn(), He = ni(we); return fe = gf(fe), J.context === null ? J.context = fe : J.pendingContext = fe, J = Nn(Te, He), J.payload = { element: V }, de = de === void 0 ? null : de, de !== null && (J.callback = de), V = Qn(we, J, He), V !== null && (Pn(V, we, He, Te), Ga(V, we, He)), He } function ys(V) { if (V = V.current, !V.child) return null; switch (V.child.tag) { case 5: return V.child.stateNode; default: return V.child.stateNode } } function yf(V, J) { if (V = V.memoizedState, V !== null && V.dehydrated !== null) { var fe = V.retryLane; V.retryLane = fe !== 0 && fe < J ? fe : J } } function Xo(V, J) { yf(V, J), (V = V.alternate) && yf(V, J) } function rh() { return null } var bf = typeof reportError == "function" ? reportError : function (V) { console.error(V) }; function Jo(V) { this._internalRoot = V } bs.prototype.render = Jo.prototype.render = function (V) { var J = this._internalRoot; if (J === null) throw Error(u(409)); vs(V, J, null, null) }, bs.prototype.unmount = Jo.prototype.unmount = function () { var V = this._internalRoot; if (V !== null) { this._internalRoot = null; var J = V.containerInfo; vi(function () { vs(null, V, null, null) }), J[On] = null } }; function bs(V) { this._internalRoot = V } bs.prototype.unstable_scheduleHydration = function (V) { if (V) { var J = Hr(); V = { blockedOn: null, target: V, priority: J }; for (var fe = 0; fe < Hn.length && J !== 0 && J < Hn[fe].priority; fe++); Hn.splice(fe, 0, V), fe === 0 && il(V) } }; function Qo(V) { return !(!V || V.nodeType !== 1 && V.nodeType !== 9 && V.nodeType !== 11) } function _s(V) { return !(!V || V.nodeType !== 1 && V.nodeType !== 9 && V.nodeType !== 11 && (V.nodeType !== 8 || V.nodeValue !== " react-mount-point-unstable ")) } function _f() { } function nh(V, J, fe, de, we) { if (we) { if (typeof de == "function") { var Te = de; de = function () { var Pt = ys(He); Te.call(Pt) } } var He = vf(J, de, V, 0, null, !1, !1, "", _f); return V._reactRootContainer = He, V[On] = He.current, ra(V.nodeType === 8 ? V.parentNode : V), vi(), He } for (; we = V.lastChild;)V.removeChild(we); if (typeof de == "function") { var ot = de; de = function () { var Pt = ys(vt); ot.call(Pt) } } var vt = Yo(V, 0, !1, null, null, !1, !1, "", _f); return V._reactRootContainer = vt, V[On] = vt.current, ra(V.nodeType === 8 ? V.parentNode : V), vi(function () { vs(J, vt, fe, de) }), vt } function ws(V, J, fe, de, we) { var Te = fe._reactRootContainer; if (Te) { var He = Te; if (typeof we == "function") { var ot = we; we = function () { var vt = ys(He); ot.call(vt) } } vs(J, He, V, we) } else He = nh(fe, J, V, we, de); return ys(He) } Or = function (V) { switch (V.tag) { case 3: var J = V.stateNode; if (J.current.memoizedState.isDehydrated) { var fe = br(J.pendingLanes); fe !== 0 && (Ir(J, fe | 1), hn(J, Ht()), (Cr & 6) === 0 && (Ui = Ht() + 500, Xn())) } break; case 13: vi(function () { var de = Fn(V, 1); if (de !== null) { var we = sn(); Pn(de, V, 1, we) } }), Xo(V, 1) } }, Tr = function (V) { if (V.tag === 13) { var J = Fn(V, 134217728); if (J !== null) { var fe = sn(); Pn(J, V, 134217728, fe) } Xo(V, 134217728) } }, $r = function (V) { if (V.tag === 13) { var J = ni(V), fe = Fn(V, J); if (fe !== null) { var de = sn(); Pn(fe, V, J, de) } Xo(V, J) } }, Hr = function () { return dr }, Gr = function (V, J) { var fe = dr; try { return dr = V, J() } finally { dr = fe } }, yt = function (V, J, fe) { switch (J) { case "input": if (Bt(V, fe), J = fe.name, fe.type === "radio" && J != null) { for (fe = V; fe.parentNode;)fe = fe.parentNode; for (fe = fe.querySelectorAll("input[name=" + JSON.stringify("" + J) + '][type="radio"]'), J = 0; J < fe.length; J++) { var de = fe[J]; if (de !== V && de.form === V.form) { var we = Da(de); if (!we) throw Error(u(90)); ke(de), Bt(de, we) } } } break; case "textarea": bt(V, fe); break; case "select": J = fe.value, J != null && pt(V, !!fe.multiple, J, !1) } }, gt = zo, rr = vi; var ih = { usingClientEntryPoint: !1, Events: [aa, Ci, Da, tr, St, zo] }, ba = { findFiberByHostInstance: ui, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, ah = { bundleType: ba.bundleType, version: ba.version, rendererPackageName: ba.rendererPackageName, rendererConfig: ba.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ue.ReactCurrentDispatcher, findHostInstanceByFiber: function (V) { return V = jt(V), V === null ? null : V.stateNode }, findFiberByHostInstance: ba.findFiberByHostInstance || rh, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var xs = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!xs.isDisabled && xs.supportsFiber) try { Nt = xs.inject(ah), Et = xs } catch { } } return reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ih, reactDom_production_min.createPortal = function (V, J) { var fe = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Qo(J)) throw Error(u(200)); return th(V, J, null, fe) }, reactDom_production_min.createRoot = function (V, J) { if (!Qo(V)) throw Error(u(299)); var fe = !1, de = "", we = bf; return J != null && (J.unstable_strictMode === !0 && (fe = !0), J.identifierPrefix !== void 0 && (de = J.identifierPrefix), J.onRecoverableError !== void 0 && (we = J.onRecoverableError)), J = Yo(V, 1, !1, null, null, fe, !1, de, we), V[On] = J.current, ra(V.nodeType === 8 ? V.parentNode : V), new Jo(J) }, reactDom_production_min.findDOMNode = function (V) { if (V == null) return null; if (V.nodeType === 1) return V; var J = V._reactInternals; if (J === void 0) throw typeof V.render == "function" ? Error(u(188)) : (V = Object.keys(V).join(","), Error(u(268, V))); return V = jt(J), V = V === null ? null : V.stateNode, V }, reactDom_production_min.flushSync = function (V) { return vi(V) }, reactDom_production_min.hydrate = function (V, J, fe) { if (!_s(J)) throw Error(u(200)); return ws(null, V, J, !0, fe) }, reactDom_production_min.hydrateRoot = function (V, J, fe) { if (!Qo(V)) throw Error(u(405)); var de = fe != null && fe.hydratedSources || null, we = !1, Te = "", He = bf; if (fe != null && (fe.unstable_strictMode === !0 && (we = !0), fe.identifierPrefix !== void 0 && (Te = fe.identifierPrefix), fe.onRecoverableError !== void 0 && (He = fe.onRecoverableError)), J = vf(J, null, V, 1, fe ?? null, we, !1, Te, He), V[On] = J.current, ra(V), de) for (V = 0; V < de.length; V++)fe = de[V], we = fe._getVersion, we = we(fe._source), J.mutableSourceEagerHydrationData == null ? J.mutableSourceEagerHydrationData = [fe, we] : J.mutableSourceEagerHydrationData.push(fe, we); return new bs(J) }, reactDom_production_min.render = function (V, J, fe) { if (!_s(J)) throw Error(u(200)); return ws(null, V, J, !1, fe) }, reactDom_production_min.unmountComponentAtNode = function (V) { if (!_s(V)) throw Error(u(40)); return V._reactRootContainer ? (vi(function () { ws(null, null, V, !1, function () { V._reactRootContainer = null, V[On] = null }) }), !0) : !1 }, reactDom_production_min.unstable_batchedUpdates = zo, reactDom_production_min.unstable_renderSubtreeIntoContainer = function (V, J, fe, de) { if (!_s(fe)) throw Error(u(200)); if (V == null || V._reactInternals === void 0) throw Error(u(38)); return ws(V, J, fe, !1, de) }, reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426", reactDom_production_min
} var hasRequiredReactDom; function requireReactDom() { if (hasRequiredReactDom) return reactDom.exports; hasRequiredReactDom = 1; function o() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(o) } catch (l) { console.error(l) } } return o(), reactDom.exports = requireReactDom_production_min(), reactDom.exports } var reactDomExports = requireReactDom(); function defaultNoopBatch(o) { o() } function observerBatching(o) { o || (o = defaultNoopBatch), configure({ reactionScheduler: o }) } function printDebugValue(o) { return getDependencyTree(o) } var REGISTRY_FINALIZE_AFTER = 1e4, REGISTRY_SWEEP_INTERVAL = 1e4, TimerBasedFinalizationRegistry = function () { function o(l) { var u = this; Object.defineProperty(this, "finalize", { enumerable: !0, configurable: !0, writable: !0, value: l }), Object.defineProperty(this, "registrations", { enumerable: !0, configurable: !0, writable: !0, value: new Map }), Object.defineProperty(this, "sweepTimeout", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "sweep", { enumerable: !0, configurable: !0, writable: !0, value: function (f) { f === void 0 && (f = REGISTRY_FINALIZE_AFTER), clearTimeout(u.sweepTimeout), u.sweepTimeout = void 0; var p = Date.now(); u.registrations.forEach(function (d, m) { p - d.registeredAt >= f && (u.finalize(d.value), u.registrations.delete(m)) }), u.registrations.size > 0 && u.scheduleSweep() } }), Object.defineProperty(this, "finalizeAllImmediately", { enumerable: !0, configurable: !0, writable: !0, value: function () { u.sweep(0) } }) } return Object.defineProperty(o.prototype, "register", { enumerable: !1, configurable: !0, writable: !0, value: function (l, u, f) { this.registrations.set(f, { value: u, registeredAt: Date.now() }), this.scheduleSweep() } }), Object.defineProperty(o.prototype, "unregister", { enumerable: !1, configurable: !0, writable: !0, value: function (l) { this.registrations.delete(l) } }), Object.defineProperty(o.prototype, "scheduleSweep", { enumerable: !1, configurable: !0, writable: !0, value: function () { this.sweepTimeout === void 0 && (this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL)) } }), o }(), UniversalFinalizationRegistry = typeof FinalizationRegistry < "u" ? FinalizationRegistry : TimerBasedFinalizationRegistry, observerFinalizationRegistry = new UniversalFinalizationRegistry(function (o) { var l; (l = o.reaction) === null || l === void 0 || l.dispose(), o.reaction = null }), shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredUseSyncExternalStoreShim_production_min; function requireUseSyncExternalStoreShim_production_min() { if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min; hasRequiredUseSyncExternalStoreShim_production_min = 1; var o = requireReact(); function l(W, Z) { return W === Z && (W !== 0 || 1 / W === 1 / Z) || W !== W && Z !== Z } var u = typeof Object.is == "function" ? Object.is : l, f = o.useState, p = o.useEffect, d = o.useLayoutEffect, m = o.useDebugValue; function v(W, Z) { var Q = Z(), re = f({ inst: { value: Q, getSnapshot: Z } }), ne = re[0].inst, oe = re[1]; return d(function () { ne.value = Q, ne.getSnapshot = Z, I(ne) && oe({ inst: ne }) }, [W, Q, Z]), p(function () { return I(ne) && oe({ inst: ne }), W(function () { I(ne) && oe({ inst: ne }) }) }, [W]), m(Q), Q } function I(W) { var Z = W.getSnapshot; W = W.value; try { var Q = Z(); return !u(W, Q) } catch { return !0 } } function F(W, Z) { return Z() } var B = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? F : v; return useSyncExternalStoreShim_production_min.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : B, useSyncExternalStoreShim_production_min } var hasRequiredShim; function requireShim() { return hasRequiredShim || (hasRequiredShim = 1, shim.exports = requireUseSyncExternalStoreShim_production_min()), shim.exports } var shimExports = requireShim(); function createReaction(o) { o.reaction = new Reaction("observer".concat(o.name), function () { var l; o.stateVersion = Symbol(), (l = o.onStoreChange) === null || l === void 0 || l.call(o) }) } function useObserver(o, l) { l === void 0 && (l = "observed"); var u = React.useRef(null); if (!u.current) { var f = { reaction: null, onStoreChange: null, stateVersion: Symbol(), name: l, subscribe: function (v) { return observerFinalizationRegistry.unregister(f), f.onStoreChange = v, f.reaction || (createReaction(f), f.stateVersion = Symbol()), function () { var I; f.onStoreChange = null, (I = f.reaction) === null || I === void 0 || I.dispose(), f.reaction = null } }, getSnapshot: function () { return f.stateVersion } }; u.current = f } var p = u.current; p.reaction || (createReaction(p), observerFinalizationRegistry.register(u, p, p)), React.useDebugValue(p.reaction, printDebugValue), shimExports.useSyncExternalStore(p.subscribe, p.getSnapshot, p.getSnapshot); var d, m; if (p.reaction.track(function () { try { d = o() } catch (v) { m = v } }), m) throw m; return d } var _a$1, _b, hasSymbol = typeof Symbol == "function" && Symbol.for, isFunctionNameConfigurable = (_b = (_a$1 = Object.getOwnPropertyDescriptor(function () { }, "name")) === null || _a$1 === void 0 ? void 0 : _a$1.configurable) !== null && _b !== void 0 ? _b : !1, ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof reactExports.forwardRef == "function" && reactExports.forwardRef(function (o) { return null }).$$typeof, ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof reactExports.memo == "function" && reactExports.memo(function (o) { return null }).$$typeof; function observer(o, l) { var u; if (ReactMemoSymbol && o.$$typeof === ReactMemoSymbol) throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you."); var f = (u = void 0) !== null && u !== void 0 ? u : !1, p = o, d = o.displayName || o.name; if (ReactForwardRefSymbol && o.$$typeof === ReactForwardRefSymbol && (f = !0, p = o.render, typeof p != "function")) throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function"); var m = function (v, I) { return useObserver(function () { return p(v, I) }, d) }; return m.displayName = o.displayName, isFunctionNameConfigurable && Object.defineProperty(m, "name", { value: o.name, writable: !0, configurable: !0 }), o.contextTypes && (m.contextTypes = o.contextTypes), f && (m = reactExports.forwardRef(m)), m = reactExports.memo(m), copyStaticProperties(o, m), m } var hoistBlackList = { $$typeof: !0, render: !0, compare: !0, type: !0, displayName: !0 }; function copyStaticProperties(o, l) { Object.keys(o).forEach(function (u) { hoistBlackList[u] || Object.defineProperty(l, u, Object.getOwnPropertyDescriptor(o, u)) }) } var _a; observerBatching(reactDomExports.unstable_batchedUpdates); _a = observerFinalizationRegistry.finalizeAllImmediately; function r(o) { var l, u, f = ""; if (typeof o == "string" || typeof o == "number") f += o; else if (typeof o == "object") if (Array.isArray(o)) { var p = o.length; for (l = 0; l < p; l++)o[l] && (u = r(o[l])) && (f && (f += " "), f += u) } else for (u in o) o[u] && (f && (f += " "), f += u); return f } function clsx() { for (var o, l, u = 0, f = "", p = arguments.length; u < p; u++)(o = arguments[u]) && (l = r(o)) && (f && (f += " "), f += l); return f } var client = {}, hasRequiredClient; function requireClient() { if (hasRequiredClient) return client; hasRequiredClient = 1; var o = requireReactDom(); return client.createRoot = o.createRoot, client.hydrateRoot = o.hydrateRoot, client } var clientExports = requireClient(); const ReactDOM = getDefaultExportFromCjs$1(clientExports);/**
 * @remix-run/router v1.18.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _extends$4() { return _extends$4 = Object.assign ? Object.assign.bind() : function (o) { for (var l = 1; l < arguments.length; l++) { var u = arguments[l]; for (var f in u) Object.prototype.hasOwnProperty.call(u, f) && (o[f] = u[f]) } return o }, _extends$4.apply(this, arguments) } var Action; (function (o) { o.Pop = "POP", o.Push = "PUSH", o.Replace = "REPLACE" })(Action || (Action = {})); const PopStateEventType = "popstate"; function createBrowserHistory(o) { o === void 0 && (o = {}); function l(f, p) { let { pathname: d, search: m, hash: v } = f.location; return createLocation("", { pathname: d, search: m, hash: v }, p.state && p.state.usr || null, p.state && p.state.key || "default") } function u(f, p) { return typeof p == "string" ? p : createPath(p) } return getUrlBasedHistory(l, u, null, o) } function invariant$1(o, l) { if (o === !1 || o === null || typeof o > "u") throw new Error(l) } function warning(o, l) { if (!o) { typeof console < "u" && console.warn(l); try { throw new Error(l) } catch { } } } function createKey() { return Math.random().toString(36).substr(2, 8) } function getHistoryState(o, l) { return { usr: o.state, key: o.key, idx: l } } function createLocation(o, l, u, f) { return u === void 0 && (u = null), _extends$4({ pathname: typeof o == "string" ? o : o.pathname, search: "", hash: "" }, typeof l == "string" ? parsePath(l) : l, { state: u, key: l && l.key || f || createKey() }) } function createPath(o) { let { pathname: l = "/", search: u = "", hash: f = "" } = o; return u && u !== "?" && (l += u.charAt(0) === "?" ? u : "?" + u), f && f !== "#" && (l += f.charAt(0) === "#" ? f : "#" + f), l } function parsePath(o) { let l = {}; if (o) { let u = o.indexOf("#"); u >= 0 && (l.hash = o.substr(u), o = o.substr(0, u)); let f = o.indexOf("?"); f >= 0 && (l.search = o.substr(f), o = o.substr(0, f)), o && (l.pathname = o) } return l } function getUrlBasedHistory(o, l, u, f) { f === void 0 && (f = {}); let { window: p = document.defaultView, v5Compat: d = !1 } = f, m = p.history, v = Action.Pop, I = null, F = B(); F == null && (F = 0, m.replaceState(_extends$4({}, m.state, { idx: F }), "")); function B() { return (m.state || { idx: null }).idx } function W() { v = Action.Pop; let oe = B(), ae = oe == null ? null : oe - F; F = oe, I && I({ action: v, location: ne.location, delta: ae }) } function Z(oe, ae) { v = Action.Push; let se = createLocation(ne.location, oe, ae); F = B() + 1; let le = getHistoryState(se, F), ue = ne.createHref(se); try { m.pushState(le, "", ue) } catch (he) { if (he instanceof DOMException && he.name === "DataCloneError") throw he; p.location.assign(ue) } d && I && I({ action: v, location: ne.location, delta: 1 }) } function Q(oe, ae) { v = Action.Replace; let se = createLocation(ne.location, oe, ae); F = B(); let le = getHistoryState(se, F), ue = ne.createHref(se); m.replaceState(le, "", ue), d && I && I({ action: v, location: ne.location, delta: 0 }) } function re(oe) { let ae = p.location.origin !== "null" ? p.location.origin : p.location.href, se = typeof oe == "string" ? oe : createPath(oe); return se = se.replace(/ $/, "%20"), invariant$1(ae, "No window.location.(origin|href) available to create URL for href: " + se), new URL(se, ae) } let ne = { get action() { return v }, get location() { return o(p, m) }, listen(oe) { if (I) throw new Error("A history only accepts one active listener"); return p.addEventListener(PopStateEventType, W), I = oe, () => { p.removeEventListener(PopStateEventType, W), I = null } }, createHref(oe) { return l(p, oe) }, createURL: re, encodeLocation(oe) { let ae = re(oe); return { pathname: ae.pathname, search: ae.search, hash: ae.hash } }, push: Z, replace: Q, go(oe) { return m.go(oe) } }; return ne } var ResultType; (function (o) { o.data = "data", o.deferred = "deferred", o.redirect = "redirect", o.error = "error" })(ResultType || (ResultType = {})); function matchRoutes(o, l, u) { return u === void 0 && (u = "/"), matchRoutesImpl(o, l, u) } function matchRoutesImpl(o, l, u, f) { let p = typeof l == "string" ? parsePath(l) : l, d = stripBasename(p.pathname || "/", u); if (d == null) return null; let m = flattenRoutes(o); rankRouteBranches(m); let v = null; for (let I = 0; v == null && I < m.length; ++I) { let F = decodePath(d); v = matchRouteBranch(m[I], F) } return v } function flattenRoutes(o, l, u, f) { l === void 0 && (l = []), u === void 0 && (u = []), f === void 0 && (f = ""); let p = (d, m, v) => { let I = { relativePath: v === void 0 ? d.path || "" : v, caseSensitive: d.caseSensitive === !0, childrenIndex: m, route: d }; I.relativePath.startsWith("/") && (invariant$1(I.relativePath.startsWith(f), 'Absolute route path "' + I.relativePath + '" nested under path ' + ('"' + f + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), I.relativePath = I.relativePath.slice(f.length)); let F = joinPaths([f, I.relativePath]), B = u.concat(I); d.children && d.children.length > 0 && (invariant$1(d.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + F + '".')), flattenRoutes(d.children, l, B, F)), !(d.path == null && !d.index) && l.push({ path: F, score: computeScore(F, d.index), routesMeta: B }) }; return o.forEach((d, m) => { var v; if (d.path === "" || !((v = d.path) != null && v.includes("?"))) p(d, m); else for (let I of explodeOptionalSegments(d.path)) p(d, m, I) }), l } function explodeOptionalSegments(o) { let l = o.split("/"); if (l.length === 0) return []; let [u, ...f] = l, p = u.endsWith("?"), d = u.replace(/\?$/, ""); if (f.length === 0) return p ? [d, ""] : [d]; let m = explodeOptionalSegments(f.join("/")), v = []; return v.push(...m.map(I => I === "" ? d : [d, I].join("/"))), p && v.push(...m), v.map(I => o.startsWith("/") && I === "" ? "/" : I) } function rankRouteBranches(o) { o.sort((l, u) => l.score !== u.score ? u.score - l.score : compareIndexes(l.routesMeta.map(f => f.childrenIndex), u.routesMeta.map(f => f.childrenIndex))) } const paramRe = /^:[\w-]+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = o => o === "*"; function computeScore(o, l) { let u = o.split("/"), f = u.length; return u.some(isSplat) && (f += splatPenalty), l && (f += indexRouteValue), u.filter(p => !isSplat(p)).reduce((p, d) => p + (paramRe.test(d) ? dynamicSegmentValue : d === "" ? emptySegmentValue : staticSegmentValue), f) } function compareIndexes(o, l) { return o.length === l.length && o.slice(0, -1).every((f, p) => f === l[p]) ? o[o.length - 1] - l[l.length - 1] : 0 } function matchRouteBranch(o, l, u) { let { routesMeta: f } = o, p = {}, d = "/", m = []; for (let v = 0; v < f.length; ++v) { let I = f[v], F = v === f.length - 1, B = d === "/" ? l : l.slice(d.length) || "/", W = matchPath({ path: I.relativePath, caseSensitive: I.caseSensitive, end: F }, B), Z = I.route; if (!W) return null; Object.assign(p, W.params), m.push({ params: p, pathname: joinPaths([d, W.pathname]), pathnameBase: normalizePathname(joinPaths([d, W.pathnameBase])), route: Z }), W.pathnameBase !== "/" && (d = joinPaths([d, W.pathnameBase])) } return m } function matchPath(o, l) { typeof o == "string" && (o = { path: o, caseSensitive: !1, end: !0 }); let [u, f] = compilePath(o.path, o.caseSensitive, o.end), p = l.match(u); if (!p) return null; let d = p[0], m = d.replace(/(.)\/+$/, "$1"), v = p.slice(1); return { params: f.reduce((F, B, W) => { let { paramName: Z, isOptional: Q } = B; if (Z === "*") { let ne = v[W] || ""; m = d.slice(0, d.length - ne.length).replace(/(.)\/+$/, "$1") } const re = v[W]; return Q && !re ? F[Z] = void 0 : F[Z] = (re || "").replace(/%2F/g, "/"), F }, {}), pathname: d, pathnameBase: m, pattern: o } } function compilePath(o, l, u) { l === void 0 && (l = !1), u === void 0 && (u = !0), warning(o === "*" || !o.endsWith("*") || o.endsWith("/*"), 'Route path "' + o + '" will be treated as if it were ' + ('"' + o.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + o.replace(/\*$/, "/*") + '".')); let f = [], p = "^" + o.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (m, v, I) => (f.push({ paramName: v, isOptional: I != null }), I ? "/?([^\\/]+)?" : "/([^\\/]+)")); return o.endsWith("*") ? (f.push({ paramName: "*" }), p += o === "*" || o === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : u ? p += "\\/*$" : o !== "" && o !== "/" && (p += "(?:(?=\\/|$))"), [new RegExp(p, l ? void 0 : "i"), f] } function decodePath(o) { try { return o.split("/").map(l => decodeURIComponent(l).replace(/\//g, "%2F")).join("/") } catch (l) { return warning(!1, 'The URL path "' + o + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + l + ").")), o } } function stripBasename(o, l) { if (l === "/") return o; if (!o.toLowerCase().startsWith(l.toLowerCase())) return null; let u = l.endsWith("/") ? l.length - 1 : l.length, f = o.charAt(u); return f && f !== "/" ? null : o.slice(u) || "/" } function resolvePath(o, l) { l === void 0 && (l = "/"); let { pathname: u, search: f = "", hash: p = "" } = typeof o == "string" ? parsePath(o) : o; return { pathname: u ? u.startsWith("/") ? u : resolvePathname(u, l) : l, search: normalizeSearch(f), hash: normalizeHash(p) } } function resolvePathname(o, l) { let u = l.replace(/\/+$/, "").split("/"); return o.split("/").forEach(p => { p === ".." ? u.length > 1 && u.pop() : p !== "." && u.push(p) }), u.length > 1 ? u.join("/") : "/" } function getInvalidPathError(o, l, u, f) { return "Cannot include a '" + o + "' character in a manually specified " + ("`to." + l + "` field [" + JSON.stringify(f) + "].  Please separate it out to the ") + ("`to." + u + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function getPathContributingMatches(o) { return o.filter((l, u) => u === 0 || l.route.path && l.route.path.length > 0) } function getResolveToMatches(o, l) { let u = getPathContributingMatches(o); return l ? u.map((f, p) => p === u.length - 1 ? f.pathname : f.pathnameBase) : u.map(f => f.pathnameBase) } function resolveTo(o, l, u, f) { f === void 0 && (f = !1); let p; typeof o == "string" ? p = parsePath(o) : (p = _extends$4({}, o), invariant$1(!p.pathname || !p.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", p)), invariant$1(!p.pathname || !p.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", p)), invariant$1(!p.search || !p.search.includes("#"), getInvalidPathError("#", "search", "hash", p))); let d = o === "" || p.pathname === "", m = d ? "/" : p.pathname, v; if (m == null) v = u; else { let W = l.length - 1; if (!f && m.startsWith("..")) { let Z = m.split("/"); for (; Z[0] === "..";)Z.shift(), W -= 1; p.pathname = Z.join("/") } v = W >= 0 ? l[W] : "/" } let I = resolvePath(p, v), F = m && m !== "/" && m.endsWith("/"), B = (d || m === ".") && u.endsWith("/"); return !I.pathname.endsWith("/") && (F || B) && (I.pathname += "/"), I } const joinPaths = o => o.join("/").replace(/\/\/+/g, "/"), normalizePathname = o => o.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = o => !o || o === "?" ? "" : o.startsWith("?") ? o : "?" + o, normalizeHash = o => !o || o === "#" ? "" : o.startsWith("#") ? o : "#" + o; function isRouteErrorResponse(o) { return o != null && typeof o.status == "number" && typeof o.statusText == "string" && typeof o.internal == "boolean" && "data" in o } const validMutationMethodsArr = ["post", "put", "patch", "delete"]; new Set(validMutationMethodsArr); const validRequestMethodsArr = ["get", ...validMutationMethodsArr]; new Set(validRequestMethodsArr);/**
 * React Router v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _extends$3() { return _extends$3 = Object.assign ? Object.assign.bind() : function (o) { for (var l = 1; l < arguments.length; l++) { var u = arguments[l]; for (var f in u) Object.prototype.hasOwnProperty.call(u, f) && (o[f] = u[f]) } return o }, _extends$3.apply(this, arguments) } const DataRouterContext = reactExports.createContext(null), DataRouterStateContext = reactExports.createContext(null), NavigationContext = reactExports.createContext(null), LocationContext = reactExports.createContext(null), RouteContext = reactExports.createContext({ outlet: null, matches: [], isDataRoute: !1 }), RouteErrorContext = reactExports.createContext(null); function useHref(o, l) { let { relative: u } = l === void 0 ? {} : l; useInRouterContext() || invariant$1(!1); let { basename: f, navigator: p } = reactExports.useContext(NavigationContext), { hash: d, pathname: m, search: v } = useResolvedPath(o, { relative: u }), I = m; return f !== "/" && (I = m === "/" ? f : joinPaths([f, m])), p.createHref({ pathname: I, search: v, hash: d }) } function useInRouterContext() { return reactExports.useContext(LocationContext) != null } function useLocation() { return useInRouterContext() || invariant$1(!1), reactExports.useContext(LocationContext).location } function useIsomorphicLayoutEffect$1(o) { reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(o) } function useNavigate() { let { isDataRoute: o } = reactExports.useContext(RouteContext); return o ? useNavigateStable() : useNavigateUnstable() } function useNavigateUnstable() { useInRouterContext() || invariant$1(!1); let o = reactExports.useContext(DataRouterContext), { basename: l, future: u, navigator: f } = reactExports.useContext(NavigationContext), { matches: p } = reactExports.useContext(RouteContext), { pathname: d } = useLocation(), m = JSON.stringify(getResolveToMatches(p, u.v7_relativeSplatPath)), v = reactExports.useRef(!1); return useIsomorphicLayoutEffect$1(() => { v.current = !0 }), reactExports.useCallback(function (F, B) { if (B === void 0 && (B = {}), !v.current) return; if (typeof F == "number") { f.go(F); return } let W = resolveTo(F, JSON.parse(m), d, B.relative === "path"); o == null && l !== "/" && (W.pathname = W.pathname === "/" ? l : joinPaths([l, W.pathname])), (B.replace ? f.replace : f.push)(W, B.state, B) }, [l, f, m, d, o]) } const OutletContext = reactExports.createContext(null); function useOutlet(o) { let l = reactExports.useContext(RouteContext).outlet; return l && reactExports.createElement(OutletContext.Provider, { value: o }, l) } function useParams() { let { matches: o } = reactExports.useContext(RouteContext), l = o[o.length - 1]; return l ? l.params : {} } function useResolvedPath(o, l) { let { relative: u } = l === void 0 ? {} : l, { future: f } = reactExports.useContext(NavigationContext), { matches: p } = reactExports.useContext(RouteContext), { pathname: d } = useLocation(), m = JSON.stringify(getResolveToMatches(p, f.v7_relativeSplatPath)); return reactExports.useMemo(() => resolveTo(o, JSON.parse(m), d, u === "path"), [o, m, d, u]) } function useRoutes(o, l) { return useRoutesImpl(o, l) } function useRoutesImpl(o, l, u, f) { useInRouterContext() || invariant$1(!1); let { navigator: p } = reactExports.useContext(NavigationContext), { matches: d } = reactExports.useContext(RouteContext), m = d[d.length - 1], v = m ? m.params : {}; m && m.pathname; let I = m ? m.pathnameBase : "/"; m && m.route; let F = useLocation(), B; if (l) { var W; let oe = typeof l == "string" ? parsePath(l) : l; I === "/" || (W = oe.pathname) != null && W.startsWith(I) || invariant$1(!1), B = oe } else B = F; let Z = B.pathname || "/", Q = Z; if (I !== "/") { let oe = I.replace(/^\//, "").split("/"); Q = "/" + Z.replace(/^\//, "").split("/").slice(oe.length).join("/") } let re = matchRoutes(o, { pathname: Q }), ne = _renderMatches(re && re.map(oe => Object.assign({}, oe, { params: Object.assign({}, v, oe.params), pathname: joinPaths([I, p.encodeLocation ? p.encodeLocation(oe.pathname).pathname : oe.pathname]), pathnameBase: oe.pathnameBase === "/" ? I : joinPaths([I, p.encodeLocation ? p.encodeLocation(oe.pathnameBase).pathname : oe.pathnameBase]) })), d, u, f); return l && ne ? reactExports.createElement(LocationContext.Provider, { value: { location: _extends$3({ pathname: "/", search: "", hash: "", state: null, key: "default" }, B), navigationType: Action.Pop } }, ne) : ne } function DefaultErrorComponent() { let o = useRouteError(), l = isRouteErrorResponse(o) ? o.status + " " + o.statusText : o instanceof Error ? o.message : JSON.stringify(o), u = o instanceof Error ? o.stack : null, p = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", { style: { fontStyle: "italic" } }, l), u ? reactExports.createElement("pre", { style: p }, u) : null, null) } const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null); class RenderErrorBoundary extends reactExports.Component { constructor(l) { super(l), this.state = { location: l.location, revalidation: l.revalidation, error: l.error } } static getDerivedStateFromError(l) { return { error: l } } static getDerivedStateFromProps(l, u) { return u.location !== l.location || u.revalidation !== "idle" && l.revalidation === "idle" ? { error: l.error, location: l.location, revalidation: l.revalidation } : { error: l.error !== void 0 ? l.error : u.error, location: u.location, revalidation: l.revalidation || u.revalidation } } componentDidCatch(l, u) { console.error("React Router caught the following error during render", l, u) } render() { return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, reactExports.createElement(RouteErrorContext.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function RenderedRoute(o) { let { routeContext: l, match: u, children: f } = o, p = reactExports.useContext(DataRouterContext); return p && p.static && p.staticContext && (u.route.errorElement || u.route.ErrorBoundary) && (p.staticContext._deepestRenderedBoundaryId = u.route.id), reactExports.createElement(RouteContext.Provider, { value: l }, f) } function _renderMatches(o, l, u, f) { var p; if (l === void 0 && (l = []), u === void 0 && (u = null), f === void 0 && (f = null), o == null) { var d; if ((d = u) != null && d.errors) o = u.matches; else return null } let m = o, v = (p = u) == null ? void 0 : p.errors; if (v != null) { let B = m.findIndex(W => W.route.id && (v == null ? void 0 : v[W.route.id]) !== void 0); B >= 0 || invariant$1(!1), m = m.slice(0, Math.min(m.length, B + 1)) } let I = !1, F = -1; if (u && f && f.v7_partialHydration) for (let B = 0; B < m.length; B++) { let W = m[B]; if ((W.route.HydrateFallback || W.route.hydrateFallbackElement) && (F = B), W.route.id) { let { loaderData: Z, errors: Q } = u, re = W.route.loader && Z[W.route.id] === void 0 && (!Q || Q[W.route.id] === void 0); if (W.route.lazy || re) { I = !0, F >= 0 ? m = m.slice(0, F + 1) : m = [m[0]]; break } } } return m.reduceRight((B, W, Z) => { let Q, re = !1, ne = null, oe = null; u && (Q = v && W.route.id ? v[W.route.id] : void 0, ne = W.route.errorElement || defaultErrorElement, I && (F < 0 && Z === 0 ? (warningOnce("route-fallback"), re = !0, oe = null) : F === Z && (re = !0, oe = W.route.hydrateFallbackElement || null))); let ae = l.concat(m.slice(0, Z + 1)), se = () => { let le; return Q ? le = ne : re ? le = oe : W.route.Component ? le = reactExports.createElement(W.route.Component, null) : W.route.element ? le = W.route.element : le = B, reactExports.createElement(RenderedRoute, { match: W, routeContext: { outlet: B, matches: ae, isDataRoute: u != null }, children: le }) }; return u && (W.route.ErrorBoundary || W.route.errorElement || Z === 0) ? reactExports.createElement(RenderErrorBoundary, { location: u.location, revalidation: u.revalidation, component: ne, error: Q, children: se(), routeContext: { outlet: null, matches: ae, isDataRoute: !0 } }) : se() }, null) } var DataRouterHook$1 = function (o) { return o.UseBlocker = "useBlocker", o.UseRevalidator = "useRevalidator", o.UseNavigateStable = "useNavigate", o }(DataRouterHook$1 || {}), DataRouterStateHook$1 = function (o) { return o.UseBlocker = "useBlocker", o.UseLoaderData = "useLoaderData", o.UseActionData = "useActionData", o.UseRouteError = "useRouteError", o.UseNavigation = "useNavigation", o.UseRouteLoaderData = "useRouteLoaderData", o.UseMatches = "useMatches", o.UseRevalidator = "useRevalidator", o.UseNavigateStable = "useNavigate", o.UseRouteId = "useRouteId", o }(DataRouterStateHook$1 || {}); function useDataRouterContext$1(o) { let l = reactExports.useContext(DataRouterContext); return l || invariant$1(!1), l } function useDataRouterState(o) { let l = reactExports.useContext(DataRouterStateContext); return l || invariant$1(!1), l } function useRouteContext(o) { let l = reactExports.useContext(RouteContext); return l || invariant$1(!1), l } function useCurrentRouteId(o) { let l = useRouteContext(), u = l.matches[l.matches.length - 1]; return u.route.id || invariant$1(!1), u.route.id } function useRouteError() { var o; let l = reactExports.useContext(RouteErrorContext), u = useDataRouterState(), f = useCurrentRouteId(); return l !== void 0 ? l : (o = u.errors) == null ? void 0 : o[f] } function useNavigateStable() { let { router: o } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable), l = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable), u = reactExports.useRef(!1); return useIsomorphicLayoutEffect$1(() => { u.current = !0 }), reactExports.useCallback(function (p, d) { d === void 0 && (d = {}), u.current && (typeof p == "number" ? o.navigate(p) : o.navigate(p, _extends$3({ fromRouteId: l }, d))) }, [o, l]) } const alreadyWarned = {}; function warningOnce(o, l, u) { alreadyWarned[o] || (alreadyWarned[o] = !0) } function Navigate(o) { let { to: l, replace: u, state: f, relative: p } = o; useInRouterContext() || invariant$1(!1); let { future: d, static: m } = reactExports.useContext(NavigationContext), { matches: v } = reactExports.useContext(RouteContext), { pathname: I } = useLocation(), F = useNavigate(), B = resolveTo(l, getResolveToMatches(v, d.v7_relativeSplatPath), I, p === "path"), W = JSON.stringify(B); return reactExports.useEffect(() => F(JSON.parse(W), { replace: u, state: f, relative: p }), [F, W, p, u, f]), null } function Outlet(o) { return useOutlet(o.context) } function Route(o) { invariant$1(!1) } function Router(o) { let { basename: l = "/", children: u = null, location: f, navigationType: p = Action.Pop, navigator: d, static: m = !1, future: v } = o; useInRouterContext() && invariant$1(!1); let I = l.replace(/^\/*/, "/"), F = reactExports.useMemo(() => ({ basename: I, navigator: d, static: m, future: _extends$3({ v7_relativeSplatPath: !1 }, v) }), [I, v, d, m]); typeof f == "string" && (f = parsePath(f)); let { pathname: B = "/", search: W = "", hash: Z = "", state: Q = null, key: re = "default" } = f, ne = reactExports.useMemo(() => { let oe = stripBasename(B, I); return oe == null ? null : { location: { pathname: oe, search: W, hash: Z, state: Q, key: re }, navigationType: p } }, [I, B, W, Z, Q, re, p]); return ne == null ? null : reactExports.createElement(NavigationContext.Provider, { value: F }, reactExports.createElement(LocationContext.Provider, { children: u, value: ne })) } function Routes(o) { let { children: l, location: u } = o; return useRoutes(createRoutesFromChildren(l), u) } new Promise(() => { }); function createRoutesFromChildren(o, l) { l === void 0 && (l = []); let u = []; return reactExports.Children.forEach(o, (f, p) => { if (!reactExports.isValidElement(f)) return; let d = [...l, p]; if (f.type === reactExports.Fragment) { u.push.apply(u, createRoutesFromChildren(f.props.children, d)); return } f.type !== Route && invariant$1(!1), !f.props.index || !f.props.children || invariant$1(!1); let m = { id: f.props.id || d.join("-"), caseSensitive: f.props.caseSensitive, element: f.props.element, Component: f.props.Component, index: f.props.index, path: f.props.path, loader: f.props.loader, action: f.props.action, errorElement: f.props.errorElement, ErrorBoundary: f.props.ErrorBoundary, hasErrorBoundary: f.props.ErrorBoundary != null || f.props.errorElement != null, shouldRevalidate: f.props.shouldRevalidate, handle: f.props.handle, lazy: f.props.lazy }; f.props.children && (m.children = createRoutesFromChildren(f.props.children, d)), u.push(m) }), u }/**
 * React Router DOM v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _extends$2() { return _extends$2 = Object.assign ? Object.assign.bind() : function (o) { for (var l = 1; l < arguments.length; l++) { var u = arguments[l]; for (var f in u) Object.prototype.hasOwnProperty.call(u, f) && (o[f] = u[f]) } return o }, _extends$2.apply(this, arguments) } function _objectWithoutPropertiesLoose$1(o, l) { if (o == null) return {}; var u = {}, f = Object.keys(o), p, d; for (d = 0; d < f.length; d++)p = f[d], !(l.indexOf(p) >= 0) && (u[p] = o[p]); return u } function isModifiedEvent(o) { return !!(o.metaKey || o.altKey || o.ctrlKey || o.shiftKey) } function shouldProcessLinkClick(o, l) { return o.button === 0 && (!l || l === "_self") && !isModifiedEvent(o) } function createSearchParams(o) { return o === void 0 && (o = ""), new URLSearchParams(typeof o == "string" || Array.isArray(o) || o instanceof URLSearchParams ? o : Object.keys(o).reduce((l, u) => { let f = o[u]; return l.concat(Array.isArray(f) ? f.map(p => [u, p]) : [[u, f]]) }, [])) } function getSearchParamsForLocation(o, l) { let u = createSearchParams(o); return l && l.forEach((f, p) => { u.has(p) || l.getAll(p).forEach(d => { u.append(p, d) }) }), u } const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"], REACT_ROUTER_VERSION = "6"; try { window.__reactRouterVersion = REACT_ROUTER_VERSION } catch (o) { } const ViewTransitionContext = reactExports.createContext({ isTransitioning: !1 }), START_TRANSITION = "startTransition", startTransitionImpl = React$1[START_TRANSITION]; function BrowserRouter(o) { let { basename: l, children: u, future: f, window: p } = o, d = reactExports.useRef(); d.current == null && (d.current = createBrowserHistory({ window: p, v5Compat: !0 })); let m = d.current, [v, I] = reactExports.useState({ action: m.action, location: m.location }), { v7_startTransition: F } = f || {}, B = reactExports.useCallback(W => { F && startTransitionImpl ? startTransitionImpl(() => I(W)) : I(W) }, [I, F]); return reactExports.useLayoutEffect(() => m.listen(B), [m, B]), reactExports.createElement(Router, { basename: l, children: u, location: v.location, navigationType: v.action, navigator: m, future: f }) } const isBrowser$2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Link = reactExports.forwardRef(function o(l, u) { let { onClick: f, relative: p, reloadDocument: d, replace: m, state: v, target: I, to: F, preventScrollReset: B, unstable_viewTransition: W } = l, Z = _objectWithoutPropertiesLoose$1(l, _excluded), { basename: Q } = reactExports.useContext(NavigationContext), re, ne = !1; if (typeof F == "string" && ABSOLUTE_URL_REGEX.test(F) && (re = F, isBrowser$2)) try { let le = new URL(window.location.href), ue = F.startsWith("//") ? new URL(le.protocol + F) : new URL(F), he = stripBasename(ue.pathname, Q); ue.origin === le.origin && he != null ? F = he + ue.search + ue.hash : ne = !0 } catch { } let oe = useHref(F, { relative: p }), ae = useLinkClickHandler(F, { replace: m, state: v, target: I, preventScrollReset: B, relative: p, unstable_viewTransition: W }); function se(le) { f && f(le), le.defaultPrevented || ae(le) } return reactExports.createElement("a", _extends$2({}, Z, { href: re || oe, onClick: ne || d ? f : se, ref: u, target: I })) }), NavLink = reactExports.forwardRef(function o(l, u) { let { "aria-current": f = "page", caseSensitive: p = !1, className: d = "", end: m = !1, style: v, to: I, unstable_viewTransition: F, children: B } = l, W = _objectWithoutPropertiesLoose$1(l, _excluded2), Z = useResolvedPath(I, { relative: W.relative }), Q = useLocation(), re = reactExports.useContext(DataRouterStateContext), { navigator: ne, basename: oe } = reactExports.useContext(NavigationContext), ae = re != null && useViewTransitionState(Z) && F === !0, se = ne.encodeLocation ? ne.encodeLocation(Z).pathname : Z.pathname, le = Q.pathname, ue = re && re.navigation && re.navigation.location ? re.navigation.location.pathname : null; p || (le = le.toLowerCase(), ue = ue ? ue.toLowerCase() : null, se = se.toLowerCase()), ue && oe && (ue = stripBasename(ue, oe) || ue); const he = se !== "/" && se.endsWith("/") ? se.length - 1 : se.length; let pe = le === se || !m && le.startsWith(se) && le.charAt(he) === "/", ve = ue != null && (ue === se || !m && ue.startsWith(se) && ue.charAt(se.length) === "/"), _e = { isActive: pe, isPending: ve, isTransitioning: ae }, Se = pe ? f : void 0, $e; typeof d == "function" ? $e = d(_e) : $e = [d, pe ? "active" : null, ve ? "pending" : null, ae ? "transitioning" : null].filter(Boolean).join(" "); let ie = typeof v == "function" ? v(_e) : v; return reactExports.createElement(Link, _extends$2({}, W, { "aria-current": Se, className: $e, ref: u, style: ie, to: I, unstable_viewTransition: F }), typeof B == "function" ? B(_e) : B) }); var DataRouterHook; (function (o) { o.UseScrollRestoration = "useScrollRestoration", o.UseSubmit = "useSubmit", o.UseSubmitFetcher = "useSubmitFetcher", o.UseFetcher = "useFetcher", o.useViewTransitionState = "useViewTransitionState" })(DataRouterHook || (DataRouterHook = {})); var DataRouterStateHook; (function (o) { o.UseFetcher = "useFetcher", o.UseFetchers = "useFetchers", o.UseScrollRestoration = "useScrollRestoration" })(DataRouterStateHook || (DataRouterStateHook = {})); function useDataRouterContext(o) { let l = reactExports.useContext(DataRouterContext); return l || invariant$1(!1), l } function useLinkClickHandler(o, l) { let { target: u, replace: f, state: p, preventScrollReset: d, relative: m, unstable_viewTransition: v } = l === void 0 ? {} : l, I = useNavigate(), F = useLocation(), B = useResolvedPath(o, { relative: m }); return reactExports.useCallback(W => { if (shouldProcessLinkClick(W, u)) { W.preventDefault(); let Z = f !== void 0 ? f : createPath(F) === createPath(B); I(o, { replace: Z, state: p, preventScrollReset: d, relative: m, unstable_viewTransition: v }) } }, [F, I, B, f, p, u, o, d, m, v]) } function useSearchParams(o) { let l = reactExports.useRef(createSearchParams(o)), u = reactExports.useRef(!1), f = useLocation(), p = reactExports.useMemo(() => getSearchParamsForLocation(f.search, u.current ? null : l.current), [f.search]), d = useNavigate(), m = reactExports.useCallback((v, I) => { const F = createSearchParams(typeof v == "function" ? v(p) : v); u.current = !0, d("?" + F, I) }, [d, p]); return [p, m] } function useViewTransitionState(o, l) { l === void 0 && (l = {}); let u = reactExports.useContext(ViewTransitionContext); u == null && invariant$1(!1); let { basename: f } = useDataRouterContext(DataRouterHook.useViewTransitionState), p = useResolvedPath(o, { relative: l.relative }); if (!u.isTransitioning) return !1; let d = stripBasename(u.currentLocation.pathname, f) || u.currentLocation.pathname, m = stripBasename(u.nextLocation.pathname, f) || u.nextLocation.pathname; return matchPath(p.pathname, m) != null || matchPath(p.pathname, d) != null } const min = Math.min, max = Math.max, round$1 = Math.round, floor = Math.floor, createCoords = o => ({ x: o, y: o }), oppositeSideMap = { left: "right", right: "left", bottom: "top", top: "bottom" }, oppositeAlignmentMap = { start: "end", end: "start" }; function clamp$1(o, l, u) { return max(o, min(l, u)) } function evaluate(o, l) { return typeof o == "function" ? o(l) : o } function getSide(o) { return o.split("-")[0] } function getAlignment(o) { return o.split("-")[1] } function getOppositeAxis(o) { return o === "x" ? "y" : "x" } function getAxisLength(o) { return o === "y" ? "height" : "width" } function getSideAxis(o) { return ["top", "bottom"].includes(getSide(o)) ? "y" : "x" } function getAlignmentAxis(o) { return getOppositeAxis(getSideAxis(o)) } function getAlignmentSides(o, l, u) { u === void 0 && (u = !1); const f = getAlignment(o), p = getAlignmentAxis(o), d = getAxisLength(p); let m = p === "x" ? f === (u ? "end" : "start") ? "right" : "left" : f === "start" ? "bottom" : "top"; return l.reference[d] > l.floating[d] && (m = getOppositePlacement(m)), [m, getOppositePlacement(m)] } function getExpandedPlacements(o) { const l = getOppositePlacement(o); return [getOppositeAlignmentPlacement(o), l, getOppositeAlignmentPlacement(l)] } function getOppositeAlignmentPlacement(o) { return o.replace(/start|end/g, l => oppositeAlignmentMap[l]) } function getSideList(o, l, u) { const f = ["left", "right"], p = ["right", "left"], d = ["top", "bottom"], m = ["bottom", "top"]; switch (o) { case "top": case "bottom": return u ? l ? p : f : l ? f : p; case "left": case "right": return l ? d : m; default: return [] } } function getOppositeAxisPlacements(o, l, u, f) { const p = getAlignment(o); let d = getSideList(getSide(o), u === "start", f); return p && (d = d.map(m => m + "-" + p), l && (d = d.concat(d.map(getOppositeAlignmentPlacement)))), d } function getOppositePlacement(o) { return o.replace(/left|right|bottom|top/g, l => oppositeSideMap[l]) } function expandPaddingObject(o) { return { top: 0, right: 0, bottom: 0, left: 0, ...o } } function getPaddingObject(o) { return typeof o != "number" ? expandPaddingObject(o) : { top: o, right: o, bottom: o, left: o } } function rectToClientRect(o) { const { x: l, y: u, width: f, height: p } = o; return { width: f, height: p, top: u, left: l, right: l + f, bottom: u + p, x: l, y: u } } function computeCoordsFromPlacement(o, l, u) { let { reference: f, floating: p } = o; const d = getSideAxis(l), m = getAlignmentAxis(l), v = getAxisLength(m), I = getSide(l), F = d === "y", B = f.x + f.width / 2 - p.width / 2, W = f.y + f.height / 2 - p.height / 2, Z = f[v] / 2 - p[v] / 2; let Q; switch (I) { case "top": Q = { x: B, y: f.y - p.height }; break; case "bottom": Q = { x: B, y: f.y + f.height }; break; case "right": Q = { x: f.x + f.width, y: W }; break; case "left": Q = { x: f.x - p.width, y: W }; break; default: Q = { x: f.x, y: f.y } }switch (getAlignment(l)) { case "start": Q[m] -= Z * (u && F ? -1 : 1); break; case "end": Q[m] += Z * (u && F ? -1 : 1); break }return Q } const computePosition$1 = async (o, l, u) => { const { placement: f = "bottom", strategy: p = "absolute", middleware: d = [], platform: m } = u, v = d.filter(Boolean), I = await (m.isRTL == null ? void 0 : m.isRTL(l)); let F = await m.getElementRects({ reference: o, floating: l, strategy: p }), { x: B, y: W } = computeCoordsFromPlacement(F, f, I), Z = f, Q = {}, re = 0; for (let ne = 0; ne < v.length; ne++) { const { name: oe, fn: ae } = v[ne], { x: se, y: le, data: ue, reset: he } = await ae({ x: B, y: W, initialPlacement: f, placement: Z, strategy: p, middlewareData: Q, rects: F, platform: m, elements: { reference: o, floating: l } }); B = se ?? B, W = le ?? W, Q = { ...Q, [oe]: { ...Q[oe], ...ue } }, he && re <= 50 && (re++, typeof he == "object" && (he.placement && (Z = he.placement), he.rects && (F = he.rects === !0 ? await m.getElementRects({ reference: o, floating: l, strategy: p }) : he.rects), { x: B, y: W } = computeCoordsFromPlacement(F, Z, I)), ne = -1) } return { x: B, y: W, placement: Z, strategy: p, middlewareData: Q } }; async function detectOverflow(o, l) { var u; l === void 0 && (l = {}); const { x: f, y: p, platform: d, rects: m, elements: v, strategy: I } = o, { boundary: F = "clippingAncestors", rootBoundary: B = "viewport", elementContext: W = "floating", altBoundary: Z = !1, padding: Q = 0 } = evaluate(l, o), re = getPaddingObject(Q), oe = v[Z ? W === "floating" ? "reference" : "floating" : W], ae = rectToClientRect(await d.getClippingRect({ element: (u = await (d.isElement == null ? void 0 : d.isElement(oe))) == null || u ? oe : oe.contextElement || await (d.getDocumentElement == null ? void 0 : d.getDocumentElement(v.floating)), boundary: F, rootBoundary: B, strategy: I })), se = W === "floating" ? { x: f, y: p, width: m.floating.width, height: m.floating.height } : m.reference, le = await (d.getOffsetParent == null ? void 0 : d.getOffsetParent(v.floating)), ue = await (d.isElement == null ? void 0 : d.isElement(le)) ? await (d.getScale == null ? void 0 : d.getScale(le)) || { x: 1, y: 1 } : { x: 1, y: 1 }, he = rectToClientRect(d.convertOffsetParentRelativeRectToViewportRelativeRect ? await d.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: v, rect: se, offsetParent: le, strategy: I }) : se); return { top: (ae.top - he.top + re.top) / ue.y, bottom: (he.bottom - ae.bottom + re.bottom) / ue.y, left: (ae.left - he.left + re.left) / ue.x, right: (he.right - ae.right + re.right) / ue.x } } const arrow$1 = o => ({ name: "arrow", options: o, async fn(l) { const { x: u, y: f, placement: p, rects: d, platform: m, elements: v, middlewareData: I } = l, { element: F, padding: B = 0 } = evaluate(o, l) || {}; if (F == null) return {}; const W = getPaddingObject(B), Z = { x: u, y: f }, Q = getAlignmentAxis(p), re = getAxisLength(Q), ne = await m.getDimensions(F), oe = Q === "y", ae = oe ? "top" : "left", se = oe ? "bottom" : "right", le = oe ? "clientHeight" : "clientWidth", ue = d.reference[re] + d.reference[Q] - Z[Q] - d.floating[re], he = Z[Q] - d.reference[Q], pe = await (m.getOffsetParent == null ? void 0 : m.getOffsetParent(F)); let ve = pe ? pe[le] : 0; (!ve || !await (m.isElement == null ? void 0 : m.isElement(pe))) && (ve = v.floating[le] || d.floating[re]); const _e = ue / 2 - he / 2, Se = ve / 2 - ne[re] / 2 - 1, $e = min(W[ae], Se), ie = min(W[se], Se), g = $e, P = ve - ne[re] - ie, U = ve / 2 - ne[re] / 2 + _e, K = clamp$1(g, U, P), Y = !I.arrow && getAlignment(p) != null && U !== K && d.reference[re] / 2 - (U < g ? $e : ie) - ne[re] / 2 < 0, te = Y ? U < g ? U - g : U - P : 0; return { [Q]: Z[Q] + te, data: { [Q]: K, centerOffset: U - K - te, ...Y && { alignmentOffset: te } }, reset: Y } } }), flip$1 = function (o) { return o === void 0 && (o = {}), { name: "flip", options: o, async fn(l) { var u, f; const { placement: p, middlewareData: d, rects: m, initialPlacement: v, platform: I, elements: F } = l, { mainAxis: B = !0, crossAxis: W = !0, fallbackPlacements: Z, fallbackStrategy: Q = "bestFit", fallbackAxisSideDirection: re = "none", flipAlignment: ne = !0, ...oe } = evaluate(o, l); if ((u = d.arrow) != null && u.alignmentOffset) return {}; const ae = getSide(p), se = getSideAxis(v), le = getSide(v) === v, ue = await (I.isRTL == null ? void 0 : I.isRTL(F.floating)), he = Z || (le || !ne ? [getOppositePlacement(v)] : getExpandedPlacements(v)), pe = re !== "none"; !Z && pe && he.push(...getOppositeAxisPlacements(v, ne, re, ue)); const ve = [v, ...he], _e = await detectOverflow(l, oe), Se = []; let $e = ((f = d.flip) == null ? void 0 : f.overflows) || []; if (B && Se.push(_e[ae]), W) { const U = getAlignmentSides(p, m, ue); Se.push(_e[U[0]], _e[U[1]]) } if ($e = [...$e, { placement: p, overflows: Se }], !Se.every(U => U <= 0)) { var ie, g; const U = (((ie = d.flip) == null ? void 0 : ie.index) || 0) + 1, K = ve[U]; if (K) return { data: { index: U, overflows: $e }, reset: { placement: K } }; let Y = (g = $e.filter(te => te.overflows[0] <= 0).sort((te, ee) => te.overflows[1] - ee.overflows[1])[0]) == null ? void 0 : g.placement; if (!Y) switch (Q) { case "bestFit": { var P; const te = (P = $e.filter(ee => { if (pe) { const G = getSideAxis(ee.placement); return G === se || G === "y" } return !0 }).map(ee => [ee.placement, ee.overflows.filter(G => G > 0).reduce((G, y) => G + y, 0)]).sort((ee, G) => ee[1] - G[1])[0]) == null ? void 0 : P[0]; te && (Y = te); break } case "initialPlacement": Y = v; break }if (p !== Y) return { reset: { placement: Y } } } return {} } } }; async function convertValueToCoords(o, l) { const { placement: u, platform: f, elements: p } = o, d = await (f.isRTL == null ? void 0 : f.isRTL(p.floating)), m = getSide(u), v = getAlignment(u), I = getSideAxis(u) === "y", F = ["left", "top"].includes(m) ? -1 : 1, B = d && I ? -1 : 1, W = evaluate(l, o); let { mainAxis: Z, crossAxis: Q, alignmentAxis: re } = typeof W == "number" ? { mainAxis: W, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...W }; return v && typeof re == "number" && (Q = v === "end" ? re * -1 : re), I ? { x: Q * B, y: Z * F } : { x: Z * F, y: Q * B } } const offset$1 = function (o) { return o === void 0 && (o = 0), { name: "offset", options: o, async fn(l) { var u, f; const { x: p, y: d, placement: m, middlewareData: v } = l, I = await convertValueToCoords(l, o); return m === ((u = v.offset) == null ? void 0 : u.placement) && (f = v.arrow) != null && f.alignmentOffset ? {} : { x: p + I.x, y: d + I.y, data: { ...I, placement: m } } } } }, shift$1 = function (o) { return o === void 0 && (o = {}), { name: "shift", options: o, async fn(l) { const { x: u, y: f, placement: p } = l, { mainAxis: d = !0, crossAxis: m = !1, limiter: v = { fn: oe => { let { x: ae, y: se } = oe; return { x: ae, y: se } } }, ...I } = evaluate(o, l), F = { x: u, y: f }, B = await detectOverflow(l, I), W = getSideAxis(getSide(p)), Z = getOppositeAxis(W); let Q = F[Z], re = F[W]; if (d) { const oe = Z === "y" ? "top" : "left", ae = Z === "y" ? "bottom" : "right", se = Q + B[oe], le = Q - B[ae]; Q = clamp$1(se, Q, le) } if (m) { const oe = W === "y" ? "top" : "left", ae = W === "y" ? "bottom" : "right", se = re + B[oe], le = re - B[ae]; re = clamp$1(se, re, le) } const ne = v.fn({ ...l, [Z]: Q, [W]: re }); return { ...ne, data: { x: ne.x - u, y: ne.y - f } } } } }; function getNodeName(o) { return isNode(o) ? (o.nodeName || "").toLowerCase() : "#document" } function getWindow(o) { var l; return (o == null || (l = o.ownerDocument) == null ? void 0 : l.defaultView) || window } function getDocumentElement(o) { var l; return (l = (isNode(o) ? o.ownerDocument : o.document) || window.document) == null ? void 0 : l.documentElement } function isNode(o) { return o instanceof Node || o instanceof getWindow(o).Node } function isElement(o) { return o instanceof Element || o instanceof getWindow(o).Element } function isHTMLElement(o) { return o instanceof HTMLElement || o instanceof getWindow(o).HTMLElement } function isShadowRoot(o) { return typeof ShadowRoot > "u" ? !1 : o instanceof ShadowRoot || o instanceof getWindow(o).ShadowRoot } function isOverflowElement(o) { const { overflow: l, overflowX: u, overflowY: f, display: p } = getComputedStyle$2(o); return /auto|scroll|overlay|hidden|clip/.test(l + f + u) && !["inline", "contents"].includes(p) } function isTableElement(o) { return ["table", "td", "th"].includes(getNodeName(o)) } function isTopLayer(o) { return [":popover-open", ":modal"].some(l => { try { return o.matches(l) } catch { return !1 } }) } function isContainingBlock(o) { const l = isWebKit(), u = isElement(o) ? getComputedStyle$2(o) : o; return u.transform !== "none" || u.perspective !== "none" || (u.containerType ? u.containerType !== "normal" : !1) || !l && (u.backdropFilter ? u.backdropFilter !== "none" : !1) || !l && (u.filter ? u.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(f => (u.willChange || "").includes(f)) || ["paint", "layout", "strict", "content"].some(f => (u.contain || "").includes(f)) } function getContainingBlock(o) { let l = getParentNode(o); for (; isHTMLElement(l) && !isLastTraversableNode(l);) { if (isContainingBlock(l)) return l; if (isTopLayer(l)) return null; l = getParentNode(l) } return null } function isWebKit() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function isLastTraversableNode(o) { return ["html", "body", "#document"].includes(getNodeName(o)) } function getComputedStyle$2(o) { return getWindow(o).getComputedStyle(o) } function getNodeScroll(o) { return isElement(o) ? { scrollLeft: o.scrollLeft, scrollTop: o.scrollTop } : { scrollLeft: o.scrollX, scrollTop: o.scrollY } } function getParentNode(o) { if (getNodeName(o) === "html") return o; const l = o.assignedSlot || o.parentNode || isShadowRoot(o) && o.host || getDocumentElement(o); return isShadowRoot(l) ? l.host : l } function getNearestOverflowAncestor(o) { const l = getParentNode(o); return isLastTraversableNode(l) ? o.ownerDocument ? o.ownerDocument.body : o.body : isHTMLElement(l) && isOverflowElement(l) ? l : getNearestOverflowAncestor(l) } function getOverflowAncestors(o, l, u) { var f; l === void 0 && (l = []), u === void 0 && (u = !0); const p = getNearestOverflowAncestor(o), d = p === ((f = o.ownerDocument) == null ? void 0 : f.body), m = getWindow(p); if (d) { const v = getFrameElement(m); return l.concat(m, m.visualViewport || [], isOverflowElement(p) ? p : [], v && u ? getOverflowAncestors(v) : []) } return l.concat(p, getOverflowAncestors(p, [], u)) } function getFrameElement(o) { return o.parent && Object.getPrototypeOf(o.parent) ? o.frameElement : null } function getCssDimensions(o) { const l = getComputedStyle$2(o); let u = parseFloat(l.width) || 0, f = parseFloat(l.height) || 0; const p = isHTMLElement(o), d = p ? o.offsetWidth : u, m = p ? o.offsetHeight : f, v = round$1(u) !== d || round$1(f) !== m; return v && (u = d, f = m), { width: u, height: f, $: v } } function unwrapElement(o) { return isElement(o) ? o : o.contextElement } function getScale(o) { const l = unwrapElement(o); if (!isHTMLElement(l)) return createCoords(1); const u = l.getBoundingClientRect(), { width: f, height: p, $: d } = getCssDimensions(l); let m = (d ? round$1(u.width) : u.width) / f, v = (d ? round$1(u.height) : u.height) / p; return (!m || !Number.isFinite(m)) && (m = 1), (!v || !Number.isFinite(v)) && (v = 1), { x: m, y: v } } const noOffsets = createCoords(0); function getVisualOffsets(o) { const l = getWindow(o); return !isWebKit() || !l.visualViewport ? noOffsets : { x: l.visualViewport.offsetLeft, y: l.visualViewport.offsetTop } } function shouldAddVisualOffsets(o, l, u) { return l === void 0 && (l = !1), !u || l && u !== getWindow(o) ? !1 : l } function getBoundingClientRect(o, l, u, f) { l === void 0 && (l = !1), u === void 0 && (u = !1); const p = o.getBoundingClientRect(), d = unwrapElement(o); let m = createCoords(1); l && (f ? isElement(f) && (m = getScale(f)) : m = getScale(o)); const v = shouldAddVisualOffsets(d, u, f) ? getVisualOffsets(d) : createCoords(0); let I = (p.left + v.x) / m.x, F = (p.top + v.y) / m.y, B = p.width / m.x, W = p.height / m.y; if (d) { const Z = getWindow(d), Q = f && isElement(f) ? getWindow(f) : f; let re = Z, ne = getFrameElement(re); for (; ne && f && Q !== re;) { const oe = getScale(ne), ae = ne.getBoundingClientRect(), se = getComputedStyle$2(ne), le = ae.left + (ne.clientLeft + parseFloat(se.paddingLeft)) * oe.x, ue = ae.top + (ne.clientTop + parseFloat(se.paddingTop)) * oe.y; I *= oe.x, F *= oe.y, B *= oe.x, W *= oe.y, I += le, F += ue, re = getWindow(ne), ne = getFrameElement(re) } } return rectToClientRect({ width: B, height: W, x: I, y: F }) } function convertOffsetParentRelativeRectToViewportRelativeRect(o) { let { elements: l, rect: u, offsetParent: f, strategy: p } = o; const d = p === "fixed", m = getDocumentElement(f), v = l ? isTopLayer(l.floating) : !1; if (f === m || v && d) return u; let I = { scrollLeft: 0, scrollTop: 0 }, F = createCoords(1); const B = createCoords(0), W = isHTMLElement(f); if ((W || !W && !d) && ((getNodeName(f) !== "body" || isOverflowElement(m)) && (I = getNodeScroll(f)), isHTMLElement(f))) { const Z = getBoundingClientRect(f); F = getScale(f), B.x = Z.x + f.clientLeft, B.y = Z.y + f.clientTop } return { width: u.width * F.x, height: u.height * F.y, x: u.x * F.x - I.scrollLeft * F.x + B.x, y: u.y * F.y - I.scrollTop * F.y + B.y } } function getClientRects(o) { return Array.from(o.getClientRects()) } function getWindowScrollBarX(o) { return getBoundingClientRect(getDocumentElement(o)).left + getNodeScroll(o).scrollLeft } function getDocumentRect(o) { const l = getDocumentElement(o), u = getNodeScroll(o), f = o.ownerDocument.body, p = max(l.scrollWidth, l.clientWidth, f.scrollWidth, f.clientWidth), d = max(l.scrollHeight, l.clientHeight, f.scrollHeight, f.clientHeight); let m = -u.scrollLeft + getWindowScrollBarX(o); const v = -u.scrollTop; return getComputedStyle$2(f).direction === "rtl" && (m += max(l.clientWidth, f.clientWidth) - p), { width: p, height: d, x: m, y: v } } function getViewportRect(o, l) { const u = getWindow(o), f = getDocumentElement(o), p = u.visualViewport; let d = f.clientWidth, m = f.clientHeight, v = 0, I = 0; if (p) { d = p.width, m = p.height; const F = isWebKit(); (!F || F && l === "fixed") && (v = p.offsetLeft, I = p.offsetTop) } return { width: d, height: m, x: v, y: I } } function getInnerBoundingClientRect(o, l) { const u = getBoundingClientRect(o, !0, l === "fixed"), f = u.top + o.clientTop, p = u.left + o.clientLeft, d = isHTMLElement(o) ? getScale(o) : createCoords(1), m = o.clientWidth * d.x, v = o.clientHeight * d.y, I = p * d.x, F = f * d.y; return { width: m, height: v, x: I, y: F } } function getClientRectFromClippingAncestor(o, l, u) { let f; if (l === "viewport") f = getViewportRect(o, u); else if (l === "document") f = getDocumentRect(getDocumentElement(o)); else if (isElement(l)) f = getInnerBoundingClientRect(l, u); else { const p = getVisualOffsets(o); f = { ...l, x: l.x - p.x, y: l.y - p.y } } return rectToClientRect(f) } function hasFixedPositionAncestor(o, l) { const u = getParentNode(o); return u === l || !isElement(u) || isLastTraversableNode(u) ? !1 : getComputedStyle$2(u).position === "fixed" || hasFixedPositionAncestor(u, l) } function getClippingElementAncestors(o, l) { const u = l.get(o); if (u) return u; let f = getOverflowAncestors(o, [], !1).filter(v => isElement(v) && getNodeName(v) !== "body"), p = null; const d = getComputedStyle$2(o).position === "fixed"; let m = d ? getParentNode(o) : o; for (; isElement(m) && !isLastTraversableNode(m);) { const v = getComputedStyle$2(m), I = isContainingBlock(m); !I && v.position === "fixed" && (p = null), (d ? !I && !p : !I && v.position === "static" && !!p && ["absolute", "fixed"].includes(p.position) || isOverflowElement(m) && !I && hasFixedPositionAncestor(o, m)) ? f = f.filter(B => B !== m) : p = v, m = getParentNode(m) } return l.set(o, f), f } function getClippingRect(o) { let { element: l, boundary: u, rootBoundary: f, strategy: p } = o; const m = [...u === "clippingAncestors" ? isTopLayer(l) ? [] : getClippingElementAncestors(l, this._c) : [].concat(u), f], v = m[0], I = m.reduce((F, B) => { const W = getClientRectFromClippingAncestor(l, B, p); return F.top = max(W.top, F.top), F.right = min(W.right, F.right), F.bottom = min(W.bottom, F.bottom), F.left = max(W.left, F.left), F }, getClientRectFromClippingAncestor(l, v, p)); return { width: I.right - I.left, height: I.bottom - I.top, x: I.left, y: I.top } } function getDimensions(o) { const { width: l, height: u } = getCssDimensions(o); return { width: l, height: u } } function getRectRelativeToOffsetParent(o, l, u) { const f = isHTMLElement(l), p = getDocumentElement(l), d = u === "fixed", m = getBoundingClientRect(o, !0, d, l); let v = { scrollLeft: 0, scrollTop: 0 }; const I = createCoords(0); if (f || !f && !d) if ((getNodeName(l) !== "body" || isOverflowElement(p)) && (v = getNodeScroll(l)), f) { const W = getBoundingClientRect(l, !0, d, l); I.x = W.x + l.clientLeft, I.y = W.y + l.clientTop } else p && (I.x = getWindowScrollBarX(p)); const F = m.left + v.scrollLeft - I.x, B = m.top + v.scrollTop - I.y; return { x: F, y: B, width: m.width, height: m.height } } function isStaticPositioned(o) { return getComputedStyle$2(o).position === "static" } function getTrueOffsetParent(o, l) { return !isHTMLElement(o) || getComputedStyle$2(o).position === "fixed" ? null : l ? l(o) : o.offsetParent } function getOffsetParent(o, l) { const u = getWindow(o); if (isTopLayer(o)) return u; if (!isHTMLElement(o)) { let p = getParentNode(o); for (; p && !isLastTraversableNode(p);) { if (isElement(p) && !isStaticPositioned(p)) return p; p = getParentNode(p) } return u } let f = getTrueOffsetParent(o, l); for (; f && isTableElement(f) && isStaticPositioned(f);)f = getTrueOffsetParent(f, l); return f && isLastTraversableNode(f) && isStaticPositioned(f) && !isContainingBlock(f) ? u : f || getContainingBlock(o) || u } const getElementRects = async function (o) { const l = this.getOffsetParent || getOffsetParent, u = this.getDimensions, f = await u(o.floating); return { reference: getRectRelativeToOffsetParent(o.reference, await l(o.floating), o.strategy), floating: { x: 0, y: 0, width: f.width, height: f.height } } }; function isRTL(o) { return getComputedStyle$2(o).direction === "rtl" } const platform = { convertOffsetParentRelativeRectToViewportRelativeRect, getDocumentElement, getClippingRect, getOffsetParent, getElementRects, getClientRects, getDimensions, getScale, isElement, isRTL }; function observeMove(o, l) { let u = null, f; const p = getDocumentElement(o); function d() { var v; clearTimeout(f), (v = u) == null || v.disconnect(), u = null } function m(v, I) { v === void 0 && (v = !1), I === void 0 && (I = 1), d(); const { left: F, top: B, width: W, height: Z } = o.getBoundingClientRect(); if (v || l(), !W || !Z) return; const Q = floor(B), re = floor(p.clientWidth - (F + W)), ne = floor(p.clientHeight - (B + Z)), oe = floor(F), se = { rootMargin: -Q + "px " + -re + "px " + -ne + "px " + -oe + "px", threshold: max(0, min(1, I)) || 1 }; let le = !0; function ue(he) { const pe = he[0].intersectionRatio; if (pe !== I) { if (!le) return m(); pe ? m(!1, pe) : f = setTimeout(() => { m(!1, 1e-7) }, 1e3) } le = !1 } try { u = new IntersectionObserver(ue, { ...se, root: p.ownerDocument }) } catch { u = new IntersectionObserver(ue, se) } u.observe(o) } return m(!0), d } function autoUpdate(o, l, u, f) { f === void 0 && (f = {}); const { ancestorScroll: p = !0, ancestorResize: d = !0, elementResize: m = typeof ResizeObserver == "function", layoutShift: v = typeof IntersectionObserver == "function", animationFrame: I = !1 } = f, F = unwrapElement(o), B = p || d ? [...F ? getOverflowAncestors(F) : [], ...getOverflowAncestors(l)] : []; B.forEach(ae => { p && ae.addEventListener("scroll", u, { passive: !0 }), d && ae.addEventListener("resize", u) }); const W = F && v ? observeMove(F, u) : null; let Z = -1, Q = null; m && (Q = new ResizeObserver(ae => { let [se] = ae; se && se.target === F && Q && (Q.unobserve(l), cancelAnimationFrame(Z), Z = requestAnimationFrame(() => { var le; (le = Q) == null || le.observe(l) })), u() }), F && !I && Q.observe(F), Q.observe(l)); let re, ne = I ? getBoundingClientRect(o) : null; I && oe(); function oe() { const ae = getBoundingClientRect(o); ne && (ae.x !== ne.x || ae.y !== ne.y || ae.width !== ne.width || ae.height !== ne.height) && u(), ne = ae, re = requestAnimationFrame(oe) } return u(), () => { var ae; B.forEach(se => { p && se.removeEventListener("scroll", u), d && se.removeEventListener("resize", u) }), W == null || W(), (ae = Q) == null || ae.disconnect(), Q = null, I && cancelAnimationFrame(re) } } const offset = offset$1, shift = shift$1, flip = flip$1, arrow = arrow$1, computePosition = (o, l, u) => { const f = new Map, p = { platform, ...u }, d = { ...p.platform, _c: f }; return computePosition$1(o, l, { ...p, platform: d }) }; var classnames = { exports: {} };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/var hasRequiredClassnames; function requireClassnames() { return hasRequiredClassnames || (hasRequiredClassnames = 1, function (o) { (function () { var l = {}.hasOwnProperty; function u() { for (var d = "", m = 0; m < arguments.length; m++) { var v = arguments[m]; v && (d = p(d, f(v))) } return d } function f(d) { if (typeof d == "string" || typeof d == "number") return d; if (typeof d != "object") return ""; if (Array.isArray(d)) return u.apply(null, d); if (d.toString !== Object.prototype.toString && !d.toString.toString().includes("[native code]")) return d.toString(); var m = ""; for (var v in d) l.call(d, v) && d[v] && (m = p(m, v)); return m } function p(d, m) { return m ? d ? d + " " + m : d + m : d } o.exports ? (u.default = u, o.exports = u) : window.classNames = u })() }(classnames)), classnames.exports } var classnamesExports = requireClassnames(); const cn = getDefaultExportFromCjs$1(classnamesExports); var define_process_env_default = {}; const h = "react-tooltip-core-styles", w = "react-tooltip-base-styles", b = { core: !1, base: !1 }; function S({ css: o, id: l = w, type: u = "base", ref: f }) { var p, d; if (!o || typeof document > "u" || b[u] || u === "core" && typeof process$1 < "u" && (!((p = process$1 == null ? void 0 : define_process_env_default) === null || p === void 0) && p.REACT_TOOLTIP_DISABLE_CORE_STYLES) || u !== "base" && typeof process$1 < "u" && (!((d = process$1 == null ? void 0 : define_process_env_default) === null || d === void 0) && d.REACT_TOOLTIP_DISABLE_BASE_STYLES)) return; u === "core" && (l = h), f || (f = {}); const { insertAt: m } = f; if (document.getElementById(l)) return; const v = document.head || document.getElementsByTagName("head")[0], I = document.createElement("style"); I.id = l, I.type = "text/css", m === "top" && v.firstChild ? v.insertBefore(I, v.firstChild) : v.appendChild(I), I.styleSheet ? I.styleSheet.cssText = o : I.appendChild(document.createTextNode(o)), b[u] = !0 } const E = async ({ elementReference: o = null, tooltipReference: l = null, tooltipArrowReference: u = null, place: f = "top", offset: p = 10, strategy: d = "absolute", middlewares: m = [offset(Number(p)), flip({ fallbackAxisSideDirection: "start" }), shift({ padding: 5 })], border: v }) => { if (!o) return { tooltipStyles: {}, tooltipArrowStyles: {}, place: f }; if (l === null) return { tooltipStyles: {}, tooltipArrowStyles: {}, place: f }; const I = m; return u ? (I.push(arrow({ element: u, padding: 5 })), computePosition(o, l, { placement: f, strategy: d, middleware: I }).then(({ x: F, y: B, placement: W, middlewareData: Z }) => { var Q, re; const ne = { left: `${F}px`, top: `${B}px`, border: v }, { x: oe, y: ae } = (Q = Z.arrow) !== null && Q !== void 0 ? Q : { x: 0, y: 0 }, se = (re = { top: "bottom", right: "left", bottom: "top", left: "right" }[W.split("-")[0]]) !== null && re !== void 0 ? re : "bottom", le = v && { borderBottom: v, borderRight: v }; let ue = 0; if (v) { const he = `${v}`.match(/(\d+)px/); ue = he != null && he[1] ? Number(he[1]) : 1 } return { tooltipStyles: ne, tooltipArrowStyles: { left: oe != null ? `${oe}px` : "", top: ae != null ? `${ae}px` : "", right: "", bottom: "", ...le, [se]: `-${4 + ue}px` }, place: W } })) : computePosition(o, l, { placement: "bottom", strategy: d, middleware: I }).then(({ x: F, y: B, placement: W }) => ({ tooltipStyles: { left: `${F}px`, top: `${B}px` }, tooltipArrowStyles: {}, place: W })) }, A = (o, l) => !("CSS" in window && "supports" in window.CSS) || window.CSS.supports(o, l), _ = (o, l, u) => { let f = null; const p = function (...d) { const m = () => { f = null }; !f && (o.apply(this, d), f = setTimeout(m, l)) }; return p.cancel = () => { f && (clearTimeout(f), f = null) }, p }, O = o => o !== null && !Array.isArray(o) && typeof o == "object", k = (o, l) => { if (o === l) return !0; if (Array.isArray(o) && Array.isArray(l)) return o.length === l.length && o.every((p, d) => k(p, l[d])); if (Array.isArray(o) !== Array.isArray(l)) return !1; if (!O(o) || !O(l)) return o === l; const u = Object.keys(o), f = Object.keys(l); return u.length === f.length && u.every(p => k(o[p], l[p])) }, T = o => { if (!(o instanceof HTMLElement || o instanceof SVGElement)) return !1; const l = getComputedStyle(o); return ["overflow", "overflow-x", "overflow-y"].some(u => { const f = l.getPropertyValue(u); return f === "auto" || f === "scroll" }) }, L = o => { if (!o) return null; let l = o.parentElement; for (; l;) { if (T(l)) return l; l = l.parentElement } return document.scrollingElement || document.documentElement }, C = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect, R = o => { o.current && (clearTimeout(o.current), o.current = null) }, x = "DEFAULT_TOOLTIP_ID", N = { anchorRefs: new Set, activeAnchor: { current: null }, attach: () => { }, detach: () => { }, setActiveAnchor: () => { } }, $ = reactExports.createContext({ getTooltipData: () => N }); function j(o = x) { return reactExports.useContext($).getTooltipData(o) } var z = { tooltip: "core-styles-module_tooltip__3vRRp", fixed: "core-styles-module_fixed__pcSol", arrow: "core-styles-module_arrow__cvMwQ", noArrow: "core-styles-module_noArrow__xock6", clickable: "core-styles-module_clickable__ZuTTB", show: "core-styles-module_show__Nt9eE", closing: "core-styles-module_closing__sGnxF" }, D = { tooltip: "styles-module_tooltip__mnnfp", arrow: "styles-module_arrow__K0L3T", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" }; const q = ({ forwardRef: o, id: l, className: u, classNameArrow: f, variant: p = "dark", anchorId: d, anchorSelect: m, place: v = "top", offset: I = 10, events: F = ["hover"], openOnClick: B = !1, positionStrategy: W = "absolute", middlewares: Z, wrapper: Q, delayShow: re = 0, delayHide: ne = 0, float: oe = !1, hidden: ae = !1, noArrow: se = !1, clickable: le = !1, closeOnEsc: ue = !1, closeOnScroll: he = !1, closeOnResize: pe = !1, openEvents: ve, closeEvents: _e, globalCloseEvents: Se, imperativeModeOnly: $e, style: ie, position: g, afterShow: P, afterHide: U, disableTooltip: K, content: Y, contentWrapperRef: te, isOpen: ee, defaultIsOpen: G = !1, setIsOpen: y, activeAnchor: X, setActiveAnchor: ce, border: me, opacity: Ae, arrowColor: Ie, role: Be = "tooltip" }) => { var Me; const De = reactExports.useRef(null), Ue = reactExports.useRef(null), Ke = reactExports.useRef(null), Ve = reactExports.useRef(null), ke = reactExports.useRef(null), [Je, dt] = reactExports.useState({ tooltipStyles: {}, tooltipArrowStyles: {}, place: v }), [lt, ht] = reactExports.useState(!1), [Bt, mt] = reactExports.useState(!1), [et, Gt] = reactExports.useState(null), pt = reactExports.useRef(!1), _t = reactExports.useRef(null), { anchorRefs: zt, setActiveAnchor: bt } = j(l), We = reactExports.useRef(!1), [Ge, ze] = reactExports.useState([]), Ze = reactExports.useRef(!1), ut = B || F.includes("click"), ye = ut || (ve == null ? void 0 : ve.click) || (ve == null ? void 0 : ve.dblclick) || (ve == null ? void 0 : ve.mousedown), ge = ve ? { ...ve } : { mouseover: !0, focus: !0, mouseenter: !1, click: !1, dblclick: !1, mousedown: !1 }; !ve && ut && Object.assign(ge, { mouseenter: !1, focus: !1, mouseover: !1, click: !0 }); const Ee = _e ? { ..._e } : { mouseout: !0, blur: !0, mouseleave: !1, click: !1, dblclick: !1, mouseup: !1 }; !_e && ut && Object.assign(Ee, { mouseleave: !1, blur: !1, mouseout: !1 }); const Oe = Se ? { ...Se } : { escape: ue || !1, scroll: he || !1, resize: pe || !1, clickOutsideAnchor: ye || !1 }; $e && (Object.assign(ge, { mouseenter: !1, focus: !1, click: !1, dblclick: !1, mousedown: !1 }), Object.assign(Ee, { mouseleave: !1, blur: !1, click: !1, dblclick: !1, mouseup: !1 }), Object.assign(Oe, { escape: !1, scroll: !1, resize: !1, clickOutsideAnchor: !1 })), C(() => (Ze.current = !0, () => { Ze.current = !1 }), []); const je = Ce => { Ze.current && (Ce && mt(!0), setTimeout(() => { Ze.current && (y == null || y(Ce), ee === void 0 && ht(Ce)) }, 10)) }; reactExports.useEffect(() => { if (ee === void 0) return () => null; ee && mt(!0); const Ce = setTimeout(() => { ht(ee) }, 10); return () => { clearTimeout(Ce) } }, [ee]), reactExports.useEffect(() => { if (lt !== pt.current) if (R(ke), pt.current = lt, lt) P == null || P(); else { const Ce = (Ne => { const Ye = Ne.match(/^([\d.]+)(ms|s)$/); if (!Ye) return 0; const [, Re, Pe] = Ye; return Number(Re) * (Pe === "ms" ? 1 : 1e3) })(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay")); ke.current = setTimeout(() => { mt(!1), Gt(null), U == null || U() }, Ce + 25) } }, [lt]); const nt = Ce => { dt(Ne => k(Ne, Ce) ? Ne : Ce) }, Xe = (Ce = re) => { R(Ke), Bt ? je(!0) : Ke.current = setTimeout(() => { je(!0) }, Ce) }, it = (Ce = ne) => { R(Ve), Ve.current = setTimeout(() => { We.current || je(!1) }, Ce) }, Tt = Ce => { var Ne; if (!Ce) return; const Ye = (Ne = Ce.currentTarget) !== null && Ne !== void 0 ? Ne : Ce.target; if (!(Ye != null && Ye.isConnected)) return ce(null), void bt({ current: null }); re ? Xe() : je(!0), ce(Ye), bt({ current: Ye }), R(Ve) }, tt = () => { le ? it(ne || 100) : ne ? it() : je(!1), R(Ke) }, yt = ({ x: Ce, y: Ne }) => { var Ye; const Re = { getBoundingClientRect: () => ({ x: Ce, y: Ne, width: 0, height: 0, top: Ne, left: Ce, right: Ce, bottom: Ne }) }; E({ place: (Ye = et == null ? void 0 : et.place) !== null && Ye !== void 0 ? Ye : v, offset: I, elementReference: Re, tooltipReference: De.current, tooltipArrowReference: Ue.current, strategy: W, middlewares: Z, border: me }).then(Pe => { nt(Pe) }) }, kt = Ce => { if (!Ce) return; const Ne = Ce, Ye = { x: Ne.clientX, y: Ne.clientY }; yt(Ye), _t.current = Ye }, wt = Ce => { var Ne; if (!lt) return; const Ye = Ce.target; Ye.isConnected && (!((Ne = De.current) === null || Ne === void 0) && Ne.contains(Ye) || [document.querySelector(`[id='${d}']`), ...Ge].some(Re => Re == null ? void 0 : Re.contains(Ye)) || (je(!1), R(Ke))) }, Mt = _(Tt, 50), tr = _(tt, 50), St = Ce => { tr.cancel(), Mt(Ce) }, gt = () => { Mt.cancel(), tr() }, rr = reactExports.useCallback(() => { var Ce, Ne; const Ye = (Ce = et == null ? void 0 : et.position) !== null && Ce !== void 0 ? Ce : g; Ye ? yt(Ye) : oe ? _t.current && yt(_t.current) : X != null && X.isConnected && E({ place: (Ne = et == null ? void 0 : et.place) !== null && Ne !== void 0 ? Ne : v, offset: I, elementReference: X, tooltipReference: De.current, tooltipArrowReference: Ue.current, strategy: W, middlewares: Z, border: me }).then(Re => { Ze.current && nt(Re) }) }, [lt, X, Y, ie, v, et == null ? void 0 : et.place, I, W, g, et == null ? void 0 : et.position, oe]); reactExports.useEffect(() => { var Ce, Ne; const Ye = new Set(zt); Ge.forEach(Ft => { K != null && K(Ft) || Ye.add({ current: Ft }) }); const Re = document.querySelector(`[id='${d}']`); Re && !(K != null && K(Re)) && Ye.add({ current: Re }); const Pe = () => { je(!1) }, qe = L(X), be = L(De.current); Oe.scroll && (window.addEventListener("scroll", Pe), qe == null || qe.addEventListener("scroll", Pe), be == null || be.addEventListener("scroll", Pe)); let Fe = null; Oe.resize ? window.addEventListener("resize", Pe) : X && De.current && (Fe = autoUpdate(X, De.current, rr, { ancestorResize: !0, elementResize: !0, layoutShift: !0 })); const Qe = Ft => { Ft.key === "Escape" && je(!1) }; Oe.escape && window.addEventListener("keydown", Qe), Oe.clickOutsideAnchor && window.addEventListener("click", wt); const st = [], rt = Ft => { lt && (Ft == null ? void 0 : Ft.target) === X || Tt(Ft) }, ct = Ft => { lt && (Ft == null ? void 0 : Ft.target) === X && tt() }, Lt = ["mouseover", "mouseout", "mouseenter", "mouseleave", "focus", "blur"], It = ["click", "dblclick", "mousedown", "mouseup"]; Object.entries(ge).forEach(([Ft, er]) => { er && (Lt.includes(Ft) ? st.push({ event: Ft, listener: St }) : It.includes(Ft) && st.push({ event: Ft, listener: rt })) }), Object.entries(Ee).forEach(([Ft, er]) => { er && (Lt.includes(Ft) ? st.push({ event: Ft, listener: gt }) : It.includes(Ft) && st.push({ event: Ft, listener: ct })) }), oe && st.push({ event: "pointermove", listener: kt }); const lr = () => { We.current = !0 }, jt = () => { We.current = !1, tt() }; return le && !ye && ((Ce = De.current) === null || Ce === void 0 || Ce.addEventListener("mouseenter", lr), (Ne = De.current) === null || Ne === void 0 || Ne.addEventListener("mouseleave", jt)), st.forEach(({ event: Ft, listener: er }) => { Ye.forEach(ar => { var nr; (nr = ar.current) === null || nr === void 0 || nr.addEventListener(Ft, er) }) }), () => { var Ft, er; Oe.scroll && (window.removeEventListener("scroll", Pe), qe == null || qe.removeEventListener("scroll", Pe), be == null || be.removeEventListener("scroll", Pe)), Oe.resize ? window.removeEventListener("resize", Pe) : Fe == null || Fe(), Oe.clickOutsideAnchor && window.removeEventListener("click", wt), Oe.escape && window.removeEventListener("keydown", Qe), le && !ye && ((Ft = De.current) === null || Ft === void 0 || Ft.removeEventListener("mouseenter", lr), (er = De.current) === null || er === void 0 || er.removeEventListener("mouseleave", jt)), st.forEach(({ event: ar, listener: nr }) => { Ye.forEach(ir => { var Ht; (Ht = ir.current) === null || Ht === void 0 || Ht.removeEventListener(ar, nr) }) }) } }, [X, rr, Bt, zt, Ge, ve, _e, Se, ut, re, ne]), reactExports.useEffect(() => { var Ce, Ne; let Ye = (Ne = (Ce = et == null ? void 0 : et.anchorSelect) !== null && Ce !== void 0 ? Ce : m) !== null && Ne !== void 0 ? Ne : ""; !Ye && l && (Ye = `[data-tooltip-id='${l.replace(/'/g, "\\'")}']`); const Re = new MutationObserver(Pe => { const qe = [], be = []; Pe.forEach(Fe => { if (Fe.type === "attributes" && Fe.attributeName === "data-tooltip-id" && (Fe.target.getAttribute("data-tooltip-id") === l ? qe.push(Fe.target) : Fe.oldValue === l && be.push(Fe.target)), Fe.type === "childList") { if (X) { const Qe = [...Fe.removedNodes].filter(st => st.nodeType === 1); if (Ye) try { be.push(...Qe.filter(st => st.matches(Ye))), be.push(...Qe.flatMap(st => [...st.querySelectorAll(Ye)])) } catch { } Qe.some(st => { var rt; return !!(!((rt = st == null ? void 0 : st.contains) === null || rt === void 0) && rt.call(st, X)) && (mt(!1), je(!1), ce(null), R(Ke), R(Ve), !0) }) } if (Ye) try { const Qe = [...Fe.addedNodes].filter(st => st.nodeType === 1); qe.push(...Qe.filter(st => st.matches(Ye))), qe.push(...Qe.flatMap(st => [...st.querySelectorAll(Ye)])) } catch { } } }), (qe.length || be.length) && ze(Fe => [...Fe.filter(Qe => !be.includes(Qe)), ...qe]) }); return Re.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"], attributeOldValue: !0 }), () => { Re.disconnect() } }, [l, m, et == null ? void 0 : et.anchorSelect, X]), reactExports.useEffect(() => { rr() }, [rr]), reactExports.useEffect(() => { if (!(te != null && te.current)) return () => null; const Ce = new ResizeObserver(() => { setTimeout(() => rr()) }); return Ce.observe(te.current), () => { Ce.disconnect() } }, [Y, te == null ? void 0 : te.current]), reactExports.useEffect(() => { var Ce; const Ne = document.querySelector(`[id='${d}']`), Ye = [...Ge, Ne]; X && Ye.includes(X) || ce((Ce = Ge[0]) !== null && Ce !== void 0 ? Ce : Ne) }, [d, Ge, X]), reactExports.useEffect(() => (G && je(!0), () => { R(Ke), R(Ve) }), []), reactExports.useEffect(() => { var Ce; let Ne = (Ce = et == null ? void 0 : et.anchorSelect) !== null && Ce !== void 0 ? Ce : m; if (!Ne && l && (Ne = `[data-tooltip-id='${l.replace(/'/g, "\\'")}']`), Ne) try { const Ye = Array.from(document.querySelectorAll(Ne)); ze(Ye) } catch { ze([]) } }, [l, m, et == null ? void 0 : et.anchorSelect]), reactExports.useEffect(() => { Ke.current && (R(Ke), Xe(re)) }, [re]); const Le = (Me = et == null ? void 0 : et.content) !== null && Me !== void 0 ? Me : Y, xe = lt && Object.keys(Je.tooltipStyles).length > 0; return reactExports.useImperativeHandle(o, () => ({ open: Ce => { if (Ce != null && Ce.anchorSelect) try { document.querySelector(Ce.anchorSelect) } catch { return void console.warn(`[react-tooltip] "${Ce.anchorSelect}" is not a valid CSS selector`) } Gt(Ce ?? null), Ce != null && Ce.delay ? Xe(Ce.delay) : je(!0) }, close: Ce => { Ce != null && Ce.delay ? it(Ce.delay) : je(!1) }, activeAnchor: X, place: Je.place, isOpen: !!(Bt && !ae && Le && xe) })), Bt && !ae && Le ? React.createElement(Q, { id: l, role: Be, className: cn("react-tooltip", z.tooltip, D.tooltip, D[p], u, `react-tooltip__place-${Je.place}`, z[xe ? "show" : "closing"], xe ? "react-tooltip__show" : "react-tooltip__closing", W === "fixed" && z.fixed, le && z.clickable), onTransitionEnd: Ce => { R(ke), lt || Ce.propertyName !== "opacity" || (mt(!1), Gt(null), U == null || U()) }, style: { ...ie, ...Je.tooltipStyles, opacity: Ae !== void 0 && xe ? Ae : void 0 }, ref: De }, Le, React.createElement(Q, { className: cn("react-tooltip-arrow", z.arrow, D.arrow, f, se && z.noArrow), style: { ...Je.tooltipArrowStyles, background: Ie ? `linear-gradient(to right bottom, transparent 50%, ${Ie} 50%)` : void 0 }, ref: Ue })) : null }, H = ({ content: o }) => React.createElement("span", { dangerouslySetInnerHTML: { __html: o } }), M = React.forwardRef(({ id: o, anchorId: l, anchorSelect: u, content: f, html: p, render: d, className: m, classNameArrow: v, variant: I = "dark", place: F = "top", offset: B = 10, wrapper: W = "div", children: Z = null, events: Q = ["hover"], openOnClick: re = !1, positionStrategy: ne = "absolute", middlewares: oe, delayShow: ae = 0, delayHide: se = 0, float: le = !1, hidden: ue = !1, noArrow: he = !1, clickable: pe = !1, closeOnEsc: ve = !1, closeOnScroll: _e = !1, closeOnResize: Se = !1, openEvents: $e, closeEvents: ie, globalCloseEvents: g, imperativeModeOnly: P = !1, style: U, position: K, isOpen: Y, defaultIsOpen: te = !1, disableStyleInjection: ee = !1, border: G, opacity: y, arrowColor: X, setIsOpen: ce, afterShow: me, afterHide: Ae, disableTooltip: Ie, role: Be = "tooltip" }, Me) => { const [De, Ue] = reactExports.useState(f), [Ke, Ve] = reactExports.useState(p), [ke, Je] = reactExports.useState(F), [dt, lt] = reactExports.useState(I), [ht, Bt] = reactExports.useState(B), [mt, et] = reactExports.useState(ae), [Gt, pt] = reactExports.useState(se), [_t, zt] = reactExports.useState(le), [bt, We] = reactExports.useState(ue), [Ge, ze] = reactExports.useState(W), [Ze, ut] = reactExports.useState(Q), [ye, ge] = reactExports.useState(ne), [Ee, Oe] = reactExports.useState(null), [je, nt] = reactExports.useState(null), Xe = reactExports.useRef(ee), { anchorRefs: it, activeAnchor: Tt } = j(o), tt = tr => tr == null ? void 0 : tr.getAttributeNames().reduce((St, gt) => { var rr; return gt.startsWith("data-tooltip-") && (St[gt.replace(/^data-tooltip-/, "")] = (rr = tr == null ? void 0 : tr.getAttribute(gt)) !== null && rr !== void 0 ? rr : null), St }, {}), yt = tr => { const St = { place: gt => { var rr; Je((rr = gt) !== null && rr !== void 0 ? rr : F) }, content: gt => { Ue(gt ?? f) }, html: gt => { Ve(gt ?? p) }, variant: gt => { var rr; lt((rr = gt) !== null && rr !== void 0 ? rr : I) }, offset: gt => { Bt(gt === null ? B : Number(gt)) }, wrapper: gt => { var rr; ze((rr = gt) !== null && rr !== void 0 ? rr : W) }, events: gt => { const rr = gt == null ? void 0 : gt.split(" "); ut(rr ?? Q) }, "position-strategy": gt => { var rr; ge((rr = gt) !== null && rr !== void 0 ? rr : ne) }, "delay-show": gt => { et(gt === null ? ae : Number(gt)) }, "delay-hide": gt => { pt(gt === null ? se : Number(gt)) }, float: gt => { zt(gt === null ? le : gt === "true") }, hidden: gt => { We(gt === null ? ue : gt === "true") }, "class-name": gt => { Oe(gt) } }; Object.values(St).forEach(gt => gt(null)), Object.entries(tr).forEach(([gt, rr]) => { var Le; (Le = St[gt]) === null || Le === void 0 || Le.call(St, rr) }) }; reactExports.useEffect(() => { Ue(f) }, [f]), reactExports.useEffect(() => { Ve(p) }, [p]), reactExports.useEffect(() => { Je(F) }, [F]), reactExports.useEffect(() => { lt(I) }, [I]), reactExports.useEffect(() => { Bt(B) }, [B]), reactExports.useEffect(() => { et(ae) }, [ae]), reactExports.useEffect(() => { pt(se) }, [se]), reactExports.useEffect(() => { zt(le) }, [le]), reactExports.useEffect(() => { We(ue) }, [ue]), reactExports.useEffect(() => { ge(ne) }, [ne]), reactExports.useEffect(() => { Xe.current !== ee && console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.") }, [ee]), reactExports.useEffect(() => { typeof window < "u" && window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles", { detail: { disableCore: ee === "core", disableBase: ee } })) }, []), reactExports.useEffect(() => { var tr; const St = new Set(it); let gt = u; if (!gt && o && (gt = `[data-tooltip-id='${o.replace(/'/g, "\\'")}']`), gt) try { document.querySelectorAll(gt).forEach(Ne => { St.add({ current: Ne }) }) } catch { console.warn(`[react-tooltip] "${gt}" is not a valid CSS selector`) } const rr = document.querySelector(`[id='${l}']`); if (rr && St.add({ current: rr }), !St.size) return () => null; const Le = (tr = je ?? rr) !== null && tr !== void 0 ? tr : Tt.current, xe = new MutationObserver(Ne => { Ne.forEach(Ye => { var Re; if (!Le || Ye.type !== "attributes" || !(!((Re = Ye.attributeName) === null || Re === void 0) && Re.startsWith("data-tooltip-"))) return; const Pe = tt(Le); yt(Pe) }) }), Ce = { attributes: !0, childList: !1, subtree: !1 }; if (Le) { const Ne = tt(Le); yt(Ne), xe.observe(Le, Ce) } return () => { xe.disconnect() } }, [it, Tt, je, l, u]), reactExports.useEffect(() => { U != null && U.border && console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."), G && !A("border", `${G}`) && console.warn(`[react-tooltip] "${G}" is not a valid \`border\`.`), U != null && U.opacity && console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."), y && !A("opacity", `${y}`) && console.warn(`[react-tooltip] "${y}" is not a valid \`opacity\`.`) }, []); let kt = Z; const wt = reactExports.useRef(null); if (d) { const tr = d({ content: (je == null ? void 0 : je.getAttribute("data-tooltip-content")) || De || null, activeAnchor: je }); kt = tr ? React.createElement("div", { ref: wt, className: "react-tooltip-content-wrapper" }, tr) : null } else De && (kt = De); Ke && (kt = React.createElement(H, { content: Ke })); const Mt = { forwardRef: Me, id: o, anchorId: l, anchorSelect: u, className: cn(m, Ee), classNameArrow: v, content: kt, contentWrapperRef: wt, place: ke, variant: dt, offset: ht, wrapper: Ge, events: Ze, openOnClick: re, positionStrategy: ye, middlewares: oe, delayShow: mt, delayHide: Gt, float: _t, hidden: bt, noArrow: he, clickable: pe, closeOnEsc: ve, closeOnScroll: _e, closeOnResize: Se, openEvents: $e, closeEvents: ie, globalCloseEvents: g, imperativeModeOnly: P, style: U, position: K, isOpen: Y, defaultIsOpen: te, border: G, opacity: y, arrowColor: X, setIsOpen: ce, afterShow: me, afterHide: Ae, disableTooltip: Ie, activeAnchor: je, setActiveAnchor: tr => nt(tr), role: Be }; return React.createElement(q, { ...Mt }) }); typeof window < "u" && window.addEventListener("react-tooltip-inject-styles", o => {
  o.detail.disableCore || S({ css: ":root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}", type: "core" }), o.detail.disableBase || S({
    css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`, type: "base"
  })
}); const MotionConfigContext = reactExports.createContext({ transformPagePoint: o => o, isStatic: !1, reducedMotion: "never" }), MotionContext = reactExports.createContext({}), PresenceContext = reactExports.createContext(null), isBrowser$1 = typeof document < "u", useIsomorphicLayoutEffect = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect, LazyContext = reactExports.createContext({ strict: !1 }), camelToDash = o => o.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId), MotionGlobalConfig = { useManualTiming: !1 }; function createRenderStep(o) { let l = new Set, u = new Set, f = !1, p = !1; const d = new WeakSet; let m = { delta: 0, timestamp: 0, isProcessing: !1 }; function v(F) { d.has(F) && (I.schedule(F), o()), F(m) } const I = { schedule: (F, B = !1, W = !1) => { const Q = W && f ? l : u; return B && d.add(F), Q.has(F) || Q.add(F), F }, cancel: F => { u.delete(F), d.delete(F) }, process: F => { if (m = F, f) { p = !0; return } f = !0, [l, u] = [u, l], u.clear(), l.forEach(v), f = !1, p && (p = !1, I.process(F)) } }; return I } const stepsOrder = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], maxElapsed = 40; function createRenderBatcher(o, l) { let u = !1, f = !0; const p = { delta: 0, timestamp: 0, isProcessing: !1 }, d = () => u = !0, m = stepsOrder.reduce((ae, se) => (ae[se] = createRenderStep(d), ae), {}), { read: v, resolveKeyframes: I, update: F, preRender: B, render: W, postRender: Z } = m, Q = () => { const ae = performance.now(); u = !1, p.delta = f ? 1e3 / 60 : Math.max(Math.min(ae - p.timestamp, maxElapsed), 1), p.timestamp = ae, p.isProcessing = !0, v.process(p), I.process(p), F.process(p), B.process(p), W.process(p), Z.process(p), p.isProcessing = !1, u && l && (f = !1, o(Q)) }, re = () => { u = !0, f = !0, p.isProcessing || o(Q) }; return { schedule: stepsOrder.reduce((ae, se) => { const le = m[se]; return ae[se] = (ue, he = !1, pe = !1) => (u || re(), le.schedule(ue, he, pe)), ae }, {}), cancel: ae => { for (let se = 0; se < stepsOrder.length; se++)m[stepsOrder[se]].cancel(ae) }, state: p, steps: m } } const { schedule: microtask } = createRenderBatcher(queueMicrotask, !1); function isRefObject(o) { return o && typeof o == "object" && Object.prototype.hasOwnProperty.call(o, "current") } const SwitchLayoutGroupContext = reactExports.createContext({}); let scheduleHandoffComplete = !1; function useVisualElement(o, l, u, f, p) { const { visualElement: d } = reactExports.useContext(MotionContext), m = reactExports.useContext(LazyContext), v = reactExports.useContext(PresenceContext), I = reactExports.useContext(MotionConfigContext).reducedMotion, F = reactExports.useRef(); f = f || m.renderer, !F.current && f && (F.current = f(o, { visualState: l, parent: d, props: u, presenceContext: v, blockInitialAnimation: v ? v.initial === !1 : !1, reducedMotionConfig: I })); const B = F.current, W = reactExports.useContext(SwitchLayoutGroupContext); B && !B.projection && p && (B.type === "html" || B.type === "svg") && createProjectionNode$1(F.current, u, p, W), reactExports.useInsertionEffect(() => { B && B.update(u, v) }); const Z = reactExports.useRef(!!(u[optimizedAppearDataAttribute] && !window.HandoffComplete)); return useIsomorphicLayoutEffect(() => { B && (B.updateFeatures(), microtask.render(B.render), Z.current && B.animationState && B.animationState.animateChanges()) }), reactExports.useEffect(() => { B && (!Z.current && B.animationState && B.animationState.animateChanges(), Z.current && (Z.current = !1, scheduleHandoffComplete || (scheduleHandoffComplete = !0, queueMicrotask(completeHandoff)))) }), B } function completeHandoff() { window.HandoffComplete = !0 } function createProjectionNode$1(o, l, u, f) { const { layoutId: p, layout: d, drag: m, dragConstraints: v, layoutScroll: I, layoutRoot: F } = l; o.projection = new u(o.latestValues, l["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(o.parent)), o.projection.setOptions({ layoutId: p, layout: d, alwaysMeasureLayout: !!m || v && isRefObject(v), visualElement: o, scheduleRender: () => o.scheduleRender(), animationType: typeof d == "string" ? d : "both", initialPromotionConfig: f, layoutScroll: I, layoutRoot: F }) } function getClosestProjectingNode(o) { if (o) return o.options.allowProjection !== !1 ? o.projection : getClosestProjectingNode(o.parent) } function useMotionRef(o, l, u) { return reactExports.useCallback(f => { f && o.mount && o.mount(f), l && (f ? l.mount(f) : l.unmount()), u && (typeof u == "function" ? u(f) : isRefObject(u) && (u.current = f)) }, [l]) } function isVariantLabel(o) { return typeof o == "string" || Array.isArray(o) } function isAnimationControls(o) { return o !== null && typeof o == "object" && typeof o.start == "function" } const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], variantProps = ["initial", ...variantPriorityOrder]; function isControllingVariants(o) { return isAnimationControls(o.animate) || variantProps.some(l => isVariantLabel(o[l])) } function isVariantNode(o) { return !!(isControllingVariants(o) || o.variants) } function getCurrentTreeVariants(o, l) { if (isControllingVariants(o)) { const { initial: u, animate: f } = o; return { initial: u === !1 || isVariantLabel(u) ? u : void 0, animate: isVariantLabel(f) ? f : void 0 } } return o.inherit !== !1 ? l : {} } function useCreateMotionContext(o) { const { initial: l, animate: u } = getCurrentTreeVariants(o, reactExports.useContext(MotionContext)); return reactExports.useMemo(() => ({ initial: l, animate: u }), [variantLabelsAsDependency(l), variantLabelsAsDependency(u)]) } function variantLabelsAsDependency(o) { return Array.isArray(o) ? o.join(" ") : o } const featureProps = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, featureDefinitions = {}; for (const o in featureProps) featureDefinitions[o] = { isEnabled: l => featureProps[o].some(u => !!l[u]) }; function loadFeatures(o) { for (const l in o) featureDefinitions[l] = { ...featureDefinitions[l], ...o[l] } } const LayoutGroupContext = reactExports.createContext({}), motionComponentSymbol = Symbol.for("motionComponentSymbol"), noop = o => o; let invariant = noop; function createMotionComponent({ preloadedFeatures: o, createVisualElement: l, useRender: u, useVisualState: f, Component: p }) { o && loadFeatures(o); function d(v, I) { let F; const B = { ...reactExports.useContext(MotionConfigContext), ...v, layoutId: useLayoutId(v) }, { isStatic: W } = B, Z = useCreateMotionContext(v), Q = f(v, W); if (!W && isBrowser$1) { useStrictMode(); const re = getProjectionFunctionality(B); F = re.MeasureLayout, Z.visualElement = useVisualElement(p, Q, B, l, re.ProjectionNode) } return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: Z, children: [F && Z.visualElement ? jsxRuntimeExports.jsx(F, { visualElement: Z.visualElement, ...B }) : null, u(p, v, useMotionRef(Q, Z.visualElement, I), Q, W, Z.visualElement)] }) } const m = reactExports.forwardRef(d); return m[motionComponentSymbol] = p, m } function useLayoutId({ layoutId: o }) { const l = reactExports.useContext(LayoutGroupContext).id; return l && o !== void 0 ? l + "-" + o : o } function useStrictMode(o, l) { reactExports.useContext(LazyContext).strict } function getProjectionFunctionality(o) { const { drag: l, layout: u } = featureDefinitions; if (!l && !u) return {}; const f = { ...l, ...u }; return { MeasureLayout: l != null && l.isEnabled(o) || u != null && u.isEnabled(o) ? f.MeasureLayout : void 0, ProjectionNode: f.ProjectionNode } } function createMotionProxy(o) { function l(f, p = {}) { return createMotionComponent(o(f, p)) } if (typeof Proxy > "u") return l; const u = new Map; return new Proxy(l, { get: (f, p) => (u.has(p) || u.set(p, l(p)), u.get(p)) }) } const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function isSVGComponent(o) { return typeof o != "string" || o.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(o) > -1 || /[A-Z]/u.test(o)) } const scaleCorrectors = {}; function addScaleCorrector(o) { Object.assign(scaleCorrectors, o) } const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], transformProps = new Set(transformPropOrder); function isForcedMotionValue(o, { layout: l, layoutId: u }) { return transformProps.has(o) || o.startsWith("origin") || (l || u !== void 0) && (!!scaleCorrectors[o] || o === "opacity") } const isMotionValue = o => !!(o && o.getVelocity), translateAlias = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, numTransforms = transformPropOrder.length; function buildTransform(o, l, u) { let f = ""; for (let p = 0; p < numTransforms; p++) { const d = transformPropOrder[p]; if (o[d] !== void 0) { const m = translateAlias[d] || d; f += `${m}(${o[d]}) ` } } return f = f.trim(), u ? f = u(o, l ? "" : f) : l && (f = "none"), f } const checkStringStartsWith = o => l => typeof l == "string" && l.startsWith(o), isCSSVariableName = checkStringStartsWith("--"), startsAsVariableToken = checkStringStartsWith("var(--"), isCSSVariableToken = o => startsAsVariableToken(o) ? singleCssVariableRegex.test(o.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, getValueAsType = (o, l) => l && typeof o == "number" ? l.transform(o) : o, clamp = (o, l, u) => u > l ? l : u < o ? o : u, number = { test: o => typeof o == "number", parse: parseFloat, transform: o => o }, alpha = { ...number, transform: o => clamp(0, 1, o) }, scale = { ...number, default: 1 }, sanitize = o => Math.round(o * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function isString$1(o) { return typeof o == "string" } function isNullish(o) { return o == null } const createUnitType = o => ({ test: l => isString$1(l) && l.endsWith(o) && l.split(" ").length === 1, parse: parseFloat, transform: l => `${l}${o}` }), degrees = createUnitType("deg"), percent$1 = createUnitType("%"), px$1 = createUnitType("px"), vh = createUnitType("vh"), vw = createUnitType("vw"), progressPercentage = { ...percent$1, parse: o => percent$1.parse(o) / 100, transform: o => percent$1.transform(o * 100) }, int = { ...number, transform: Math.round }, numberValueTypes = { borderWidth: px$1, borderTopWidth: px$1, borderRightWidth: px$1, borderBottomWidth: px$1, borderLeftWidth: px$1, borderRadius: px$1, radius: px$1, borderTopLeftRadius: px$1, borderTopRightRadius: px$1, borderBottomRightRadius: px$1, borderBottomLeftRadius: px$1, width: px$1, maxWidth: px$1, height: px$1, maxHeight: px$1, size: px$1, top: px$1, right: px$1, bottom: px$1, left: px$1, padding: px$1, paddingTop: px$1, paddingRight: px$1, paddingBottom: px$1, paddingLeft: px$1, margin: px$1, marginTop: px$1, marginRight: px$1, marginBottom: px$1, marginLeft: px$1, rotate: degrees, rotateX: degrees, rotateY: degrees, rotateZ: degrees, scale, scaleX: scale, scaleY: scale, scaleZ: scale, skew: degrees, skewX: degrees, skewY: degrees, distance: px$1, translateX: px$1, translateY: px$1, translateZ: px$1, x: px$1, y: px$1, z: px$1, perspective: px$1, transformPerspective: px$1, opacity: alpha, originX: progressPercentage, originY: progressPercentage, originZ: px$1, zIndex: int, backgroundPositionX: px$1, backgroundPositionY: px$1, fillOpacity: alpha, strokeOpacity: alpha, numOctaves: int }; function buildHTMLStyles(o, l, u) { const { style: f, vars: p, transform: d, transformOrigin: m } = o; let v = !1, I = !1, F = !0; for (const B in l) { const W = l[B]; if (isCSSVariableName(B)) { p[B] = W; continue } const Z = numberValueTypes[B], Q = getValueAsType(W, Z); if (transformProps.has(B)) { if (v = !0, d[B] = Q, !F) continue; W !== (Z.default || 0) && (F = !1) } else B.startsWith("origin") ? (I = !0, m[B] = Q) : f[B] = Q } if (l.transform || (v || u ? f.transform = buildTransform(o.transform, F, u) : f.transform && (f.transform = "none")), I) { const { originX: B = "50%", originY: W = "50%", originZ: Z = 0 } = m; f.transformOrigin = `${B} ${W} ${Z}` } } const createHtmlRenderState = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function copyRawValuesOnly(o, l, u) { for (const f in l) !isMotionValue(l[f]) && !isForcedMotionValue(f, u) && (o[f] = l[f]) } function useInitialMotionValues({ transformTemplate: o }, l) { return reactExports.useMemo(() => { const u = createHtmlRenderState(); return buildHTMLStyles(u, l, o), Object.assign({}, u.vars, u.style) }, [l]) } function useStyle(o, l) { const u = o.style || {}, f = {}; return copyRawValuesOnly(f, u, o), Object.assign(f, useInitialMotionValues(o, l)), f } function useHTMLProps(o, l) { const u = {}, f = useStyle(o, l); return o.drag && o.dragListener !== !1 && (u.draggable = !1, f.userSelect = f.WebkitUserSelect = f.WebkitTouchCallout = "none", f.touchAction = o.drag === !0 ? "none" : `pan-${o.drag === "x" ? "y" : "x"}`), o.tabIndex === void 0 && (o.onTap || o.onTapStart || o.whileTap) && (u.tabIndex = 0), u.style = f, u } const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function isValidMotionProp(o) { return o.startsWith("while") || o.startsWith("drag") && o !== "draggable" || o.startsWith("layout") || o.startsWith("onTap") || o.startsWith("onPan") || o.startsWith("onLayout") || validMotionProps.has(o) } let shouldForward = o => !isValidMotionProp(o); function loadExternalIsValidProp(o) { o && (shouldForward = l => l.startsWith("on") ? !isValidMotionProp(l) : o(l)) } try { loadExternalIsValidProp(require("@emotion/is-prop-valid").default) } catch (o) { } function filterProps(o, l, u) { const f = {}; for (const p in o) p === "values" && typeof o.values == "object" || (shouldForward(p) || u === !0 && isValidMotionProp(p) || !l && !isValidMotionProp(p) || o.draggable && p.startsWith("onDrag")) && (f[p] = o[p]); return f } function calcOrigin$1(o, l, u) { return typeof o == "string" ? o : px$1.transform(l + u * o) } function calcSVGTransformOrigin(o, l, u) { const f = calcOrigin$1(l, o.x, o.width), p = calcOrigin$1(u, o.y, o.height); return `${f} ${p}` } const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" }; function buildSVGPath(o, l, u = 1, f = 0, p = !0) { o.pathLength = 1; const d = p ? dashKeys : camelKeys; o[d.offset] = px$1.transform(-f); const m = px$1.transform(l), v = px$1.transform(u); o[d.array] = `${m} ${v}` } function buildSVGAttrs(o, { attrX: l, attrY: u, attrScale: f, originX: p, originY: d, pathLength: m, pathSpacing: v = 1, pathOffset: I = 0, ...F }, B, W) { if (buildHTMLStyles(o, F, W), B) { o.style.viewBox && (o.attrs.viewBox = o.style.viewBox); return } o.attrs = o.style, o.style = {}; const { attrs: Z, style: Q, dimensions: re } = o; Z.transform && (re && (Q.transform = Z.transform), delete Z.transform), re && (p !== void 0 || d !== void 0 || Q.transform) && (Q.transformOrigin = calcSVGTransformOrigin(re, p !== void 0 ? p : .5, d !== void 0 ? d : .5)), l !== void 0 && (Z.x = l), u !== void 0 && (Z.y = u), f !== void 0 && (Z.scale = f), m !== void 0 && buildSVGPath(Z, m, v, I, !1) } const createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {} }), isSVGTag = o => typeof o == "string" && o.toLowerCase() === "svg"; function useSVGProps(o, l, u, f) { const p = reactExports.useMemo(() => { const d = createSvgRenderState(); return buildSVGAttrs(d, l, isSVGTag(f), o.transformTemplate), { ...d.attrs, style: { ...d.style } } }, [l]); if (o.style) { const d = {}; copyRawValuesOnly(d, o.style, o), p.style = { ...d, ...p.style } } return p } function createUseRender(o = !1) { return (u, f, p, { latestValues: d }, m) => { const I = (isSVGComponent(u) ? useSVGProps : useHTMLProps)(f, d, m, u), F = filterProps(f, typeof u == "string", o), B = u !== reactExports.Fragment ? { ...F, ...I, ref: p } : {}, { children: W } = f, Z = reactExports.useMemo(() => isMotionValue(W) ? W.get() : W, [W]); return reactExports.createElement(u, { ...B, children: Z }) } } function renderHTML(o, { style: l, vars: u }, f, p) { Object.assign(o.style, l, p && p.getProjectionStyles(f)); for (const d in u) o.style.setProperty(d, u[d]) } const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function renderSVG(o, l, u, f) { renderHTML(o, l, void 0, f); for (const p in l.attrs) o.setAttribute(camelCaseAttributes.has(p) ? p : camelToDash(p), l.attrs[p]) } function scrapeMotionValuesFromProps$1(o, l, u) { var f; const { style: p } = o, d = {}; for (const m in p) (isMotionValue(p[m]) || l.style && isMotionValue(l.style[m]) || isForcedMotionValue(m, o) || ((f = u == null ? void 0 : u.getValue(m)) === null || f === void 0 ? void 0 : f.liveStyle) !== void 0) && (d[m] = p[m]); return u && p && typeof p.willChange == "string" && (u.applyWillChange = !1), d } function scrapeMotionValuesFromProps(o, l, u) { const f = scrapeMotionValuesFromProps$1(o, l, u); for (const p in o) if (isMotionValue(o[p]) || isMotionValue(l[p])) { const d = transformPropOrder.indexOf(p) !== -1 ? "attr" + p.charAt(0).toUpperCase() + p.substring(1) : p; f[d] = o[p] } return f } function getValueState(o) { const l = [{}, {}]; return o == null || o.values.forEach((u, f) => { l[0][f] = u.get(), l[1][f] = u.getVelocity() }), l } function resolveVariantFromProps(o, l, u, f) { if (typeof l == "function") { const [p, d] = getValueState(f); l = l(u !== void 0 ? u : o.custom, p, d) } if (typeof l == "string" && (l = o.variants && o.variants[l]), typeof l == "function") { const [p, d] = getValueState(f); l = l(u !== void 0 ? u : o.custom, p, d) } return l } function useConstant(o) { const l = reactExports.useRef(null); return l.current === null && (l.current = o()), l.current } const isKeyframesTarget = o => Array.isArray(o), isCustomValue = o => !!(o && typeof o == "object" && o.mix && o.toValue), resolveFinalValueInKeyframes = o => isKeyframesTarget(o) ? o[o.length - 1] || 0 : o; function resolveMotionValue(o) { const l = isMotionValue(o) ? o.get() : o; return isCustomValue(l) ? l.toValue() : l } const acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"]); function getWillChangeName(o) { if (transformProps.has(o)) return "transform"; if (acceleratedValues.has(o)) return camelToDash(o) } function addUniqueItem(o, l) { o.indexOf(l) === -1 && o.push(l) } function removeItem(o, l) { const u = o.indexOf(l); u > -1 && o.splice(u, 1) } function makeState({ applyWillChange: o = !1, scrapeMotionValuesFromProps: l, createRenderState: u, onMount: f }, p, d, m, v) { const I = { latestValues: makeLatestValues(p, d, m, v ? !1 : o, l), renderState: u() }; return f && (I.mount = F => f(p, F, I)), I } const makeUseVisualState = o => (l, u) => { const f = reactExports.useContext(MotionContext), p = reactExports.useContext(PresenceContext), d = () => makeState(o, l, f, p, u); return u ? d() : useConstant(d) }; function addWillChange(o, l) { const u = getWillChangeName(l); u && addUniqueItem(o, u) } function forEachDefinition(o, l, u) { const f = Array.isArray(l) ? l : [l]; for (let p = 0; p < f.length; p++) { const d = resolveVariantFromProps(o, f[p]); if (d) { const { transitionEnd: m, transition: v, ...I } = d; u(I, m) } } } function makeLatestValues(o, l, u, f, p) { var d; const m = {}, v = [], I = f && ((d = o.style) === null || d === void 0 ? void 0 : d.willChange) === void 0, F = p(o, {}); for (const oe in F) m[oe] = resolveMotionValue(F[oe]); let { initial: B, animate: W } = o; const Z = isControllingVariants(o), Q = isVariantNode(o); l && Q && !Z && o.inherit !== !1 && (B === void 0 && (B = l.initial), W === void 0 && (W = l.animate)); let re = u ? u.initial === !1 : !1; re = re || B === !1; const ne = re ? W : B; return ne && typeof ne != "boolean" && !isAnimationControls(ne) && forEachDefinition(o, ne, (oe, ae) => { for (const se in oe) { let le = oe[se]; if (Array.isArray(le)) { const ue = re ? le.length - 1 : 0; le = le[ue] } le !== null && (m[se] = le) } for (const se in ae) m[se] = ae[se] }), I && (W && B !== !1 && !isAnimationControls(W) && forEachDefinition(o, W, oe => { for (const ae in oe) addWillChange(v, ae) }), v.length && (m.willChange = v.join(","))), m } const { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0), svgMotionConfig = { useVisualState: makeUseVisualState({ scrapeMotionValuesFromProps, createRenderState: createSvgRenderState, onMount: (o, l, { renderState: u, latestValues: f }) => { frame.read(() => { try { u.dimensions = typeof l.getBBox == "function" ? l.getBBox() : l.getBoundingClientRect() } catch { u.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), frame.render(() => { buildSVGAttrs(u, f, isSVGTag(l.tagName), o.transformTemplate), renderSVG(l, u) }) } }) }, htmlMotionConfig = { useVisualState: makeUseVisualState({ applyWillChange: !0, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1, createRenderState: createHtmlRenderState }) }; function createDomMotionConfig(o, { forwardMotionProps: l = !1 }, u, f) { return { ...isSVGComponent(o) ? svgMotionConfig : htmlMotionConfig, preloadedFeatures: u, useRender: createUseRender(l), createVisualElement: f, Component: o } } function addDomEvent(o, l, u, f = { passive: !0 }) { return o.addEventListener(l, u, f), () => o.removeEventListener(l, u) } const isPrimaryPointer = o => o.pointerType === "mouse" ? typeof o.button != "number" || o.button <= 0 : o.isPrimary !== !1; function extractEventInfo(o, l = "page") { return { point: { x: o[`${l}X`], y: o[`${l}Y`] } } } const addPointerInfo = o => l => isPrimaryPointer(l) && o(l, extractEventInfo(l)); function addPointerEvent(o, l, u, f) { return addDomEvent(o, l, addPointerInfo(u), f) } const combineFunctions = (o, l) => u => l(o(u)), pipe = (...o) => o.reduce(combineFunctions); function createLock(o) { let l = null; return () => { const u = () => { l = null }; return l === null ? (l = o, u) : !1 } } const globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical"); function getGlobalLock(o) { let l = !1; if (o === "y") l = globalVerticalLock(); else if (o === "x") l = globalHorizontalLock(); else { const u = globalHorizontalLock(), f = globalVerticalLock(); u && f ? l = () => { u(), f() } : (u && u(), f && f()) } return l } function isDragActive() { const o = getGlobalLock(!0); return o ? (o(), !1) : !0 } class Feature { constructor(l) { this.isMounted = !1, this.node = l } update() { } } function addHoverEvent(o, l) { const u = l ? "pointerenter" : "pointerleave", f = l ? "onHoverStart" : "onHoverEnd", p = (d, m) => { if (d.pointerType === "touch" || isDragActive()) return; const v = o.getProps(); o.animationState && v.whileHover && o.animationState.setActive("whileHover", l); const I = v[f]; I && frame.postRender(() => I(d, m)) }; return addPointerEvent(o.current, u, p, { passive: !o.getProps()[f] }) } class HoverGesture extends Feature { mount() { this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1)) } unmount() { } } class FocusGesture extends Feature { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let l = !1; try { l = this.node.current.matches(":focus-visible") } catch { l = !0 } !l || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const isNodeOrChild = (o, l) => l ? o === l ? !0 : isNodeOrChild(o, l.parentElement) : !1; function fireSyntheticPointerEvent(o, l) { if (!l) return; const u = new PointerEvent("pointer" + o); l(u, extractEventInfo(u)) } class PressGesture extends Feature { constructor() { super(...arguments), this.removeStartListeners = noop, this.removeEndListeners = noop, this.removeAccessibleListeners = noop, this.startPointerPress = (l, u) => { if (this.isPressing) return; this.removeEndListeners(); const f = this.node.getProps(), d = addPointerEvent(window, "pointerup", (v, I) => { if (!this.checkPressEnd()) return; const { onTap: F, onTapCancel: B, globalTapTarget: W } = this.node.getProps(), Z = !W && !isNodeOrChild(this.node.current, v.target) ? B : F; Z && frame.update(() => Z(v, I)) }, { passive: !(f.onTap || f.onPointerUp) }), m = addPointerEvent(window, "pointercancel", (v, I) => this.cancelPress(v, I), { passive: !(f.onTapCancel || f.onPointerCancel) }); this.removeEndListeners = pipe(d, m), this.startPress(l, u) }, this.startAccessiblePress = () => { const l = d => { if (d.key !== "Enter" || this.isPressing) return; const m = v => { v.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (I, F) => { const { onTap: B } = this.node.getProps(); B && frame.postRender(() => B(I, F)) }) }; this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", m), fireSyntheticPointerEvent("down", (v, I) => { this.startPress(v, I) }) }, u = addDomEvent(this.node.current, "keydown", l), f = () => { this.isPressing && fireSyntheticPointerEvent("cancel", (d, m) => this.cancelPress(d, m)) }, p = addDomEvent(this.node.current, "blur", f); this.removeAccessibleListeners = pipe(u, p) } } startPress(l, u) { this.isPressing = !0; const { onTapStart: f, whileTap: p } = this.node.getProps(); p && this.node.animationState && this.node.animationState.setActive("whileTap", !0), f && frame.postRender(() => f(l, u)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive() } cancelPress(l, u) { if (!this.checkPressEnd()) return; const { onTapCancel: f } = this.node.getProps(); f && frame.postRender(() => f(l, u)) } mount() { const l = this.node.getProps(), u = addPointerEvent(l.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(l.onTapStart || l.onPointerStart) }), f = addDomEvent(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = pipe(u, f) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const observerCallbacks = new WeakMap, observers = new WeakMap, fireObserverCallback = o => { const l = observerCallbacks.get(o.target); l && l(o) }, fireAllObserverCallbacks = o => { o.forEach(fireObserverCallback) }; function initIntersectionObserver({ root: o, ...l }) { const u = o || document; observers.has(u) || observers.set(u, {}); const f = observers.get(u), p = JSON.stringify(l); return f[p] || (f[p] = new IntersectionObserver(fireAllObserverCallbacks, { root: o, ...l })), f[p] } function observeIntersection(o, l, u) { const f = initIntersectionObserver(l); return observerCallbacks.set(o, u), f.observe(o), () => { observerCallbacks.delete(o), f.unobserve(o) } } const thresholdNames = { some: 0, all: 1 }; class InViewFeature extends Feature { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: l = {} } = this.node.getProps(), { root: u, margin: f, amount: p = "some", once: d } = l, m = { root: u ? u.current : void 0, rootMargin: f, threshold: typeof p == "number" ? p : thresholdNames[p] }, v = I => { const { isIntersecting: F } = I; if (this.isInView === F || (this.isInView = F, d && !F && this.hasEnteredView)) return; F && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", F); const { onViewportEnter: B, onViewportLeave: W } = this.node.getProps(), Z = F ? B : W; Z && Z(I) }; return observeIntersection(this.node.current, m, v) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: l, prevProps: u } = this.node;["amount", "margin", "root"].some(hasViewportOptionChanged(l, u)) && this.startObserver() } unmount() { } } function hasViewportOptionChanged({ viewport: o = {} }, { viewport: l = {} } = {}) { return u => o[u] !== l[u] } const gestureAnimations = { inView: { Feature: InViewFeature }, tap: { Feature: PressGesture }, focus: { Feature: FocusGesture }, hover: { Feature: HoverGesture } }; function shallowCompare(o, l) { if (!Array.isArray(l)) return !1; const u = l.length; if (u !== o.length) return !1; for (let f = 0; f < u; f++)if (l[f] !== o[f]) return !1; return !0 } function resolveVariant(o, l, u) { const f = o.getProps(); return resolveVariantFromProps(f, l, u !== void 0 ? u : f.custom, o) } const secondsToMilliseconds = o => o * 1e3, millisecondsToSeconds = o => o / 1e3, underDampedSpring = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, criticallyDampedSpring = o => ({ type: "spring", stiffness: 550, damping: o === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), keyframesTransition = { type: "keyframes", duration: .8 }, ease = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, getDefaultTransition = (o, { keyframes: l }) => l.length > 2 ? keyframesTransition : transformProps.has(o) ? o.startsWith("scale") ? criticallyDampedSpring(l[1]) : underDampedSpring : ease; function isTransitionDefined({ when: o, delay: l, delayChildren: u, staggerChildren: f, staggerDirection: p, repeat: d, repeatType: m, repeatDelay: v, from: I, elapsed: F, ...B }) { return !!Object.keys(B).length } function getValueTransition$1(o, l) { return o[l] || o.default || o } const isNotNull = o => o !== null; function getFinalKeyframe(o, { repeat: l, repeatType: u = "loop" }, f) { const p = o.filter(isNotNull), d = l && u !== "loop" && l % 2 === 1 ? 0 : p.length - 1; return !d || f === void 0 ? p[d] : f } let now$1; function clearTime() { now$1 = void 0 } const time = { now: () => (now$1 === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now$1), set: o => { now$1 = o, queueMicrotask(clearTime) } }, isZeroValueString = o => /^0[^.\s]+$/u.test(o); function isNone(o) { return typeof o == "number" ? o === 0 : o !== null ? o === "none" || o === "0" || isZeroValueString(o) : !0 } const isNumericalString = o => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(o), splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function parseCSSVariable(o) { const l = splitCSSVariableRegex.exec(o); if (!l) return [,]; const [, u, f, p] = l; return [`--${u ?? f}`, p] } function getVariableValue(o, l, u = 1) { const [f, p] = parseCSSVariable(o); if (!f) return; const d = window.getComputedStyle(l).getPropertyValue(f); if (d) { const m = d.trim(); return isNumericalString(m) ? parseFloat(m) : m } return isCSSVariableToken(p) ? getVariableValue(p, l, u + 1) : p } const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), isNumOrPxType = o => o === number || o === px$1, getPosFromMatrix = (o, l) => parseFloat(o.split(", ")[l]), getTranslateFromMatrix = (o, l) => (u, { transform: f }) => { if (f === "none" || !f) return 0; const p = f.match(/^matrix3d\((.+)\)$/u); if (p) return getPosFromMatrix(p[1], l); { const d = f.match(/^matrix\((.+)\)$/u); return d ? getPosFromMatrix(d[1], o) : 0 } }, transformKeys = new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter(o => !transformKeys.has(o)); function removeNonTranslationalTransform(o) { const l = []; return nonTranslationalTransformKeys.forEach(u => { const f = o.getValue(u); f !== void 0 && (l.push([u, f.get()]), f.set(u.startsWith("scale") ? 1 : 0)) }), l } const positionalValues = { width: ({ x: o }, { paddingLeft: l = "0", paddingRight: u = "0" }) => o.max - o.min - parseFloat(l) - parseFloat(u), height: ({ y: o }, { paddingTop: l = "0", paddingBottom: u = "0" }) => o.max - o.min - parseFloat(l) - parseFloat(u), top: (o, { top: l }) => parseFloat(l), left: (o, { left: l }) => parseFloat(l), bottom: ({ y: o }, { top: l }) => parseFloat(l) + (o.max - o.min), right: ({ x: o }, { left: l }) => parseFloat(l) + (o.max - o.min), x: getTranslateFromMatrix(4, 13), y: getTranslateFromMatrix(5, 14) }; positionalValues.translateX = positionalValues.x; positionalValues.translateY = positionalValues.y; const testValueType = o => l => l.test(o), auto = { test: o => o === "auto", parse: o => o }, dimensionValueTypes = [number, px$1, percent$1, degrees, vw, vh, auto], findDimensionValueType = o => dimensionValueTypes.find(testValueType(o)), toResolve = new Set; let isScheduled = !1, anyNeedsMeasurement = !1; function measureAllKeyframes() { if (anyNeedsMeasurement) { const o = Array.from(toResolve).filter(f => f.needsMeasurement), l = new Set(o.map(f => f.element)), u = new Map; l.forEach(f => { const p = removeNonTranslationalTransform(f); p.length && (u.set(f, p), f.render()) }), o.forEach(f => f.measureInitialState()), l.forEach(f => { f.render(); const p = u.get(f); p && p.forEach(([d, m]) => { var v; (v = f.getValue(d)) === null || v === void 0 || v.set(m) }) }), o.forEach(f => f.measureEndState()), o.forEach(f => { f.suspendedScrollY !== void 0 && window.scrollTo(0, f.suspendedScrollY) }) } anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach(o => o.complete()), toResolve.clear() } function readAllKeyframes() { toResolve.forEach(o => { o.readKeyframes(), o.needsMeasurement && (anyNeedsMeasurement = !0) }) } function flushKeyframeResolvers() { readAllKeyframes(), measureAllKeyframes() } class KeyframeResolver { constructor(l, u, f, p, d, m = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...l], this.onComplete = u, this.name = f, this.motionValue = p, this.element = d, this.isAsync = m } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: l, name: u, element: f, motionValue: p } = this; for (let d = 0; d < l.length; d++)if (l[d] === null) if (d === 0) { const m = p == null ? void 0 : p.get(), v = l[l.length - 1]; if (m !== void 0) l[0] = m; else if (f && u) { const I = f.readValue(u, v); I != null && (l[0] = I) } l[0] === void 0 && (l[0] = v), p && m === void 0 && p.set(l[0]) } else l[d] = l[d - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), toResolve.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, toResolve.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const isColorString = (o, l) => u => !!(isString$1(u) && singleColorRegex.test(u) && u.startsWith(o) || l && !isNullish(u) && Object.prototype.hasOwnProperty.call(u, l)), splitColor = (o, l, u) => f => { if (!isString$1(f)) return f; const [p, d, m, v] = f.match(floatRegex); return { [o]: parseFloat(p), [l]: parseFloat(d), [u]: parseFloat(m), alpha: v !== void 0 ? parseFloat(v) : 1 } }, clampRgbUnit = o => clamp(0, 255, o), rgbUnit = { ...number, transform: o => Math.round(clampRgbUnit(o)) }, rgba = { test: isColorString("rgb", "red"), parse: splitColor("red", "green", "blue"), transform: ({ red: o, green: l, blue: u, alpha: f = 1 }) => "rgba(" + rgbUnit.transform(o) + ", " + rgbUnit.transform(l) + ", " + rgbUnit.transform(u) + ", " + sanitize(alpha.transform(f)) + ")" }; function parseHex(o) { let l = "", u = "", f = "", p = ""; return o.length > 5 ? (l = o.substring(1, 3), u = o.substring(3, 5), f = o.substring(5, 7), p = o.substring(7, 9)) : (l = o.substring(1, 2), u = o.substring(2, 3), f = o.substring(3, 4), p = o.substring(4, 5), l += l, u += u, f += f, p += p), { red: parseInt(l, 16), green: parseInt(u, 16), blue: parseInt(f, 16), alpha: p ? parseInt(p, 16) / 255 : 1 } } const hex = { test: isColorString("#"), parse: parseHex, transform: rgba.transform }, hsla = { test: isColorString("hsl", "hue"), parse: splitColor("hue", "saturation", "lightness"), transform: ({ hue: o, saturation: l, lightness: u, alpha: f = 1 }) => "hsla(" + Math.round(o) + ", " + percent$1.transform(sanitize(l)) + ", " + percent$1.transform(sanitize(u)) + ", " + sanitize(alpha.transform(f)) + ")" }, color = { test: o => rgba.test(o) || hex.test(o) || hsla.test(o), parse: o => rgba.test(o) ? rgba.parse(o) : hsla.test(o) ? hsla.parse(o) : hex.parse(o), transform: o => isString$1(o) ? o : o.hasOwnProperty("red") ? rgba.transform(o) : hsla.transform(o) }; function test(o) { var l, u; return isNaN(o) && isString$1(o) && (((l = o.match(floatRegex)) === null || l === void 0 ? void 0 : l.length) || 0) + (((u = o.match(colorRegex)) === null || u === void 0 ? void 0 : u.length) || 0) > 0 } const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function analyseComplexValue(o) { const l = o.toString(), u = [], f = { color: [], number: [], var: [] }, p = []; let d = 0; const v = l.replace(complexRegex, I => (color.test(I) ? (f.color.push(d), p.push(COLOR_TOKEN), u.push(color.parse(I))) : I.startsWith(VAR_FUNCTION_TOKEN) ? (f.var.push(d), p.push(VAR_TOKEN), u.push(I)) : (f.number.push(d), p.push(NUMBER_TOKEN), u.push(parseFloat(I))), ++d, SPLIT_TOKEN)).split(SPLIT_TOKEN); return { values: u, split: v, indexes: f, types: p } } function parseComplexValue(o) { return analyseComplexValue(o).values } function createTransformer(o) { const { split: l, types: u } = analyseComplexValue(o), f = l.length; return p => { let d = ""; for (let m = 0; m < f; m++)if (d += l[m], p[m] !== void 0) { const v = u[m]; v === NUMBER_TOKEN ? d += sanitize(p[m]) : v === COLOR_TOKEN ? d += color.transform(p[m]) : d += p[m] } return d } } const convertNumbersToZero = o => typeof o == "number" ? 0 : o; function getAnimatableNone$1(o) { const l = parseComplexValue(o); return createTransformer(o)(l.map(convertNumbersToZero)) } const complex = { test, parse: parseComplexValue, createTransformer, getAnimatableNone: getAnimatableNone$1 }, maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]); function applyDefaultFilter(o) { const [l, u] = o.slice(0, -1).split("("); if (l === "drop-shadow") return o; const [f] = u.match(floatRegex) || []; if (!f) return o; const p = u.replace(f, ""); let d = maxDefaults.has(l) ? 1 : 0; return f !== u && (d *= 100), l + "(" + d + p + ")" } const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = { ...complex, getAnimatableNone: o => { const l = o.match(functionRegex); return l ? l.map(applyDefaultFilter).join(" ") : o } }, defaultValueTypes = { ...numberValueTypes, color, backgroundColor: color, outlineColor: color, fill: color, stroke: color, borderColor: color, borderTopColor: color, borderRightColor: color, borderBottomColor: color, borderLeftColor: color, filter, WebkitFilter: filter }, getDefaultValueType = o => defaultValueTypes[o]; function getAnimatableNone(o, l) { let u = getDefaultValueType(o); return u !== filter && (u = complex), u.getAnimatableNone ? u.getAnimatableNone(l) : void 0 } const invalidTemplates = new Set(["auto", "none", "0"]); function makeNoneKeyframesAnimatable(o, l, u) { let f = 0, p; for (; f < o.length && !p;) { const d = o[f]; typeof d == "string" && !invalidTemplates.has(d) && analyseComplexValue(d).values.length && (p = o[f]), f++ } if (p && u) for (const d of l) o[d] = getAnimatableNone(u, p) } class DOMKeyframesResolver extends KeyframeResolver { constructor(l, u, f, p) { super(l, u, f, p, p == null ? void 0 : p.owner, !0) } readKeyframes() { const { unresolvedKeyframes: l, element: u, name: f } = this; if (!u.current) return; super.readKeyframes(); for (let I = 0; I < l.length; I++) { let F = l[I]; if (typeof F == "string" && (F = F.trim(), isCSSVariableToken(F))) { const B = getVariableValue(F, u.current); B !== void 0 && (l[I] = B), I === l.length - 1 && (this.finalKeyframe = F) } } if (this.resolveNoneKeyframes(), !positionalKeys.has(f) || l.length !== 2) return; const [p, d] = l, m = findDimensionValueType(p), v = findDimensionValueType(d); if (m !== v) if (isNumOrPxType(m) && isNumOrPxType(v)) for (let I = 0; I < l.length; I++) { const F = l[I]; typeof F == "string" && (l[I] = parseFloat(F)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: l, name: u } = this, f = []; for (let p = 0; p < l.length; p++)isNone(l[p]) && f.push(p); f.length && makeNoneKeyframesAnimatable(l, f, u) } measureInitialState() { const { element: l, unresolvedKeyframes: u, name: f } = this; if (!l.current) return; f === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[f](l.measureViewportBox(), window.getComputedStyle(l.current)), u[0] = this.measuredOrigin; const p = u[u.length - 1]; p !== void 0 && l.getValue(f, p).jump(p, !1) } measureEndState() { var l; const { element: u, name: f, unresolvedKeyframes: p } = this; if (!u.current) return; const d = u.getValue(f); d && d.jump(this.measuredOrigin, !1); const m = p.length - 1, v = p[m]; p[m] = positionalValues[f](u.measureViewportBox(), window.getComputedStyle(u.current)), v !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = v), !((l = this.removedTransforms) === null || l === void 0) && l.length && this.removedTransforms.forEach(([I, F]) => { u.getValue(I).set(F) }), this.resolveNoneKeyframes() } } function memo(o) { let l; return () => (l === void 0 && (l = o()), l) } const isAnimatable = (o, l) => l === "zIndex" ? !1 : !!(typeof o == "number" || Array.isArray(o) || typeof o == "string" && (complex.test(o) || o === "0") && !o.startsWith("url(")); function hasKeyframesChanged(o) { const l = o[0]; if (o.length === 1) return !0; for (let u = 0; u < o.length; u++)if (o[u] !== l) return !0 } function canAnimate(o, l, u, f) { const p = o[0]; if (p === null) return !1; if (l === "display" || l === "visibility") return !0; const d = o[o.length - 1], m = isAnimatable(p, l), v = isAnimatable(d, l); return !m || !v ? !1 : hasKeyframesChanged(o) || u === "spring" && f } class BaseAnimation { constructor({ autoplay: l = !0, delay: u = 0, type: f = "keyframes", repeat: p = 0, repeatDelay: d = 0, repeatType: m = "loop", ...v }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = { autoplay: l, delay: u, type: f, repeat: p, repeatDelay: d, repeatType: m, ...v }, this.updateFinishedPromise() } get resolved() { return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(), this._resolved } onKeyframesResolved(l, u) { this.hasAttemptedResolve = !0; const { name: f, type: p, velocity: d, delay: m, onComplete: v, onUpdate: I, isGenerator: F } = this.options; if (!F && !canAnimate(l, f, p, d)) if (m) this.options.duration = 0; else { I == null || I(getFinalKeyframe(l, this.options, u)), v == null || v(), this.resolveFinishedPromise(); return } const B = this.initPlayback(l, u); B !== !1 && (this._resolved = { keyframes: l, finalKeyframe: u, ...B }, this.onPostResolved()) } onPostResolved() { } then(l, u) { return this.currentFinishedPromise.then(l, u) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(l => { this.resolveFinishedPromise = l }) } } function velocityPerSecond(o, l) { return l ? o * (1e3 / l) : 0 } const velocitySampleDuration = 5; function calcGeneratorVelocity(o, l, u) { const f = Math.max(l - velocitySampleDuration, 0); return velocityPerSecond(u - o(f), l - f) } const safeMin = .001, minDuration = .01, maxDuration$1 = 10, minDamping = .05, maxDamping = 1; function findSpring({ duration: o = 800, bounce: l = .25, velocity: u = 0, mass: f = 1 }) { let p, d, m = 1 - l; m = clamp(minDamping, maxDamping, m), o = clamp(minDuration, maxDuration$1, millisecondsToSeconds(o)), m < 1 ? (p = F => { const B = F * m, W = B * o, Z = B - u, Q = calcAngularFreq(F, m), re = Math.exp(-W); return safeMin - Z / Q * re }, d = F => { const W = F * m * o, Z = W * u + u, Q = Math.pow(m, 2) * Math.pow(F, 2) * o, re = Math.exp(-W), ne = calcAngularFreq(Math.pow(F, 2), m); return (-p(F) + safeMin > 0 ? -1 : 1) * ((Z - Q) * re) / ne }) : (p = F => { const B = Math.exp(-F * o), W = (F - u) * o + 1; return -safeMin + B * W }, d = F => { const B = Math.exp(-F * o), W = (u - F) * (o * o); return B * W }); const v = 5 / o, I = approximateRoot(p, d, v); if (o = secondsToMilliseconds(o), isNaN(I)) return { stiffness: 100, damping: 10, duration: o }; { const F = Math.pow(I, 2) * f; return { stiffness: F, damping: m * 2 * Math.sqrt(f * F), duration: o } } } const rootIterations = 12; function approximateRoot(o, l, u) { let f = u; for (let p = 1; p < rootIterations; p++)f = f - o(f) / l(f); return f } function calcAngularFreq(o, l) { return o * Math.sqrt(1 - l * l) } const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"]; function isSpringType(o, l) { return l.some(u => o[u] !== void 0) } function getSpringOptions(o) { let l = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...o }; if (!isSpringType(o, physicsKeys) && isSpringType(o, durationKeys)) { const u = findSpring(o); l = { ...l, ...u, mass: 1 }, l.isResolvedFromDuration = !0 } return l } function spring({ keyframes: o, restDelta: l, restSpeed: u, ...f }) { const p = o[0], d = o[o.length - 1], m = { done: !1, value: p }, { stiffness: v, damping: I, mass: F, duration: B, velocity: W, isResolvedFromDuration: Z } = getSpringOptions({ ...f, velocity: -millisecondsToSeconds(f.velocity || 0) }), Q = W || 0, re = I / (2 * Math.sqrt(v * F)), ne = d - p, oe = millisecondsToSeconds(Math.sqrt(v / F)), ae = Math.abs(ne) < 5; u || (u = ae ? .01 : 2), l || (l = ae ? .005 : .5); let se; if (re < 1) { const le = calcAngularFreq(oe, re); se = ue => { const he = Math.exp(-re * oe * ue); return d - he * ((Q + re * oe * ne) / le * Math.sin(le * ue) + ne * Math.cos(le * ue)) } } else if (re === 1) se = le => d - Math.exp(-oe * le) * (ne + (Q + oe * ne) * le); else { const le = oe * Math.sqrt(re * re - 1); se = ue => { const he = Math.exp(-re * oe * ue), pe = Math.min(le * ue, 300); return d - he * ((Q + re * oe * ne) * Math.sinh(pe) + le * ne * Math.cosh(pe)) / le } } return { calculatedDuration: Z && B || null, next: le => { const ue = se(le); if (Z) m.done = le >= B; else { let he = Q; le !== 0 && (re < 1 ? he = calcGeneratorVelocity(se, le, ue) : he = 0); const pe = Math.abs(he) <= u, ve = Math.abs(d - ue) <= l; m.done = pe && ve } return m.value = m.done ? d : ue, m } } } function inertia({ keyframes: o, velocity: l = 0, power: u = .8, timeConstant: f = 325, bounceDamping: p = 10, bounceStiffness: d = 500, modifyTarget: m, min: v, max: I, restDelta: F = .5, restSpeed: B }) { const W = o[0], Z = { done: !1, value: W }, Q = _e => v !== void 0 && _e < v || I !== void 0 && _e > I, re = _e => v === void 0 ? I : I === void 0 || Math.abs(v - _e) < Math.abs(I - _e) ? v : I; let ne = u * l; const oe = W + ne, ae = m === void 0 ? oe : m(oe); ae !== oe && (ne = ae - W); const se = _e => -ne * Math.exp(-_e / f), le = _e => ae + se(_e), ue = _e => { const Se = se(_e), $e = le(_e); Z.done = Math.abs(Se) <= F, Z.value = Z.done ? ae : $e }; let he, pe; const ve = _e => { Q(Z.value) && (he = _e, pe = spring({ keyframes: [Z.value, re(Z.value)], velocity: calcGeneratorVelocity(le, _e, Z.value), damping: p, stiffness: d, restDelta: F, restSpeed: B })) }; return ve(0), { calculatedDuration: null, next: _e => { let Se = !1; return !pe && he === void 0 && (Se = !0, ue(_e), ve(_e)), he !== void 0 && _e >= he ? pe.next(_e - he) : (!Se && ue(_e), Z) } } } const calcBezier = (o, l, u) => (((1 - 3 * u + 3 * l) * o + (3 * u - 6 * l)) * o + 3 * l) * o, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12; function binarySubdivide(o, l, u, f, p) { let d, m, v = 0; do m = l + (u - l) / 2, d = calcBezier(m, f, p) - o, d > 0 ? u = m : l = m; while (Math.abs(d) > subdivisionPrecision && ++v < subdivisionMaxIterations); return m } function cubicBezier(o, l, u, f) { if (o === l && u === f) return noop; const p = d => binarySubdivide(d, 0, 1, o, u); return d => d === 0 || d === 1 ? d : calcBezier(p(d), l, f) } const easeIn = cubicBezier(.42, 0, 1, 1), easeOut = cubicBezier(0, 0, .58, 1), easeInOut = cubicBezier(.42, 0, .58, 1), isEasingArray = o => Array.isArray(o) && typeof o[0] != "number", mirrorEasing = o => l => l <= .5 ? o(2 * l) / 2 : (2 - o(2 * (1 - l))) / 2, reverseEasing = o => l => 1 - o(1 - l), circIn = o => 1 - Math.sin(Math.acos(o)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), backOut = cubicBezier(.33, 1.53, .69, .99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn), anticipate = o => (o *= 2) < 1 ? .5 * backIn(o) : .5 * (2 - Math.pow(2, -10 * (o - 1))), easingLookup = { linear: noop, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate }, easingDefinitionToFunction = o => { if (Array.isArray(o)) { invariant(o.length === 4); const [l, u, f, p] = o; return cubicBezier(l, u, f, p) } else if (typeof o == "string") return easingLookup[o]; return o }, progress = (o, l, u) => { const f = l - o; return f === 0 ? 1 : (u - o) / f }, mixNumber$1 = (o, l, u) => o + (l - o) * u; function hueToRgb(o, l, u) { return u < 0 && (u += 1), u > 1 && (u -= 1), u < 1 / 6 ? o + (l - o) * 6 * u : u < 1 / 2 ? l : u < 2 / 3 ? o + (l - o) * (2 / 3 - u) * 6 : o } function hslaToRgba({ hue: o, saturation: l, lightness: u, alpha: f }) { o /= 360, l /= 100, u /= 100; let p = 0, d = 0, m = 0; if (!l) p = d = m = u; else { const v = u < .5 ? u * (1 + l) : u + l - u * l, I = 2 * u - v; p = hueToRgb(I, v, o + 1 / 3), d = hueToRgb(I, v, o), m = hueToRgb(I, v, o - 1 / 3) } return { red: Math.round(p * 255), green: Math.round(d * 255), blue: Math.round(m * 255), alpha: f } } function mixImmediate(o, l) { return u => u > 0 ? l : o } const mixLinearColor = (o, l, u) => { const f = o * o, p = u * (l * l - f) + f; return p < 0 ? 0 : Math.sqrt(p) }, colorTypes = [hex, rgba, hsla], getColorType = o => colorTypes.find(l => l.test(o)); function asRGBA(o) { const l = getColorType(o); if (!l) return !1; let u = l.parse(o); return l === hsla && (u = hslaToRgba(u)), u } const mixColor = (o, l) => { const u = asRGBA(o), f = asRGBA(l); if (!u || !f) return mixImmediate(o, l); const p = { ...u }; return d => (p.red = mixLinearColor(u.red, f.red, d), p.green = mixLinearColor(u.green, f.green, d), p.blue = mixLinearColor(u.blue, f.blue, d), p.alpha = mixNumber$1(u.alpha, f.alpha, d), rgba.transform(p)) }, invisibleValues = new Set(["none", "hidden"]); function mixVisibility(o, l) { return invisibleValues.has(o) ? u => u <= 0 ? o : l : u => u >= 1 ? l : o } function mixNumber(o, l) { return u => mixNumber$1(o, l, u) } function getMixer(o) { return typeof o == "number" ? mixNumber : typeof o == "string" ? isCSSVariableToken(o) ? mixImmediate : color.test(o) ? mixColor : mixComplex : Array.isArray(o) ? mixArray : typeof o == "object" ? color.test(o) ? mixColor : mixObject : mixImmediate } function mixArray(o, l) { const u = [...o], f = u.length, p = o.map((d, m) => getMixer(d)(d, l[m])); return d => { for (let m = 0; m < f; m++)u[m] = p[m](d); return u } } function mixObject(o, l) { const u = { ...o, ...l }, f = {}; for (const p in u) o[p] !== void 0 && l[p] !== void 0 && (f[p] = getMixer(o[p])(o[p], l[p])); return p => { for (const d in f) u[d] = f[d](p); return u } } function matchOrder(o, l) { var u; const f = [], p = { color: 0, var: 0, number: 0 }; for (let d = 0; d < l.values.length; d++) { const m = l.types[d], v = o.indexes[m][p[m]], I = (u = o.values[v]) !== null && u !== void 0 ? u : 0; f[d] = I, p[m]++ } return f } const mixComplex = (o, l) => { const u = complex.createTransformer(l), f = analyseComplexValue(o), p = analyseComplexValue(l); return f.indexes.var.length === p.indexes.var.length && f.indexes.color.length === p.indexes.color.length && f.indexes.number.length >= p.indexes.number.length ? invisibleValues.has(o) && !p.values.length || invisibleValues.has(l) && !f.values.length ? mixVisibility(o, l) : pipe(mixArray(matchOrder(f, p), p.values), u) : mixImmediate(o, l) }; function mix(o, l, u) { return typeof o == "number" && typeof l == "number" && typeof u == "number" ? mixNumber$1(o, l, u) : getMixer(o)(o, l) } function createMixers(o, l, u) { const f = [], p = u || mix, d = o.length - 1; for (let m = 0; m < d; m++) { let v = p(o[m], o[m + 1]); if (l) { const I = Array.isArray(l) ? l[m] || noop : l; v = pipe(I, v) } f.push(v) } return f } function interpolate(o, l, { clamp: u = !0, ease: f, mixer: p } = {}) { const d = o.length; if (invariant(d === l.length), d === 1) return () => l[0]; if (d === 2 && o[0] === o[1]) return () => l[1]; o[0] > o[d - 1] && (o = [...o].reverse(), l = [...l].reverse()); const m = createMixers(l, f, p), v = m.length, I = F => { let B = 0; if (v > 1) for (; B < o.length - 2 && !(F < o[B + 1]); B++); const W = progress(o[B], o[B + 1], F); return m[B](W) }; return u ? F => I(clamp(o[0], o[d - 1], F)) : I } function fillOffset(o, l) { const u = o[o.length - 1]; for (let f = 1; f <= l; f++) { const p = progress(0, l, f); o.push(mixNumber$1(u, 1, p)) } } function defaultOffset(o) { const l = [0]; return fillOffset(l, o.length - 1), l } function convertOffsetToTimes(o, l) { return o.map(u => u * l) } function defaultEasing(o, l) { return o.map(() => l || easeInOut).splice(0, o.length - 1) } function keyframes({ duration: o = 300, keyframes: l, times: u, ease: f = "easeInOut" }) { const p = isEasingArray(f) ? f.map(easingDefinitionToFunction) : easingDefinitionToFunction(f), d = { done: !1, value: l[0] }, m = convertOffsetToTimes(u && u.length === l.length ? u : defaultOffset(l), o), v = interpolate(m, l, { ease: Array.isArray(p) ? p : defaultEasing(l, p) }); return { calculatedDuration: o, next: I => (d.value = v(I), d.done = I >= o, d) } } const maxGeneratorDuration = 2e4; function calcGeneratorDuration(o) { let l = 0; const u = 50; let f = o.next(l); for (; !f.done && l < maxGeneratorDuration;)l += u, f = o.next(l); return l >= maxGeneratorDuration ? 1 / 0 : l } const frameloopDriver = o => { const l = ({ timestamp: u }) => o(u); return { start: () => frame.update(l, !0), stop: () => cancelFrame(l), now: () => frameData.isProcessing ? frameData.timestamp : time.now() } }, generators = { decay: inertia, inertia, tween: keyframes, keyframes, spring }, percentToProgress = o => o / 100; class MainThreadAnimation extends BaseAnimation { constructor({ KeyframeResolver: l = KeyframeResolver, ...u }) { super(u), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: v } = this.options; v && v() }; const { name: f, motionValue: p, keyframes: d } = this.options, m = (v, I) => this.onKeyframesResolved(v, I); f && p && p.owner ? this.resolver = p.owner.resolveKeyframes(d, m, f, p) : this.resolver = new l(d, m, f, p), this.resolver.scheduleResolve() } initPlayback(l) { const { type: u = "keyframes", repeat: f = 0, repeatDelay: p = 0, repeatType: d, velocity: m = 0 } = this.options, v = generators[u] || keyframes; let I, F; v !== keyframes && typeof l[0] != "number" && (I = pipe(percentToProgress, mix(l[0], l[1])), l = [0, 100]); const B = v({ ...this.options, keyframes: l }); d === "mirror" && (F = v({ ...this.options, keyframes: [...l].reverse(), velocity: -m })), B.calculatedDuration === null && (B.calculatedDuration = calcGeneratorDuration(B)); const { calculatedDuration: W } = B, Z = W + p, Q = Z * (f + 1) - p; return { generator: B, mirroredGenerator: F, mapPercentToKeyframes: I, calculatedDuration: W, resolvedDuration: Z, totalDuration: Q } } onPostResolved() { const { autoplay: l = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !l ? this.pause() : this.state = this.pendingPlayState } tick(l, u = !1) { const { resolved: f } = this; if (!f) { const { keyframes: _e } = this.options; return { done: !0, value: _e[_e.length - 1] } } const { finalKeyframe: p, generator: d, mirroredGenerator: m, mapPercentToKeyframes: v, keyframes: I, calculatedDuration: F, totalDuration: B, resolvedDuration: W } = f; if (this.startTime === null) return d.next(0); const { delay: Z, repeat: Q, repeatType: re, repeatDelay: ne, onUpdate: oe } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, l) : this.speed < 0 && (this.startTime = Math.min(l - B / this.speed, this.startTime)), u ? this.currentTime = l : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(l - this.startTime) * this.speed; const ae = this.currentTime - Z * (this.speed >= 0 ? 1 : -1), se = this.speed >= 0 ? ae < 0 : ae > B; this.currentTime = Math.max(ae, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = B); let le = this.currentTime, ue = d; if (Q) { const _e = Math.min(this.currentTime, B) / W; let Se = Math.floor(_e), $e = _e % 1; !$e && _e >= 1 && ($e = 1), $e === 1 && Se--, Se = Math.min(Se, Q + 1), !!(Se % 2) && (re === "reverse" ? ($e = 1 - $e, ne && ($e -= ne / W)) : re === "mirror" && (ue = m)), le = clamp(0, 1, $e) * W } const he = se ? { done: !1, value: I[0] } : ue.next(le); v && (he.value = v(he.value)); let { done: pe } = he; !se && F !== null && (pe = this.speed >= 0 ? this.currentTime >= B : this.currentTime <= 0); const ve = this.holdTime === null && (this.state === "finished" || this.state === "running" && pe); return ve && p !== void 0 && (he.value = getFinalKeyframe(I, this.options, p)), oe && oe(he.value), ve && this.finish(), he } get duration() { const { resolved: l } = this; return l ? millisecondsToSeconds(l.calculatedDuration) : 0 } get time() { return millisecondsToSeconds(this.currentTime) } set time(l) { l = secondsToMilliseconds(l), this.currentTime = l, this.holdTime !== null || this.speed === 0 ? this.holdTime = l : this.driver && (this.startTime = this.driver.now() - l / this.speed) } get speed() { return this.playbackSpeed } set speed(l) { const u = this.playbackSpeed !== l; this.playbackSpeed = l, u && (this.time = millisecondsToSeconds(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: l = frameloopDriver, onPlay: u } = this.options; this.driver || (this.driver = l(p => this.tick(p))), u && u(); const f = this.driver.now(); this.holdTime !== null ? this.startTime = f - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = f), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var l; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (l = this.currentTime) !== null && l !== void 0 ? l : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: l } = this.options; l && l() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(l) { return this.startTime = 0, this.tick(l, !0) } } const isBezierDefinition = o => Array.isArray(o) && typeof o[0] == "number"; function isWaapiSupportedEasing(o) { return !!(!o || typeof o == "string" && o in supportedWaapiEasing || isBezierDefinition(o) || Array.isArray(o) && o.every(isWaapiSupportedEasing)) } const cubicBezierAsString = ([o, l, u, f]) => `cubic-bezier(${o}, ${l}, ${u}, ${f})`, supportedWaapiEasing = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: cubicBezierAsString([0, .65, .55, 1]), circOut: cubicBezierAsString([.55, 0, 1, .45]), backIn: cubicBezierAsString([.31, .01, .66, -.59]), backOut: cubicBezierAsString([.33, 1.53, .69, .99]) }; function mapEasingToNativeEasingWithDefault(o) { return mapEasingToNativeEasing(o) || supportedWaapiEasing.easeOut } function mapEasingToNativeEasing(o) { if (o) return isBezierDefinition(o) ? cubicBezierAsString(o) : Array.isArray(o) ? o.map(mapEasingToNativeEasingWithDefault) : supportedWaapiEasing[o] } function animateStyle(o, l, u, { delay: f = 0, duration: p = 300, repeat: d = 0, repeatType: m = "loop", ease: v, times: I } = {}) { const F = { [l]: u }; I && (F.offset = I); const B = mapEasingToNativeEasing(v); return Array.isArray(B) && (F.easing = B), o.animate(F, { delay: f, duration: p, easing: Array.isArray(B) ? "linear" : B, fill: "both", iterations: d + 1, direction: m === "reverse" ? "alternate" : "normal" }) } const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), sampleDelta = 10, maxDuration = 2e4; function requiresPregeneratedKeyframes(o) { return o.type === "spring" || !isWaapiSupportedEasing(o.ease) } function pregenerateKeyframes(o, l) { const u = new MainThreadAnimation({ ...l, keyframes: o, repeat: 0, delay: 0, isGenerator: !0 }); let f = { done: !1, value: o[0] }; const p = []; let d = 0; for (; !f.done && d < maxDuration;)f = u.sample(d), p.push(f.value), d += sampleDelta; return { times: void 0, keyframes: p, duration: d - sampleDelta, ease: "linear" } } class AcceleratedAnimation extends BaseAnimation { constructor(l) { super(l); const { name: u, motionValue: f, keyframes: p } = this.options; this.resolver = new DOMKeyframesResolver(p, (d, m) => this.onKeyframesResolved(d, m), u, f), this.resolver.scheduleResolve() } initPlayback(l, u) { var f; let { duration: p = 300, times: d, ease: m, type: v, motionValue: I, name: F } = this.options; if (!(!((f = I.owner) === null || f === void 0) && f.current)) return !1; if (requiresPregeneratedKeyframes(this.options)) { const { onComplete: W, onUpdate: Z, motionValue: Q, ...re } = this.options, ne = pregenerateKeyframes(l, re); l = ne.keyframes, l.length === 1 && (l[1] = l[0]), p = ne.duration, d = ne.times, m = ne.ease, v = "keyframes" } const B = animateStyle(I.owner.current, F, l, { ...this.options, duration: p, times: d, ease: m }); return B.startTime = time.now(), this.pendingTimeline ? (B.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : B.onfinish = () => { const { onComplete: W } = this.options; I.set(getFinalKeyframe(l, this.options, u)), W && W(), this.cancel(), this.resolveFinishedPromise() }, { animation: B, duration: p, times: d, type: v, ease: m, keyframes: l } } get duration() { const { resolved: l } = this; if (!l) return 0; const { duration: u } = l; return millisecondsToSeconds(u) } get time() { const { resolved: l } = this; if (!l) return 0; const { animation: u } = l; return millisecondsToSeconds(u.currentTime || 0) } set time(l) { const { resolved: u } = this; if (!u) return; const { animation: f } = u; f.currentTime = secondsToMilliseconds(l) } get speed() { const { resolved: l } = this; if (!l) return 1; const { animation: u } = l; return u.playbackRate } set speed(l) { const { resolved: u } = this; if (!u) return; const { animation: f } = u; f.playbackRate = l } get state() { const { resolved: l } = this; if (!l) return "idle"; const { animation: u } = l; return u.playState } attachTimeline(l) { if (!this._resolved) this.pendingTimeline = l; else { const { resolved: u } = this; if (!u) return noop; const { animation: f } = u; f.timeline = l, f.onfinish = null } return noop } play() { if (this.isStopped) return; const { resolved: l } = this; if (!l) return; const { animation: u } = l; u.playState === "finished" && this.updateFinishedPromise(), u.play() } pause() { const { resolved: l } = this; if (!l) return; const { animation: u } = l; u.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; const { resolved: l } = this; if (!l) return; const { animation: u, keyframes: f, duration: p, type: d, ease: m, times: v } = l; if (u.playState === "idle" || u.playState === "finished") return; if (this.time) { const { motionValue: F, onUpdate: B, onComplete: W, ...Z } = this.options, Q = new MainThreadAnimation({ ...Z, keyframes: f, duration: p, type: d, ease: m, times: v, isGenerator: !0 }), re = secondsToMilliseconds(this.time); F.setWithVelocity(Q.sample(re - sampleDelta).value, Q.sample(re).value, sampleDelta) } const { onStop: I } = this.options; I && I(), this.cancel() } complete() { const { resolved: l } = this; l && l.animation.finish() } cancel() { const { resolved: l } = this; l && l.animation.cancel() } static supports(l) { const { motionValue: u, name: f, repeatDelay: p, repeatType: d, damping: m, type: v } = l; return supportsWaapi() && f && acceleratedValues.has(f) && u && u.owner && u.owner.current instanceof HTMLElement && !u.owner.getProps().onUpdate && !p && d !== "mirror" && m !== 0 && v !== "inertia" } } function observeTimeline(o, l) { let u; const f = () => { const { currentTime: p } = l, m = (p === null ? 0 : p.value) / 100; u !== m && o(m), u = m }; return frame.update(f, !0), () => cancelFrame(f) } const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0); class GroupPlaybackControls { constructor(l) { this.stop = () => this.runAll("stop"), this.animations = l.filter(Boolean) } then(l, u) { return Promise.all(this.animations).then(l).catch(u) } getAll(l) { return this.animations[0][l] } setAll(l, u) { for (let f = 0; f < this.animations.length; f++)this.animations[f][l] = u } attachTimeline(l) { const u = this.animations.map(f => { if (supportsScrollTimeline() && f.attachTimeline) f.attachTimeline(l); else return f.pause(), observeTimeline(p => { f.time = f.duration * p }, l) }); return () => { u.forEach((f, p) => { f && f(), this.animations[p].stop() }) } } get time() { return this.getAll("time") } set time(l) { this.setAll("time", l) } get speed() { return this.getAll("speed") } set speed(l) { this.setAll("speed", l) } get duration() { let l = 0; for (let u = 0; u < this.animations.length; u++)l = Math.max(l, this.animations[u].duration); return l } runAll(l) { this.animations.forEach(u => u[l]()) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } const animateMotionValue = (o, l, u, f = {}, p, d, m) => v => { const I = getValueTransition$1(f, o) || {}, F = I.delay || f.delay || 0; let { elapsed: B = 0 } = f; B = B - secondsToMilliseconds(F); let W = { keyframes: Array.isArray(u) ? u : [null, u], ease: "easeOut", velocity: l.getVelocity(), ...I, delay: -B, onUpdate: Q => { l.set(Q), I.onUpdate && I.onUpdate(Q) }, onComplete: () => { v(), I.onComplete && I.onComplete(), m && m() }, onStop: m, name: o, motionValue: l, element: d ? void 0 : p }; isTransitionDefined(I) || (W = { ...W, ...getDefaultTransition(o, W) }), W.duration && (W.duration = secondsToMilliseconds(W.duration)), W.repeatDelay && (W.repeatDelay = secondsToMilliseconds(W.repeatDelay)), W.from !== void 0 && (W.keyframes[0] = W.from); let Z = !1; if ((W.type === !1 || W.duration === 0 && !W.repeatDelay) && (W.duration = 0, W.delay === 0 && (Z = !0)), Z && !d && l.get() !== void 0) { const Q = getFinalKeyframe(W.keyframes, I); if (Q !== void 0) return frame.update(() => { W.onUpdate(Q), W.onComplete() }), new GroupPlaybackControls([]) } return !d && AcceleratedAnimation.supports(W) ? new AcceleratedAnimation(W) : new MainThreadAnimation(W) }; class SubscriptionManager { constructor() { this.subscriptions = [] } add(l) { return addUniqueItem(this.subscriptions, l), () => removeItem(this.subscriptions, l) } notify(l, u, f) { const p = this.subscriptions.length; if (p) if (p === 1) this.subscriptions[0](l, u, f); else for (let d = 0; d < p; d++) { const m = this.subscriptions[d]; m && m(l, u, f) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const MAX_VELOCITY_DELTA = 30, isFloat = o => !isNaN(parseFloat(o)); class MotionValue { constructor(l, u = {}) { this.version = "11.3.8", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (f, p = !0) => { const d = time.now(); this.updatedAt !== d && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(f), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), p && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(l), this.owner = u.owner } setCurrent(l) { this.current = l, this.updatedAt = time.now(), this.canTrackVelocity === null && l !== void 0 && (this.canTrackVelocity = isFloat(this.current)) } setPrevFrameValue(l = this.current) { this.prevFrameValue = l, this.prevUpdatedAt = this.updatedAt } onChange(l) { return this.on("change", l) } on(l, u) { this.events[l] || (this.events[l] = new SubscriptionManager); const f = this.events[l].add(u); return l === "change" ? () => { f(), frame.read(() => { this.events.change.getSize() || this.stop() }) } : f } clearListeners() { for (const l in this.events) this.events[l].clear() } attach(l, u) { this.passiveEffect = l, this.stopPassiveEffect = u } set(l, u = !0) { !u || !this.passiveEffect ? this.updateAndNotify(l, u) : this.passiveEffect(l, this.updateAndNotify) } setWithVelocity(l, u, f) { this.set(u), this.prev = void 0, this.prevFrameValue = l, this.prevUpdatedAt = this.updatedAt - f } jump(l, u = !0) { this.updateAndNotify(l), this.prev = l, this.prevUpdatedAt = this.prevFrameValue = void 0, u && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const l = time.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || l - this.updatedAt > MAX_VELOCITY_DELTA) return 0; const u = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA); return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), u) } start(l) { return this.stop(), new Promise(u => { this.hasAnimated = !0, this.animation = l(u), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function motionValue(o, l) { return new MotionValue(o, l) } function setMotionValue(o, l, u) { o.hasValue(l) ? o.getValue(l).set(u) : o.addValue(l, motionValue(u)) } function setTarget(o, l) { const u = resolveVariant(o, l); let { transitionEnd: f = {}, transition: p = {}, ...d } = u || {}; d = { ...d, ...f }; for (const m in d) { const v = resolveFinalValueInKeyframes(d[m]); setMotionValue(o, m, v) } } function getOptimisedAppearId(o) { return o.getProps()[optimizedAppearDataAttribute] } class WillChangeMotionValue extends MotionValue { constructor() { super(...arguments), this.output = [], this.counts = new Map } add(l) { const u = getWillChangeName(l); if (!u) return; const f = this.counts.get(u) || 0; this.counts.set(u, f + 1), f === 0 && (this.output.push(u), this.update()); let p = !1; return () => { if (p) return; p = !0; const d = this.counts.get(u) - 1; this.counts.set(u, d), d === 0 && (removeItem(this.output, u), this.update()) } } update() { this.set(this.output.length ? this.output.join(", ") : "auto") } } function isWillChangeMotionValue(o) { return !!(isMotionValue(o) && o.add) } function addValueToWillChange(o, l) { var u; if (!o.applyWillChange) return; let f = o.getValue("willChange"); if (!f && !(!((u = o.props.style) === null || u === void 0) && u.willChange) && (f = new WillChangeMotionValue("auto"), o.addValue("willChange", f)), isWillChangeMotionValue(f)) return f.add(l) } function shouldBlockAnimation({ protectedKeys: o, needsAnimating: l }, u) { const f = o.hasOwnProperty(u) && l[u] !== !0; return l[u] = !1, f } function animateTarget(o, l, { delay: u = 0, transitionOverride: f, type: p } = {}) { var d; let { transition: m = o.getDefaultTransition(), transitionEnd: v, ...I } = l; f && (m = f); const F = [], B = p && o.animationState && o.animationState.getState()[p]; for (const W in I) { const Z = o.getValue(W, (d = o.latestValues[W]) !== null && d !== void 0 ? d : null), Q = I[W]; if (Q === void 0 || B && shouldBlockAnimation(B, W)) continue; const re = { delay: u, elapsed: 0, ...getValueTransition$1(m || {}, W) }; let ne = !1; if (window.HandoffAppearAnimations) { const ae = getOptimisedAppearId(o); if (ae) { const se = window.HandoffAppearAnimations(ae, W, Z, frame); se !== null && (re.elapsed = se, ne = !0) } } Z.start(animateMotionValue(W, Z, Q, o.shouldReduceMotion && transformProps.has(W) ? { type: !1 } : re, o, ne, addValueToWillChange(o, W))); const oe = Z.animation; oe && F.push(oe) } return v && Promise.all(F).then(() => { frame.update(() => { v && setTarget(o, v) }) }), F } function animateVariant(o, l, u = {}) { var f; const p = resolveVariant(o, l, u.type === "exit" ? (f = o.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0); let { transition: d = o.getDefaultTransition() || {} } = p || {}; u.transitionOverride && (d = u.transitionOverride); const m = p ? () => Promise.all(animateTarget(o, p, u)) : () => Promise.resolve(), v = o.variantChildren && o.variantChildren.size ? (F = 0) => { const { delayChildren: B = 0, staggerChildren: W, staggerDirection: Z } = d; return animateChildren(o, l, B + F, W, Z, u) } : () => Promise.resolve(), { when: I } = d; if (I) { const [F, B] = I === "beforeChildren" ? [m, v] : [v, m]; return F().then(() => B()) } else return Promise.all([m(), v(u.delay)]) } function animateChildren(o, l, u = 0, f = 0, p = 1, d) { const m = [], v = (o.variantChildren.size - 1) * f, I = p === 1 ? (F = 0) => F * f : (F = 0) => v - F * f; return Array.from(o.variantChildren).sort(sortByTreeOrder).forEach((F, B) => { F.notify("AnimationStart", l), m.push(animateVariant(F, l, { ...d, delay: u + I(B) }).then(() => F.notify("AnimationComplete", l))) }), Promise.all(m) } function sortByTreeOrder(o, l) { return o.sortNodePosition(l) } function animateVisualElement(o, l, u = {}) { o.notify("AnimationStart", l); let f; if (Array.isArray(l)) { const p = l.map(d => animateVariant(o, d, u)); f = Promise.all(p) } else if (typeof l == "string") f = animateVariant(o, l, u); else { const p = typeof l == "function" ? resolveVariant(o, l, u.custom) : l; f = Promise.all(animateTarget(o, p, u)) } return f.then(() => { frame.postRender(() => { o.notify("AnimationComplete", l) }) }) } const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length; function animateList(o) { return l => Promise.all(l.map(({ animation: u, options: f }) => animateVisualElement(o, u, f))) } function createAnimationState(o) { let l = animateList(o), u = createState(), f = !0; const p = I => (F, B) => { var W; const Z = resolveVariant(o, B, I === "exit" ? (W = o.presenceContext) === null || W === void 0 ? void 0 : W.custom : void 0); if (Z) { const { transition: Q, transitionEnd: re, ...ne } = Z; F = { ...F, ...ne, ...re } } return F }; function d(I) { l = I(o) } function m(I) { const F = o.getProps(), B = o.getVariantContext(!0) || {}, W = [], Z = new Set; let Q = {}, re = 1 / 0; for (let oe = 0; oe < numAnimationTypes; oe++) { const ae = reversePriorityOrder[oe], se = u[ae], le = F[ae] !== void 0 ? F[ae] : B[ae], ue = isVariantLabel(le), he = ae === I ? se.isActive : null; he === !1 && (re = oe); let pe = le === B[ae] && le !== F[ae] && ue; if (pe && f && o.manuallyAnimateOnMount && (pe = !1), se.protectedKeys = { ...Q }, !se.isActive && he === null || !le && !se.prevProp || isAnimationControls(le) || typeof le == "boolean") continue; let _e = checkVariantsDidChange(se.prevProp, le) || ae === I && se.isActive && !pe && ue || oe > re && ue, Se = !1; const $e = Array.isArray(le) ? le : [le]; let ie = $e.reduce(p(ae), {}); he === !1 && (ie = {}); const { prevResolvedValues: g = {} } = se, P = { ...g, ...ie }, U = K => { _e = !0, Z.has(K) && (Se = !0, Z.delete(K)), se.needsAnimating[K] = !0; const Y = o.getValue(K); Y && (Y.liveStyle = !1) }; for (const K in P) { const Y = ie[K], te = g[K]; if (Q.hasOwnProperty(K)) continue; let ee = !1; isKeyframesTarget(Y) && isKeyframesTarget(te) ? ee = !shallowCompare(Y, te) : ee = Y !== te, ee ? Y != null ? U(K) : Z.add(K) : Y !== void 0 && Z.has(K) ? U(K) : se.protectedKeys[K] = !0 } se.prevProp = le, se.prevResolvedValues = ie, se.isActive && (Q = { ...Q, ...ie }), f && o.blockInitialAnimation && (_e = !1), _e && (!pe || Se) && W.push(...$e.map(K => ({ animation: K, options: { type: ae } }))) } if (Z.size) { const oe = {}; Z.forEach(ae => { const se = o.getBaseTarget(ae), le = o.getValue(ae); le && (le.liveStyle = !0), oe[ae] = se ?? null }), W.push({ animation: oe }) } let ne = !!W.length; return f && (F.initial === !1 || F.initial === F.animate) && !o.manuallyAnimateOnMount && (ne = !1), f = !1, ne ? l(W) : Promise.resolve() } function v(I, F) { var B; if (u[I].isActive === F) return Promise.resolve(); (B = o.variantChildren) === null || B === void 0 || B.forEach(Z => { var Q; return (Q = Z.animationState) === null || Q === void 0 ? void 0 : Q.setActive(I, F) }), u[I].isActive = F; const W = m(I); for (const Z in u) u[Z].protectedKeys = {}; return W } return { animateChanges: m, setActive: v, setAnimateFunction: d, getState: () => u, reset: () => { u = createState(), f = !0 } } } function checkVariantsDidChange(o, l) { return typeof l == "string" ? l !== o : Array.isArray(l) ? !shallowCompare(l, o) : !1 } function createTypeState(o = !1) { return { isActive: o, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function createState() { return { animate: createTypeState(!0), whileInView: createTypeState(), whileHover: createTypeState(), whileTap: createTypeState(), whileDrag: createTypeState(), whileFocus: createTypeState(), exit: createTypeState() } } class AnimationFeature extends Feature { constructor(l) { super(l), l.animationState || (l.animationState = createAnimationState(l)) } updateAnimationControlsSubscription() { const { animate: l } = this.node.getProps(); isAnimationControls(l) && (this.unmountControls = l.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: l } = this.node.getProps(), { animate: u } = this.node.prevProps || {}; l !== u && this.updateAnimationControlsSubscription() } unmount() { var l; this.node.animationState.reset(), (l = this.unmountControls) === null || l === void 0 || l.call(this) } } let id$1 = 0; class ExitAnimationFeature extends Feature { constructor() { super(...arguments), this.id = id$1++ } update() { if (!this.node.presenceContext) return; const { isPresent: l, onExitComplete: u } = this.node.presenceContext, { isPresent: f } = this.node.prevPresenceContext || {}; if (!this.node.animationState || l === f) return; const p = this.node.animationState.setActive("exit", !l); u && !l && p.then(() => u(this.id)) } mount() { const { register: l } = this.node.presenceContext || {}; l && (this.unmount = l(this.id)) } unmount() { } } const animations = { animation: { Feature: AnimationFeature }, exit: { Feature: ExitAnimationFeature } }, distance = (o, l) => Math.abs(o - l); function distance2D(o, l) { const u = distance(o.x, l.x), f = distance(o.y, l.y); return Math.sqrt(u ** 2 + f ** 2) } class PanSession { constructor(l, u, { transformPagePoint: f, contextWindow: p, dragSnapToOrigin: d = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const W = getPanInfo(this.lastMoveEventInfo, this.history), Z = this.startEvent !== null, Q = distance2D(W.offset, { x: 0, y: 0 }) >= 3; if (!Z && !Q) return; const { point: re } = W, { timestamp: ne } = frameData; this.history.push({ ...re, timestamp: ne }); const { onStart: oe, onMove: ae } = this.handlers; Z || (oe && oe(this.lastMoveEvent, W), this.startEvent = this.lastMoveEvent), ae && ae(this.lastMoveEvent, W) }, this.handlePointerMove = (W, Z) => { this.lastMoveEvent = W, this.lastMoveEventInfo = transformPoint(Z, this.transformPagePoint), frame.update(this.updatePoint, !0) }, this.handlePointerUp = (W, Z) => { this.end(); const { onEnd: Q, onSessionEnd: re, resumeAnimation: ne } = this.handlers; if (this.dragSnapToOrigin && ne && ne(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const oe = getPanInfo(W.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(Z, this.transformPagePoint), this.history); this.startEvent && Q && Q(W, oe), re && re(W, oe) }, !isPrimaryPointer(l)) return; this.dragSnapToOrigin = d, this.handlers = u, this.transformPagePoint = f, this.contextWindow = p || window; const m = extractEventInfo(l), v = transformPoint(m, this.transformPagePoint), { point: I } = v, { timestamp: F } = frameData; this.history = [{ ...I, timestamp: F }]; const { onSessionStart: B } = u; B && B(l, getPanInfo(v, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(l) { this.handlers = l } end() { this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint) } } function transformPoint(o, l) { return l ? { point: l(o.point) } : o } function subtractPoint(o, l) { return { x: o.x - l.x, y: o.y - l.y } } function getPanInfo({ point: o }, l) { return { point: o, delta: subtractPoint(o, lastDevicePoint(l)), offset: subtractPoint(o, startDevicePoint(l)), velocity: getVelocity(l, .1) } } function startDevicePoint(o) { return o[0] } function lastDevicePoint(o) { return o[o.length - 1] } function getVelocity(o, l) { if (o.length < 2) return { x: 0, y: 0 }; let u = o.length - 1, f = null; const p = lastDevicePoint(o); for (; u >= 0 && (f = o[u], !(p.timestamp - f.timestamp > secondsToMilliseconds(l)));)u--; if (!f) return { x: 0, y: 0 }; const d = millisecondsToSeconds(p.timestamp - f.timestamp); if (d === 0) return { x: 0, y: 0 }; const m = { x: (p.x - f.x) / d, y: (p.y - f.y) / d }; return m.x === 1 / 0 && (m.x = 0), m.y === 1 / 0 && (m.y = 0), m } const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = .01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION; function calcLength(o) { return o.max - o.min } function isNear(o, l, u) { return Math.abs(o - l) <= u } function calcAxisDelta(o, l, u, f = .5) { o.origin = f, o.originPoint = mixNumber$1(l.min, l.max, o.origin), o.scale = calcLength(u) / calcLength(l), o.translate = mixNumber$1(u.min, u.max, o.origin) - o.originPoint, (o.scale >= SCALE_MIN && o.scale <= SCALE_MAX || isNaN(o.scale)) && (o.scale = 1), (o.translate >= TRANSLATE_MIN && o.translate <= TRANSLATE_MAX || isNaN(o.translate)) && (o.translate = 0) } function calcBoxDelta(o, l, u, f) { calcAxisDelta(o.x, l.x, u.x, f ? f.originX : void 0), calcAxisDelta(o.y, l.y, u.y, f ? f.originY : void 0) } function calcRelativeAxis(o, l, u) { o.min = u.min + l.min, o.max = o.min + calcLength(l) } function calcRelativeBox(o, l, u) { calcRelativeAxis(o.x, l.x, u.x), calcRelativeAxis(o.y, l.y, u.y) } function calcRelativeAxisPosition(o, l, u) { o.min = l.min - u.min, o.max = o.min + calcLength(l) } function calcRelativePosition(o, l, u) { calcRelativeAxisPosition(o.x, l.x, u.x), calcRelativeAxisPosition(o.y, l.y, u.y) } function applyConstraints(o, { min: l, max: u }, f) { return l !== void 0 && o < l ? o = f ? mixNumber$1(l, o, f.min) : Math.max(o, l) : u !== void 0 && o > u && (o = f ? mixNumber$1(u, o, f.max) : Math.min(o, u)), o } function calcRelativeAxisConstraints(o, l, u) { return { min: l !== void 0 ? o.min + l : void 0, max: u !== void 0 ? o.max + u - (o.max - o.min) : void 0 } } function calcRelativeConstraints(o, { top: l, left: u, bottom: f, right: p }) { return { x: calcRelativeAxisConstraints(o.x, u, p), y: calcRelativeAxisConstraints(o.y, l, f) } } function calcViewportAxisConstraints(o, l) { let u = l.min - o.min, f = l.max - o.max; return l.max - l.min < o.max - o.min && ([u, f] = [f, u]), { min: u, max: f } } function calcViewportConstraints(o, l) { return { x: calcViewportAxisConstraints(o.x, l.x), y: calcViewportAxisConstraints(o.y, l.y) } } function calcOrigin(o, l) { let u = .5; const f = calcLength(o), p = calcLength(l); return p > f ? u = progress(l.min, l.max - f, o.min) : f > p && (u = progress(o.min, o.max - p, l.min)), clamp(0, 1, u) } function rebaseAxisConstraints(o, l) { const u = {}; return l.min !== void 0 && (u.min = l.min - o.min), l.max !== void 0 && (u.max = l.max - o.min), u } const defaultElastic = .35; function resolveDragElastic(o = defaultElastic) { return o === !1 ? o = 0 : o === !0 && (o = defaultElastic), { x: resolveAxisElastic(o, "left", "right"), y: resolveAxisElastic(o, "top", "bottom") } } function resolveAxisElastic(o, l, u) { return { min: resolvePointElastic(o, l), max: resolvePointElastic(o, u) } } function resolvePointElastic(o, l) { return typeof o == "number" ? o : o[l] || 0 } const createAxisDelta = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({ x: createAxis(), y: createAxis() }); function eachAxis(o) { return [o("x"), o("y")] } function convertBoundingBoxToBox({ top: o, left: l, right: u, bottom: f }) { return { x: { min: l, max: u }, y: { min: o, max: f } } } function convertBoxToBoundingBox({ x: o, y: l }) { return { top: l.min, right: o.max, bottom: l.max, left: o.min } } function transformBoxPoints(o, l) { if (!l) return o; const u = l({ x: o.left, y: o.top }), f = l({ x: o.right, y: o.bottom }); return { top: u.y, left: u.x, bottom: f.y, right: f.x } } function isIdentityScale(o) { return o === void 0 || o === 1 } function hasScale({ scale: o, scaleX: l, scaleY: u }) { return !isIdentityScale(o) || !isIdentityScale(l) || !isIdentityScale(u) } function hasTransform(o) { return hasScale(o) || has2DTranslate(o) || o.z || o.rotate || o.rotateX || o.rotateY || o.skewX || o.skewY } function has2DTranslate(o) { return is2DTranslate(o.x) || is2DTranslate(o.y) } function is2DTranslate(o) { return o && o !== "0%" } function scalePoint(o, l, u) { const f = o - u, p = l * f; return u + p } function applyPointDelta(o, l, u, f, p) { return p !== void 0 && (o = scalePoint(o, p, f)), scalePoint(o, u, f) + l } function applyAxisDelta(o, l = 0, u = 1, f, p) { o.min = applyPointDelta(o.min, l, u, f, p), o.max = applyPointDelta(o.max, l, u, f, p) } function applyBoxDelta(o, { x: l, y: u }) { applyAxisDelta(o.x, l.translate, l.scale, l.originPoint), applyAxisDelta(o.y, u.translate, u.scale, u.originPoint) } const TREE_SCALE_SNAP_MIN = .999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001; function applyTreeDeltas(o, l, u, f = !1) { const p = u.length; if (!p) return; l.x = l.y = 1; let d, m; for (let v = 0; v < p; v++) { d = u[v], m = d.projectionDelta; const { visualElement: I } = d.options; I && I.props.style && I.props.style.display === "contents" || (f && d.options.layoutScroll && d.scroll && d !== d.root && transformBox(o, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), m && (l.x *= m.x.scale, l.y *= m.y.scale, applyBoxDelta(o, m)), f && hasTransform(d.latestValues) && transformBox(o, d.latestValues)) } l.x < TREE_SCALE_SNAP_MAX && l.x > TREE_SCALE_SNAP_MIN && (l.x = 1), l.y < TREE_SCALE_SNAP_MAX && l.y > TREE_SCALE_SNAP_MIN && (l.y = 1) } function translateAxis(o, l) { o.min = o.min + l, o.max = o.max + l } function transformAxis(o, l, u, f, p = .5) { const d = mixNumber$1(o.min, o.max, p); applyAxisDelta(o, l, u, d, f) } function transformBox(o, l) { transformAxis(o.x, l.x, l.scaleX, l.scale, l.originX), transformAxis(o.y, l.y, l.scaleY, l.scale, l.originY) } function measureViewportBox(o, l) { return convertBoundingBoxToBox(transformBoxPoints(o.getBoundingClientRect(), l)) } function measurePageBox(o, l, u) { const f = measureViewportBox(o, u), { scroll: p } = l; return p && (translateAxis(f.x, p.offset.x), translateAxis(f.y, p.offset.y)), f } const getContextWindow = ({ current: o }) => o ? o.ownerDocument.defaultView : null, elementDragControls = new WeakMap; class VisualElementDragControls { constructor(l) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = l } start(l, { snapToCursor: u = !1 } = {}) { const { presenceContext: f } = this.visualElement; if (f && f.isPresent === !1) return; const p = B => { const { dragSnapToOrigin: W } = this.getProps(); W ? this.pauseAnimation() : this.stopAnimation(), u && this.snapToCursor(extractEventInfo(B, "page").point) }, d = (B, W) => { var Z; const { drag: Q, dragPropagation: re, onDragStart: ne } = this.getProps(); if (Q && !re && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(Q), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis(ae => { let se = this.getAxisMotionValue(ae).get() || 0; if (percent$1.test(se)) { const { projection: le } = this.visualElement; if (le && le.layout) { const ue = le.layout.layoutBox[ae]; ue && (se = calcLength(ue) * (parseFloat(se) / 100)) } } this.originPoint[ae] = se }), ne && frame.postRender(() => ne(B, W)), (Z = this.removeWillChange) === null || Z === void 0 || Z.call(this), this.removeWillChange = addValueToWillChange(this.visualElement, "transform"); const { animationState: oe } = this.visualElement; oe && oe.setActive("whileDrag", !0) }, m = (B, W) => { const { dragPropagation: Z, dragDirectionLock: Q, onDirectionLock: re, onDrag: ne } = this.getProps(); if (!Z && !this.openGlobalLock) return; const { offset: oe } = W; if (Q && this.currentDirection === null) { this.currentDirection = getCurrentDirection(oe), this.currentDirection !== null && re && re(this.currentDirection); return } this.updateAxis("x", W.point, oe), this.updateAxis("y", W.point, oe), this.visualElement.render(), ne && ne(B, W) }, v = (B, W) => this.stop(B, W), I = () => eachAxis(B => { var W; return this.getAnimationState(B) === "paused" && ((W = this.getAxisMotionValue(B).animation) === null || W === void 0 ? void 0 : W.play()) }), { dragSnapToOrigin: F } = this.getProps(); this.panSession = new PanSession(l, { onSessionStart: p, onStart: d, onMove: m, onSessionEnd: v, resumeAnimation: I }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: F, contextWindow: getContextWindow(this.visualElement) }) } stop(l, u) { var f; (f = this.removeWillChange) === null || f === void 0 || f.call(this); const p = this.isDragging; if (this.cancel(), !p) return; const { velocity: d } = u; this.startAnimation(d); const { onDragEnd: m } = this.getProps(); m && frame.postRender(() => m(l, u)) } cancel() { this.isDragging = !1; const { projection: l, animationState: u } = this.visualElement; l && (l.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: f } = this.getProps(); !f && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), u && u.setActive("whileDrag", !1) } updateAxis(l, u, f) { const { drag: p } = this.getProps(); if (!f || !shouldDrag(l, p, this.currentDirection)) return; const d = this.getAxisMotionValue(l); let m = this.originPoint[l] + f[l]; this.constraints && this.constraints[l] && (m = applyConstraints(m, this.constraints[l], this.elastic[l])), d.set(m) } resolveConstraints() { var l; const { dragConstraints: u, dragElastic: f } = this.getProps(), p = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (l = this.visualElement.projection) === null || l === void 0 ? void 0 : l.layout, d = this.constraints; u && isRefObject(u) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : u && p ? this.constraints = calcRelativeConstraints(p.layoutBox, u) : this.constraints = !1, this.elastic = resolveDragElastic(f), d !== this.constraints && p && this.constraints && !this.hasMutatedConstraints && eachAxis(m => { this.constraints !== !1 && this.getAxisMotionValue(m) && (this.constraints[m] = rebaseAxisConstraints(p.layoutBox[m], this.constraints[m])) }) } resolveRefConstraints() { const { dragConstraints: l, onMeasureDragConstraints: u } = this.getProps(); if (!l || !isRefObject(l)) return !1; const f = l.current, { projection: p } = this.visualElement; if (!p || !p.layout) return !1; const d = measurePageBox(f, p.root, this.visualElement.getTransformPagePoint()); let m = calcViewportConstraints(p.layout.layoutBox, d); if (u) { const v = u(convertBoxToBoundingBox(m)); this.hasMutatedConstraints = !!v, v && (m = convertBoundingBoxToBox(v)) } return m } startAnimation(l) { const { drag: u, dragMomentum: f, dragElastic: p, dragTransition: d, dragSnapToOrigin: m, onDragTransitionEnd: v } = this.getProps(), I = this.constraints || {}, F = eachAxis(B => { if (!shouldDrag(B, u, this.currentDirection)) return; let W = I && I[B] || {}; m && (W = { min: 0, max: 0 }); const Z = p ? 200 : 1e6, Q = p ? 40 : 1e7, re = { type: "inertia", velocity: f ? l[B] : 0, bounceStiffness: Z, bounceDamping: Q, timeConstant: 750, restDelta: 1, restSpeed: 10, ...d, ...W }; return this.startAxisValueAnimation(B, re) }); return Promise.all(F).then(v) } startAxisValueAnimation(l, u) { const f = this.getAxisMotionValue(l); return f.start(animateMotionValue(l, f, 0, u, this.visualElement, !1, addValueToWillChange(this.visualElement, l))) } stopAnimation() { eachAxis(l => this.getAxisMotionValue(l).stop()) } pauseAnimation() { eachAxis(l => { var u; return (u = this.getAxisMotionValue(l).animation) === null || u === void 0 ? void 0 : u.pause() }) } getAnimationState(l) { var u; return (u = this.getAxisMotionValue(l).animation) === null || u === void 0 ? void 0 : u.state } getAxisMotionValue(l) { const u = `_drag${l.toUpperCase()}`, f = this.visualElement.getProps(), p = f[u]; return p || this.visualElement.getValue(l, (f.initial ? f.initial[l] : void 0) || 0) } snapToCursor(l) { eachAxis(u => { const { drag: f } = this.getProps(); if (!shouldDrag(u, f, this.currentDirection)) return; const { projection: p } = this.visualElement, d = this.getAxisMotionValue(u); if (p && p.layout) { const { min: m, max: v } = p.layout.layoutBox[u]; d.set(l[u] - mixNumber$1(m, v, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: l, dragConstraints: u } = this.getProps(), { projection: f } = this.visualElement; if (!isRefObject(u) || !f || !this.constraints) return; this.stopAnimation(); const p = { x: 0, y: 0 }; eachAxis(m => { const v = this.getAxisMotionValue(m); if (v && this.constraints !== !1) { const I = v.get(); p[m] = calcOrigin({ min: I, max: I }, this.constraints[m]) } }); const { transformTemplate: d } = this.visualElement.getProps(); this.visualElement.current.style.transform = d ? d({}, "") : "none", f.root && f.root.updateScroll(), f.updateLayout(), this.resolveConstraints(), eachAxis(m => { if (!shouldDrag(m, l, null)) return; const v = this.getAxisMotionValue(m), { min: I, max: F } = this.constraints[m]; v.set(mixNumber$1(I, F, p[m])) }) } addListeners() { if (!this.visualElement.current) return; elementDragControls.set(this.visualElement, this); const l = this.visualElement.current, u = addPointerEvent(l, "pointerdown", I => { const { drag: F, dragListener: B = !0 } = this.getProps(); F && B && this.start(I) }), f = () => { const { dragConstraints: I } = this.getProps(); isRefObject(I) && I.current && (this.constraints = this.resolveRefConstraints()) }, { projection: p } = this.visualElement, d = p.addEventListener("measure", f); p && !p.layout && (p.root && p.root.updateScroll(), p.updateLayout()), frame.read(f); const m = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), v = p.addEventListener("didUpdate", ({ delta: I, hasLayoutChanged: F }) => { this.isDragging && F && (eachAxis(B => { const W = this.getAxisMotionValue(B); W && (this.originPoint[B] += I[B].translate, W.set(W.get() + I[B].translate)) }), this.visualElement.render()) }); return () => { m(), u(), d(), v && v() } } getProps() { const l = this.visualElement.getProps(), { drag: u = !1, dragDirectionLock: f = !1, dragPropagation: p = !1, dragConstraints: d = !1, dragElastic: m = defaultElastic, dragMomentum: v = !0 } = l; return { ...l, drag: u, dragDirectionLock: f, dragPropagation: p, dragConstraints: d, dragElastic: m, dragMomentum: v } } } function shouldDrag(o, l, u) { return (l === !0 || l === o) && (u === null || u === o) } function getCurrentDirection(o, l = 10) { let u = null; return Math.abs(o.y) > l ? u = "y" : Math.abs(o.x) > l && (u = "x"), u } class DragGesture extends Feature { constructor(l) { super(l), this.removeGroupControls = noop, this.removeListeners = noop, this.controls = new VisualElementDragControls(l) } mount() { const { dragControls: l } = this.node.getProps(); l && (this.removeGroupControls = l.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop } unmount() { this.removeGroupControls(), this.removeListeners() } } const asyncHandler = o => (l, u) => { o && frame.postRender(() => o(l, u)) }; class PanGesture extends Feature { constructor() { super(...arguments), this.removePointerDownListener = noop } onPointerDown(l) { this.session = new PanSession(l, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: getContextWindow(this.node) }) } createPanHandlers() { const { onPanSessionStart: l, onPanStart: u, onPan: f, onPanEnd: p } = this.node.getProps(); return { onSessionStart: asyncHandler(l), onStart: asyncHandler(u), onMove: f, onEnd: (d, m) => { delete this.session, p && frame.postRender(() => p(d, m)) } } } mount() { this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", l => this.onPointerDown(l)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function usePresence() { const o = reactExports.useContext(PresenceContext); if (o === null) return [!0, null]; const { isPresent: l, onExitComplete: u, register: f } = o, p = reactExports.useId(); return reactExports.useEffect(() => f(p), []), !l && u ? [!1, () => u && u(p)] : [!0] } const globalProjectionState = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function pixelsToPercent(o, l) { return l.max === l.min ? 0 : o / (l.max - l.min) * 100 } const correctBorderRadius = { correct: (o, l) => { if (!l.target) return o; if (typeof o == "string") if (px$1.test(o)) o = parseFloat(o); else return o; const u = pixelsToPercent(o, l.target.x), f = pixelsToPercent(o, l.target.y); return `${u}% ${f}%` } }, correctBoxShadow = { correct: (o, { treeScale: l, projectionDelta: u }) => { const f = o, p = complex.parse(o); if (p.length > 5) return f; const d = complex.createTransformer(o), m = typeof p[0] != "number" ? 1 : 0, v = u.x.scale * l.x, I = u.y.scale * l.y; p[0 + m] /= v, p[1 + m] /= I; const F = mixNumber$1(v, I, .5); return typeof p[2 + m] == "number" && (p[2 + m] /= F), typeof p[3 + m] == "number" && (p[3 + m] /= F), d(p) } }; class MeasureLayoutWithContext extends reactExports.Component { componentDidMount() { const { visualElement: l, layoutGroup: u, switchLayoutGroup: f, layoutId: p } = this.props, { projection: d } = l; addScaleCorrector(defaultScaleCorrectors), d && (u.group && u.group.add(d), f && f.register && p && f.register(d), d.root.didUpdate(), d.addEventListener("animationComplete", () => { this.safeToRemove() }), d.setOptions({ ...d.options, onExitComplete: () => this.safeToRemove() })), globalProjectionState.hasEverUpdated = !0 } getSnapshotBeforeUpdate(l) { const { layoutDependency: u, visualElement: f, drag: p, isPresent: d } = this.props, m = f.projection; return m && (m.isPresent = d, p || l.layoutDependency !== u || u === void 0 ? m.willUpdate() : this.safeToRemove(), l.isPresent !== d && (d ? m.promote() : m.relegate() || frame.postRender(() => { const v = m.getStack(); (!v || !v.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: l } = this.props.visualElement; l && (l.root.didUpdate(), microtask.postRender(() => { !l.currentAnimation && l.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: l, layoutGroup: u, switchLayoutGroup: f } = this.props, { projection: p } = l; p && (p.scheduleCheckAfterUnmount(), u && u.group && u.group.remove(p), f && f.deregister && f.deregister(p)) } safeToRemove() { const { safeToRemove: l } = this.props; l && l() } render() { return null } } function MeasureLayout(o) { const [l, u] = usePresence(), f = reactExports.useContext(LayoutGroupContext); return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...o, layoutGroup: f, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent: l, safeToRemove: u }) } const defaultScaleCorrectors = { borderRadius: { ...correctBorderRadius, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: correctBorderRadius, borderTopRightRadius: correctBorderRadius, borderBottomLeftRadius: correctBorderRadius, borderBottomRightRadius: correctBorderRadius, boxShadow: correctBoxShadow }, borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = o => typeof o == "string" ? parseFloat(o) : o, isPx = o => typeof o == "number" || px$1.test(o); function mixValues(o, l, u, f, p, d) { p ? (o.opacity = mixNumber$1(0, u.opacity !== void 0 ? u.opacity : 1, easeCrossfadeIn(f)), o.opacityExit = mixNumber$1(l.opacity !== void 0 ? l.opacity : 1, 0, easeCrossfadeOut(f))) : d && (o.opacity = mixNumber$1(l.opacity !== void 0 ? l.opacity : 1, u.opacity !== void 0 ? u.opacity : 1, f)); for (let m = 0; m < numBorders; m++) { const v = `border${borders[m]}Radius`; let I = getRadius(l, v), F = getRadius(u, v); if (I === void 0 && F === void 0) continue; I || (I = 0), F || (F = 0), I === 0 || F === 0 || isPx(I) === isPx(F) ? (o[v] = Math.max(mixNumber$1(asNumber(I), asNumber(F), f), 0), (percent$1.test(F) || percent$1.test(I)) && (o[v] += "%")) : o[v] = F } (l.rotate || u.rotate) && (o.rotate = mixNumber$1(l.rotate || 0, u.rotate || 0, f)) } function getRadius(o, l) { return o[l] !== void 0 ? o[l] : o.borderRadius } const easeCrossfadeIn = compress(0, .5, circOut), easeCrossfadeOut = compress(.5, .95, noop); function compress(o, l, u) { return f => f < o ? 0 : f > l ? 1 : u(progress(o, l, f)) } function copyAxisInto(o, l) { o.min = l.min, o.max = l.max } function copyBoxInto(o, l) { copyAxisInto(o.x, l.x), copyAxisInto(o.y, l.y) } function copyAxisDeltaInto(o, l) { o.translate = l.translate, o.scale = l.scale, o.originPoint = l.originPoint, o.origin = l.origin } function removePointDelta(o, l, u, f, p) { return o -= l, o = scalePoint(o, 1 / u, f), p !== void 0 && (o = scalePoint(o, 1 / p, f)), o } function removeAxisDelta(o, l = 0, u = 1, f = .5, p, d = o, m = o) { if (percent$1.test(l) && (l = parseFloat(l), l = mixNumber$1(m.min, m.max, l / 100) - m.min), typeof l != "number") return; let v = mixNumber$1(d.min, d.max, f); o === d && (v -= l), o.min = removePointDelta(o.min, l, u, v, p), o.max = removePointDelta(o.max, l, u, v, p) } function removeAxisTransforms(o, l, [u, f, p], d, m) { removeAxisDelta(o, l[u], l[f], l[p], l.scale, d, m) } const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"]; function removeBoxTransforms(o, l, u, f) { removeAxisTransforms(o.x, l, xKeys, u ? u.x : void 0, f ? f.x : void 0), removeAxisTransforms(o.y, l, yKeys, u ? u.y : void 0, f ? f.y : void 0) } function isAxisDeltaZero(o) { return o.translate === 0 && o.scale === 1 } function isDeltaZero(o) { return isAxisDeltaZero(o.x) && isAxisDeltaZero(o.y) } function boxEquals(o, l) { return o.x.min === l.x.min && o.x.max === l.x.max && o.y.min === l.y.min && o.y.max === l.y.max } function boxEqualsRounded(o, l) { return Math.round(o.x.min) === Math.round(l.x.min) && Math.round(o.x.max) === Math.round(l.x.max) && Math.round(o.y.min) === Math.round(l.y.min) && Math.round(o.y.max) === Math.round(l.y.max) } function aspectRatio(o) { return calcLength(o.x) / calcLength(o.y) } function axisDeltaEquals(o, l) { return o.translate === l.translate && o.scale === l.scale && o.originPoint === l.originPoint } class NodeStack { constructor() { this.members = [] } add(l) { addUniqueItem(this.members, l), l.scheduleRender() } remove(l) { if (removeItem(this.members, l), l === this.prevLead && (this.prevLead = void 0), l === this.lead) { const u = this.members[this.members.length - 1]; u && this.promote(u) } } relegate(l) { const u = this.members.findIndex(p => l === p); if (u === 0) return !1; let f; for (let p = u; p >= 0; p--) { const d = this.members[p]; if (d.isPresent !== !1) { f = d; break } } return f ? (this.promote(f), !0) : !1 } promote(l, u) { const f = this.lead; if (l !== f && (this.prevLead = f, this.lead = l, l.show(), f)) { f.instance && f.scheduleRender(), l.scheduleRender(), l.resumeFrom = f, u && (l.resumeFrom.preserveOpacity = !0), f.snapshot && (l.snapshot = f.snapshot, l.snapshot.latestValues = f.animationValues || f.latestValues), l.root && l.root.isUpdating && (l.isLayoutDirty = !0); const { crossfade: p } = l.options; p === !1 && f.hide() } } exitAnimationComplete() { this.members.forEach(l => { const { options: u, resumingFrom: f } = l; u.onExitComplete && u.onExitComplete(), f && f.options.onExitComplete && f.options.onExitComplete() }) } scheduleRender() { this.members.forEach(l => { l.instance && l.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function buildProjectionTransform(o, l, u) { let f = ""; const p = o.x.translate / l.x, d = o.y.translate / l.y, m = (u == null ? void 0 : u.z) || 0; if ((p || d || m) && (f = `translate3d(${p}px, ${d}px, ${m}px) `), (l.x !== 1 || l.y !== 1) && (f += `scale(${1 / l.x}, ${1 / l.y}) `), u) { const { transformPerspective: F, rotate: B, rotateX: W, rotateY: Z, skewX: Q, skewY: re } = u; F && (f = `perspective(${F}px) ${f}`), B && (f += `rotate(${B}deg) `), W && (f += `rotateX(${W}deg) `), Z && (f += `rotateY(${Z}deg) `), Q && (f += `skewX(${Q}deg) `), re && (f += `skewY(${re}deg) `) } const v = o.x.scale * l.x, I = o.y.scale * l.y; return (v !== 1 || I !== 1) && (f += `scale(${v}, ${I})`), f || "none" } const compareByDepth = (o, l) => o.depth - l.depth; class FlatTree { constructor() { this.children = [], this.isDirty = !1 } add(l) { addUniqueItem(this.children, l), this.isDirty = !0 } remove(l) { removeItem(this.children, l), this.isDirty = !0 } forEach(l) { this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(l) } } function delay(o, l) { const u = time.now(), f = ({ timestamp: p }) => { const d = p - u; d >= l && (cancelFrame(f), o(d - l)) }; return frame.read(f, !0), () => cancelFrame(f) } function isSVGElement(o) { return o instanceof SVGElement && o.tagName !== "svg" } function animateSingleValue(o, l, u) { const f = isMotionValue(o) ? o : motionValue(o); return f.start(animateMotionValue("", f, l, u)), f.animation } const metrics = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = { visibility: "hidden" }, animationTarget = 1e3; let id = 0; function resetDistortingTransform(o, l, u, f) { const { latestValues: p } = l; p[o] && (u[o] = p[o], l.setStaticValue(o, 0), f && (f[o] = 0)) } function isOptimisedAppearTree(o) { if (o.hasCheckedOptimisedAppear = !0, o.root === o) return !1; const { visualElement: l } = o.options; return l ? getOptimisedAppearId(l) ? !0 : o.parent && !o.parent.hasCheckedOptimisedAppear ? isOptimisedAppearTree(o.parent) : !1 : !1 } function createProjectionNode({ attachResizeListener: o, defaultParent: l, measureScroll: u, checkIsScrollRoot: f, resetTransform: p }) { return class { constructor(m = {}, v = l == null ? void 0 : l()) { this.id = id++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, window.MotionDebug && (metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0), this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), window.MotionDebug && window.MotionDebug.record(metrics) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = m, this.root = v ? v.root || v : this, this.path = v ? [...v.path, v] : [], this.parent = v, this.depth = v ? v.depth + 1 : 0; for (let I = 0; I < this.path.length; I++)this.path[I].shouldResetTransform = !0; this.root === this && (this.nodes = new FlatTree) } addEventListener(m, v) { return this.eventHandlers.has(m) || this.eventHandlers.set(m, new SubscriptionManager), this.eventHandlers.get(m).add(v) } notifyListeners(m, ...v) { const I = this.eventHandlers.get(m); I && I.notify(...v) } hasListeners(m) { return this.eventHandlers.has(m) } mount(m, v = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = isSVGElement(m), this.instance = m; const { layoutId: I, layout: F, visualElement: B } = this.options; if (B && !B.current && B.mount(m), this.root.nodes.add(this), this.parent && this.parent.children.add(this), v && (F || I) && (this.isLayoutDirty = !0), o) { let W; const Z = () => this.root.updateBlockedByResize = !1; o(m, () => { this.root.updateBlockedByResize = !0, W && W(), W = delay(Z, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation)) }) } I && this.root.registerSharedNode(I, this), this.options.animate !== !1 && B && (I || F) && this.addEventListener("didUpdate", ({ delta: W, hasLayoutChanged: Z, hasRelativeTargetChanged: Q, layout: re }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const ne = this.options.transition || B.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart: oe, onLayoutAnimationComplete: ae } = B.getProps(), se = !this.targetLayout || !boxEqualsRounded(this.targetLayout, re) || Q, le = !Z && Q; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || le || Z && (se || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(W, le); const ue = { ...getValueTransition$1(ne, "layout"), onPlay: oe, onComplete: ae }; (B.shouldReduceMotion || this.options.layoutRoot) && (ue.delay = 0, ue.type = !1), this.startAnimation(ue) } else Z || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = re }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const m = this.getStack(); m && m.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++) } getTransformTemplate() { const { visualElement: m } = this.options; return m && m.getProps().transformTemplate } willUpdate(m = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.HandoffCancelAllAnimations && isOptimisedAppearTree(this) && window.HandoffCancelAllAnimations(), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let B = 0; B < this.path.length; B++) { const W = this.path[B]; W.shouldResetTransform = !0, W.updateScroll("snapshot"), W.options.layoutRoot && W.willUpdate(!1) } const { layoutId: v, layout: I } = this.options; if (v === void 0 && !I) return; const F = this.getTransformTemplate(); this.prevTransformTemplateValue = F ? F(this.latestValues, "") : void 0, this.updateSnapshot(), m && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements); return } this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots(); const v = time.now(); frameData.delta = clamp(0, 1e3 / 60, v - frameData.timestamp), frameData.timestamp = v, frameData.isProcessing = !0, steps.update.process(frameData), steps.preRender.process(frameData), steps.render.process(frameData), frameData.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { frame.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let I = 0; I < this.path.length; I++)this.path[I].updateScroll(); const m = this.layout; this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: v } = this.options; v && v.notify("LayoutMeasure", this.layout.layoutBox, m ? m.layoutBox : void 0) } updateScroll(m = "measure") { let v = !!(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === m && (v = !1), v && (this.scroll = { animationId: this.root.animationId, phase: m, isRoot: f(this.instance), offset: u(this.instance) }) } resetTransform() { if (!p) return; const m = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, v = this.projectionDelta && !isDeltaZero(this.projectionDelta), I = this.getTransformTemplate(), F = I ? I(this.latestValues, "") : void 0, B = F !== this.prevTransformTemplateValue; m && (v || hasTransform(this.latestValues) || B) && (p(this.instance, F), this.shouldResetTransform = !1, this.scheduleRender()) } measure(m = !0) { const v = this.measurePageBox(); let I = this.removeElementScroll(v); return m && (I = this.removeTransform(I)), roundBox(I), { animationId: this.root.animationId, measuredBox: v, layoutBox: I, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: m } = this.options; if (!m) return createBox(); const v = m.measureViewportBox(), { scroll: I } = this.root; return I && (translateAxis(v.x, I.offset.x), translateAxis(v.y, I.offset.y)), v } removeElementScroll(m) { const v = createBox(); copyBoxInto(v, m); for (let I = 0; I < this.path.length; I++) { const F = this.path[I], { scroll: B, options: W } = F; if (F !== this.root && B && W.layoutScroll) { if (B.isRoot) { copyBoxInto(v, m); const { scroll: Z } = this.root; Z && (translateAxis(v.x, -Z.offset.x), translateAxis(v.y, -Z.offset.y)) } translateAxis(v.x, B.offset.x), translateAxis(v.y, B.offset.y) } } return v } applyTransform(m, v = !1) { const I = createBox(); copyBoxInto(I, m); for (let F = 0; F < this.path.length; F++) { const B = this.path[F]; !v && B.options.layoutScroll && B.scroll && B !== B.root && transformBox(I, { x: -B.scroll.offset.x, y: -B.scroll.offset.y }), hasTransform(B.latestValues) && transformBox(I, B.latestValues) } return hasTransform(this.latestValues) && transformBox(I, this.latestValues), I } removeTransform(m) { const v = createBox(); copyBoxInto(v, m); for (let I = 0; I < this.path.length; I++) { const F = this.path[I]; if (!F.instance || !hasTransform(F.latestValues)) continue; hasScale(F.latestValues) && F.updateSnapshot(); const B = createBox(), W = F.measurePageBox(); copyBoxInto(B, W), removeBoxTransforms(v, F.latestValues, F.snapshot ? F.snapshot.layoutBox : void 0, B) } return hasTransform(this.latestValues) && removeBoxTransforms(v, this.latestValues), v } setTargetDelta(m) { this.targetDelta = m, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(m) { this.options = { ...this.options, ...m, crossfade: m.crossfade !== void 0 ? m.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(m = !1) { var v; const I = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = I.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = I.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = I.isSharedProjectionDirty); const F = !!this.resumingFrom || this !== I; if (!(m || F && this.isSharedProjectionDirty || this.isProjectionDirty || !((v = this.parent) === null || v === void 0) && v.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: W, layoutId: Z } = this.options; if (!(!this.layout || !(W || Z))) { if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) { const Q = this.getClosestProjectingParent(); Q && Q.layout && this.animationProgress !== 1 ? (this.relativeParent = Q, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, Q.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const Q = this.getClosestProjectingParent(); Q && !!Q.resumingFrom == !!this.resumingFrom && !Q.options.layoutScroll && Q.target && this.animationProgress !== 1 ? (this.relativeParent = Q, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, Q.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } window.MotionDebug && metrics.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var m; const v = this.getLead(), I = !!this.resumingFrom || this !== v; let F = !0; if ((this.isProjectionDirty || !((m = this.parent) === null || m === void 0) && m.isProjectionDirty) && (F = !1), I && (this.isSharedProjectionDirty || this.isTransformDirty) && (F = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (F = !1), F) return; const { layout: B, layoutId: W } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(B || W)) return; copyBoxInto(this.layoutCorrected, this.layout.layoutBox); const Z = this.treeScale.x, Q = this.treeScale.y; applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, I), v.layout && !v.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (v.target = v.layout.layoutBox, v.targetWithTransforms = createBox()); const { target: re } = v; if (!re) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, re, this.latestValues), (this.treeScale.x !== Z || this.treeScale.y !== Q || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", re)), window.MotionDebug && metrics.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(m = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), m) { const v = this.getStack(); v && v.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta() } setAnimationOrigin(m, v = !1) { const I = this.snapshot, F = I ? I.latestValues : {}, B = { ...this.latestValues }, W = createDelta(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !v; const Z = createBox(), Q = I ? I.source : void 0, re = this.layout ? this.layout.source : void 0, ne = Q !== re, oe = this.getStack(), ae = !oe || oe.members.length <= 1, se = !!(ne && !ae && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade)); this.animationProgress = 0; let le; this.mixTargetDelta = ue => { const he = ue / 1e3; mixAxisDelta(W.x, m.x, he), mixAxisDelta(W.y, m.y, he), this.setTargetDelta(W), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(Z, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, Z, he), le && boxEquals(this.relativeTarget, le) && (this.isProjectionDirty = !1), le || (le = createBox()), copyBoxInto(le, this.relativeTarget)), ne && (this.animationValues = B, mixValues(B, F, this.latestValues, he, se, ae)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = he }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(m) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => { globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, { ...m, onUpdate: v => { this.mixTargetDelta(v), m.onUpdate && m.onUpdate(v) }, onComplete: () => { m.onComplete && m.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const m = this.getStack(); m && m.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const m = this.getLead(); let { targetWithTransforms: v, target: I, layout: F, latestValues: B } = m; if (!(!v || !I || !F)) { if (this !== m && this.layout && F && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, F.layoutBox)) { I = this.target || createBox(); const W = calcLength(this.layout.layoutBox.x); I.x.min = m.target.x.min, I.x.max = I.x.min + W; const Z = calcLength(this.layout.layoutBox.y); I.y.min = m.target.y.min, I.y.max = I.y.min + Z } copyBoxInto(v, I), transformBox(v, B), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, v, B) } } registerSharedNode(m, v) { this.sharedNodes.has(m) || this.sharedNodes.set(m, new NodeStack), this.sharedNodes.get(m).add(v); const F = v.options.initialPromotionConfig; v.promote({ transition: F ? F.transition : void 0, preserveFollowOpacity: F && F.shouldPreserveFollowOpacity ? F.shouldPreserveFollowOpacity(v) : void 0 }) } isLead() { const m = this.getStack(); return m ? m.lead === this : !0 } getLead() { var m; const { layoutId: v } = this.options; return v ? ((m = this.getStack()) === null || m === void 0 ? void 0 : m.lead) || this : this } getPrevLead() { var m; const { layoutId: v } = this.options; return v ? (m = this.getStack()) === null || m === void 0 ? void 0 : m.prevLead : void 0 } getStack() { const { layoutId: m } = this.options; if (m) return this.root.sharedNodes.get(m) } promote({ needsReset: m, transition: v, preserveFollowOpacity: I } = {}) { const F = this.getStack(); F && F.promote(this, I), m && (this.projectionDelta = void 0, this.needsReset = !0), v && this.setOptions({ transition: v }) } relegate() { const m = this.getStack(); return m ? m.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: m } = this.options; if (!m) return; let v = !1; const { latestValues: I } = m; if ((I.z || I.rotate || I.rotateX || I.rotateY || I.rotateZ || I.skewX || I.skewY) && (v = !0), !v) return; const F = {}; I.z && resetDistortingTransform("z", m, F, this.animationValues); for (let B = 0; B < transformAxes.length; B++)resetDistortingTransform(`rotate${transformAxes[B]}`, m, F, this.animationValues), resetDistortingTransform(`skew${transformAxes[B]}`, m, F, this.animationValues); m.render(); for (const B in F) m.setStaticValue(B, F[B]), this.animationValues && (this.animationValues[B] = F[B]); m.scheduleRender() } getProjectionStyles(m) { var v, I; if (!this.instance || this.isSVG) return; if (!this.isVisible) return hiddenVisibility; const F = { visibility: "" }, B = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, F.opacity = "", F.pointerEvents = resolveMotionValue(m == null ? void 0 : m.pointerEvents) || "", F.transform = B ? B(this.latestValues, "") : "none", F; const W = this.getLead(); if (!this.projectionDelta || !this.layout || !W.target) { const ne = {}; return this.options.layoutId && (ne.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, ne.pointerEvents = resolveMotionValue(m == null ? void 0 : m.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (ne.transform = B ? B({}, "") : "none", this.hasProjected = !1), ne } const Z = W.animationValues || W.latestValues; this.applyTransformsToTarget(), F.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, Z), B && (F.transform = B(Z, F.transform)); const { x: Q, y: re } = this.projectionDelta; F.transformOrigin = `${Q.origin * 100}% ${re.origin * 100}% 0`, W.animationValues ? F.opacity = W === this ? (I = (v = Z.opacity) !== null && v !== void 0 ? v : this.latestValues.opacity) !== null && I !== void 0 ? I : 1 : this.preserveOpacity ? this.latestValues.opacity : Z.opacityExit : F.opacity = W === this ? Z.opacity !== void 0 ? Z.opacity : "" : Z.opacityExit !== void 0 ? Z.opacityExit : 0; for (const ne in scaleCorrectors) { if (Z[ne] === void 0) continue; const { correct: oe, applyTo: ae } = scaleCorrectors[ne], se = F.transform === "none" ? Z[ne] : oe(Z[ne], W); if (ae) { const le = ae.length; for (let ue = 0; ue < le; ue++)F[ae[ue]] = se } else F[ne] = se } return this.options.layoutId && (F.pointerEvents = W === this ? resolveMotionValue(m == null ? void 0 : m.pointerEvents) || "" : "none"), F } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(m => { var v; return (v = m.currentAnimation) === null || v === void 0 ? void 0 : v.stop() }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear() } } } function updateLayout(o) { o.updateLayout() } function notifyLayoutUpdate(o) { var l; const u = ((l = o.resumeFrom) === null || l === void 0 ? void 0 : l.snapshot) || o.snapshot; if (o.isLead() && o.layout && u && o.hasListeners("didUpdate")) { const { layoutBox: f, measuredBox: p } = o.layout, { animationType: d } = o.options, m = u.source !== o.layout.source; d === "size" ? eachAxis(W => { const Z = m ? u.measuredBox[W] : u.layoutBox[W], Q = calcLength(Z); Z.min = f[W].min, Z.max = Z.min + Q }) : shouldAnimatePositionOnly(d, u.layoutBox, f) && eachAxis(W => { const Z = m ? u.measuredBox[W] : u.layoutBox[W], Q = calcLength(f[W]); Z.max = Z.min + Q, o.relativeTarget && !o.currentAnimation && (o.isProjectionDirty = !0, o.relativeTarget[W].max = o.relativeTarget[W].min + Q) }); const v = createDelta(); calcBoxDelta(v, f, u.layoutBox); const I = createDelta(); m ? calcBoxDelta(I, o.applyTransform(p, !0), u.measuredBox) : calcBoxDelta(I, f, u.layoutBox); const F = !isDeltaZero(v); let B = !1; if (!o.resumeFrom) { const W = o.getClosestProjectingParent(); if (W && !W.resumeFrom) { const { snapshot: Z, layout: Q } = W; if (Z && Q) { const re = createBox(); calcRelativePosition(re, u.layoutBox, Z.layoutBox); const ne = createBox(); calcRelativePosition(ne, f, Q.layoutBox), boxEqualsRounded(re, ne) || (B = !0), W.options.layoutRoot && (o.relativeTarget = ne, o.relativeTargetOrigin = re, o.relativeParent = W) } } } o.notifyListeners("didUpdate", { layout: f, snapshot: u, delta: I, layoutDelta: v, hasLayoutChanged: F, hasRelativeTargetChanged: B }) } else if (o.isLead()) { const { onExitComplete: f } = o.options; f && f() } o.options.transition = void 0 } function propagateDirtyNodes(o) { window.MotionDebug && metrics.totalNodes++, o.parent && (o.isProjecting() || (o.isProjectionDirty = o.parent.isProjectionDirty), o.isSharedProjectionDirty || (o.isSharedProjectionDirty = !!(o.isProjectionDirty || o.parent.isProjectionDirty || o.parent.isSharedProjectionDirty)), o.isTransformDirty || (o.isTransformDirty = o.parent.isTransformDirty)) } function cleanDirtyNodes(o) { o.isProjectionDirty = o.isSharedProjectionDirty = o.isTransformDirty = !1 } function clearSnapshot(o) { o.clearSnapshot() } function clearMeasurements(o) { o.clearMeasurements() } function clearIsLayoutDirty(o) { o.isLayoutDirty = !1 } function resetTransformStyle(o) { const { visualElement: l } = o.options; l && l.getProps().onBeforeLayoutMeasure && l.notify("BeforeLayoutMeasure"), o.resetTransform() } function finishAnimation(o) { o.finishAnimation(), o.targetDelta = o.relativeTarget = o.target = void 0, o.isProjectionDirty = !0 } function resolveTargetDelta(o) { o.resolveTargetDelta() } function calcProjection(o) { o.calcProjection() } function resetSkewAndRotation(o) { o.resetSkewAndRotation() } function removeLeadSnapshots(o) { o.removeLeadSnapshot() } function mixAxisDelta(o, l, u) { o.translate = mixNumber$1(l.translate, 0, u), o.scale = mixNumber$1(l.scale, 1, u), o.origin = l.origin, o.originPoint = l.originPoint } function mixAxis(o, l, u, f) { o.min = mixNumber$1(l.min, u.min, f), o.max = mixNumber$1(l.max, u.max, f) } function mixBox(o, l, u, f) { mixAxis(o.x, l.x, u.x, f), mixAxis(o.y, l.y, u.y, f) } function hasOpacityCrossfade(o) { return o.animationValues && o.animationValues.opacityExit !== void 0 } const defaultLayoutTransition = { duration: .45, ease: [.4, 0, .1, 1] }, userAgentContains = o => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(o), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop; function roundAxis(o) { o.min = roundPoint(o.min), o.max = roundPoint(o.max) } function roundBox(o) { roundAxis(o.x), roundAxis(o.y) } function shouldAnimatePositionOnly(o, l, u) { return o === "position" || o === "preserve-aspect" && !isNear(aspectRatio(l), aspectRatio(u), .2) } const DocumentProjectionNode = createProjectionNode({ attachResizeListener: (o, l) => addDomEvent(o, "resize", l), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), rootProjectionNode = { current: void 0 }, HTMLProjectionNode = createProjectionNode({ measureScroll: o => ({ x: o.scrollLeft, y: o.scrollTop }), defaultParent: () => { if (!rootProjectionNode.current) { const o = new DocumentProjectionNode({}); o.mount(window), o.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = o } return rootProjectionNode.current }, resetTransform: (o, l) => { o.style.transform = l !== void 0 ? l : "none" }, checkIsScrollRoot: o => window.getComputedStyle(o).position === "fixed" }), drag = { pan: { Feature: PanGesture }, drag: { Feature: DragGesture, ProjectionNode: HTMLProjectionNode, MeasureLayout } }, prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 }; function initPrefersReducedMotion() { if (hasReducedMotionListener.current = !0, !!isBrowser$1) if (window.matchMedia) { const o = window.matchMedia("(prefers-reduced-motion)"), l = () => prefersReducedMotion.current = o.matches; o.addListener(l), l() } else prefersReducedMotion.current = !1 } function updateMotionValuesFromProps(o, l, u) { for (const f in l) { const p = l[f], d = u[f]; if (isMotionValue(p)) o.addValue(f, p); else if (isMotionValue(d)) o.addValue(f, motionValue(p, { owner: o })); else if (d !== p) if (o.hasValue(f)) { const m = o.getValue(f); m.liveStyle === !0 ? m.jump(p) : m.hasAnimated || m.set(p) } else { const m = o.getStaticValue(f); o.addValue(f, motionValue(m !== void 0 ? m : p, { owner: o })) } } for (const f in u) l[f] === void 0 && o.removeValue(f); return l } const visualElementStore = new WeakMap, valueTypes = [...dimensionValueTypes, color, complex], findValueType = o => valueTypes.find(testValueType(o)), propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], numVariantProps = variantProps.length; class VisualElement { scrapeMotionValuesFromProps(l, u, f) { return {} } constructor({ parent: l, props: u, presenceContext: f, reducedMotionConfig: p, blockInitialAnimation: d, visualState: m }, v = {}) { this.applyWillChange = !1, this.resolveKeyframes = (Z, Q, re, ne) => new this.KeyframeResolver(Z, Q, re, ne, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.isRenderScheduled = !1, this.scheduleRender = () => { this.isRenderScheduled || (this.isRenderScheduled = !0, frame.render(this.render, !1, !0)) }; const { latestValues: I, renderState: F } = m; this.latestValues = I, this.baseTarget = { ...I }, this.initialValues = u.initial ? { ...I } : {}, this.renderState = F, this.parent = l, this.props = u, this.presenceContext = f, this.depth = l ? l.depth + 1 : 0, this.reducedMotionConfig = p, this.options = v, this.blockInitialAnimation = !!d, this.isControllingVariants = isControllingVariants(u), this.isVariantNode = isVariantNode(u), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(l && l.current); const { willChange: B, ...W } = this.scrapeMotionValuesFromProps(u, {}, this); for (const Z in W) { const Q = W[Z]; I[Z] !== void 0 && isMotionValue(Q) && Q.set(I[Z], !1) } } mount(l) { this.current = l, visualElementStore.set(l, this), this.projection && !this.projection.instance && this.projection.mount(l), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((u, f) => this.bindToMotionValue(f, u)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach(l => l()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const l in this.events) this.events[l].clear(); for (const l in this.features) { const u = this.features[l]; u && (u.unmount(), u.isMounted = !1) } this.current = null } bindToMotionValue(l, u) { const f = transformProps.has(l), p = u.on("change", m => { this.latestValues[l] = m, this.props.onUpdate && frame.preRender(this.notifyUpdate), f && this.projection && (this.projection.isTransformDirty = !0) }), d = u.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(l, () => { p(), d(), u.owner && u.stop() }) } sortNodePosition(l) { return !this.current || !this.sortInstanceNodePosition || this.type !== l.type ? 0 : this.sortInstanceNodePosition(this.current, l.current) } updateFeatures() { let l = "animation"; for (l in featureDefinitions) { const u = featureDefinitions[l]; if (!u) continue; const { isEnabled: f, Feature: p } = u; if (!this.features[l] && p && f(this.props) && (this.features[l] = new p(this)), this.features[l]) { const d = this.features[l]; d.isMounted ? d.update() : (d.mount(), d.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox() } getStaticValue(l) { return this.latestValues[l] } setStaticValue(l, u) { this.latestValues[l] = u } update(l, u) { (l.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = l, this.prevPresenceContext = this.presenceContext, this.presenceContext = u; for (let f = 0; f < propEventHandlers.length; f++) { const p = propEventHandlers[f]; this.propEventSubscriptions[p] && (this.propEventSubscriptions[p](), delete this.propEventSubscriptions[p]); const d = "on" + p, m = l[d]; m && (this.propEventSubscriptions[p] = this.on(p, m)) } this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(l, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(l) { return this.props.variants ? this.props.variants[l] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(l = !1) { if (l) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const f = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (f.initial = this.props.initial), f } const u = {}; for (let f = 0; f < numVariantProps; f++) { const p = variantProps[f], d = this.props[p]; (isVariantLabel(d) || d === !1) && (u[p] = d) } return u } addVariantChild(l) { const u = this.getClosestVariantNode(); if (u) return u.variantChildren && u.variantChildren.add(l), () => u.variantChildren.delete(l) } addValue(l, u) { const f = this.values.get(l); u !== f && (f && this.removeValue(l), this.bindToMotionValue(l, u), this.values.set(l, u), this.latestValues[l] = u.get()) } removeValue(l) { this.values.delete(l); const u = this.valueSubscriptions.get(l); u && (u(), this.valueSubscriptions.delete(l)), delete this.latestValues[l], this.removeValueFromRenderState(l, this.renderState) } hasValue(l) { return this.values.has(l) } getValue(l, u) { if (this.props.values && this.props.values[l]) return this.props.values[l]; let f = this.values.get(l); return f === void 0 && u !== void 0 && (f = motionValue(u === null ? void 0 : u, { owner: this }), this.addValue(l, f)), f } readValue(l, u) { var f; let p = this.latestValues[l] !== void 0 || !this.current ? this.latestValues[l] : (f = this.getBaseTargetFromProps(this.props, l)) !== null && f !== void 0 ? f : this.readValueFromInstance(this.current, l, this.options); return p != null && (typeof p == "string" && (isNumericalString(p) || isZeroValueString(p)) ? p = parseFloat(p) : !findValueType(p) && complex.test(u) && (p = getAnimatableNone(l, u)), this.setBaseTarget(l, isMotionValue(p) ? p.get() : p)), isMotionValue(p) ? p.get() : p } setBaseTarget(l, u) { this.baseTarget[l] = u } getBaseTarget(l) { var u; const { initial: f } = this.props; let p; if (typeof f == "string" || typeof f == "object") { const m = resolveVariantFromProps(this.props, f, (u = this.presenceContext) === null || u === void 0 ? void 0 : u.custom); m && (p = m[l]) } if (f && p !== void 0) return p; const d = this.getBaseTargetFromProps(this.props, l); return d !== void 0 && !isMotionValue(d) ? d : this.initialValues[l] !== void 0 && p === void 0 ? void 0 : this.baseTarget[l] } on(l, u) { return this.events[l] || (this.events[l] = new SubscriptionManager), this.events[l].add(u) } notify(l, ...u) { this.events[l] && this.events[l].notify(...u) } } class DOMVisualElement extends VisualElement { constructor() { super(...arguments), this.KeyframeResolver = DOMKeyframesResolver } sortInstanceNodePosition(l, u) { return l.compareDocumentPosition(u) & 2 ? 1 : -1 } getBaseTargetFromProps(l, u) { return l.style ? l.style[u] : void 0 } removeValueFromRenderState(l, { vars: u, style: f }) { delete u[l], delete f[l] } } function getComputedStyle$1(o) { return window.getComputedStyle(o) } class HTMLVisualElement extends DOMVisualElement { constructor() { super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = renderHTML } readValueFromInstance(l, u) { if (transformProps.has(u)) { const f = getDefaultValueType(u); return f && f.default || 0 } else { const f = getComputedStyle$1(l), p = (isCSSVariableName(u) ? f.getPropertyValue(u) : f[u]) || 0; return typeof p == "string" ? p.trim() : p } } measureInstanceViewportBox(l, { transformPagePoint: u }) { return measureViewportBox(l, u) } build(l, u, f) { buildHTMLStyles(l, u, f.transformTemplate) } scrapeMotionValuesFromProps(l, u, f) { return scrapeMotionValuesFromProps$1(l, u, f) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: l } = this.props; isMotionValue(l) && (this.childSubscription = l.on("change", u => { this.current && (this.current.textContent = `${u}`) })) } } class SVGVisualElement extends DOMVisualElement { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox } getBaseTargetFromProps(l, u) { return l[u] } readValueFromInstance(l, u) { if (transformProps.has(u)) { const f = getDefaultValueType(u); return f && f.default || 0 } return u = camelCaseAttributes.has(u) ? u : camelToDash(u), l.getAttribute(u) } scrapeMotionValuesFromProps(l, u, f) { return scrapeMotionValuesFromProps(l, u, f) } build(l, u, f) { buildSVGAttrs(l, u, this.isSVGTag, f.transformTemplate) } renderInstance(l, u, f, p) { renderSVG(l, u, f, p) } mount(l) { this.isSVGTag = isSVGTag(l.tagName), super.mount(l) } } const createDomVisualElement = (o, l) => isSVGComponent(o) ? new SVGVisualElement(l) : new HTMLVisualElement(l, { allowProjection: o !== reactExports.Fragment }), layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout } }, preloadedFeatures = { ...animations, ...gestureAnimations, ...drag, ...layout }, motion = createMotionProxy((o, l) => createDomMotionConfig(o, l, preloadedFeatures, createDomVisualElement)); function useIsMounted() { const o = reactExports.useRef(!1); return useIsomorphicLayoutEffect(() => (o.current = !0, () => { o.current = !1 }), []), o } function useForceUpdate() { const o = useIsMounted(), [l, u] = reactExports.useState(0), f = reactExports.useCallback(() => { o.current && u(l + 1) }, [l]); return [reactExports.useCallback(() => frame.postRender(f), [f]), l] } class PopChildMeasure extends reactExports.Component { getSnapshotBeforeUpdate(l) { const u = this.props.childRef.current; if (u && l.isPresent && !this.props.isPresent) { const f = this.props.sizeRef.current; f.height = u.offsetHeight || 0, f.width = u.offsetWidth || 0, f.top = u.offsetTop, f.left = u.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function PopChild({ children: o, isPresent: l }) {
  const u = reactExports.useId(), f = reactExports.useRef(null), p = reactExports.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: d } = reactExports.useContext(MotionConfigContext); return reactExports.useInsertionEffect(() => {
    const { width: m, height: v, top: I, left: F } = p.current; if (l || !f.current || !m || !v) return; f.current.dataset.motionPopId = u; const B = document.createElement("style"); return d && (B.nonce = d), document.head.appendChild(B), B.sheet && B.sheet.insertRule(`
          [data-motion-pop-id="${u}"] {
            position: absolute !important;
            width: ${m}px !important;
            height: ${v}px !important;
            top: ${I}px !important;
            left: ${F}px !important;
          }
        `), () => { document.head.removeChild(B) }
  }, [l]), jsxRuntimeExports.jsx(PopChildMeasure, { isPresent: l, childRef: f, sizeRef: p, children: reactExports.cloneElement(o, { ref: f }) })
} const PresenceChild = ({ children: o, initial: l, isPresent: u, onExitComplete: f, custom: p, presenceAffectsLayout: d, mode: m }) => { const v = useConstant(newChildrenMap), I = reactExports.useId(), F = reactExports.useMemo(() => ({ id: I, initial: l, isPresent: u, custom: p, onExitComplete: B => { v.set(B, !0); for (const W of v.values()) if (!W) return; f && f() }, register: B => (v.set(B, !1), () => v.delete(B)) }), d ? [Math.random()] : [u]); return reactExports.useMemo(() => { v.forEach((B, W) => v.set(W, !1)) }, [u]), reactExports.useEffect(() => { !u && !v.size && f && f() }, [u]), m === "popLayout" && (o = jsxRuntimeExports.jsx(PopChild, { isPresent: u, children: o })), jsxRuntimeExports.jsx(PresenceContext.Provider, { value: F, children: o }) }; function newChildrenMap() { return new Map } function useUnmountEffect(o) { return reactExports.useEffect(() => () => o(), []) } const getChildKey = o => o.key || ""; function updateChildLookup(o, l) { o.forEach(u => { const f = getChildKey(u); l.set(f, u) }) } function onlyElements(o) { const l = []; return reactExports.Children.forEach(o, u => { reactExports.isValidElement(u) && l.push(u) }), l } const AnimatePresence = ({ children: o, custom: l, initial: u = !0, onExitComplete: f, exitBeforeEnter: p, presenceAffectsLayout: d = !0, mode: m = "sync" }) => { const v = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0], I = useIsMounted(), F = onlyElements(o); let B = F; const W = reactExports.useRef(new Map).current, Z = reactExports.useRef(B), Q = reactExports.useRef(new Map).current, re = reactExports.useRef(!0); if (useIsomorphicLayoutEffect(() => { re.current = !1, updateChildLookup(F, Q), Z.current = B }), useUnmountEffect(() => { re.current = !0, Q.clear(), W.clear() }), re.current) return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: B.map(se => jsxRuntimeExports.jsx(PresenceChild, { isPresent: !0, initial: u ? void 0 : !1, presenceAffectsLayout: d, mode: m, children: se }, getChildKey(se))) }); B = [...B]; const ne = Z.current.map(getChildKey), oe = F.map(getChildKey), ae = ne.length; for (let se = 0; se < ae; se++) { const le = ne[se]; oe.indexOf(le) === -1 && !W.has(le) && W.set(le, void 0) } return m === "wait" && W.size && (B = []), W.forEach((se, le) => { if (oe.indexOf(le) !== -1) return; const ue = Q.get(le); if (!ue) return; const he = ne.indexOf(le); let pe = se; if (!pe) { const ve = () => { W.delete(le); const _e = Array.from(Q.keys()).filter(Se => !oe.includes(Se)); if (_e.forEach(Se => Q.delete(Se)), Z.current = F.filter(Se => { const $e = getChildKey(Se); return $e === le || _e.includes($e) }), !W.size) { if (I.current === !1) return; v(), f && f() } }; pe = jsxRuntimeExports.jsx(PresenceChild, { isPresent: !1, onExitComplete: ve, custom: l, presenceAffectsLayout: d, mode: m, children: ue }, getChildKey(ue)), W.set(le, pe) } B.splice(he, 0, pe) }), B = B.map(se => { const le = se.key; return W.has(le) ? se : jsxRuntimeExports.jsx(PresenceChild, { isPresent: !0, presenceAffectsLayout: d, mode: m, children: se }, getChildKey(se)) }), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: W.size ? B : B.map(se => reactExports.cloneElement(se)) }) }; function resolveElements(o, l, u) { var f; if (typeof o == "string") { let p = document; l && (invariant(!!l.current), p = l.current), u ? ((f = u[o]) !== null && f !== void 0 || (u[o] = p.querySelectorAll(o)), o = u[o]) : o = p.querySelectorAll(o) } else o instanceof Element && (o = [o]); return Array.from(o || []) } function stopAnimation(o) { o.values.forEach(l => l.stop()) } function setVariants(o, l) { [...l].reverse().forEach(f => { const p = o.getVariant(f); p && setTarget(o, p), o.variantChildren && o.variantChildren.forEach(d => { setVariants(d, l) }) }) } function setValues(o, l) { if (Array.isArray(l)) return setVariants(o, l); if (typeof l == "string") return setVariants(o, [l]); setTarget(o, l) } function animationControls() { const o = new Set, l = { subscribe(u) { return o.add(u), () => void o.delete(u) }, start(u, f) { const p = []; return o.forEach(d => { p.push(animateVisualElement(d, u, { transitionOverride: f })) }), Promise.all(p) }, set(u) { return o.forEach(f => { setValues(f, u) }) }, stop() { o.forEach(u => { stopAnimation(u) }) }, mount() { return () => { l.stop() } } }; return l } function isDOMKeyframes(o) { return typeof o == "object" && !Array.isArray(o) } function createVisualElement(o) { const l = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, u = isSVGElement(o) ? new SVGVisualElement(l) : new HTMLVisualElement(l); u.mount(o), visualElementStore.set(o, u) } function createGeneratorEasing(o, l = 100) { const u = spring({ keyframes: [0, l], ...o }), f = Math.min(calcGeneratorDuration(u), maxGeneratorDuration); return { type: "keyframes", ease: p => u.next(f * p).value / l, duration: millisecondsToSeconds(f) } } function calcNextTime(o, l, u, f) { var p; return typeof l == "number" ? l : l.startsWith("-") || l.startsWith("+") ? Math.max(0, o + parseFloat(l)) : l === "<" ? u : (p = f.get(l)) !== null && p !== void 0 ? p : o } const wrap = (o, l, u) => { const f = l - o; return ((u - o) % f + f) % f + o }; function getEasingForSegment(o, l) { return isEasingArray(o) ? o[wrap(0, o.length, l)] : o } function eraseKeyframes(o, l, u) { for (let f = 0; f < o.length; f++) { const p = o[f]; p.at > l && p.at < u && (removeItem(o, p), f--) } } function addKeyframes(o, l, u, f, p, d) { eraseKeyframes(o, p, d); for (let m = 0; m < l.length; m++)o.push({ value: l[m], at: mixNumber$1(p, d, f[m]), easing: getEasingForSegment(u, m) }) } function compareByTime(o, l) { return o.at === l.at ? o.value === null ? 1 : l.value === null ? -1 : 0 : o.at - l.at } const defaultSegmentEasing = "easeInOut"; function createAnimationsFromSequence(o, { defaultTransition: l = {}, ...u } = {}, f) { const p = l.duration || .3, d = new Map, m = new Map, v = {}, I = new Map; let F = 0, B = 0, W = 0; for (let Z = 0; Z < o.length; Z++) { const Q = o[Z]; if (typeof Q == "string") { I.set(Q, B); continue } else if (!Array.isArray(Q)) { I.set(Q.name, calcNextTime(B, Q.at, F, I)); continue } let [re, ne, oe = {}] = Q; oe.at !== void 0 && (B = calcNextTime(B, oe.at, F, I)); let ae = 0; const se = (le, ue, he, pe = 0, ve = 0) => { const _e = keyframesAsList(le), { delay: Se = 0, times: $e = defaultOffset(_e), type: ie = "keyframes", ...g } = ue; let { ease: P = l.ease || "easeOut", duration: U } = ue; const K = typeof Se == "function" ? Se(pe, ve) : Se, Y = _e.length; if (Y <= 2 && ie === "spring") { let y = 100; if (Y === 2 && isNumberKeyframesArray(_e)) { const me = _e[1] - _e[0]; y = Math.abs(me) } const X = { ...g }; U !== void 0 && (X.duration = secondsToMilliseconds(U)); const ce = createGeneratorEasing(X, y); P = ce.ease, U = ce.duration } U ?? (U = p); const te = B + K, ee = te + U; $e.length === 1 && $e[0] === 0 && ($e[1] = 1); const G = $e.length - _e.length; G > 0 && fillOffset($e, G), _e.length === 1 && _e.unshift(null), addKeyframes(he, _e, P, $e, te, ee), ae = Math.max(K + U, ae), W = Math.max(ee, W) }; if (isMotionValue(re)) { const le = getSubjectSequence(re, m); se(ne, oe, getValueSequence("default", le)) } else { const le = resolveElements(re, f, v), ue = le.length; for (let he = 0; he < ue; he++) { ne = ne, oe = oe; const pe = le[he], ve = getSubjectSequence(pe, m); for (const _e in ne) se(ne[_e], getValueTransition(oe, _e), getValueSequence(_e, ve), he, ue) } } F = B, B += ae } return m.forEach((Z, Q) => { for (const re in Z) { const ne = Z[re]; ne.sort(compareByTime); const oe = [], ae = [], se = []; for (let ue = 0; ue < ne.length; ue++) { const { at: he, value: pe, easing: ve } = ne[ue]; oe.push(pe), ae.push(progress(0, W, he)), se.push(ve || "easeOut") } ae[0] !== 0 && (ae.unshift(0), oe.unshift(oe[0]), se.unshift(defaultSegmentEasing)), ae[ae.length - 1] !== 1 && (ae.push(1), oe.push(null)), d.has(Q) || d.set(Q, { keyframes: {}, transition: {} }); const le = d.get(Q); le.keyframes[re] = oe, le.transition[re] = { ...l, duration: W, ease: se, times: ae, ...u } } }), d } function getSubjectSequence(o, l) { return !l.has(o) && l.set(o, {}), l.get(o) } function getValueSequence(o, l) { return l[o] || (l[o] = []), l[o] } function keyframesAsList(o) { return Array.isArray(o) ? o : [o] } function getValueTransition(o, l) { return o[l] ? { ...o, ...o[l] } : { ...o } } const isNumber$1 = o => typeof o == "number", isNumberKeyframesArray = o => o.every(isNumber$1); function animateElements(o, l, u, f) { const p = resolveElements(o, f), d = p.length, m = []; for (let v = 0; v < d; v++) { const I = p[v]; visualElementStore.has(I) || createVisualElement(I); const F = visualElementStore.get(I), B = { ...u }; typeof B.delay == "function" && (B.delay = B.delay(v, d)), m.push(...animateTarget(F, { ...l, transition: B }, {})) } return new GroupPlaybackControls(m) } const isSequence = o => Array.isArray(o) && Array.isArray(o[0]); function animateSequence(o, l, u) { const f = []; return createAnimationsFromSequence(o, l, u).forEach(({ keyframes: d, transition: m }, v) => { let I; isMotionValue(v) ? I = animateSingleValue(v, d.default, m.default) : I = animateElements(v, d, m), f.push(I) }), new GroupPlaybackControls(f) } const createScopedAnimate = o => { function l(u, f, p) { let d; return isSequence(u) ? d = animateSequence(u, f, o) : isDOMKeyframes(f) ? d = animateElements(u, f, p, o) : d = animateSingleValue(u, f, p), o && o.animations.push(d), d } return l }; function useAnimate() { const o = useConstant(() => ({ current: null, animations: [] })), l = useConstant(() => createScopedAnimate(o)); return useUnmountEffect(() => { o.animations.forEach(u => u.stop()) }), [o, l] } function useAnimationControls() { const o = useConstant(animationControls); return useIsomorphicLayoutEffect(o.mount, []), o } function isObject$2(o) { return Object.prototype.toString.call(o) === "[object Object]" } function isRecord(o) { return isObject$2(o) || Array.isArray(o) } function canUseDOM() { return !!(typeof window < "u" && window.document && window.document.createElement) } function areOptionsEqual(o, l) { const u = Object.keys(o), f = Object.keys(l); if (u.length !== f.length) return !1; const p = JSON.stringify(Object.keys(o.breakpoints || {})), d = JSON.stringify(Object.keys(l.breakpoints || {})); return p !== d ? !1 : u.every(m => { const v = o[m], I = l[m]; return typeof v == "function" ? `${v}` == `${I}` : !isRecord(v) || !isRecord(I) ? v === I : areOptionsEqual(v, I) }) } function sortAndMapPluginToOptions(o) { return o.concat().sort((l, u) => l.name > u.name ? 1 : -1).map(l => l.options) } function arePluginsEqual(o, l) { if (o.length !== l.length) return !1; const u = sortAndMapPluginToOptions(o), f = sortAndMapPluginToOptions(l); return u.every((p, d) => { const m = f[d]; return areOptionsEqual(p, m) }) } function isNumber(o) { return typeof o == "number" } function isString(o) { return typeof o == "string" } function isBoolean(o) { return typeof o == "boolean" } function isObject$1(o) { return Object.prototype.toString.call(o) === "[object Object]" } function mathAbs(o) { return Math.abs(o) } function mathSign(o) { return Math.sign(o) } function deltaAbs(o, l) { return mathAbs(o - l) } function factorAbs(o, l) { if (o === 0 || l === 0 || mathAbs(o) <= mathAbs(l)) return 0; const u = deltaAbs(mathAbs(o), mathAbs(l)); return mathAbs(u / o) } function arrayKeys(o) { return objectKeys(o).map(Number) } function arrayLast(o) { return o[arrayLastIndex(o)] } function arrayLastIndex(o) { return Math.max(0, o.length - 1) } function arrayIsLastIndex(o, l) { return l === arrayLastIndex(o) } function arrayFromNumber(o, l = 0) { return Array.from(Array(o), (u, f) => l + f) } function objectKeys(o) { return Object.keys(o) } function objectsMergeDeep(o, l) { return [o, l].reduce((u, f) => (objectKeys(f).forEach(p => { const d = u[p], m = f[p], v = isObject$1(d) && isObject$1(m); u[p] = v ? objectsMergeDeep(d, m) : m }), u), {}) } function isMouseEvent(o, l) { return typeof l.MouseEvent < "u" && o instanceof l.MouseEvent } function Alignment(o, l) { const u = { start: f, center: p, end: d }; function f() { return 0 } function p(I) { return d(I) / 2 } function d(I) { return l - I } function m(I, F) { return isString(o) ? u[o](I) : o(l, I, F) } return { measure: m } } function EventStore() { let o = []; function l(p, d, m, v = { passive: !0 }) { let I; if ("addEventListener" in p) p.addEventListener(d, m, v), I = () => p.removeEventListener(d, m, v); else { const F = p; F.addListener(m), I = () => F.removeListener(m) } return o.push(I), f } function u() { o = o.filter(p => p()) } const f = { add: l, clear: u }; return f } function Animations(o, l, u, f) { const p = EventStore(), d = 1e3 / 60; let m = null, v = 0, I = 0; function F() { p.add(o, "visibilitychange", () => { o.hidden && re() }) } function B() { Q(), p.clear() } function W(oe) { if (!I) return; m || (m = oe); const ae = oe - m; for (m = oe, v += ae; v >= d;)u(d), v -= d; const se = v / d; f(se), I && l.requestAnimationFrame(W) } function Z() { I || (I = l.requestAnimationFrame(W)) } function Q() { l.cancelAnimationFrame(I), m = null, v = 0, I = 0 } function re() { m = null, v = 0 } return { init: F, destroy: B, start: Z, stop: Q, update: () => u(d), render: f } } function Axis(o, l) { const u = l === "rtl", f = o === "y", p = f ? "y" : "x", d = f ? "x" : "y", m = !f && u ? -1 : 1, v = B(), I = W(); function F(re) { const { height: ne, width: oe } = re; return f ? ne : oe } function B() { return f ? "top" : u ? "right" : "left" } function W() { return f ? "bottom" : u ? "left" : "right" } function Z(re) { return re * m } return { scroll: p, cross: d, startEdge: v, endEdge: I, measureSize: F, direction: Z } } function Limit(o = 0, l = 0) { const u = mathAbs(o - l); function f(F) { return F < o } function p(F) { return F > l } function d(F) { return f(F) || p(F) } function m(F) { return d(F) ? f(F) ? o : l : F } function v(F) { return u ? F - u * Math.ceil((F - l) / u) : F } return { length: u, max: l, min: o, constrain: m, reachedAny: d, reachedMax: p, reachedMin: f, removeOffset: v } } function Counter(o, l, u) { const { constrain: f } = Limit(0, o), p = o + 1; let d = m(l); function m(Z) { return u ? mathAbs((p + Z) % p) : f(Z) } function v() { return d } function I(Z) { return d = m(Z), W } function F(Z) { return B().set(v() + Z) } function B() { return Counter(o, v(), u) } const W = { get: v, set: I, add: F, clone: B }; return W } function DragHandler(o, l, u, f, p, d, m, v, I, F, B, W, Z, Q, re, ne, oe, ae, se) { const { cross: le, direction: ue } = o, he = ["INPUT", "SELECT", "TEXTAREA"], pe = { passive: !1 }, ve = EventStore(), _e = EventStore(), Se = Limit(50, 225).constrain(Q.measure(20)), $e = { mouse: 300, touch: 400 }, ie = { mouse: 500, touch: 600 }, g = re ? 43 : 25; let P = !1, U = 0, K = 0, Y = !1, te = !1, ee = !1, G = !1; function y(ke) { if (!se) return; function Je(lt) { (isBoolean(se) || se(ke, lt)) && Be(lt) } const dt = l; ve.add(dt, "dragstart", lt => lt.preventDefault(), pe).add(dt, "touchmove", () => { }, pe).add(dt, "touchend", () => { }).add(dt, "touchstart", Je).add(dt, "mousedown", Je).add(dt, "touchcancel", De).add(dt, "contextmenu", De).add(dt, "click", Ue, !0) } function X() { ve.clear(), _e.clear() } function ce() { const ke = G ? u : l; _e.add(ke, "touchmove", Me, pe).add(ke, "touchend", De).add(ke, "mousemove", Me, pe).add(ke, "mouseup", De) } function me(ke) { const Je = ke.nodeName || ""; return he.includes(Je) } function Ae() { return (re ? ie : $e)[G ? "mouse" : "touch"] } function Ie(ke, Je) { const dt = W.add(mathSign(ke) * -1), lt = B.byDistance(ke, !re).distance; return re || mathAbs(ke) < Se ? lt : oe && Je ? lt * .5 : B.byIndex(dt.get(), 0).distance } function Be(ke) { const Je = isMouseEvent(ke, f); G = Je, ee = re && Je && !ke.buttons && P, P = deltaAbs(p.get(), m.get()) >= 2, !(Je && ke.button !== 0) && (me(ke.target) || (Y = !0, d.pointerDown(ke), F.useFriction(0).useDuration(0), p.set(m), ce(), U = d.readPoint(ke), K = d.readPoint(ke, le), Z.emit("pointerDown"))) } function Me(ke) { if (!isMouseEvent(ke, f) && ke.touches.length >= 2) return De(ke); const dt = d.readPoint(ke), lt = d.readPoint(ke, le), ht = deltaAbs(dt, U), Bt = deltaAbs(lt, K); if (!te && !G && (!ke.cancelable || (te = ht > Bt, !te))) return De(ke); const mt = d.pointerMove(ke); ht > ne && (ee = !0), F.useFriction(.3).useDuration(.75), v.start(), p.add(ue(mt)), ke.preventDefault() } function De(ke) { const dt = B.byDistance(0, !1).index !== W.get(), lt = d.pointerUp(ke) * Ae(), ht = Ie(ue(lt), dt), Bt = factorAbs(lt, ht), mt = g - 10 * Bt, et = ae + Bt / 50; te = !1, Y = !1, _e.clear(), F.useDuration(mt).useFriction(et), I.distance(ht, !re), G = !1, Z.emit("pointerUp") } function Ue(ke) { ee && (ke.stopPropagation(), ke.preventDefault(), ee = !1) } function Ke() { return Y } return { init: y, destroy: X, pointerDown: Ke } } function DragTracker(o, l) { let f, p; function d(W) { return W.timeStamp } function m(W, Z) { const re = `client${(Z || o.scroll) === "x" ? "X" : "Y"}`; return (isMouseEvent(W, l) ? W : W.touches[0])[re] } function v(W) { return f = W, p = W, m(W) } function I(W) { const Z = m(W) - m(p), Q = d(W) - d(f) > 170; return p = W, Q && (f = W), Z } function F(W) { if (!f || !p) return 0; const Z = m(p) - m(f), Q = d(W) - d(f), re = d(W) - d(p) > 170, ne = Z / Q; return Q && !re && mathAbs(ne) > .1 ? ne : 0 } return { pointerDown: v, pointerMove: I, pointerUp: F, readPoint: m } } function NodeRects() { function o(u) { const { offsetTop: f, offsetLeft: p, offsetWidth: d, offsetHeight: m } = u; return { top: f, right: p + d, bottom: f + m, left: p, width: d, height: m } } return { measure: o } } function PercentOfView(o) { function l(f) { return o * (f / 100) } return { measure: l } } function ResizeHandler(o, l, u, f, p, d, m) { let v, I, F = [], B = !1; function W(ne) { return p.measureSize(m.measure(ne)) } function Z(ne) { if (!d) return; I = W(o), F = f.map(W); function oe(se) { for (const le of se) { const ue = le.target === o, he = f.indexOf(le.target), pe = ue ? I : F[he], ve = W(ue ? o : f[he]); if (mathAbs(ve - pe) >= .5) { u.requestAnimationFrame(() => { ne.reInit(), l.emit("resize") }); break } } } v = new ResizeObserver(se => { B || (isBoolean(d) || d(ne, se)) && oe(se) }), [o].concat(f).forEach(se => v.observe(se)) } function Q() { v && v.disconnect(), B = !0 } return { init: Z, destroy: Q } } function ScrollBody(o, l, u, f, p, d) { let m = 0, v = 0, I = p, F = d, B = o.get(), W = 0; function Z(pe) { const ve = pe / 1e3, _e = I * ve, Se = f.get() - o.get(), $e = !I; let ie = 0; return $e ? (m = 0, u.set(f), o.set(f), ie = Se) : (u.set(o), m += Se / _e, m *= F, B += m, o.add(m * ve), ie = B - W), v = mathSign(ie), W = B, he } function Q() { const pe = f.get() - l.get(); return mathAbs(pe) < .001 } function re() { return I } function ne() { return v } function oe() { return m } function ae() { return le(p) } function se() { return ue(d) } function le(pe) { return I = pe, he } function ue(pe) { return F = pe, he } const he = { direction: ne, duration: re, velocity: oe, seek: Z, settled: Q, useBaseFriction: se, useBaseDuration: ae, useFriction: ue, useDuration: le }; return he } function ScrollBounds(o, l, u, f, p) { const d = p.measure(10), m = p.measure(50), v = Limit(.1, .99); let I = !1; function F() { return !(I || !o.reachedAny(u.get()) || !o.reachedAny(l.get())) } function B(Q) { if (!F()) return; const re = o.reachedMin(l.get()) ? "min" : "max", ne = mathAbs(o[re] - l.get()), oe = u.get() - l.get(), ae = v.constrain(ne / m); u.subtract(oe * ae), !Q && mathAbs(oe) < d && (u.set(o.constrain(u.get())), f.useDuration(25).useBaseFriction()) } function W(Q) { I = !Q } return { shouldConstrain: F, constrain: B, toggleActive: W } } function ScrollContain(o, l, u, f, p) { const d = Limit(-l + o, 0), m = W(), v = B(), I = Z(); function F(re, ne) { return deltaAbs(re, ne) < 1 } function B() { const re = m[0], ne = arrayLast(m), oe = m.lastIndexOf(re), ae = m.indexOf(ne) + 1; return Limit(oe, ae) } function W() { return u.map((re, ne) => { const { min: oe, max: ae } = d, se = d.constrain(re), le = !ne, ue = arrayIsLastIndex(u, ne); return le ? ae : ue || F(oe, se) ? oe : F(ae, se) ? ae : se }).map(re => parseFloat(re.toFixed(3))) } function Z() { if (l <= o + p) return [d.max]; if (f === "keepSnaps") return m; const { min: re, max: ne } = v; return m.slice(re, ne) } return { snapsContained: I, scrollContainLimit: v } } function ScrollLimit(o, l, u) { const f = l[0], p = u ? f - o : arrayLast(l); return { limit: Limit(p, f) } } function ScrollLooper(o, l, u, f) { const d = l.min + .1, m = l.max + .1, { reachedMin: v, reachedMax: I } = Limit(d, m); function F(Z) { return Z === 1 ? I(u.get()) : Z === -1 ? v(u.get()) : !1 } function B(Z) { if (!F(Z)) return; const Q = o * (Z * -1); f.forEach(re => re.add(Q)) } return { loop: B } } function ScrollProgress(o) { const { max: l, length: u } = o; function f(d) { const m = d - l; return u ? m / -u : 0 } return { get: f } } function ScrollSnaps(o, l, u, f, p) { const { startEdge: d, endEdge: m } = o, { groupSlides: v } = p, I = W().map(l.measure), F = Z(), B = Q(); function W() { return v(f).map(ne => arrayLast(ne)[m] - ne[0][d]).map(mathAbs) } function Z() { return f.map(ne => u[d] - ne[d]).map(ne => -mathAbs(ne)) } function Q() { return v(F).map(ne => ne[0]).map((ne, oe) => ne + I[oe]) } return { snaps: F, snapsAligned: B } } function SlideRegistry(o, l, u, f, p, d) { const { groupSlides: m } = p, { min: v, max: I } = f, F = B(); function B() { const Z = m(d), Q = !o || l === "keepSnaps"; return u.length === 1 ? [d] : Q ? Z : Z.slice(v, I).map((re, ne, oe) => { const ae = !ne, se = arrayIsLastIndex(oe, ne); if (ae) { const le = arrayLast(oe[0]) + 1; return arrayFromNumber(le) } if (se) { const le = arrayLastIndex(d) - arrayLast(oe)[0] + 1; return arrayFromNumber(le, arrayLast(oe)[0]) } return re }) } return { slideRegistry: F } } function ScrollTarget(o, l, u, f, p) { const { reachedAny: d, removeOffset: m, constrain: v } = f; function I(re) { return re.concat().sort((ne, oe) => mathAbs(ne) - mathAbs(oe))[0] } function F(re) { const ne = o ? m(re) : v(re), oe = l.map((se, le) => ({ diff: B(se - ne, 0), index: le })).sort((se, le) => mathAbs(se.diff) - mathAbs(le.diff)), { index: ae } = oe[0]; return { index: ae, distance: ne } } function B(re, ne) { const oe = [re, re + u, re - u]; if (!o) return re; if (!ne) return I(oe); const ae = oe.filter(se => mathSign(se) === ne); return ae.length ? I(ae) : arrayLast(oe) - u } function W(re, ne) { const oe = l[re] - p.get(), ae = B(oe, ne); return { index: re, distance: ae } } function Z(re, ne) { const oe = p.get() + re, { index: ae, distance: se } = F(oe), le = !o && d(oe); if (!ne || le) return { index: ae, distance: re }; const ue = l[ae] - se, he = re + B(ue, 0); return { index: ae, distance: he } } return { byDistance: Z, byIndex: W, shortcut: B } } function ScrollTo(o, l, u, f, p, d, m) { function v(W) { const Z = W.distance, Q = W.index !== l.get(); d.add(Z), Z && (f.duration() ? o.start() : (o.update(), o.render(1), o.update())), Q && (u.set(l.get()), l.set(W.index), m.emit("select")) } function I(W, Z) { const Q = p.byDistance(W, Z); v(Q) } function F(W, Z) { const Q = l.clone().set(W), re = p.byIndex(Q.get(), Z); v(re) } return { distance: I, index: F } } function SlideFocus(o, l, u, f, p, d, m) { let v = 0; function I() { d.add(document, "keydown", F, !1), l.forEach(B) } function F(Z) { Z.code === "Tab" && (v = new Date().getTime()) } function B(Z) { const Q = () => { if (new Date().getTime() - v > 10) return; o.scrollLeft = 0; const oe = l.indexOf(Z), ae = u.findIndex(se => se.includes(oe)); isNumber(ae) && (p.useDuration(0), f.index(ae, 0), m.emit("slideFocus")) }; d.add(Z, "focus", Q, { passive: !0, capture: !0 }) } return { init: I } } function Vector1D(o) { let l = o; function u() { return l } function f(I) { l = m(I) } function p(I) { l += m(I) } function d(I) { l -= m(I) } function m(I) { return isNumber(I) ? I : I.get() } return { get: u, set: f, add: p, subtract: d } } function Translate(o, l) { const u = o.scroll === "x" ? d : m, f = l.style; let p = !1; function d(W) { return `translate3d(${W}px,0px,0px)` } function m(W) { return `translate3d(0px,${W}px,0px)` } function v(W) { p || (f.transform = u(o.direction(W))) } function I(W) { p = !W } function F() { p || (f.transform = "", l.getAttribute("style") || l.removeAttribute("style")) } return { clear: F, to: v, toggleActive: I } } function SlideLooper(o, l, u, f, p, d, m, v, I) { const B = arrayKeys(p), W = arrayKeys(p).reverse(), Z = ae().concat(se()); function Q(ve, _e) { return ve.reduce((Se, $e) => Se - p[$e], _e) } function re(ve, _e) { return ve.reduce((Se, $e) => Q(Se, _e) > 0 ? Se.concat([$e]) : Se, []) } function ne(ve) { return d.map((_e, Se) => ({ start: _e - f[Se] + .5 + ve, end: _e + l - .5 + ve })) } function oe(ve, _e, Se) { const $e = ne(_e); return ve.map(ie => { const g = Se ? 0 : -u, P = Se ? u : 0, U = Se ? "end" : "start", K = $e[ie][U]; return { index: ie, loopPoint: K, slideLocation: Vector1D(-1), translate: Translate(o, I[ie]), target: () => v.get() > K ? g : P } }) } function ae() { const ve = m[0], _e = re(W, ve); return oe(_e, u, !1) } function se() { const ve = l - m[0] - 1, _e = re(B, ve); return oe(_e, -u, !0) } function le() { return Z.every(({ index: ve }) => { const _e = B.filter(Se => Se !== ve); return Q(_e, l) <= .1 }) } function ue() { Z.forEach(ve => { const { target: _e, translate: Se, slideLocation: $e } = ve, ie = _e(); ie !== $e.get() && (Se.to(ie), $e.set(ie)) }) } function he() { Z.forEach(ve => ve.translate.clear()) } return { canLoop: le, clear: he, loop: ue, loopPoints: Z } } function SlidesHandler(o, l, u) { let f, p = !1; function d(I) { if (!u) return; function F(B) { for (const W of B) if (W.type === "childList") { I.reInit(), l.emit("slidesChanged"); break } } f = new MutationObserver(B => { p || (isBoolean(u) || u(I, B)) && F(B) }), f.observe(o, { childList: !0 }) } function m() { f && f.disconnect(), p = !0 } return { init: d, destroy: m } } function SlidesInView(o, l, u, f) { const p = {}; let d = null, m = null, v, I = !1; function F() { v = new IntersectionObserver(re => { I || (re.forEach(ne => { const oe = l.indexOf(ne.target); p[oe] = ne }), d = null, m = null, u.emit("slidesInView")) }, { root: o.parentElement, threshold: f }), l.forEach(re => v.observe(re)) } function B() { v && v.disconnect(), I = !0 } function W(re) { return objectKeys(p).reduce((ne, oe) => { const ae = parseInt(oe), { isIntersecting: se } = p[ae]; return (re && se || !re && !se) && ne.push(ae), ne }, []) } function Z(re = !0) { if (re && d) return d; if (!re && m) return m; const ne = W(re); return re && (d = ne), re || (m = ne), ne } return { init: F, destroy: B, get: Z } } function SlideSizes(o, l, u, f, p, d) { const { measureSize: m, startEdge: v, endEdge: I } = o, F = u[0] && p, B = re(), W = ne(), Z = u.map(m), Q = oe(); function re() { if (!F) return 0; const se = u[0]; return mathAbs(l[v] - se[v]) } function ne() { if (!F) return 0; const se = d.getComputedStyle(arrayLast(f)); return parseFloat(se.getPropertyValue(`margin-${I}`)) } function oe() { return u.map((se, le, ue) => { const he = !le, pe = arrayIsLastIndex(ue, le); return he ? Z[le] + B : pe ? Z[le] + W : ue[le + 1][v] - se[v] }).map(mathAbs) } return { slideSizes: Z, slideSizesWithGaps: Q, startGap: B, endGap: W } } function SlidesToScroll(o, l, u, f, p, d, m, v, I) { const { startEdge: F, endEdge: B, direction: W } = o, Z = isNumber(u); function Q(ae, se) { return arrayKeys(ae).filter(le => le % se === 0).map(le => ae.slice(le, le + se)) } function re(ae) { return ae.length ? arrayKeys(ae).reduce((se, le, ue) => { const he = arrayLast(se) || 0, pe = he === 0, ve = le === arrayLastIndex(ae), _e = p[F] - d[he][F], Se = p[F] - d[le][B], $e = !f && pe ? W(m) : 0, ie = !f && ve ? W(v) : 0, g = mathAbs(Se - ie - (_e + $e)); return ue && g > l + I && se.push(le), ve && se.push(ae.length), se }, []).map((se, le, ue) => { const he = Math.max(ue[le - 1] || 0); return ae.slice(he, se) }) : [] } function ne(ae) { return Z ? Q(ae, u) : re(ae) } return { groupSlides: ne } } function Engine(o, l, u, f, p, d, m) { const { align: v, axis: I, direction: F, startIndex: B, loop: W, duration: Z, dragFree: Q, dragThreshold: re, inViewThreshold: ne, slidesToScroll: oe, skipSnaps: ae, containScroll: se, watchResize: le, watchSlides: ue, watchDrag: he } = d, pe = 2, ve = NodeRects(), _e = ve.measure(l), Se = u.map(ve.measure), $e = Axis(I, F), ie = $e.measureSize(_e), g = PercentOfView(ie), P = Alignment(v, ie), U = !W && !!se, K = W || !!se, { slideSizes: Y, slideSizesWithGaps: te, startGap: ee, endGap: G } = SlideSizes($e, _e, Se, u, K, p), y = SlidesToScroll($e, ie, oe, W, _e, Se, ee, G, pe), { snaps: X, snapsAligned: ce } = ScrollSnaps($e, P, _e, Se, y), me = -arrayLast(X) + arrayLast(te), { snapsContained: Ae, scrollContainLimit: Ie } = ScrollContain(ie, me, ce, se, pe), Be = U ? Ae : ce, { limit: Me } = ScrollLimit(me, Be, W), De = Counter(arrayLastIndex(Be), B, W), Ue = De.clone(), Ke = arrayKeys(u), Ve = ({ dragHandler: ut, scrollBody: ye, scrollBounds: ge, options: { loop: Ee } }, Oe) => { Ee || ge.constrain(ut.pointerDown()), ye.seek(Oe) }, ke = ({ scrollBody: ut, translate: ye, location: ge, offsetLocation: Ee, scrollLooper: Oe, slideLooper: je, dragHandler: nt, animation: Xe, eventHandler: it, scrollBounds: Tt, options: { loop: tt } }, yt) => { const kt = ut.settled(), wt = !Tt.shouldConstrain(), Mt = tt ? kt : kt && wt; Mt && !nt.pointerDown() && (Xe.stop(), it.emit("settle")), Mt || it.emit("scroll"); const tr = ge.get() * yt + Bt.get() * (1 - yt); Ee.set(tr), tt && (Oe.loop(ut.direction()), je.loop()), ye.to(Ee.get()) }, Je = Animations(f, p, ut => Ve(Ze, ut), ut => ke(Ze, ut)), dt = .68, lt = Be[De.get()], ht = Vector1D(lt), Bt = Vector1D(lt), mt = Vector1D(lt), et = Vector1D(lt), Gt = ScrollBody(ht, mt, Bt, et, Z, dt), pt = ScrollTarget(W, Be, me, Me, et), _t = ScrollTo(Je, De, Ue, Gt, pt, et, m), zt = ScrollProgress(Me), bt = EventStore(), We = SlidesInView(l, u, m, ne), { slideRegistry: Ge } = SlideRegistry(U, se, Be, Ie, y, Ke), ze = SlideFocus(o, u, Ge, _t, Gt, bt, m), Ze = { ownerDocument: f, ownerWindow: p, eventHandler: m, containerRect: _e, slideRects: Se, animation: Je, axis: $e, dragHandler: DragHandler($e, o, f, p, et, DragTracker($e, p), ht, Je, _t, Gt, pt, De, m, g, Q, re, ae, dt, he), eventStore: bt, percentOfView: g, index: De, indexPrevious: Ue, limit: Me, location: ht, offsetLocation: mt, previousLocation: Bt, options: d, resizeHandler: ResizeHandler(l, m, p, u, $e, le, ve), scrollBody: Gt, scrollBounds: ScrollBounds(Me, mt, et, Gt, g), scrollLooper: ScrollLooper(me, Me, mt, [ht, mt, Bt, et]), scrollProgress: zt, scrollSnapList: Be.map(zt.get), scrollSnaps: Be, scrollTarget: pt, scrollTo: _t, slideLooper: SlideLooper($e, ie, me, Y, te, X, Be, mt, u), slideFocus: ze, slidesHandler: SlidesHandler(l, m, ue), slidesInView: We, slideIndexes: Ke, slideRegistry: Ge, slidesToScroll: y, target: et, translate: Translate($e, l) }; return Ze } function EventHandler() { let o = {}, l; function u(F) { l = F } function f(F) { return o[F] || [] } function p(F) { return f(F).forEach(B => B(l, F)), I } function d(F, B) { return o[F] = f(F).concat([B]), I } function m(F, B) { return o[F] = f(F).filter(W => W !== B), I } function v() { o = {} } const I = { init: u, emit: p, off: m, on: d, clear: v }; return I } const defaultOptions = { align: "center", axis: "x", container: null, slides: null, containScroll: "trimSnaps", direction: "ltr", slidesToScroll: 1, inViewThreshold: 0, breakpoints: {}, dragFree: !1, dragThreshold: 10, loop: !1, skipSnaps: !1, duration: 25, startIndex: 0, active: !0, watchDrag: !0, watchResize: !0, watchSlides: !0 }; function OptionsHandler(o) { function l(d, m) { return objectsMergeDeep(d, m || {}) } function u(d) { const m = d.breakpoints || {}, v = objectKeys(m).filter(I => o.matchMedia(I).matches).map(I => m[I]).reduce((I, F) => l(I, F), {}); return l(d, v) } function f(d) { return d.map(m => objectKeys(m.breakpoints || {})).reduce((m, v) => m.concat(v), []).map(o.matchMedia) } return { mergeOptions: l, optionsAtMedia: u, optionsMediaQueries: f } } function PluginsHandler(o) { let l = []; function u(d, m) { return l = m.filter(({ options: v }) => o.optionsAtMedia(v).active !== !1), l.forEach(v => v.init(d, o)), m.reduce((v, I) => Object.assign(v, { [I.name]: I }), {}) } function f() { l = l.filter(d => d.destroy()) } return { init: u, destroy: f } } function EmblaCarousel(o, l, u) { const f = o.ownerDocument, p = f.defaultView, d = OptionsHandler(p), m = PluginsHandler(d), v = EventStore(), I = EventHandler(), { mergeOptions: F, optionsAtMedia: B, optionsMediaQueries: W } = d, { on: Z, off: Q, emit: re } = I, ne = ie; let oe = !1, ae, se = F(defaultOptions, EmblaCarousel.globalOptions), le = F(se), ue = [], he, pe, ve; function _e() { const { container: Ve, slides: ke } = le; pe = (isString(Ve) ? o.querySelector(Ve) : Ve) || o.children[0]; const dt = isString(ke) ? pe.querySelectorAll(ke) : ke; ve = [].slice.call(dt || pe.children) } function Se(Ve) { const ke = Engine(o, pe, ve, f, p, Ve, I); if (Ve.loop && !ke.slideLooper.canLoop()) { const Je = Object.assign({}, Ve, { loop: !1 }); return Se(Je) } return ke } function $e(Ve, ke) { oe || (se = F(se, Ve), le = B(se), ue = ke || ue, _e(), ae = Se(le), W([se, ...ue.map(({ options: Je }) => Je)]).forEach(Je => v.add(Je, "change", ie)), le.active && (ae.translate.to(ae.location.get()), ae.animation.init(), ae.slidesInView.init(), ae.slideFocus.init(), ae.eventHandler.init(Ke), ae.resizeHandler.init(Ke), ae.slidesHandler.init(Ke), ae.options.loop && ae.slideLooper.loop(), pe.offsetParent && ve.length && ae.dragHandler.init(Ke), he = m.init(Ke, ue))) } function ie(Ve, ke) { const Je = X(); g(), $e(F({ startIndex: Je }, Ve), ke), I.emit("reInit") } function g() { ae.dragHandler.destroy(), ae.eventStore.clear(), ae.translate.clear(), ae.slideLooper.clear(), ae.resizeHandler.destroy(), ae.slidesHandler.destroy(), ae.slidesInView.destroy(), ae.animation.destroy(), m.destroy(), v.clear() } function P() { oe || (oe = !0, v.clear(), g(), I.emit("destroy"), I.clear()) } function U(Ve, ke, Je) { !le.active || oe || (ae.scrollBody.useBaseFriction().useDuration(ke === !0 ? 0 : le.duration), ae.scrollTo.index(Ve, Je || 0)) } function K(Ve) { const ke = ae.index.add(1).get(); U(ke, Ve, -1) } function Y(Ve) { const ke = ae.index.add(-1).get(); U(ke, Ve, 1) } function te() { return ae.index.add(1).get() !== X() } function ee() { return ae.index.add(-1).get() !== X() } function G() { return ae.scrollSnapList } function y() { return ae.scrollProgress.get(ae.location.get()) } function X() { return ae.index.get() } function ce() { return ae.indexPrevious.get() } function me() { return ae.slidesInView.get() } function Ae() { return ae.slidesInView.get(!1) } function Ie() { return he } function Be() { return ae } function Me() { return o } function De() { return pe } function Ue() { return ve } const Ke = { canScrollNext: te, canScrollPrev: ee, containerNode: De, internalEngine: Be, destroy: P, off: Q, on: Z, emit: re, plugins: Ie, previousScrollSnap: ce, reInit: ne, rootNode: Me, scrollNext: K, scrollPrev: Y, scrollProgress: y, scrollSnapList: G, scrollTo: U, selectedScrollSnap: X, slideNodes: Ue, slidesInView: me, slidesNotInView: Ae }; return $e(l, u), setTimeout(() => I.emit("init"), 0), Ke } EmblaCarousel.globalOptions = void 0; function useEmblaCarousel(o = {}, l = []) { const u = reactExports.useRef(o), f = reactExports.useRef(l), [p, d] = reactExports.useState(), [m, v] = reactExports.useState(), I = reactExports.useCallback(() => { p && p.reInit(u.current, f.current) }, [p]); return reactExports.useEffect(() => { if (canUseDOM() && m) { EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions; const F = EmblaCarousel(m, u.current, f.current); return d(F), () => F.destroy() } else d(void 0) }, [m, d]), reactExports.useEffect(() => { areOptionsEqual(u.current, o) || (u.current = o, I()) }, [o, I]), reactExports.useEffect(() => { arePluginsEqual(f.current, l) || (f.current = l, I()) }, [l, I]), [v, p] } useEmblaCarousel.globalOptions = void 0; var _baseRange, hasRequired_baseRange; function require_baseRange() { if (hasRequired_baseRange) return _baseRange; hasRequired_baseRange = 1; var o = Math.ceil, l = Math.max; function u(f, p, d, m) { for (var v = -1, I = l(o((p - f) / (d || 1)), 0), F = Array(I); I--;)F[m ? I : ++v] = f, f += d; return F } return _baseRange = u, _baseRange } var eq_1, hasRequiredEq; function requireEq() { if (hasRequiredEq) return eq_1; hasRequiredEq = 1; function o(l, u) { return l === u || l !== l && u !== u } return eq_1 = o, eq_1 } var _freeGlobal, hasRequired_freeGlobal; function require_freeGlobal() { if (hasRequired_freeGlobal) return _freeGlobal; hasRequired_freeGlobal = 1; var o = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal; return _freeGlobal = o, _freeGlobal } var _root, hasRequired_root; function require_root() { if (hasRequired_root) return _root; hasRequired_root = 1; var o = require_freeGlobal(), l = typeof self == "object" && self && self.Object === Object && self, u = o || l || Function("return this")(); return _root = u, _root } var _Symbol, hasRequired_Symbol; function require_Symbol() { if (hasRequired_Symbol) return _Symbol; hasRequired_Symbol = 1; var o = require_root(), l = o.Symbol; return _Symbol = l, _Symbol } var _getRawTag, hasRequired_getRawTag; function require_getRawTag() { if (hasRequired_getRawTag) return _getRawTag; hasRequired_getRawTag = 1; var o = require_Symbol(), l = Object.prototype, u = l.hasOwnProperty, f = l.toString, p = o ? o.toStringTag : void 0; function d(m) { var v = u.call(m, p), I = m[p]; try { m[p] = void 0; var F = !0 } catch { } var B = f.call(m); return F && (v ? m[p] = I : delete m[p]), B } return _getRawTag = d, _getRawTag } var _objectToString, hasRequired_objectToString; function require_objectToString() { if (hasRequired_objectToString) return _objectToString; hasRequired_objectToString = 1; var o = Object.prototype, l = o.toString; function u(f) { return l.call(f) } return _objectToString = u, _objectToString } var _baseGetTag, hasRequired_baseGetTag; function require_baseGetTag() { if (hasRequired_baseGetTag) return _baseGetTag; hasRequired_baseGetTag = 1; var o = require_Symbol(), l = require_getRawTag(), u = require_objectToString(), f = "[object Null]", p = "[object Undefined]", d = o ? o.toStringTag : void 0; function m(v) { return v == null ? v === void 0 ? p : f : d && d in Object(v) ? l(v) : u(v) } return _baseGetTag = m, _baseGetTag } var isObject_1, hasRequiredIsObject; function requireIsObject() { if (hasRequiredIsObject) return isObject_1; hasRequiredIsObject = 1; function o(l) { var u = typeof l; return l != null && (u == "object" || u == "function") } return isObject_1 = o, isObject_1 } var isFunction_1, hasRequiredIsFunction; function requireIsFunction() { if (hasRequiredIsFunction) return isFunction_1; hasRequiredIsFunction = 1; var o = require_baseGetTag(), l = requireIsObject(), u = "[object AsyncFunction]", f = "[object Function]", p = "[object GeneratorFunction]", d = "[object Proxy]"; function m(v) { if (!l(v)) return !1; var I = o(v); return I == f || I == p || I == u || I == d } return isFunction_1 = m, isFunction_1 } var isLength_1, hasRequiredIsLength; function requireIsLength() { if (hasRequiredIsLength) return isLength_1; hasRequiredIsLength = 1; var o = 9007199254740991; function l(u) { return typeof u == "number" && u > -1 && u % 1 == 0 && u <= o } return isLength_1 = l, isLength_1 } var isArrayLike_1, hasRequiredIsArrayLike; function requireIsArrayLike() { if (hasRequiredIsArrayLike) return isArrayLike_1; hasRequiredIsArrayLike = 1; var o = requireIsFunction(), l = requireIsLength(); function u(f) { return f != null && l(f.length) && !o(f) } return isArrayLike_1 = u, isArrayLike_1 } var _isIndex, hasRequired_isIndex; function require_isIndex() { if (hasRequired_isIndex) return _isIndex; hasRequired_isIndex = 1; var o = 9007199254740991, l = /^(?:0|[1-9]\d*)$/; function u(f, p) { var d = typeof f; return p = p ?? o, !!p && (d == "number" || d != "symbol" && l.test(f)) && f > -1 && f % 1 == 0 && f < p } return _isIndex = u, _isIndex } var _isIterateeCall, hasRequired_isIterateeCall; function require_isIterateeCall() { if (hasRequired_isIterateeCall) return _isIterateeCall; hasRequired_isIterateeCall = 1; var o = requireEq(), l = requireIsArrayLike(), u = require_isIndex(), f = requireIsObject(); function p(d, m, v) { if (!f(v)) return !1; var I = typeof m; return (I == "number" ? l(v) && u(m, v.length) : I == "string" && m in v) ? o(v[m], d) : !1 } return _isIterateeCall = p, _isIterateeCall } var _trimmedEndIndex, hasRequired_trimmedEndIndex; function require_trimmedEndIndex() { if (hasRequired_trimmedEndIndex) return _trimmedEndIndex; hasRequired_trimmedEndIndex = 1; var o = /\s/; function l(u) { for (var f = u.length; f-- && o.test(u.charAt(f));); return f } return _trimmedEndIndex = l, _trimmedEndIndex } var _baseTrim, hasRequired_baseTrim; function require_baseTrim() { if (hasRequired_baseTrim) return _baseTrim; hasRequired_baseTrim = 1; var o = require_trimmedEndIndex(), l = /^\s+/; function u(f) { return f && f.slice(0, o(f) + 1).replace(l, "") } return _baseTrim = u, _baseTrim } var isObjectLike_1, hasRequiredIsObjectLike; function requireIsObjectLike() { if (hasRequiredIsObjectLike) return isObjectLike_1; hasRequiredIsObjectLike = 1; function o(l) { return l != null && typeof l == "object" } return isObjectLike_1 = o, isObjectLike_1 } var isSymbol_1, hasRequiredIsSymbol; function requireIsSymbol() { if (hasRequiredIsSymbol) return isSymbol_1; hasRequiredIsSymbol = 1; var o = require_baseGetTag(), l = requireIsObjectLike(), u = "[object Symbol]"; function f(p) { return typeof p == "symbol" || l(p) && o(p) == u } return isSymbol_1 = f, isSymbol_1 } var toNumber_1, hasRequiredToNumber; function requireToNumber() { if (hasRequiredToNumber) return toNumber_1; hasRequiredToNumber = 1; var o = require_baseTrim(), l = requireIsObject(), u = requireIsSymbol(), f = NaN, p = /^[-+]0x[0-9a-f]+$/i, d = /^0b[01]+$/i, m = /^0o[0-7]+$/i, v = parseInt; function I(F) { if (typeof F == "number") return F; if (u(F)) return f; if (l(F)) { var B = typeof F.valueOf == "function" ? F.valueOf() : F; F = l(B) ? B + "" : B } if (typeof F != "string") return F === 0 ? F : +F; F = o(F); var W = d.test(F); return W || m.test(F) ? v(F.slice(2), W ? 2 : 8) : p.test(F) ? f : +F } return toNumber_1 = I, toNumber_1 } var toFinite_1, hasRequiredToFinite; function requireToFinite() { if (hasRequiredToFinite) return toFinite_1; hasRequiredToFinite = 1; var o = requireToNumber(), l = 1 / 0, u = 17976931348623157e292; function f(p) { if (!p) return p === 0 ? p : 0; if (p = o(p), p === l || p === -l) { var d = p < 0 ? -1 : 1; return d * u } return p === p ? p : 0 } return toFinite_1 = f, toFinite_1 } var _createRange, hasRequired_createRange; function require_createRange() { if (hasRequired_createRange) return _createRange; hasRequired_createRange = 1; var o = require_baseRange(), l = require_isIterateeCall(), u = requireToFinite(); function f(p) { return function (d, m, v) { return v && typeof v != "number" && l(d, m, v) && (m = v = void 0), d = u(d), m === void 0 ? (m = d, d = 0) : m = u(m), v = v === void 0 ? d < m ? 1 : -1 : u(v), o(d, m, v, p) } } return _createRange = f, _createRange } var range_1, hasRequiredRange; function requireRange() { if (hasRequiredRange) return range_1; hasRequiredRange = 1; var o = require_createRange(), l = o(); return range_1 = l, range_1 } var rangeExports = requireRange(); const range = getDefaultExportFromCjs$1(rangeExports); function _extends$1() { return _extends$1 = Object.assign ? Object.assign.bind() : function (o) { for (var l = 1; l < arguments.length; l++) { var u = arguments[l]; for (var f in u) ({}).hasOwnProperty.call(u, f) && (o[f] = u[f]) } return o }, _extends$1.apply(null, arguments) } function _objectWithoutPropertiesLoose(o, l) { if (o == null) return {}; var u = {}; for (var f in o) if ({}.hasOwnProperty.call(o, f)) { if (l.indexOf(f) !== -1) continue; u[f] = o[f] } return u } var getDisplayName = {}, hasRequiredGetDisplayName; function requireGetDisplayName() { if (hasRequiredGetDisplayName) return getDisplayName; hasRequiredGetDisplayName = 1, Object.defineProperty(getDisplayName, "__esModule", { value: !0 }), getDisplayName.default = o; function o(l) { return l.displayName || l.name || (typeof l == "string" && l.length > 0 ? l : "Unknown") } return getDisplayName } requireGetDisplayName(); function _defineProperty(o, l, u) { return l in o ? Object.defineProperty(o, l, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : o[l] = u, o } function _extends() { return _extends = Object.assign || function (o) { for (var l = 1; l < arguments.length; l++) { var u = arguments[l]; for (var f in u) Object.prototype.hasOwnProperty.call(u, f) && (o[f] = u[f]) } return o }, _extends.apply(this, arguments) } function _inheritsLoose$1(o, l) { o.prototype = Object.create(l.prototype), o.prototype.constructor = o, o.__proto__ = l } function _assertThisInitialized$1(o) { if (o === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return o } function createThemeProvider(o) { var l = function (u) { _inheritsLoose$1(f, u); function f() { for (var d, m = arguments.length, v = new Array(m), I = 0; I < m; I++)v[I] = arguments[I]; return d = u.call.apply(u, [this].concat(v)) || this, _defineProperty(_assertThisInitialized$1(_assertThisInitialized$1(d)), "cachedTheme", void 0), _defineProperty(_assertThisInitialized$1(_assertThisInitialized$1(d)), "lastOuterTheme", void 0), _defineProperty(_assertThisInitialized$1(_assertThisInitialized$1(d)), "lastTheme", void 0), _defineProperty(_assertThisInitialized$1(_assertThisInitialized$1(d)), "renderProvider", function (F) { var B = d.props.children; return React.createElement(o.Provider, { value: d.getTheme(F) }, B) }), d } var p = f.prototype; return p.getTheme = function (m) { if (this.props.theme !== this.lastTheme || m !== this.lastOuterTheme || !this.cachedTheme) if (this.lastOuterTheme = m, this.lastTheme = this.props.theme, typeof this.lastTheme == "function") { var v = this.props.theme; this.cachedTheme = v(m) } else { var I = this.props.theme; this.cachedTheme = m ? _extends({}, m, I) : I } return this.cachedTheme }, p.render = function () { var m = this.props.children; return m ? React.createElement(o.Consumer, null, this.renderProvider) : null }, f }(React.Component); return l } function createWithTheme(o) { return function (u) { var f = React.forwardRef(function (p, d) { return React.createElement(o.Consumer, null, function (m) { return React.createElement(u, _extends({ theme: m, ref: d }, p)) }) }); return hoistNonReactStatics(f, u), f } } function createUseTheme(o) { var l = function () { var f = React.useContext(o); return f }; return l } function createTheming(o) { return { context: o, withTheme: createWithTheme(o), useTheme: createUseTheme(o), ThemeProvider: createThemeProvider(o) } } var ThemeContext = reactExports.createContext(); createTheming(ThemeContext); var _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (o) { return typeof o } : function (o) { return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o }, isBrowser = (typeof window > "u" ? "undefined" : _typeof$1(window)) === "object" && (typeof document > "u" ? "undefined" : _typeof$1(document)) === "object" && document.nodeType === 9; function _typeof(o) { "@babel/helpers - typeof"; return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (l) { return typeof l } : function (l) { return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l }, _typeof(o) } function toPrimitive(o, l) { if (_typeof(o) != "object" || !o) return o; var u = o[Symbol.toPrimitive]; if (u !== void 0) { var f = u.call(o, l); if (_typeof(f) != "object") return f; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(o) } function toPropertyKey(o) { var l = toPrimitive(o, "string"); return _typeof(l) == "symbol" ? l : l + "" } function _defineProperties(o, l) { for (var u = 0; u < l.length; u++) { var f = l[u]; f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(o, toPropertyKey(f.key), f) } } function _createClass(o, l, u) { return l && _defineProperties(o.prototype, l), Object.defineProperty(o, "prototype", { writable: !1 }), o } function _setPrototypeOf(o, l) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (u, f) { return u.__proto__ = f, u }, _setPrototypeOf(o, l) } function _inheritsLoose(o, l) { o.prototype = Object.create(l.prototype), o.prototype.constructor = o, _setPrototypeOf(o, l) } function _assertThisInitialized(o) { if (o === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return o } var plainObjectConstrurctor = {}.constructor; function cloneStyle(o) { if (o == null || typeof o != "object") return o; if (Array.isArray(o)) return o.map(cloneStyle); if (o.constructor !== plainObjectConstrurctor) return o; var l = {}; for (var u in o) l[u] = cloneStyle(o[u]); return l } function createRule(o, l, u) { o === void 0 && (o = "unnamed"); var f = u.jss, p = cloneStyle(l), d = f.plugins.onCreateRule(o, p, u); return d || (o[0], null) } var join = function o(l, u) { for (var f = "", p = 0; p < l.length && l[p] !== "!important"; p++)f && (f += u), f += l[p]; return f }, toCssValue = function o(l) { if (!Array.isArray(l)) return l; var u = ""; if (Array.isArray(l[0])) for (var f = 0; f < l.length && l[f] !== "!important"; f++)u && (u += ", "), u += join(l[f], " "); else u = join(l, ", "); return l[l.length - 1] === "!important" && (u += " !important"), u }; function getWhitespaceSymbols(o) {
  return o && o.format === !1 ? { linebreak: "", space: "" } : {
    linebreak: `
`, space: " "
  }
} function indentStr(o, l) { for (var u = "", f = 0; f < l; f++)u += "  "; return u + o } function toCss(o, l, u) { u === void 0 && (u = {}); var f = ""; if (!l) return f; var p = u, d = p.indent, m = d === void 0 ? 0 : d, v = l.fallbacks; u.format === !1 && (m = -1 / 0); var I = getWhitespaceSymbols(u), F = I.linebreak, B = I.space; if (o && m++, v) if (Array.isArray(v)) for (var W = 0; W < v.length; W++) { var Z = v[W]; for (var Q in Z) { var re = Z[Q]; re != null && (f && (f += F), f += indentStr(Q + ":" + B + toCssValue(re) + ";", m)) } } else for (var ne in v) { var oe = v[ne]; oe != null && (f && (f += F), f += indentStr(ne + ":" + B + toCssValue(oe) + ";", m)) } for (var ae in l) { var se = l[ae]; se != null && ae !== "fallbacks" && (f && (f += F), f += indentStr(ae + ":" + B + toCssValue(se) + ";", m)) } return !f && !u.allowEmpty || !o ? f : (m--, f && (f = "" + F + f + F), indentStr("" + o + B + "{" + f, m) + indentStr("}", m)) } var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g, nativeEscape = typeof CSS < "u" && CSS.escape, escape = function (o) { return nativeEscape ? nativeEscape(o) : o.replace(escapeRegex, "\\$1") }, BaseStyleRule = function () { function o(u, f, p) { this.type = "style", this.isProcessed = !1; var d = p.sheet, m = p.Renderer; this.key = u, this.options = p, this.style = f, d ? this.renderer = d.renderer : m && (this.renderer = new m) } var l = o.prototype; return l.prop = function (f, p, d) { if (p === void 0) return this.style[f]; var m = d ? d.force : !1; if (!m && this.style[f] === p) return this; var v = p; (!d || d.process !== !1) && (v = this.options.jss.plugins.onChangeValue(p, f, this)); var I = v == null || v === !1, F = f in this.style; if (I && !F && !m) return this; var B = I && F; if (B ? delete this.style[f] : this.style[f] = v, this.renderable && this.renderer) return B ? this.renderer.removeProperty(this.renderable, f) : this.renderer.setProperty(this.renderable, f, v), this; var W = this.options.sheet; return W && W.attached, this }, o }(), StyleRule = function (o) { _inheritsLoose(l, o); function l(f, p, d) { var m; m = o.call(this, f, p, d) || this; var v = d.selector, I = d.scoped, F = d.sheet, B = d.generateId; return v ? m.selectorText = v : I !== !1 && (m.id = B(_assertThisInitialized(_assertThisInitialized(m)), F), m.selectorText = "." + escape(m.id)), m } var u = l.prototype; return u.applyTo = function (p) { var d = this.renderer; if (d) { var m = this.toJSON(); for (var v in m) d.setProperty(p, v, m[v]) } return this }, u.toJSON = function () { var p = {}; for (var d in this.style) { var m = this.style[d]; typeof m != "object" ? p[d] = m : Array.isArray(m) && (p[d] = toCssValue(m)) } return p }, u.toString = function (p) { var d = this.options.sheet, m = d ? d.options.link : !1, v = m ? _extends$1({}, p, { allowEmpty: !0 }) : p; return toCss(this.selectorText, this.style, v) }, _createClass(l, [{ key: "selector", set: function (p) { if (p !== this.selectorText) { this.selectorText = p; var d = this.renderer, m = this.renderable; if (!(!m || !d)) { var v = d.setSelector(m, p); v || d.replaceRule(m, this) } } }, get: function () { return this.selectorText } }]), l }(BaseStyleRule), pluginStyleRule = { onCreateRule: function o(l, u, f) { return l[0] === "@" || f.parent && f.parent.type === "keyframes" ? null : new StyleRule(l, u, f) } }, defaultToStringOptions = { indent: 1, children: !0 }, atRegExp = /@([\w-]+)/, ConditionalRule = function () { function o(u, f, p) { this.type = "conditional", this.isProcessed = !1, this.key = u; var d = u.match(atRegExp); this.at = d ? d[1] : "unknown", this.query = p.name || "@" + this.at, this.options = p, this.rules = new RuleList(_extends$1({}, p, { parent: this })); for (var m in f) this.rules.add(m, f[m]); this.rules.process() } var l = o.prototype; return l.getRule = function (f) { return this.rules.get(f) }, l.indexOf = function (f) { return this.rules.indexOf(f) }, l.addRule = function (f, p, d) { var m = this.rules.add(f, p, d); return m ? (this.options.jss.plugins.onProcessRule(m), m) : null }, l.replaceRule = function (f, p, d) { var m = this.rules.replace(f, p, d); return m && this.options.jss.plugins.onProcessRule(m), m }, l.toString = function (f) { f === void 0 && (f = defaultToStringOptions); var p = getWhitespaceSymbols(f), d = p.linebreak; if (f.indent == null && (f.indent = defaultToStringOptions.indent), f.children == null && (f.children = defaultToStringOptions.children), f.children === !1) return this.query + " {}"; var m = this.rules.toString(f); return m ? this.query + " {" + d + m + d + "}" : "" }, o }(), keyRegExp = /@container|@media|@supports\s+/, pluginConditionalRule = { onCreateRule: function o(l, u, f) { return keyRegExp.test(l) ? new ConditionalRule(l, u, f) : null } }, defaultToStringOptions$1 = { indent: 1, children: !0 }, nameRegExp = /@keyframes\s+([\w-]+)/, KeyframesRule = function () { function o(u, f, p) { this.type = "keyframes", this.at = "@keyframes", this.isProcessed = !1; var d = u.match(nameRegExp); d && d[1] ? this.name = d[1] : this.name = "noname", this.key = this.type + "-" + this.name, this.options = p; var m = p.scoped, v = p.sheet, I = p.generateId; this.id = m === !1 ? this.name : escape(I(this, v)), this.rules = new RuleList(_extends$1({}, p, { parent: this })); for (var F in f) this.rules.add(F, f[F], _extends$1({}, p, { parent: this })); this.rules.process() } var l = o.prototype; return l.toString = function (f) { f === void 0 && (f = defaultToStringOptions$1); var p = getWhitespaceSymbols(f), d = p.linebreak; if (f.indent == null && (f.indent = defaultToStringOptions$1.indent), f.children == null && (f.children = defaultToStringOptions$1.children), f.children === !1) return this.at + " " + this.id + " {}"; var m = this.rules.toString(f); return m && (m = "" + d + m + d), this.at + " " + this.id + " {" + m + "}" }, o }(), keyRegExp$1 = /@keyframes\s+/, refRegExp$1 = /\$([\w-]+)/g, findReferencedKeyframe = function o(l, u) { return typeof l == "string" ? l.replace(refRegExp$1, function (f, p) { return p in u ? u[p] : f }) : l }, replaceRef = function o(l, u, f) { var p = l[u], d = findReferencedKeyframe(p, f); d !== p && (l[u] = d) }, pluginKeyframesRule = { onCreateRule: function o(l, u, f) { return typeof l == "string" && keyRegExp$1.test(l) ? new KeyframesRule(l, u, f) : null }, onProcessStyle: function o(l, u, f) { return u.type !== "style" || !f || ("animation-name" in l && replaceRef(l, "animation-name", f.keyframes), "animation" in l && replaceRef(l, "animation", f.keyframes)), l }, onChangeValue: function o(l, u, f) { var p = f.options.sheet; if (!p) return l; switch (u) { case "animation": return findReferencedKeyframe(l, p.keyframes); case "animation-name": return findReferencedKeyframe(l, p.keyframes); default: return l } } }, KeyframeRule = function (o) { _inheritsLoose(l, o); function l() { return o.apply(this, arguments) || this } var u = l.prototype; return u.toString = function (p) { var d = this.options.sheet, m = d ? d.options.link : !1, v = m ? _extends$1({}, p, { allowEmpty: !0 }) : p; return toCss(this.key, this.style, v) }, l }(BaseStyleRule), pluginKeyframeRule = { onCreateRule: function o(l, u, f) { return f.parent && f.parent.type === "keyframes" ? new KeyframeRule(l, u, f) : null } }, FontFaceRule = function () { function o(u, f, p) { this.type = "font-face", this.at = "@font-face", this.isProcessed = !1, this.key = u, this.style = f, this.options = p } var l = o.prototype; return l.toString = function (f) { var p = getWhitespaceSymbols(f), d = p.linebreak; if (Array.isArray(this.style)) { for (var m = "", v = 0; v < this.style.length; v++)m += toCss(this.at, this.style[v]), this.style[v + 1] && (m += d); return m } return toCss(this.at, this.style, f) }, o }(), keyRegExp$2 = /@font-face/, pluginFontFaceRule = { onCreateRule: function o(l, u, f) { return keyRegExp$2.test(l) ? new FontFaceRule(l, u, f) : null } }, ViewportRule = function () { function o(u, f, p) { this.type = "viewport", this.at = "@viewport", this.isProcessed = !1, this.key = u, this.style = f, this.options = p } var l = o.prototype; return l.toString = function (f) { return toCss(this.key, this.style, f) }, o }(), pluginViewportRule = { onCreateRule: function o(l, u, f) { return l === "@viewport" || l === "@-ms-viewport" ? new ViewportRule(l, u, f) : null } }, SimpleRule = function () {
  function o(u, f, p) { this.type = "simple", this.isProcessed = !1, this.key = u, this.value = f, this.options = p } var l = o.prototype; return l.toString = function (f) {
    if (Array.isArray(this.value)) {
      for (var p = "", d = 0; d < this.value.length; d++)p += this.key + " " + this.value[d] + ";", this.value[d + 1] && (p += `
`); return p
    } return this.key + " " + this.value + ";"
  }, o
}(), keysMap = { "@charset": !0, "@import": !0, "@namespace": !0 }, pluginSimpleRule = { onCreateRule: function o(l, u, f) { return l in keysMap ? new SimpleRule(l, u, f) : null } }, plugins$1 = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule], defaultUpdateOptions = { process: !0 }, forceUpdateOptions = { force: !0, process: !0 }, RuleList = function () { function o(u) { this.map = {}, this.raw = {}, this.index = [], this.counter = 0, this.options = u, this.classes = u.classes, this.keyframes = u.keyframes } var l = o.prototype; return l.add = function (f, p, d) { var m = this.options, v = m.parent, I = m.sheet, F = m.jss, B = m.Renderer, W = m.generateId, Z = m.scoped, Q = _extends$1({ classes: this.classes, parent: v, sheet: I, jss: F, Renderer: B, generateId: W, scoped: Z, name: f, keyframes: this.keyframes, selector: void 0 }, d), re = f; f in this.raw && (re = f + "-d" + this.counter++), this.raw[re] = p, re in this.classes && (Q.selector = "." + escape(this.classes[re])); var ne = createRule(re, p, Q); if (!ne) return null; this.register(ne); var oe = Q.index === void 0 ? this.index.length : Q.index; return this.index.splice(oe, 0, ne), ne }, l.replace = function (f, p, d) { var m = this.get(f), v = this.index.indexOf(m); m && this.remove(m); var I = d; return v !== -1 && (I = _extends$1({}, d, { index: v })), this.add(f, p, I) }, l.get = function (f) { return this.map[f] }, l.remove = function (f) { this.unregister(f), delete this.raw[f.key], this.index.splice(this.index.indexOf(f), 1) }, l.indexOf = function (f) { return this.index.indexOf(f) }, l.process = function () { var f = this.options.jss.plugins; this.index.slice(0).forEach(f.onProcessRule, f) }, l.register = function (f) { this.map[f.key] = f, f instanceof StyleRule ? (this.map[f.selector] = f, f.id && (this.classes[f.key] = f.id)) : f instanceof KeyframesRule && this.keyframes && (this.keyframes[f.name] = f.id) }, l.unregister = function (f) { delete this.map[f.key], f instanceof StyleRule ? (delete this.map[f.selector], delete this.classes[f.key]) : f instanceof KeyframesRule && delete this.keyframes[f.name] }, l.update = function () { var f, p, d; if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) == "string" ? (f = arguments.length <= 0 ? void 0 : arguments[0], p = arguments.length <= 1 ? void 0 : arguments[1], d = arguments.length <= 2 ? void 0 : arguments[2]) : (p = arguments.length <= 0 ? void 0 : arguments[0], d = arguments.length <= 1 ? void 0 : arguments[1], f = null), f) this.updateOne(this.get(f), p, d); else for (var m = 0; m < this.index.length; m++)this.updateOne(this.index[m], p, d) }, l.updateOne = function (f, p, d) { d === void 0 && (d = defaultUpdateOptions); var m = this.options, v = m.jss.plugins, I = m.sheet; if (f.rules instanceof o) { f.rules.update(p, d); return } var F = f.style; if (v.onUpdate(p, f, I, d), d.process && F && F !== f.style) { v.onProcessStyle(f.style, f, I); for (var B in f.style) { var W = f.style[B], Z = F[B]; W !== Z && f.prop(B, W, forceUpdateOptions) } for (var Q in F) { var re = f.style[Q], ne = F[Q]; re == null && re !== ne && f.prop(Q, null, forceUpdateOptions) } } }, l.toString = function (f) { for (var p = "", d = this.options.sheet, m = d ? d.options.link : !1, v = getWhitespaceSymbols(f), I = v.linebreak, F = 0; F < this.index.length; F++) { var B = this.index[F], W = B.toString(f); !W && !m || (p && (p += I), p += W) } return p }, o }(), StyleSheet = function () { function o(u, f) { this.attached = !1, this.deployed = !1, this.classes = {}, this.keyframes = {}, this.options = _extends$1({}, f, { sheet: this, parent: this, classes: this.classes, keyframes: this.keyframes }), f.Renderer && (this.renderer = new f.Renderer(this)), this.rules = new RuleList(this.options); for (var p in u) this.rules.add(p, u[p]); this.rules.process() } var l = o.prototype; return l.attach = function () { return this.attached ? this : (this.renderer && this.renderer.attach(), this.attached = !0, this.deployed || this.deploy(), this) }, l.detach = function () { return this.attached ? (this.renderer && this.renderer.detach(), this.attached = !1, this) : this }, l.addRule = function (f, p, d) { var m = this.queue; this.attached && !m && (this.queue = []); var v = this.rules.add(f, p, d); return v ? (this.options.jss.plugins.onProcessRule(v), this.attached ? (this.deployed && (m ? m.push(v) : (this.insertRule(v), this.queue && (this.queue.forEach(this.insertRule, this), this.queue = void 0))), v) : (this.deployed = !1, v)) : null }, l.replaceRule = function (f, p, d) { var m = this.rules.get(f); if (!m) return this.addRule(f, p, d); var v = this.rules.replace(f, p, d); return v && this.options.jss.plugins.onProcessRule(v), this.attached ? (this.deployed && this.renderer && (v ? m.renderable && this.renderer.replaceRule(m.renderable, v) : this.renderer.deleteRule(m)), v) : (this.deployed = !1, v) }, l.insertRule = function (f) { this.renderer && this.renderer.insertRule(f) }, l.addRules = function (f, p) { var d = []; for (var m in f) { var v = this.addRule(m, f[m], p); v && d.push(v) } return d }, l.getRule = function (f) { return this.rules.get(f) }, l.deleteRule = function (f) { var p = typeof f == "object" ? f : this.rules.get(f); return !p || this.attached && !p.renderable ? !1 : (this.rules.remove(p), this.attached && p.renderable && this.renderer ? this.renderer.deleteRule(p.renderable) : !0) }, l.indexOf = function (f) { return this.rules.indexOf(f) }, l.deploy = function () { return this.renderer && this.renderer.deploy(), this.deployed = !0, this }, l.update = function () { var f; return (f = this.rules).update.apply(f, arguments), this }, l.updateOne = function (f, p, d) { return this.rules.updateOne(f, p, d), this }, l.toString = function (f) { return this.rules.toString(f) }, o }(), PluginsRegistry = function () { function o() { this.plugins = { internal: [], external: [] }, this.registry = {} } var l = o.prototype; return l.onCreateRule = function (f, p, d) { for (var m = 0; m < this.registry.onCreateRule.length; m++) { var v = this.registry.onCreateRule[m](f, p, d); if (v) return v } return null }, l.onProcessRule = function (f) { if (!f.isProcessed) { for (var p = f.options.sheet, d = 0; d < this.registry.onProcessRule.length; d++)this.registry.onProcessRule[d](f, p); f.style && this.onProcessStyle(f.style, f, p), f.isProcessed = !0 } }, l.onProcessStyle = function (f, p, d) { for (var m = 0; m < this.registry.onProcessStyle.length; m++)p.style = this.registry.onProcessStyle[m](p.style, p, d) }, l.onProcessSheet = function (f) { for (var p = 0; p < this.registry.onProcessSheet.length; p++)this.registry.onProcessSheet[p](f) }, l.onUpdate = function (f, p, d, m) { for (var v = 0; v < this.registry.onUpdate.length; v++)this.registry.onUpdate[v](f, p, d, m) }, l.onChangeValue = function (f, p, d) { for (var m = f, v = 0; v < this.registry.onChangeValue.length; v++)m = this.registry.onChangeValue[v](m, p, d); return m }, l.use = function (f, p) { p === void 0 && (p = { queue: "external" }); var d = this.plugins[p.queue]; d.indexOf(f) === -1 && (d.push(f), this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (m, v) { for (var I in v) I in m && m[I].push(v[I]); return m }, { onCreateRule: [], onProcessRule: [], onProcessStyle: [], onProcessSheet: [], onChangeValue: [], onUpdate: [] })) }, o }(), SheetsRegistry = function () { function o() { this.registry = [] } var l = o.prototype; return l.add = function (f) { var p = this.registry, d = f.options.index; if (p.indexOf(f) === -1) { if (p.length === 0 || d >= this.index) { p.push(f); return } for (var m = 0; m < p.length; m++)if (p[m].options.index > d) { p.splice(m, 0, f); return } } }, l.reset = function () { this.registry = [] }, l.remove = function (f) { var p = this.registry.indexOf(f); this.registry.splice(p, 1) }, l.toString = function (f) { for (var p = f === void 0 ? {} : f, d = p.attached, m = _objectWithoutPropertiesLoose(p, ["attached"]), v = getWhitespaceSymbols(m), I = v.linebreak, F = "", B = 0; B < this.registry.length; B++) { var W = this.registry[B]; d != null && W.attached !== d || (F && (F += I), F += W.toString(m)) } return F }, _createClass(o, [{ key: "index", get: function () { return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index } }]), o }(), sheets = new SheetsRegistry, globalThis$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" && window.Math === Math ? window : typeof self < "u" && self.Math === Math ? self : Function("return this")(), ns = "2f1acc6c3a606b082e5eef5e54414ffb"; globalThis$1[ns] == null && (globalThis$1[ns] = 0); var moduleId = globalThis$1[ns]++, createGenerateId = function o(l) { l === void 0 && (l = {}); var u = 0, f = function (d, m) { u += 1; var v = "", I = ""; return m && (m.options.classNamePrefix && (I = m.options.classNamePrefix), m.options.jss.id != null && (v = String(m.options.jss.id))), l.minify ? "" + (I || "c") + moduleId + v + u : I + d.key + "-" + moduleId + (v ? "-" + v : "") + "-" + u }; return f }, memoize = function o(l) { var u; return function () { return u || (u = l()), u } }, getPropertyValue = function o(l, u) { try { return l.attributeStyleMap ? l.attributeStyleMap.get(u) : l.style.getPropertyValue(u) } catch { return "" } }, setProperty = function o(l, u, f) { try { var p = f; if (Array.isArray(f) && (p = toCssValue(f)), l.attributeStyleMap) l.attributeStyleMap.set(u, p); else { var d = p ? p.indexOf("!important") : -1, m = d > -1 ? p.substr(0, d - 1) : p; l.style.setProperty(u, m, d > -1 ? "important" : "") } } catch { return !1 } return !0 }, removeProperty = function o(l, u) { try { l.attributeStyleMap ? l.attributeStyleMap.delete(u) : l.style.removeProperty(u) } catch { } }, setSelector = function o(l, u) { return l.selectorText = u, l.selectorText === u }, getHead = memoize(function () { return document.querySelector("head") }); function findHigherSheet(o, l) { for (var u = 0; u < o.length; u++) { var f = o[u]; if (f.attached && f.options.index > l.index && f.options.insertionPoint === l.insertionPoint) return f } return null } function findHighestSheet(o, l) { for (var u = o.length - 1; u >= 0; u--) { var f = o[u]; if (f.attached && f.options.insertionPoint === l.insertionPoint) return f } return null } function findCommentNode(o) { for (var l = getHead(), u = 0; u < l.childNodes.length; u++) { var f = l.childNodes[u]; if (f.nodeType === 8 && f.nodeValue.trim() === o) return f } return null } function findPrevNode(o) { var l = sheets.registry; if (l.length > 0) { var u = findHigherSheet(l, o); if (u && u.renderer) return { parent: u.renderer.element.parentNode, node: u.renderer.element }; if (u = findHighestSheet(l, o), u && u.renderer) return { parent: u.renderer.element.parentNode, node: u.renderer.element.nextSibling } } var f = o.insertionPoint; if (f && typeof f == "string") { var p = findCommentNode(f); if (p) return { parent: p.parentNode, node: p.nextSibling } } return !1 } function insertStyle(o, l) { var u = l.insertionPoint, f = findPrevNode(l); if (f !== !1 && f.parent) { f.parent.insertBefore(o, f.node); return } if (u && typeof u.nodeType == "number") { var p = u, d = p.parentNode; d && d.insertBefore(o, p.nextSibling); return } getHead().appendChild(o) } var getNonce = memoize(function () { var o = document.querySelector('meta[property="csp-nonce"]'); return o ? o.getAttribute("content") : null }), _insertRule = function o(l, u, f) { try { "insertRule" in l ? l.insertRule(u, f) : "appendRule" in l && l.appendRule(u) } catch { return !1 } return l.cssRules[f] }, getValidRuleInsertionIndex = function o(l, u) { var f = l.cssRules.length; return u === void 0 || u > f ? f : u }, createStyle = function o() {
  var l = document.createElement("style"); return l.textContent = `
`, l
}, DomRenderer = function () {
  function o(u) { this.getPropertyValue = getPropertyValue, this.setProperty = setProperty, this.removeProperty = removeProperty, this.setSelector = setSelector, this.hasInsertedRules = !1, this.cssRules = [], u && sheets.add(u), this.sheet = u; var f = this.sheet ? this.sheet.options : {}, p = f.media, d = f.meta, m = f.element; this.element = m || createStyle(), this.element.setAttribute("data-jss", ""), p && this.element.setAttribute("media", p), d && this.element.setAttribute("data-meta", d); var v = getNonce(); v && this.element.setAttribute("nonce", v) } var l = o.prototype; return l.attach = function () { if (!(this.element.parentNode || !this.sheet)) { insertStyle(this.element, this.sheet.options); var f = !!(this.sheet && this.sheet.deployed); this.hasInsertedRules && f && (this.hasInsertedRules = !1, this.deploy()) } }, l.detach = function () {
    if (this.sheet) {
      var f = this.element.parentNode; f && f.removeChild(this.element), this.sheet.options.link && (this.cssRules = [], this.element.textContent = `
`)
    }
  }, l.deploy = function () {
    var f = this.sheet; if (f) {
      if (f.options.link) { this.insertRules(f.rules); return } this.element.textContent = `
`+ f.toString() + `
`}
  }, l.insertRules = function (f, p) { for (var d = 0; d < f.index.length; d++)this.insertRule(f.index[d], d, p) }, l.insertRule = function (f, p, d) { if (d === void 0 && (d = this.element.sheet), f.rules) { var m = f, v = d; if (f.type === "conditional" || f.type === "keyframes") { var I = getValidRuleInsertionIndex(d, p); if (v = _insertRule(d, m.toString({ children: !1 }), I), v === !1) return !1; this.refCssRule(f, I, v) } return this.insertRules(m.rules, v), v } var F = f.toString(); if (!F) return !1; var B = getValidRuleInsertionIndex(d, p), W = _insertRule(d, F, B); return W === !1 ? !1 : (this.hasInsertedRules = !0, this.refCssRule(f, B, W), W) }, l.refCssRule = function (f, p, d) { f.renderable = d, f.options.parent instanceof StyleSheet && this.cssRules.splice(p, 0, d) }, l.deleteRule = function (f) { var p = this.element.sheet, d = this.indexOf(f); return d === -1 ? !1 : (p.deleteRule(d), this.cssRules.splice(d, 1), !0) }, l.indexOf = function (f) { return this.cssRules.indexOf(f) }, l.replaceRule = function (f, p) { var d = this.indexOf(f); return d === -1 ? !1 : (this.element.sheet.deleteRule(d), this.cssRules.splice(d, 1), this.insertRule(p, d)) }, l.getRules = function () { return this.element.sheet.cssRules }, o
}(), instanceCounter = 0, Jss = function () { function o(u) { this.id = instanceCounter++, this.version = "10.10.0", this.plugins = new PluginsRegistry, this.options = { id: { minify: !1 }, createGenerateId, Renderer: isBrowser ? DomRenderer : null, plugins: [] }, this.generateId = createGenerateId({ minify: !1 }); for (var f = 0; f < plugins$1.length; f++)this.plugins.use(plugins$1[f], { queue: "internal" }); this.setup(u) } var l = o.prototype; return l.setup = function (f) { return f === void 0 && (f = {}), f.createGenerateId && (this.options.createGenerateId = f.createGenerateId), f.id && (this.options.id = _extends$1({}, this.options.id, f.id)), (f.createGenerateId || f.id) && (this.generateId = this.options.createGenerateId(this.options.id)), f.insertionPoint != null && (this.options.insertionPoint = f.insertionPoint), "Renderer" in f && (this.options.Renderer = f.Renderer), f.plugins && this.use.apply(this, f.plugins), this }, l.createStyleSheet = function (f, p) { p === void 0 && (p = {}); var d = p, m = d.index; typeof m != "number" && (m = sheets.index === 0 ? 0 : sheets.index + 1); var v = new StyleSheet(f, _extends$1({}, p, { jss: this, generateId: p.generateId || this.generateId, insertionPoint: this.options.insertionPoint, Renderer: this.options.Renderer, index: m })); return this.plugins.onProcessSheet(v), v }, l.removeStyleSheet = function (f) { return f.detach(), sheets.remove(f), this }, l.createRule = function (f, p, d) { if (p === void 0 && (p = {}), d === void 0 && (d = {}), typeof f == "object") return this.createRule(void 0, f, p); var m = _extends$1({}, d, { name: f, jss: this, Renderer: this.options.Renderer }); m.generateId || (m.generateId = this.generateId), m.classes || (m.classes = {}), m.keyframes || (m.keyframes = {}); var v = createRule(f, p, m); return v && this.plugins.onProcessRule(v), v }, l.use = function () { for (var f = this, p = arguments.length, d = new Array(p), m = 0; m < p; m++)d[m] = arguments[m]; return d.forEach(function (v) { f.plugins.use(v) }), this }, o }(), createJss = function o(l) { return new Jss(l) }, SheetsManager = function () { function o() { this.length = 0, this.sheets = new WeakMap } var l = o.prototype; return l.get = function (f) { var p = this.sheets.get(f); return p && p.sheet }, l.add = function (f, p) { this.sheets.has(f) || (this.length++, this.sheets.set(f, { sheet: p, refs: 0 })) }, l.manage = function (f) { var p = this.sheets.get(f); if (p) return p.refs === 0 && p.sheet.attach(), p.refs++, p.sheet }, l.unmanage = function (f) { var p = this.sheets.get(f); p && p.refs > 0 && (p.refs--, p.refs === 0 && p.sheet.detach()) }, _createClass(o, [{ key: "size", get: function () { return this.length } }]), o }(), hasCSSTOMSupport = typeof CSS == "object" && CSS != null && "number" in CSS; function getDynamicStyles(o) { var l = null; for (var u in o) { var f = o[u], p = typeof f; if (p === "function") l || (l = {}), l[u] = f; else if (p === "object" && f !== null && !Array.isArray(f)) { var d = getDynamicStyles(f); d && (l || (l = {}), l[u] = d) } } return l }/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */createJss(); var now = Date.now(), fnValuesNs = "fnValues" + now, fnRuleNs = "fnStyle" + ++now, functionPlugin = function o() { return { onCreateRule: function (u, f, p) { if (typeof f != "function") return null; var d = createRule(u, {}, p); return d[fnRuleNs] = f, d }, onProcessStyle: function (u, f) { if (fnValuesNs in f || fnRuleNs in f) return u; var p = {}; for (var d in u) { var m = u[d]; typeof m == "function" && (delete u[d], p[d] = m) } return f[fnValuesNs] = p, u }, onUpdate: function (u, f, p, d) { var m = f, v = m[fnRuleNs]; v && (m.style = v(u) || {}); var I = m[fnValuesNs]; if (I) for (var F in I) m.prop(F, I[F](u), d) } } }; function symbolObservablePonyfill(o) { var l, u = o.Symbol; return typeof u == "function" ? u.observable ? l = u.observable : (l = u("observable"), u.observable = l) : l = "@@observable", l } var root; typeof self < "u" ? root = self : typeof window < "u" ? root = window : typeof global$1 < "u" ? root = global$1 : typeof module < "u" ? root = module : root = Function("return this")(); var result = symbolObservablePonyfill(root), isObservable = function o(l) { return l && l[result] && l === l[result]() }, observablePlugin = function o(l) { return { onCreateRule: function (f, p, d) { if (!isObservable(p)) return null; var m = p, v = createRule(f, {}, d); return m.subscribe(function (I) { for (var F in I) v.prop(F, I[F], l) }), v }, onProcessRule: function (f) { if (!(f && f.type !== "style")) { var p = f, d = p.style, m = function (B) { var W = d[B]; if (!isObservable(W)) return "continue"; delete d[B], W.subscribe({ next: function (Q) { p.prop(B, Q, l) } }) }; for (var v in d) var I = m(v) } } } }, semiWithNl = /;\n/, parse = function o(l) { for (var u = {}, f = l.split(semiWithNl), p = 0; p < f.length; p++) { var d = (f[p] || "").trim(); if (d) { var m = d.indexOf(":"); if (m !== -1) { var v = d.substr(0, m).trim(), I = d.substr(m + 1).trim(); u[v] = I } } } return u }, onProcessRule = function o(l) { typeof l.style == "string" && (l.style = parse(l.style)) }; function templatePlugin() { return { onProcessRule } } var at = "@global", atPrefix = "@global ", GlobalContainerRule = function () { function o(u, f, p) { this.type = "global", this.at = at, this.isProcessed = !1, this.key = u, this.options = p, this.rules = new RuleList(_extends$1({}, p, { parent: this })); for (var d in f) this.rules.add(d, f[d]); this.rules.process() } var l = o.prototype; return l.getRule = function (f) { return this.rules.get(f) }, l.addRule = function (f, p, d) { var m = this.rules.add(f, p, d); return m && this.options.jss.plugins.onProcessRule(m), m }, l.replaceRule = function (f, p, d) { var m = this.rules.replace(f, p, d); return m && this.options.jss.plugins.onProcessRule(m), m }, l.indexOf = function (f) { return this.rules.indexOf(f) }, l.toString = function (f) { return this.rules.toString(f) }, o }(), GlobalPrefixedRule = function () { function o(u, f, p) { this.type = "global", this.at = at, this.isProcessed = !1, this.key = u, this.options = p; var d = u.substr(atPrefix.length); this.rule = p.jss.createRule(d, f, _extends$1({}, p, { parent: this })) } var l = o.prototype; return l.toString = function (f) { return this.rule ? this.rule.toString(f) : "" }, o }(), separatorRegExp$1 = /\s*,\s*/g; function addScope(o, l) { for (var u = o.split(separatorRegExp$1), f = "", p = 0; p < u.length; p++)f += l + " " + u[p].trim(), u[p + 1] && (f += ", "); return f } function handleNestedGlobalContainerRule(o, l) { var u = o.options, f = o.style, p = f ? f[at] : null; if (p) { for (var d in p) l.addRule(d, p[d], _extends$1({}, u, { selector: addScope(d, o.selector) })); delete f[at] } } function handlePrefixedGlobalRule(o, l) { var u = o.options, f = o.style; for (var p in f) if (!(p[0] !== "@" || p.substr(0, at.length) !== at)) { var d = addScope(p.substr(at.length), o.selector); l.addRule(d, f[p], _extends$1({}, u, { selector: d })), delete f[p] } } function jssGlobal() { function o(u, f, p) { if (!u) return null; if (u === at) return new GlobalContainerRule(u, f, p); if (u[0] === "@" && u.substr(0, atPrefix.length) === atPrefix) return new GlobalPrefixedRule(u, f, p); var d = p.parent; return d && (d.type === "global" || d.options.parent && d.options.parent.type === "global") && (p.scoped = !1), !p.selector && p.scoped === !1 && (p.selector = u), null } function l(u, f) { u.type !== "style" || !f || (handleNestedGlobalContainerRule(u, f), handlePrefixedGlobalRule(u, f)) } return { onCreateRule: o, onProcessRule: l } } var isObject = function o(l) { return l && typeof l == "object" && !Array.isArray(l) }, valueNs = "extendCurrValue" + Date.now(); function mergeExtend(o, l, u, f) { var p = typeof o.extend; if (p === "string") { if (!u) return; var d = u.getRule(o.extend); if (!d || d === l) return; var m = d.options.parent; if (m) { var v = m.rules.raw[o.extend]; extend(v, l, u, f) } return } if (Array.isArray(o.extend)) { for (var I = 0; I < o.extend.length; I++) { var F = o.extend[I], B = typeof F == "string" ? _extends$1({}, o, { extend: F }) : o.extend[I]; extend(B, l, u, f) } return } for (var W in o.extend) { if (W === "extend") { extend(o.extend.extend, l, u, f); continue } if (isObject(o.extend[W])) { W in f || (f[W] = {}), extend(o.extend[W], l, u, f[W]); continue } f[W] = o.extend[W] } } function mergeRest(o, l, u, f) { for (var p in o) if (p !== "extend") { if (isObject(f[p]) && isObject(o[p])) { extend(o[p], l, u, f[p]); continue } if (isObject(o[p])) { f[p] = extend(o[p], l, u); continue } f[p] = o[p] } } function extend(o, l, u, f) { return f === void 0 && (f = {}), mergeExtend(o, l, u, f), mergeRest(o, l, u, f), f } function jssExtend() { function o(u, f, p) { return "extend" in u ? extend(u, f, p) : u } function l(u, f, p) { if (f !== "extend") return u; if (u == null || u === !1) { for (var d in p[valueNs]) p.prop(d, null); return p[valueNs] = null, null } if (typeof u == "object") { for (var m in u) p.prop(m, u[m]); p[valueNs] = u } return null } return { onProcessStyle: o, onChangeValue: l } } var separatorRegExp = /\s*,\s*/g, parentRegExp = /&/g, refRegExp = /\$([\w-]+)/g; function jssNested() { function o(p, d) { return function (m, v) { var I = p.getRule(v) || d && d.getRule(v); return I ? I.selector : v } } function l(p, d) { for (var m = d.split(separatorRegExp), v = p.split(separatorRegExp), I = "", F = 0; F < m.length; F++)for (var B = m[F], W = 0; W < v.length; W++) { var Z = v[W]; I && (I += ", "), I += Z.indexOf("&") !== -1 ? Z.replace(parentRegExp, B) : B + " " + Z } return I } function u(p, d, m) { if (m) return _extends$1({}, m, { index: m.index + 1 }); var v = p.options.nestingLevel; v = v === void 0 ? 1 : v + 1; var I = _extends$1({}, p.options, { nestingLevel: v, index: d.indexOf(p) + 1 }); return delete I.name, I } function f(p, d, m) { if (d.type !== "style") return p; var v = d, I = v.options.parent, F, B; for (var W in p) { var Z = W.indexOf("&") !== -1, Q = W[0] === "@"; if (!(!Z && !Q)) { if (F = u(v, I, F), Z) { var re = l(W, v.selector); B || (B = o(I, m)), re = re.replace(refRegExp, B); var ne = v.key + "-" + W; "replaceRule" in I ? I.replaceRule(ne, p[W], _extends$1({}, F, { selector: re })) : I.addRule(ne, p[W], _extends$1({}, F, { selector: re })) } else Q && I.addRule(W, {}, F).addRule(v.key, p[W], { selector: v.selector }); delete p[W] } } return p } return { onProcessStyle: f } } function registerClass(o, l) { if (!l) return !0; if (Array.isArray(l)) { for (var u = 0; u < l.length; u++) { var f = registerClass(o, l[u]); if (!f) return !1 } return !0 } if (l.indexOf(" ") > -1) return registerClass(o, l.split(" ")); var p = o.options.parent; if (l[0] === "$") { var d = p.getRule(l.substr(1)); return !d || d === o ? !1 : (p.classes[o.key] += " " + p.classes[d.key], !0) } return p.classes[o.key] += " " + l, !0 } function jssCompose() { function o(l, u) { return "composes" in l && (registerClass(u, l.composes), delete l.composes), l } return { onProcessStyle: o } } var uppercasePattern = /[A-Z]/g, msPattern = /^ms-/, cache$2 = {}; function toHyphenLower(o) { return "-" + o.toLowerCase() } function hyphenateStyleName(o) { if (cache$2.hasOwnProperty(o)) return cache$2[o]; var l = o.replace(uppercasePattern, toHyphenLower); return cache$2[o] = msPattern.test(l) ? "-" + l : l } function convertCase(o) { var l = {}; for (var u in o) { var f = u.indexOf("--") === 0 ? u : hyphenateStyleName(u); l[f] = o[u] } return o.fallbacks && (Array.isArray(o.fallbacks) ? l.fallbacks = o.fallbacks.map(convertCase) : l.fallbacks = convertCase(o.fallbacks)), l } function camelCase() { function o(u) { if (Array.isArray(u)) { for (var f = 0; f < u.length; f++)u[f] = convertCase(u[f]); return u } return convertCase(u) } function l(u, f, p) { if (f.indexOf("--") === 0) return u; var d = hyphenateStyleName(f); return f === d ? u : (p.prop(d, u), null) } return { onProcessStyle: o, onChangeValue: l } } var px = hasCSSTOMSupport && CSS ? CSS.px : "px", ms = hasCSSTOMSupport && CSS ? CSS.ms : "ms", percent = hasCSSTOMSupport && CSS ? CSS.percent : "%", defaultUnits = { "animation-delay": ms, "animation-duration": ms, "background-position": px, "background-position-x": px, "background-position-y": px, "background-size": px, border: px, "border-bottom": px, "border-bottom-left-radius": px, "border-bottom-right-radius": px, "border-bottom-width": px, "border-left": px, "border-left-width": px, "border-radius": px, "border-right": px, "border-right-width": px, "border-top": px, "border-top-left-radius": px, "border-top-right-radius": px, "border-top-width": px, "border-width": px, "border-block": px, "border-block-end": px, "border-block-end-width": px, "border-block-start": px, "border-block-start-width": px, "border-block-width": px, "border-inline": px, "border-inline-end": px, "border-inline-end-width": px, "border-inline-start": px, "border-inline-start-width": px, "border-inline-width": px, "border-start-start-radius": px, "border-start-end-radius": px, "border-end-start-radius": px, "border-end-end-radius": px, margin: px, "margin-bottom": px, "margin-left": px, "margin-right": px, "margin-top": px, "margin-block": px, "margin-block-end": px, "margin-block-start": px, "margin-inline": px, "margin-inline-end": px, "margin-inline-start": px, padding: px, "padding-bottom": px, "padding-left": px, "padding-right": px, "padding-top": px, "padding-block": px, "padding-block-end": px, "padding-block-start": px, "padding-inline": px, "padding-inline-end": px, "padding-inline-start": px, "mask-position-x": px, "mask-position-y": px, "mask-size": px, height: px, width: px, "min-height": px, "max-height": px, "min-width": px, "max-width": px, bottom: px, left: px, top: px, right: px, inset: px, "inset-block": px, "inset-block-end": px, "inset-block-start": px, "inset-inline": px, "inset-inline-end": px, "inset-inline-start": px, "box-shadow": px, "text-shadow": px, "column-gap": px, "column-rule": px, "column-rule-width": px, "column-width": px, "font-size": px, "font-size-delta": px, "letter-spacing": px, "text-decoration-thickness": px, "text-indent": px, "text-stroke": px, "text-stroke-width": px, "word-spacing": px, motion: px, "motion-offset": px, outline: px, "outline-offset": px, "outline-width": px, perspective: px, "perspective-origin-x": percent, "perspective-origin-y": percent, "transform-origin": percent, "transform-origin-x": percent, "transform-origin-y": percent, "transform-origin-z": percent, "transition-delay": ms, "transition-duration": ms, "vertical-align": px, "flex-basis": px, "shape-margin": px, size: px, gap: px, grid: px, "grid-gap": px, "row-gap": px, "grid-row-gap": px, "grid-column-gap": px, "grid-template-rows": px, "grid-template-columns": px, "grid-auto-rows": px, "grid-auto-columns": px, "box-shadow-x": px, "box-shadow-y": px, "box-shadow-blur": px, "box-shadow-spread": px, "font-line-height": px, "text-shadow-x": px, "text-shadow-y": px, "text-shadow-blur": px }; function addCamelCasedVersion(o) { var l = /(-[a-z])/g, u = function (m) { return m[1].toUpperCase() }, f = {}; for (var p in o) f[p] = o[p], f[p.replace(l, u)] = o[p]; return f } var units = addCamelCasedVersion(defaultUnits); function iterate(o, l, u) { if (l == null) return l; if (Array.isArray(l)) for (var f = 0; f < l.length; f++)l[f] = iterate(o, l[f], u); else if (typeof l == "object") if (o === "fallbacks") for (var p in l) l[p] = iterate(p, l[p], u); else for (var d in l) l[d] = iterate(o + "-" + d, l[d], u); else if (typeof l == "number" && isNaN(l) === !1) { var m = u[o] || units[o]; return m && !(l === 0 && m === px) ? typeof m == "function" ? m(l).toString() : "" + l + m : l.toString() } return l } function defaultUnit(o) { o === void 0 && (o = {}); var l = addCamelCasedVersion(o); function u(p, d) { if (d.type !== "style") return p; for (var m in p) p[m] = iterate(m, p[m], l); return p } function f(p, d) { return iterate(d, p, l) } return { onProcessStyle: u, onChangeValue: f } } var propArray = { "background-size": !0, "background-position": !0, border: !0, "border-bottom": !0, "border-left": !0, "border-top": !0, "border-right": !0, "border-radius": !0, "border-image": !0, "border-width": !0, "border-style": !0, "border-color": !0, "box-shadow": !0, flex: !0, margin: !0, padding: !0, outline: !0, "transform-origin": !0, transform: !0, transition: !0 }, propArrayInObj = { position: !0, size: !0 }, propObj = { padding: { top: 0, right: 0, bottom: 0, left: 0 }, margin: { top: 0, right: 0, bottom: 0, left: 0 }, background: { attachment: null, color: null, image: null, position: null, repeat: null }, border: { width: null, style: null, color: null }, "border-top": { width: null, style: null, color: null }, "border-right": { width: null, style: null, color: null }, "border-bottom": { width: null, style: null, color: null }, "border-left": { width: null, style: null, color: null }, outline: { width: null, style: null, color: null }, "list-style": { type: null, position: null, image: null }, transition: { property: null, duration: null, "timing-function": null, timingFunction: null, delay: null }, animation: { name: null, duration: null, "timing-function": null, timingFunction: null, delay: null, "iteration-count": null, iterationCount: null, direction: null, "fill-mode": null, fillMode: null, "play-state": null, playState: null }, "box-shadow": { x: 0, y: 0, blur: 0, spread: 0, color: null, inset: null }, "text-shadow": { x: 0, y: 0, blur: null, color: null } }, customPropObj = { border: { radius: "border-radius", image: "border-image", width: "border-width", style: "border-style", color: "border-color" }, "border-bottom": { width: "border-bottom-width", style: "border-bottom-style", color: "border-bottom-color" }, "border-top": { width: "border-top-width", style: "border-top-style", color: "border-top-color" }, "border-left": { width: "border-left-width", style: "border-left-style", color: "border-left-color" }, "border-right": { width: "border-right-width", style: "border-right-style", color: "border-right-color" }, background: { size: "background-size", image: "background-image" }, font: { style: "font-style", variant: "font-variant", weight: "font-weight", stretch: "font-stretch", size: "font-size", family: "font-family", lineHeight: "line-height", "line-height": "line-height" }, flex: { grow: "flex-grow", basis: "flex-basis", direction: "flex-direction", wrap: "flex-wrap", flow: "flex-flow", shrink: "flex-shrink" }, align: { self: "align-self", items: "align-items", content: "align-content" }, grid: { "template-columns": "grid-template-columns", templateColumns: "grid-template-columns", "template-rows": "grid-template-rows", templateRows: "grid-template-rows", "template-areas": "grid-template-areas", templateAreas: "grid-template-areas", template: "grid-template", "auto-columns": "grid-auto-columns", autoColumns: "grid-auto-columns", "auto-rows": "grid-auto-rows", autoRows: "grid-auto-rows", "auto-flow": "grid-auto-flow", autoFlow: "grid-auto-flow", row: "grid-row", column: "grid-column", "row-start": "grid-row-start", rowStart: "grid-row-start", "row-end": "grid-row-end", rowEnd: "grid-row-end", "column-start": "grid-column-start", columnStart: "grid-column-start", "column-end": "grid-column-end", columnEnd: "grid-column-end", area: "grid-area", gap: "grid-gap", "row-gap": "grid-row-gap", rowGap: "grid-row-gap", "column-gap": "grid-column-gap", columnGap: "grid-column-gap" } }; function mapValuesByProp(o, l, u) { return o.map(function (f) { return objectToArray(f, l, u, !1, !0) }) } function processArray(o, l, u, f) { return u[l] == null ? o : o.length === 0 ? [] : Array.isArray(o[0]) ? processArray(o[0], l, u, f) : typeof o[0] == "object" ? mapValuesByProp(o, l, f) : [o] } function objectToArray(o, l, u, f, p) { if (!(propObj[l] || customPropObj[l])) return []; var d = []; if (customPropObj[l] && (o = customPropsToStyle(o, u, customPropObj[l], f)), Object.keys(o).length) for (var m in propObj[l]) { if (o[m]) { Array.isArray(o[m]) ? d.push(propArrayInObj[m] === null ? o[m] : o[m].join(" ")) : d.push(o[m]); continue } propObj[l][m] != null && d.push(propObj[l][m]) } return !d.length || p ? d : [d] } function customPropsToStyle(o, l, u, f) { for (var p in u) { var d = u[p]; if (typeof o[p] < "u" && (f || !l.prop(d))) { var m, v = styleDetector((m = {}, m[d] = o[p], m), l)[d]; f ? l.style.fallbacks[d] = v : l.style[d] = v } delete o[p] } return o } function styleDetector(o, l, u) { for (var f in o) { var p = o[f]; if (Array.isArray(p)) { if (!Array.isArray(p[0])) { if (f === "fallbacks") { for (var d = 0; d < o.fallbacks.length; d++)o.fallbacks[d] = styleDetector(o.fallbacks[d], l, !0); continue } o[f] = processArray(p, f, propArray, l), o[f].length || delete o[f] } } else if (typeof p == "object") { if (f === "fallbacks") { o.fallbacks = styleDetector(o.fallbacks, l, !0); continue } o[f] = objectToArray(p, f, l, u), o[f].length || delete o[f] } else o[f] === "" && delete o[f] } return o } function jssExpand() { function o(l, u) { if (!l || u.type !== "style") return l; if (Array.isArray(l)) { for (var f = 0; f < l.length; f++)l[f] = styleDetector(l[f], u); return l } return styleDetector(l, u) } return { onProcessStyle: o } } function _arrayLikeToArray(o, l) { (l == null || l > o.length) && (l = o.length); for (var u = 0, f = Array(l); u < l; u++)f[u] = o[u]; return f } function _arrayWithoutHoles(o) { if (Array.isArray(o)) return _arrayLikeToArray(o) } function _iterableToArray(o) { if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o) } function _unsupportedIterableToArray(o, l) { if (o) { if (typeof o == "string") return _arrayLikeToArray(o, l); var u = {}.toString.call(o).slice(8, -1); return u === "Object" && o.constructor && (u = o.constructor.name), u === "Map" || u === "Set" ? Array.from(o) : u === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u) ? _arrayLikeToArray(o, l) : void 0 } } function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function _toConsumableArray(o) { return _arrayWithoutHoles(o) || _iterableToArray(o) || _unsupportedIterableToArray(o) || _nonIterableSpread() } var js = "", css = "", vendor = "", browser = "", isTouch = isBrowser && "ontouchstart" in document.documentElement; if (isBrowser) { var jsCssMap = { Moz: "-moz-", ms: "-ms-", O: "-o-", Webkit: "-webkit-" }, _document$createEleme = document.createElement("p"), style = _document$createEleme.style, testProp = "Transform"; for (var key in jsCssMap) if (key + testProp in style) { js = key, css = jsCssMap[key]; break } js === "Webkit" && "msHyphens" in style && (js = "ms", css = jsCssMap.ms, browser = "edge"), js === "Webkit" && "-apple-trailing-word" in style && (vendor = "apple") } var prefix = { js, css, vendor, browser, isTouch }; function supportedKeyframes(o) { return o[1] === "-" || prefix.js === "ms" ? o : "@" + prefix.css + "keyframes" + o.substr(10) } var appearence = { noPrefill: ["appearance"], supportedProperty: function o(l) { return l !== "appearance" ? !1 : prefix.js === "ms" ? "-webkit-" + l : prefix.css + l } }, colorAdjust = { noPrefill: ["color-adjust"], supportedProperty: function o(l) { return l !== "color-adjust" ? !1 : prefix.js === "Webkit" ? prefix.css + "print-" + l : l } }, regExp = /[-\s]+(.)?/g; function toUpper(o, l) { return l ? l.toUpperCase() : "" } function camelize(o) { return o.replace(regExp, toUpper) } function pascalize(o) { return camelize("-" + o) } var mask = { noPrefill: ["mask"], supportedProperty: function o(l, u) { if (!/^mask/.test(l)) return !1; if (prefix.js === "Webkit") { var f = "mask-image"; if (camelize(f) in u) return l; if (prefix.js + pascalize(f) in u) return prefix.css + l } return l } }, textOrientation = { noPrefill: ["text-orientation"], supportedProperty: function o(l) { return l !== "text-orientation" ? !1 : prefix.vendor === "apple" && !prefix.isTouch ? prefix.css + l : l } }, transform = { noPrefill: ["transform"], supportedProperty: function o(l, u, f) { return l !== "transform" ? !1 : f.transform ? l : prefix.css + l } }, transition = { noPrefill: ["transition"], supportedProperty: function o(l, u, f) { return l !== "transition" ? !1 : f.transition ? l : prefix.css + l } }, writingMode = { noPrefill: ["writing-mode"], supportedProperty: function o(l) { return l !== "writing-mode" ? !1 : prefix.js === "Webkit" || prefix.js === "ms" && prefix.browser !== "edge" ? prefix.css + l : l } }, userSelect = { noPrefill: ["user-select"], supportedProperty: function o(l) { return l !== "user-select" ? !1 : prefix.js === "Moz" || prefix.js === "ms" || prefix.vendor === "apple" ? prefix.css + l : l } }, breakPropsOld = { supportedProperty: function o(l, u) { if (!/^break-/.test(l)) return !1; if (prefix.js === "Webkit") { var f = "WebkitColumn" + pascalize(l); return f in u ? prefix.css + "column-" + l : !1 } if (prefix.js === "Moz") { var p = "page" + pascalize(l); return p in u ? "page-" + l : !1 } return !1 } }, inlineLogicalOld = { supportedProperty: function o(l, u) { if (!/^(border|margin|padding)-inline/.test(l)) return !1; if (prefix.js === "Moz") return l; var f = l.replace("-inline", ""); return prefix.js + pascalize(f) in u ? prefix.css + f : !1 } }, unprefixed = { supportedProperty: function o(l, u) { return camelize(l) in u ? l : !1 } }, prefixed = { supportedProperty: function o(l, u) { var f = pascalize(l); return l[0] === "-" || l[0] === "-" && l[1] === "-" ? l : prefix.js + f in u ? prefix.css + l : prefix.js !== "Webkit" && "Webkit" + f in u ? "-webkit-" + l : !1 } }, scrollSnap = { supportedProperty: function o(l) { return l.substring(0, 11) !== "scroll-snap" ? !1 : prefix.js === "ms" ? "" + prefix.css + l : l } }, overscrollBehavior = { supportedProperty: function o(l) { return l !== "overscroll-behavior" ? !1 : prefix.js === "ms" ? prefix.css + "scroll-chaining" : l } }, propMap = { "flex-grow": "flex-positive", "flex-shrink": "flex-negative", "flex-basis": "flex-preferred-size", "justify-content": "flex-pack", order: "flex-order", "align-items": "flex-align", "align-content": "flex-line-pack" }, flex2012 = { supportedProperty: function o(l, u) { var f = propMap[l]; return f && prefix.js + pascalize(f) in u ? prefix.css + f : !1 } }, propMap$1 = { flex: "box-flex", "flex-grow": "box-flex", "flex-direction": ["box-orient", "box-direction"], order: "box-ordinal-group", "align-items": "box-align", "flex-flow": ["box-orient", "box-direction"], "justify-content": "box-pack" }, propKeys = Object.keys(propMap$1), prefixCss = function o(l) { return prefix.css + l }, flex2009 = { supportedProperty: function o(l, u, f) { var p = f.multiple; if (propKeys.indexOf(l) > -1) { var d = propMap$1[l]; if (!Array.isArray(d)) return prefix.js + pascalize(d) in u ? prefix.css + d : !1; if (!p) return !1; for (var m = 0; m < d.length; m++)if (!(prefix.js + pascalize(d[0]) in u)) return !1; return d.map(prefixCss) } return !1 } }, plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009], propertyDetectors = plugins.filter(function (o) { return o.supportedProperty }).map(function (o) { return o.supportedProperty }), noPrefill = plugins.filter(function (o) { return o.noPrefill }).reduce(function (o, l) { return o.push.apply(o, _toConsumableArray(l.noPrefill)), o }, []), el, cache = {}; if (isBrowser) { el = document.createElement("p"); var computed = window.getComputedStyle(document.documentElement, ""); for (var key$1 in computed) isNaN(key$1) || (cache[computed[key$1]] = computed[key$1]); noPrefill.forEach(function (o) { return delete cache[o] }) } function supportedProperty17(o, l) { if (l === void 0 && (l = {}), !el) return o; if (cache[o] != null) return cache[o]; (o === "transition" || o === "transform") && (l[o] = o in el.style); for (var u = 0; u < propertyDetectors.length && (cache[o] = propertyDetectors[u](o, el.style, l), !cache[o]); u++); try { el.style[o] = "" } catch { return !1 } return cache[o] } var cache$1 = {}, transitionProperties = { transition: 1, "transition-property": 1, "-webkit-transition": 1, "-webkit-transition-property": 1 }, transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g, el$1; function prefixTransitionCallback(o, l, u) { if (l === "var") return "var"; if (l === "all") return "all"; if (u === "all") return ", all"; var f = l ? supportedProperty17(l) : ", " + supportedProperty17(u); return f || l || u } isBrowser && (el$1 = document.createElement("p")); function supportedValue(o, l) { var u = l; if (!el$1 || o === "content") return l; if (typeof u != "string" || !isNaN(parseInt(u, 10))) return u; var f = o + u; if (cache$1[f] != null) return cache$1[f]; try { el$1.style[o] = u } catch { return cache$1[f] = !1, !1 } if (transitionProperties[o]) u = u.replace(transPropsRegExp, prefixTransitionCallback); else if (el$1.style[o] === "" && (u = prefix.css + u, u === "-ms-flex" && (el$1.style[o] = "-ms-flexbox"), el$1.style[o] = u, el$1.style[o] === "")) return cache$1[f] = !1, !1; return el$1.style[o] = "", cache$1[f] = u, cache$1[f] } function jssVendorPrefixer() { function o(p) { if (p.type === "keyframes") { var d = p; d.at = supportedKeyframes(d.at) } } function l(p) { for (var d in p) { var m = p[d]; if (d === "fallbacks" && Array.isArray(m)) { p[d] = m.map(l); continue } var v = !1, I = supportedProperty17(d); I && I !== d && (v = !0); var F = !1, B = supportedValue(I, toCssValue(m)); B && B !== m && (F = !0), (v || F) && (v && delete p[d], p[I || d] = B || m) } return p } function u(p, d) { return d.type !== "style" ? p : l(p) } function f(p, d) { return supportedValue(d, toCssValue(p)) || p } return { onProcessRule: o, onProcessStyle: u, onChangeValue: f } } function jssPropsSort() { var o = function (u, f) { return u.length === f.length ? u > f ? 1 : -1 : u.length - f.length }; return { onProcessStyle: function (u, f) { if (f.type !== "style") return u; for (var p = {}, d = Object.keys(u).sort(o), m = 0; m < d.length; m++)p[d[m]] = u[d[m]]; return p } } } var create = function o(l) { return l === void 0 && (l = {}), { plugins: [functionPlugin(), observablePlugin(l.observable), templatePlugin(), jssGlobal(), jssExtend(), jssNested(), jssCompose(), camelCase(), defaultUnit(l.defaultUnit), jssExpand(), jssVendorPrefixer(), jssPropsSort()] } }, MAX_RULES_PER_SHEET = 1e4, defaultJss$1 = createJss(create()), createCss = function o(l) { l === void 0 && (l = defaultJss$1); var u = new Map, f = 0, p, d = function () { return (!p || p.rules.index.length > MAX_RULES_PER_SHEET) && (p = l.createStyleSheet().attach()), p }; function m() { var v = arguments, I = JSON.stringify(v), F = u.get(I); if (F) return F.className; var B = []; for (var W in v) { var Z = v[W]; if (!Array.isArray(Z)) { B.push(Z); continue } for (var Q = 0; Q < Z.length; Q++)B.push(Z[Q]) } for (var re = {}, ne = [], oe = 0; oe < B.length; oe++) { var ae = B[oe]; if (ae) { var se = ae; if (typeof ae == "string") { var le = u.get(ae); le && (le.labels.length && ne.push.apply(ne, le.labels), se = le.style) } se.label && ne.indexOf(se.label) === -1 && ne.push(se.label), Object.assign(re, se) } } delete re.label; var ue = ne.length === 0 ? "css" : ne.join("-"), he = ue + "-" + f++; d().addRule(he, re); var pe = d().classes[he], ve = { style: re, labels: ne, className: pe }; return u.set(I, ve), u.set(pe, ve), pe } return m.getSheet = d, m }; createCss(); var index = Number.MIN_SAFE_INTEGER || -1e9, getSheetIndex = function o() { return index++ }, JssContext = reactExports.createContext({ classNamePrefix: "", disableStylesGeneration: !1, isSSR: !isBrowser }), defaultManagers = new Map, getManager = function o(l, u) { var f = l.managers; if (f) return f[u] || (f[u] = new SheetsManager), f[u]; var p = defaultManagers.get(u); return p || (p = new SheetsManager, defaultManagers.set(u, p)), p }, manageSheet = function o(l) { var u = l.sheet, f = l.context, p = l.index, d = l.theme; if (u) { var m = getManager(f, p); m.manage(d), f.registry && f.registry.add(u) } }, unmanageSheet = function o(l) { if (l.sheet) { var u = getManager(l.context, l.index); u.unmanage(l.theme) } }, defaultJss = createJss(create()), sheetsMeta = new WeakMap, getMeta = function o(l) { return sheetsMeta.get(l) }, addMeta = function o(l, u) { sheetsMeta.set(l, u) }, getStyles = function o(l) { var u = l.styles; return typeof u != "function" ? u : u(l.theme) }; function getSheetOptions(o, l) { var u; o.context.id && o.context.id.minify != null && (u = o.context.id.minify); var f = o.context.classNamePrefix || ""; o.name && !u && (f += o.name.replace(/\s/g, "-") + "-"); var p = ""; return o.name && (p = o.name + ", "), p += typeof o.styles == "function" ? "Themed" : "Unthemed", _extends$1({}, o.sheetOptions, { index: o.index, meta: p, classNamePrefix: f, link: l, generateId: o.sheetOptions && o.sheetOptions.generateId ? o.sheetOptions.generateId : o.context.generateId }) } var createStyleSheet = function o(l) { if (!l.context.disableStylesGeneration) { var u = getManager(l.context, l.index), f = u.get(l.theme); if (f) return f; var p = l.context.jss || defaultJss, d = getStyles(l), m = getDynamicStyles(d), v = p.createStyleSheet(d, getSheetOptions(l, m !== null)); return addMeta(v, { dynamicStyles: m, styles: d }), u.add(l.theme, v), v } }, removeDynamicRules = function o(l, u) { for (var f in u) l.deleteRule(u[f]) }, updateDynamicRules = function o(l, u, f) { for (var p in f) u.updateOne(f[p], l) }, addDynamicRules = function o(l, u) { var f = getMeta(l); if (f) { var p = {}; for (var d in f.dynamicStyles) for (var m = l.rules.index.length, v = l.addRule(d, f.dynamicStyles[d]), I = m; I < l.rules.index.length; I++) { var F = l.rules.index[I]; l.updateOne(F, u), p[v === F ? d : F.key] = F } return p } }, getSheetClasses = function o(l, u) { if (!u) return l.classes; var f = getMeta(l); if (!f) return l.classes; var p = {}; for (var d in f.styles) p[d] = l.classes[d], d in u && (p[d] += " " + l.classes[u[d].key]); return p }; function getUseInsertionEffect(o) { return o ? reactExports.useEffect : React.useInsertionEffect || reactExports.useLayoutEffect } var noTheme = {}, createUseStyles = function o(l, u) { u === void 0 && (u = {}); var f = u, p = f.index, d = p === void 0 ? getSheetIndex() : p, m = f.theming, v = f.name, I = _objectWithoutPropertiesLoose(f, ["index", "theming", "name"]), F = m && m.context || ThemeContext, B = function (Q) { return typeof l == "function" && (Q || reactExports.useContext(F)) || noTheme }, W = {}; return function (Q) { var re = reactExports.useRef(!0), ne = reactExports.useContext(JssContext), oe = B(Q && Q.theme), ae = reactExports.useMemo(function () { var he = createStyleSheet({ context: ne, styles: l, name: v, theme: oe, index: d, sheetOptions: I }); return he && ne.isSSR && manageSheet({ index: d, context: ne, sheet: he, theme: oe }), [he, he ? addDynamicRules(he, Q) : null] }, [ne, oe]), se = ae[0], le = ae[1]; getUseInsertionEffect(ne.isSSR)(function () { se && le && !re.current && updateDynamicRules(Q, se, le) }, [Q]), getUseInsertionEffect(ne.isSSR)(function () { return se && manageSheet({ index: d, context: ne, sheet: se, theme: oe }), function () { se && (unmanageSheet({ index: d, context: ne, sheet: se, theme: oe }), le && removeDynamicRules(se, le)) } }, [se]); var ue = reactExports.useMemo(function () { return se && le ? getSheetClasses(se, le) : W }, [se, le]); return reactExports.useDebugValue(ue), reactExports.useDebugValue(oe === noTheme ? "No theme" : oe), reactExports.useEffect(function () { re.current = !1 }), ue } }, toInteger_1, hasRequiredToInteger; function requireToInteger() { if (hasRequiredToInteger) return toInteger_1; hasRequiredToInteger = 1; var o = requireToFinite(); function l(u) { var f = o(u), p = f % 1; return f === f ? p ? f - p : f : 0 } return toInteger_1 = l, toInteger_1 } var _arrayMap, hasRequired_arrayMap; function require_arrayMap() { if (hasRequired_arrayMap) return _arrayMap; hasRequired_arrayMap = 1; function o(l, u) { for (var f = -1, p = l == null ? 0 : l.length, d = Array(p); ++f < p;)d[f] = u(l[f], f, l); return d } return _arrayMap = o, _arrayMap } var isArray_1, hasRequiredIsArray; function requireIsArray() { if (hasRequiredIsArray) return isArray_1; hasRequiredIsArray = 1; var o = Array.isArray; return isArray_1 = o, isArray_1 } var _baseToString, hasRequired_baseToString; function require_baseToString() { if (hasRequired_baseToString) return _baseToString; hasRequired_baseToString = 1; var o = require_Symbol(), l = require_arrayMap(), u = requireIsArray(), f = requireIsSymbol(), p = o ? o.prototype : void 0, d = p ? p.toString : void 0; function m(v) { if (typeof v == "string") return v; if (u(v)) return l(v, m) + ""; if (f(v)) return d ? d.call(v) : ""; var I = v + ""; return I == "0" && 1 / v == -1 / 0 ? "-0" : I } return _baseToString = m, _baseToString } var toString_1, hasRequiredToString; function requireToString() { if (hasRequiredToString) return toString_1; hasRequiredToString = 1; var o = require_baseToString(); function l(u) { return u == null ? "" : o(u) } return toString_1 = l, toString_1 } var _createRound, hasRequired_createRound; function require_createRound() { if (hasRequired_createRound) return _createRound; hasRequired_createRound = 1; var o = require_root(), l = requireToInteger(), u = requireToNumber(), f = requireToString(), p = o.isFinite, d = Math.min; function m(v) { var I = Math[v]; return function (F, B) { if (F = u(F), B = B == null ? 0 : d(l(B), 292), B && p(F)) { var W = (f(F) + "e").split("e"), Z = I(W[0] + "e" + (+W[1] + B)); return W = (f(Z) + "e").split("e"), +(W[0] + "e" + (+W[1] - B)) } return I(F) } } return _createRound = m, _createRound } var round_1, hasRequiredRound; function requireRound() { if (hasRequiredRound) return round_1; hasRequiredRound = 1; var o = require_createRound(), l = o("round"); return round_1 = l, round_1 } var roundExports = requireRound(); const round = getDefaultExportFromCjs$1(roundExports); var _listCacheClear, hasRequired_listCacheClear; function require_listCacheClear() { if (hasRequired_listCacheClear) return _listCacheClear; hasRequired_listCacheClear = 1; function o() { this.__data__ = [], this.size = 0 } return _listCacheClear = o, _listCacheClear } var _assocIndexOf, hasRequired_assocIndexOf; function require_assocIndexOf() { if (hasRequired_assocIndexOf) return _assocIndexOf; hasRequired_assocIndexOf = 1; var o = requireEq(); function l(u, f) { for (var p = u.length; p--;)if (o(u[p][0], f)) return p; return -1 } return _assocIndexOf = l, _assocIndexOf } var _listCacheDelete, hasRequired_listCacheDelete; function require_listCacheDelete() { if (hasRequired_listCacheDelete) return _listCacheDelete; hasRequired_listCacheDelete = 1; var o = require_assocIndexOf(), l = Array.prototype, u = l.splice; function f(p) { var d = this.__data__, m = o(d, p); if (m < 0) return !1; var v = d.length - 1; return m == v ? d.pop() : u.call(d, m, 1), --this.size, !0 } return _listCacheDelete = f, _listCacheDelete } var _listCacheGet, hasRequired_listCacheGet; function require_listCacheGet() { if (hasRequired_listCacheGet) return _listCacheGet; hasRequired_listCacheGet = 1; var o = require_assocIndexOf(); function l(u) { var f = this.__data__, p = o(f, u); return p < 0 ? void 0 : f[p][1] } return _listCacheGet = l, _listCacheGet } var _listCacheHas, hasRequired_listCacheHas; function require_listCacheHas() { if (hasRequired_listCacheHas) return _listCacheHas; hasRequired_listCacheHas = 1; var o = require_assocIndexOf(); function l(u) { return o(this.__data__, u) > -1 } return _listCacheHas = l, _listCacheHas } var _listCacheSet, hasRequired_listCacheSet; function require_listCacheSet() { if (hasRequired_listCacheSet) return _listCacheSet; hasRequired_listCacheSet = 1; var o = require_assocIndexOf(); function l(u, f) { var p = this.__data__, d = o(p, u); return d < 0 ? (++this.size, p.push([u, f])) : p[d][1] = f, this } return _listCacheSet = l, _listCacheSet } var _ListCache, hasRequired_ListCache; function require_ListCache() { if (hasRequired_ListCache) return _ListCache; hasRequired_ListCache = 1; var o = require_listCacheClear(), l = require_listCacheDelete(), u = require_listCacheGet(), f = require_listCacheHas(), p = require_listCacheSet(); function d(m) { var v = -1, I = m == null ? 0 : m.length; for (this.clear(); ++v < I;) { var F = m[v]; this.set(F[0], F[1]) } } return d.prototype.clear = o, d.prototype.delete = l, d.prototype.get = u, d.prototype.has = f, d.prototype.set = p, _ListCache = d, _ListCache } var _stackClear, hasRequired_stackClear; function require_stackClear() { if (hasRequired_stackClear) return _stackClear; hasRequired_stackClear = 1; var o = require_ListCache(); function l() { this.__data__ = new o, this.size = 0 } return _stackClear = l, _stackClear } var _stackDelete, hasRequired_stackDelete; function require_stackDelete() { if (hasRequired_stackDelete) return _stackDelete; hasRequired_stackDelete = 1; function o(l) { var u = this.__data__, f = u.delete(l); return this.size = u.size, f } return _stackDelete = o, _stackDelete } var _stackGet, hasRequired_stackGet; function require_stackGet() { if (hasRequired_stackGet) return _stackGet; hasRequired_stackGet = 1; function o(l) { return this.__data__.get(l) } return _stackGet = o, _stackGet } var _stackHas, hasRequired_stackHas; function require_stackHas() { if (hasRequired_stackHas) return _stackHas; hasRequired_stackHas = 1; function o(l) { return this.__data__.has(l) } return _stackHas = o, _stackHas } var _coreJsData, hasRequired_coreJsData; function require_coreJsData() { if (hasRequired_coreJsData) return _coreJsData; hasRequired_coreJsData = 1; var o = require_root(), l = o["__core-js_shared__"]; return _coreJsData = l, _coreJsData } var _isMasked, hasRequired_isMasked; function require_isMasked() { if (hasRequired_isMasked) return _isMasked; hasRequired_isMasked = 1; var o = require_coreJsData(), l = function () { var f = /[^.]+$/.exec(o && o.keys && o.keys.IE_PROTO || ""); return f ? "Symbol(src)_1." + f : "" }(); function u(f) { return !!l && l in f } return _isMasked = u, _isMasked } var _toSource, hasRequired_toSource; function require_toSource() { if (hasRequired_toSource) return _toSource; hasRequired_toSource = 1; var o = Function.prototype, l = o.toString; function u(f) { if (f != null) { try { return l.call(f) } catch { } try { return f + "" } catch { } } return "" } return _toSource = u, _toSource } var _baseIsNative, hasRequired_baseIsNative; function require_baseIsNative() { if (hasRequired_baseIsNative) return _baseIsNative; hasRequired_baseIsNative = 1; var o = requireIsFunction(), l = require_isMasked(), u = requireIsObject(), f = require_toSource(), p = /[\\^$.*+?()[\]{}|]/g, d = /^\[object .+?Constructor\]$/, m = Function.prototype, v = Object.prototype, I = m.toString, F = v.hasOwnProperty, B = RegExp("^" + I.call(F).replace(p, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function W(Z) { if (!u(Z) || l(Z)) return !1; var Q = o(Z) ? B : d; return Q.test(f(Z)) } return _baseIsNative = W, _baseIsNative } var _getValue, hasRequired_getValue; function require_getValue() { if (hasRequired_getValue) return _getValue; hasRequired_getValue = 1; function o(l, u) { return l == null ? void 0 : l[u] } return _getValue = o, _getValue } var _getNative, hasRequired_getNative; function require_getNative() { if (hasRequired_getNative) return _getNative; hasRequired_getNative = 1; var o = require_baseIsNative(), l = require_getValue(); function u(f, p) { var d = l(f, p); return o(d) ? d : void 0 } return _getNative = u, _getNative } var _Map, hasRequired_Map; function require_Map() { if (hasRequired_Map) return _Map; hasRequired_Map = 1; var o = require_getNative(), l = require_root(), u = o(l, "Map"); return _Map = u, _Map } var _nativeCreate, hasRequired_nativeCreate; function require_nativeCreate() { if (hasRequired_nativeCreate) return _nativeCreate; hasRequired_nativeCreate = 1; var o = require_getNative(), l = o(Object, "create"); return _nativeCreate = l, _nativeCreate } var _hashClear, hasRequired_hashClear; function require_hashClear() { if (hasRequired_hashClear) return _hashClear; hasRequired_hashClear = 1; var o = require_nativeCreate(); function l() { this.__data__ = o ? o(null) : {}, this.size = 0 } return _hashClear = l, _hashClear } var _hashDelete, hasRequired_hashDelete; function require_hashDelete() { if (hasRequired_hashDelete) return _hashDelete; hasRequired_hashDelete = 1; function o(l) { var u = this.has(l) && delete this.__data__[l]; return this.size -= u ? 1 : 0, u } return _hashDelete = o, _hashDelete } var _hashGet, hasRequired_hashGet; function require_hashGet() { if (hasRequired_hashGet) return _hashGet; hasRequired_hashGet = 1; var o = require_nativeCreate(), l = "__lodash_hash_undefined__", u = Object.prototype, f = u.hasOwnProperty; function p(d) { var m = this.__data__; if (o) { var v = m[d]; return v === l ? void 0 : v } return f.call(m, d) ? m[d] : void 0 } return _hashGet = p, _hashGet } var _hashHas, hasRequired_hashHas; function require_hashHas() { if (hasRequired_hashHas) return _hashHas; hasRequired_hashHas = 1; var o = require_nativeCreate(), l = Object.prototype, u = l.hasOwnProperty; function f(p) { var d = this.__data__; return o ? d[p] !== void 0 : u.call(d, p) } return _hashHas = f, _hashHas } var _hashSet, hasRequired_hashSet; function require_hashSet() { if (hasRequired_hashSet) return _hashSet; hasRequired_hashSet = 1; var o = require_nativeCreate(), l = "__lodash_hash_undefined__"; function u(f, p) { var d = this.__data__; return this.size += this.has(f) ? 0 : 1, d[f] = o && p === void 0 ? l : p, this } return _hashSet = u, _hashSet } var _Hash, hasRequired_Hash; function require_Hash() { if (hasRequired_Hash) return _Hash; hasRequired_Hash = 1; var o = require_hashClear(), l = require_hashDelete(), u = require_hashGet(), f = require_hashHas(), p = require_hashSet(); function d(m) { var v = -1, I = m == null ? 0 : m.length; for (this.clear(); ++v < I;) { var F = m[v]; this.set(F[0], F[1]) } } return d.prototype.clear = o, d.prototype.delete = l, d.prototype.get = u, d.prototype.has = f, d.prototype.set = p, _Hash = d, _Hash } var _mapCacheClear, hasRequired_mapCacheClear; function require_mapCacheClear() { if (hasRequired_mapCacheClear) return _mapCacheClear; hasRequired_mapCacheClear = 1; var o = require_Hash(), l = require_ListCache(), u = require_Map(); function f() { this.size = 0, this.__data__ = { hash: new o, map: new (u || l), string: new o } } return _mapCacheClear = f, _mapCacheClear } var _isKeyable, hasRequired_isKeyable; function require_isKeyable() { if (hasRequired_isKeyable) return _isKeyable; hasRequired_isKeyable = 1; function o(l) { var u = typeof l; return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? l !== "__proto__" : l === null } return _isKeyable = o, _isKeyable } var _getMapData, hasRequired_getMapData; function require_getMapData() { if (hasRequired_getMapData) return _getMapData; hasRequired_getMapData = 1; var o = require_isKeyable(); function l(u, f) { var p = u.__data__; return o(f) ? p[typeof f == "string" ? "string" : "hash"] : p.map } return _getMapData = l, _getMapData } var _mapCacheDelete, hasRequired_mapCacheDelete; function require_mapCacheDelete() { if (hasRequired_mapCacheDelete) return _mapCacheDelete; hasRequired_mapCacheDelete = 1; var o = require_getMapData(); function l(u) { var f = o(this, u).delete(u); return this.size -= f ? 1 : 0, f } return _mapCacheDelete = l, _mapCacheDelete } var _mapCacheGet, hasRequired_mapCacheGet; function require_mapCacheGet() { if (hasRequired_mapCacheGet) return _mapCacheGet; hasRequired_mapCacheGet = 1; var o = require_getMapData(); function l(u) { return o(this, u).get(u) } return _mapCacheGet = l, _mapCacheGet } var _mapCacheHas, hasRequired_mapCacheHas; function require_mapCacheHas() { if (hasRequired_mapCacheHas) return _mapCacheHas; hasRequired_mapCacheHas = 1; var o = require_getMapData(); function l(u) { return o(this, u).has(u) } return _mapCacheHas = l, _mapCacheHas } var _mapCacheSet, hasRequired_mapCacheSet; function require_mapCacheSet() { if (hasRequired_mapCacheSet) return _mapCacheSet; hasRequired_mapCacheSet = 1; var o = require_getMapData(); function l(u, f) { var p = o(this, u), d = p.size; return p.set(u, f), this.size += p.size == d ? 0 : 1, this } return _mapCacheSet = l, _mapCacheSet } var _MapCache, hasRequired_MapCache; function require_MapCache() { if (hasRequired_MapCache) return _MapCache; hasRequired_MapCache = 1; var o = require_mapCacheClear(), l = require_mapCacheDelete(), u = require_mapCacheGet(), f = require_mapCacheHas(), p = require_mapCacheSet(); function d(m) { var v = -1, I = m == null ? 0 : m.length; for (this.clear(); ++v < I;) { var F = m[v]; this.set(F[0], F[1]) } } return d.prototype.clear = o, d.prototype.delete = l, d.prototype.get = u, d.prototype.has = f, d.prototype.set = p, _MapCache = d, _MapCache } var _stackSet, hasRequired_stackSet; function require_stackSet() { if (hasRequired_stackSet) return _stackSet; hasRequired_stackSet = 1; var o = require_ListCache(), l = require_Map(), u = require_MapCache(), f = 200; function p(d, m) { var v = this.__data__; if (v instanceof o) { var I = v.__data__; if (!l || I.length < f - 1) return I.push([d, m]), this.size = ++v.size, this; v = this.__data__ = new u(I) } return v.set(d, m), this.size = v.size, this } return _stackSet = p, _stackSet } var _Stack, hasRequired_Stack; function require_Stack() { if (hasRequired_Stack) return _Stack; hasRequired_Stack = 1; var o = require_ListCache(), l = require_stackClear(), u = require_stackDelete(), f = require_stackGet(), p = require_stackHas(), d = require_stackSet(); function m(v) { var I = this.__data__ = new o(v); this.size = I.size } return m.prototype.clear = l, m.prototype.delete = u, m.prototype.get = f, m.prototype.has = p, m.prototype.set = d, _Stack = m, _Stack } var _setCacheAdd, hasRequired_setCacheAdd; function require_setCacheAdd() { if (hasRequired_setCacheAdd) return _setCacheAdd; hasRequired_setCacheAdd = 1; var o = "__lodash_hash_undefined__"; function l(u) { return this.__data__.set(u, o), this } return _setCacheAdd = l, _setCacheAdd } var _setCacheHas, hasRequired_setCacheHas; function require_setCacheHas() { if (hasRequired_setCacheHas) return _setCacheHas; hasRequired_setCacheHas = 1; function o(l) { return this.__data__.has(l) } return _setCacheHas = o, _setCacheHas } var _SetCache, hasRequired_SetCache; function require_SetCache() { if (hasRequired_SetCache) return _SetCache; hasRequired_SetCache = 1; var o = require_MapCache(), l = require_setCacheAdd(), u = require_setCacheHas(); function f(p) { var d = -1, m = p == null ? 0 : p.length; for (this.__data__ = new o; ++d < m;)this.add(p[d]) } return f.prototype.add = f.prototype.push = l, f.prototype.has = u, _SetCache = f, _SetCache } var _arraySome, hasRequired_arraySome; function require_arraySome() { if (hasRequired_arraySome) return _arraySome; hasRequired_arraySome = 1; function o(l, u) { for (var f = -1, p = l == null ? 0 : l.length; ++f < p;)if (u(l[f], f, l)) return !0; return !1 } return _arraySome = o, _arraySome } var _cacheHas, hasRequired_cacheHas; function require_cacheHas() { if (hasRequired_cacheHas) return _cacheHas; hasRequired_cacheHas = 1; function o(l, u) { return l.has(u) } return _cacheHas = o, _cacheHas } var _equalArrays, hasRequired_equalArrays; function require_equalArrays() { if (hasRequired_equalArrays) return _equalArrays; hasRequired_equalArrays = 1; var o = require_SetCache(), l = require_arraySome(), u = require_cacheHas(), f = 1, p = 2; function d(m, v, I, F, B, W) { var Z = I & f, Q = m.length, re = v.length; if (Q != re && !(Z && re > Q)) return !1; var ne = W.get(m), oe = W.get(v); if (ne && oe) return ne == v && oe == m; var ae = -1, se = !0, le = I & p ? new o : void 0; for (W.set(m, v), W.set(v, m); ++ae < Q;) { var ue = m[ae], he = v[ae]; if (F) var pe = Z ? F(he, ue, ae, v, m, W) : F(ue, he, ae, m, v, W); if (pe !== void 0) { if (pe) continue; se = !1; break } if (le) { if (!l(v, function (ve, _e) { if (!u(le, _e) && (ue === ve || B(ue, ve, I, F, W))) return le.push(_e) })) { se = !1; break } } else if (!(ue === he || B(ue, he, I, F, W))) { se = !1; break } } return W.delete(m), W.delete(v), se } return _equalArrays = d, _equalArrays } var _Uint8Array, hasRequired_Uint8Array; function require_Uint8Array() { if (hasRequired_Uint8Array) return _Uint8Array; hasRequired_Uint8Array = 1; var o = require_root(), l = o.Uint8Array; return _Uint8Array = l, _Uint8Array } var _mapToArray, hasRequired_mapToArray; function require_mapToArray() { if (hasRequired_mapToArray) return _mapToArray; hasRequired_mapToArray = 1; function o(l) { var u = -1, f = Array(l.size); return l.forEach(function (p, d) { f[++u] = [d, p] }), f } return _mapToArray = o, _mapToArray } var _setToArray, hasRequired_setToArray; function require_setToArray() { if (hasRequired_setToArray) return _setToArray; hasRequired_setToArray = 1; function o(l) { var u = -1, f = Array(l.size); return l.forEach(function (p) { f[++u] = p }), f } return _setToArray = o, _setToArray } var _equalByTag, hasRequired_equalByTag; function require_equalByTag() { if (hasRequired_equalByTag) return _equalByTag; hasRequired_equalByTag = 1; var o = require_Symbol(), l = require_Uint8Array(), u = requireEq(), f = require_equalArrays(), p = require_mapToArray(), d = require_setToArray(), m = 1, v = 2, I = "[object Boolean]", F = "[object Date]", B = "[object Error]", W = "[object Map]", Z = "[object Number]", Q = "[object RegExp]", re = "[object Set]", ne = "[object String]", oe = "[object Symbol]", ae = "[object ArrayBuffer]", se = "[object DataView]", le = o ? o.prototype : void 0, ue = le ? le.valueOf : void 0; function he(pe, ve, _e, Se, $e, ie, g) { switch (_e) { case se: if (pe.byteLength != ve.byteLength || pe.byteOffset != ve.byteOffset) return !1; pe = pe.buffer, ve = ve.buffer; case ae: return !(pe.byteLength != ve.byteLength || !ie(new l(pe), new l(ve))); case I: case F: case Z: return u(+pe, +ve); case B: return pe.name == ve.name && pe.message == ve.message; case Q: case ne: return pe == ve + ""; case W: var P = p; case re: var U = Se & m; if (P || (P = d), pe.size != ve.size && !U) return !1; var K = g.get(pe); if (K) return K == ve; Se |= v, g.set(pe, ve); var Y = f(P(pe), P(ve), Se, $e, ie, g); return g.delete(pe), Y; case oe: if (ue) return ue.call(pe) == ue.call(ve) }return !1 } return _equalByTag = he, _equalByTag } var _arrayPush, hasRequired_arrayPush; function require_arrayPush() { if (hasRequired_arrayPush) return _arrayPush; hasRequired_arrayPush = 1; function o(l, u) { for (var f = -1, p = u.length, d = l.length; ++f < p;)l[d + f] = u[f]; return l } return _arrayPush = o, _arrayPush } var _baseGetAllKeys, hasRequired_baseGetAllKeys; function require_baseGetAllKeys() { if (hasRequired_baseGetAllKeys) return _baseGetAllKeys; hasRequired_baseGetAllKeys = 1; var o = require_arrayPush(), l = requireIsArray(); function u(f, p, d) { var m = p(f); return l(f) ? m : o(m, d(f)) } return _baseGetAllKeys = u, _baseGetAllKeys } var _arrayFilter, hasRequired_arrayFilter; function require_arrayFilter() { if (hasRequired_arrayFilter) return _arrayFilter; hasRequired_arrayFilter = 1; function o(l, u) { for (var f = -1, p = l == null ? 0 : l.length, d = 0, m = []; ++f < p;) { var v = l[f]; u(v, f, l) && (m[d++] = v) } return m } return _arrayFilter = o, _arrayFilter } var stubArray_1, hasRequiredStubArray; function requireStubArray() { if (hasRequiredStubArray) return stubArray_1; hasRequiredStubArray = 1; function o() { return [] } return stubArray_1 = o, stubArray_1 } var _getSymbols, hasRequired_getSymbols; function require_getSymbols() { if (hasRequired_getSymbols) return _getSymbols; hasRequired_getSymbols = 1; var o = require_arrayFilter(), l = requireStubArray(), u = Object.prototype, f = u.propertyIsEnumerable, p = Object.getOwnPropertySymbols, d = p ? function (m) { return m == null ? [] : (m = Object(m), o(p(m), function (v) { return f.call(m, v) })) } : l; return _getSymbols = d, _getSymbols } var _baseTimes, hasRequired_baseTimes; function require_baseTimes() { if (hasRequired_baseTimes) return _baseTimes; hasRequired_baseTimes = 1; function o(l, u) { for (var f = -1, p = Array(l); ++f < l;)p[f] = u(f); return p } return _baseTimes = o, _baseTimes } var _baseIsArguments, hasRequired_baseIsArguments; function require_baseIsArguments() { if (hasRequired_baseIsArguments) return _baseIsArguments; hasRequired_baseIsArguments = 1; var o = require_baseGetTag(), l = requireIsObjectLike(), u = "[object Arguments]"; function f(p) { return l(p) && o(p) == u } return _baseIsArguments = f, _baseIsArguments } var isArguments_1, hasRequiredIsArguments; function requireIsArguments() { if (hasRequiredIsArguments) return isArguments_1; hasRequiredIsArguments = 1; var o = require_baseIsArguments(), l = requireIsObjectLike(), u = Object.prototype, f = u.hasOwnProperty, p = u.propertyIsEnumerable, d = o(function () { return arguments }()) ? o : function (m) { return l(m) && f.call(m, "callee") && !p.call(m, "callee") }; return isArguments_1 = d, isArguments_1 } var isBuffer = { exports: {} }, stubFalse_1, hasRequiredStubFalse; function requireStubFalse() { if (hasRequiredStubFalse) return stubFalse_1; hasRequiredStubFalse = 1; function o() { return !1 } return stubFalse_1 = o, stubFalse_1 } isBuffer.exports; var hasRequiredIsBuffer; function requireIsBuffer() { return hasRequiredIsBuffer || (hasRequiredIsBuffer = 1, function (o, l) { var u = require_root(), f = requireStubFalse(), p = l && !l.nodeType && l, d = p && !0 && o && !o.nodeType && o, m = d && d.exports === p, v = m ? u.Buffer : void 0, I = v ? v.isBuffer : void 0, F = I || f; o.exports = F }(isBuffer, isBuffer.exports)), isBuffer.exports } var _baseIsTypedArray, hasRequired_baseIsTypedArray; function require_baseIsTypedArray() { if (hasRequired_baseIsTypedArray) return _baseIsTypedArray; hasRequired_baseIsTypedArray = 1; var o = require_baseGetTag(), l = requireIsLength(), u = requireIsObjectLike(), f = "[object Arguments]", p = "[object Array]", d = "[object Boolean]", m = "[object Date]", v = "[object Error]", I = "[object Function]", F = "[object Map]", B = "[object Number]", W = "[object Object]", Z = "[object RegExp]", Q = "[object Set]", re = "[object String]", ne = "[object WeakMap]", oe = "[object ArrayBuffer]", ae = "[object DataView]", se = "[object Float32Array]", le = "[object Float64Array]", ue = "[object Int8Array]", he = "[object Int16Array]", pe = "[object Int32Array]", ve = "[object Uint8Array]", _e = "[object Uint8ClampedArray]", Se = "[object Uint16Array]", $e = "[object Uint32Array]", ie = {}; ie[se] = ie[le] = ie[ue] = ie[he] = ie[pe] = ie[ve] = ie[_e] = ie[Se] = ie[$e] = !0, ie[f] = ie[p] = ie[oe] = ie[d] = ie[ae] = ie[m] = ie[v] = ie[I] = ie[F] = ie[B] = ie[W] = ie[Z] = ie[Q] = ie[re] = ie[ne] = !1; function g(P) { return u(P) && l(P.length) && !!ie[o(P)] } return _baseIsTypedArray = g, _baseIsTypedArray } var _baseUnary, hasRequired_baseUnary; function require_baseUnary() { if (hasRequired_baseUnary) return _baseUnary; hasRequired_baseUnary = 1; function o(l) { return function (u) { return l(u) } } return _baseUnary = o, _baseUnary } var _nodeUtil = { exports: {} }; _nodeUtil.exports; var hasRequired_nodeUtil; function require_nodeUtil() { return hasRequired_nodeUtil || (hasRequired_nodeUtil = 1, function (o, l) { var u = require_freeGlobal(), f = l && !l.nodeType && l, p = f && !0 && o && !o.nodeType && o, d = p && p.exports === f, m = d && u.process, v = function () { try { var I = p && p.require && p.require("util").types; return I || m && m.binding && m.binding("util") } catch { } }(); o.exports = v }(_nodeUtil, _nodeUtil.exports)), _nodeUtil.exports } var isTypedArray_1, hasRequiredIsTypedArray; function requireIsTypedArray() { if (hasRequiredIsTypedArray) return isTypedArray_1; hasRequiredIsTypedArray = 1; var o = require_baseIsTypedArray(), l = require_baseUnary(), u = require_nodeUtil(), f = u && u.isTypedArray, p = f ? l(f) : o; return isTypedArray_1 = p, isTypedArray_1 } var _arrayLikeKeys, hasRequired_arrayLikeKeys; function require_arrayLikeKeys() { if (hasRequired_arrayLikeKeys) return _arrayLikeKeys; hasRequired_arrayLikeKeys = 1; var o = require_baseTimes(), l = requireIsArguments(), u = requireIsArray(), f = requireIsBuffer(), p = require_isIndex(), d = requireIsTypedArray(), m = Object.prototype, v = m.hasOwnProperty; function I(F, B) { var W = u(F), Z = !W && l(F), Q = !W && !Z && f(F), re = !W && !Z && !Q && d(F), ne = W || Z || Q || re, oe = ne ? o(F.length, String) : [], ae = oe.length; for (var se in F) (B || v.call(F, se)) && !(ne && (se == "length" || Q && (se == "offset" || se == "parent") || re && (se == "buffer" || se == "byteLength" || se == "byteOffset") || p(se, ae))) && oe.push(se); return oe } return _arrayLikeKeys = I, _arrayLikeKeys } var _isPrototype, hasRequired_isPrototype; function require_isPrototype() { if (hasRequired_isPrototype) return _isPrototype; hasRequired_isPrototype = 1; var o = Object.prototype; function l(u) { var f = u && u.constructor, p = typeof f == "function" && f.prototype || o; return u === p } return _isPrototype = l, _isPrototype } var _overArg, hasRequired_overArg; function require_overArg() { if (hasRequired_overArg) return _overArg; hasRequired_overArg = 1; function o(l, u) { return function (f) { return l(u(f)) } } return _overArg = o, _overArg } var _nativeKeys, hasRequired_nativeKeys; function require_nativeKeys() { if (hasRequired_nativeKeys) return _nativeKeys; hasRequired_nativeKeys = 1; var o = require_overArg(), l = o(Object.keys, Object); return _nativeKeys = l, _nativeKeys } var _baseKeys, hasRequired_baseKeys; function require_baseKeys() { if (hasRequired_baseKeys) return _baseKeys; hasRequired_baseKeys = 1; var o = require_isPrototype(), l = require_nativeKeys(), u = Object.prototype, f = u.hasOwnProperty; function p(d) { if (!o(d)) return l(d); var m = []; for (var v in Object(d)) f.call(d, v) && v != "constructor" && m.push(v); return m } return _baseKeys = p, _baseKeys } var keys_1, hasRequiredKeys; function requireKeys() { if (hasRequiredKeys) return keys_1; hasRequiredKeys = 1; var o = require_arrayLikeKeys(), l = require_baseKeys(), u = requireIsArrayLike(); function f(p) { return u(p) ? o(p) : l(p) } return keys_1 = f, keys_1 } var _getAllKeys, hasRequired_getAllKeys; function require_getAllKeys() { if (hasRequired_getAllKeys) return _getAllKeys; hasRequired_getAllKeys = 1; var o = require_baseGetAllKeys(), l = require_getSymbols(), u = requireKeys(); function f(p) { return o(p, u, l) } return _getAllKeys = f, _getAllKeys } var _equalObjects, hasRequired_equalObjects; function require_equalObjects() { if (hasRequired_equalObjects) return _equalObjects; hasRequired_equalObjects = 1; var o = require_getAllKeys(), l = 1, u = Object.prototype, f = u.hasOwnProperty; function p(d, m, v, I, F, B) { var W = v & l, Z = o(d), Q = Z.length, re = o(m), ne = re.length; if (Q != ne && !W) return !1; for (var oe = Q; oe--;) { var ae = Z[oe]; if (!(W ? ae in m : f.call(m, ae))) return !1 } var se = B.get(d), le = B.get(m); if (se && le) return se == m && le == d; var ue = !0; B.set(d, m), B.set(m, d); for (var he = W; ++oe < Q;) { ae = Z[oe]; var pe = d[ae], ve = m[ae]; if (I) var _e = W ? I(ve, pe, ae, m, d, B) : I(pe, ve, ae, d, m, B); if (!(_e === void 0 ? pe === ve || F(pe, ve, v, I, B) : _e)) { ue = !1; break } he || (he = ae == "constructor") } if (ue && !he) { var Se = d.constructor, $e = m.constructor; Se != $e && "constructor" in d && "constructor" in m && !(typeof Se == "function" && Se instanceof Se && typeof $e == "function" && $e instanceof $e) && (ue = !1) } return B.delete(d), B.delete(m), ue } return _equalObjects = p, _equalObjects } var _DataView, hasRequired_DataView; function require_DataView() { if (hasRequired_DataView) return _DataView; hasRequired_DataView = 1; var o = require_getNative(), l = require_root(), u = o(l, "DataView"); return _DataView = u, _DataView } var _Promise, hasRequired_Promise; function require_Promise() { if (hasRequired_Promise) return _Promise; hasRequired_Promise = 1; var o = require_getNative(), l = require_root(), u = o(l, "Promise"); return _Promise = u, _Promise } var _Set, hasRequired_Set; function require_Set() { if (hasRequired_Set) return _Set; hasRequired_Set = 1; var o = require_getNative(), l = require_root(), u = o(l, "Set"); return _Set = u, _Set } var _WeakMap, hasRequired_WeakMap; function require_WeakMap() { if (hasRequired_WeakMap) return _WeakMap; hasRequired_WeakMap = 1; var o = require_getNative(), l = require_root(), u = o(l, "WeakMap"); return _WeakMap = u, _WeakMap } var _getTag, hasRequired_getTag; function require_getTag() { if (hasRequired_getTag) return _getTag; hasRequired_getTag = 1; var o = require_DataView(), l = require_Map(), u = require_Promise(), f = require_Set(), p = require_WeakMap(), d = require_baseGetTag(), m = require_toSource(), v = "[object Map]", I = "[object Object]", F = "[object Promise]", B = "[object Set]", W = "[object WeakMap]", Z = "[object DataView]", Q = m(o), re = m(l), ne = m(u), oe = m(f), ae = m(p), se = d; return (o && se(new o(new ArrayBuffer(1))) != Z || l && se(new l) != v || u && se(u.resolve()) != F || f && se(new f) != B || p && se(new p) != W) && (se = function (le) { var ue = d(le), he = ue == I ? le.constructor : void 0, pe = he ? m(he) : ""; if (pe) switch (pe) { case Q: return Z; case re: return v; case ne: return F; case oe: return B; case ae: return W }return ue }), _getTag = se, _getTag } var _baseIsEqualDeep, hasRequired_baseIsEqualDeep; function require_baseIsEqualDeep() { if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep; hasRequired_baseIsEqualDeep = 1; var o = require_Stack(), l = require_equalArrays(), u = require_equalByTag(), f = require_equalObjects(), p = require_getTag(), d = requireIsArray(), m = requireIsBuffer(), v = requireIsTypedArray(), I = 1, F = "[object Arguments]", B = "[object Array]", W = "[object Object]", Z = Object.prototype, Q = Z.hasOwnProperty; function re(ne, oe, ae, se, le, ue) { var he = d(ne), pe = d(oe), ve = he ? B : p(ne), _e = pe ? B : p(oe); ve = ve == F ? W : ve, _e = _e == F ? W : _e; var Se = ve == W, $e = _e == W, ie = ve == _e; if (ie && m(ne)) { if (!m(oe)) return !1; he = !0, Se = !1 } if (ie && !Se) return ue || (ue = new o), he || v(ne) ? l(ne, oe, ae, se, le, ue) : u(ne, oe, ve, ae, se, le, ue); if (!(ae & I)) { var g = Se && Q.call(ne, "__wrapped__"), P = $e && Q.call(oe, "__wrapped__"); if (g || P) { var U = g ? ne.value() : ne, K = P ? oe.value() : oe; return ue || (ue = new o), le(U, K, ae, se, ue) } } return ie ? (ue || (ue = new o), f(ne, oe, ae, se, le, ue)) : !1 } return _baseIsEqualDeep = re, _baseIsEqualDeep } var _baseIsEqual, hasRequired_baseIsEqual; function require_baseIsEqual() { if (hasRequired_baseIsEqual) return _baseIsEqual; hasRequired_baseIsEqual = 1; var o = require_baseIsEqualDeep(), l = requireIsObjectLike(); function u(f, p, d, m, v) { return f === p ? !0 : f == null || p == null || !l(f) && !l(p) ? f !== f && p !== p : o(f, p, d, m, u, v) } return _baseIsEqual = u, _baseIsEqual } var isEqual_1, hasRequiredIsEqual; function requireIsEqual() { if (hasRequiredIsEqual) return isEqual_1; hasRequiredIsEqual = 1; var o = require_baseIsEqual(); function l(u, f) { return o(u, f) } return isEqual_1 = l, isEqual_1 } var isEqualExports = requireIsEqual(); const isEqual = getDefaultExportFromCjs$1(isEqualExports); var __assign = function () { return __assign = Object.assign || function (l) { for (var u, f = 1, p = arguments.length; f < p; f++) { u = arguments[f]; for (var d in u) Object.prototype.hasOwnProperty.call(u, d) && (l[d] = u[d]) } return l }, __assign.apply(this, arguments) }; function __rest(o, l) { var u = {}; for (var f in o) Object.prototype.hasOwnProperty.call(o, f) && l.indexOf(f) < 0 && (u[f] = o[f]); if (o != null && typeof Object.getOwnPropertySymbols == "function") for (var p = 0, f = Object.getOwnPropertySymbols(o); p < f.length; p++)l.indexOf(f[p]) < 0 && Object.prototype.propertyIsEnumerable.call(o, f[p]) && (u[f[p]] = o[f[p]]); return u } var mapRange = function (o, l, u, f, p) { return (o - l) * (p - f) / (u - l) + f }, rotate = function (o, l) { var u = o + l; return u > 360 ? u - 360 : u }, coinFlip = function () { return Math.random() > .5 }, zAxisRotation = [0, 0, 1], rotationTransforms = [[1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 0, 0], [0, 1, 0], zAxisRotation], shouldBeCircle = function (o) { return !isEqual(rotationTransforms[o], zAxisRotation) && coinFlip() }, ROTATION_SPEED_MIN = 200, ROTATION_SPEED_MAX = 800, CRAZY_PARTICLES_FREQUENCY = .1, CRAZY_PARTICLE_CRAZINESS = .25, BEZIER_MEDIAN = .5, rotationKeyframes = rotationTransforms.reduce(function (o, l, u) { var f; return __assign(__assign({}, o), (f = {}, f["@keyframes rotation-".concat(u)] = { "50%": { transform: "rotate3d(".concat(l.map(function (p) { return p / 2 }).join(), ", 180deg)") }, "100%": { transform: "rotate3d(".concat(l.join(), ", 360deg)") } }, f)) }, {}), confettiKeyframes = function (o, l, u) { var f = typeof l == "string" ? l : "".concat(l, "px"), p = o.reduce(function (d, m, v) { var I, F = mapRange(Math.abs(rotate(m, 90) - 180), 0, 180, -u / 2, u / 2); return __assign(__assign({}, d), (I = {}, I["@keyframes x-axis-".concat(v)] = { to: { transform: "translateX(".concat(F, "px)") } }, I)) }, {}); return __assign({ "@keyframes y-axis": { to: { transform: "translateY(".concat(f, ")") } } }, p) }, confettoStyle = function (o, l, u, f, p) { var d, m = Math.round(Math.random() * (ROTATION_SPEED_MAX - ROTATION_SPEED_MIN) + ROTATION_SPEED_MIN), v = Math.round(Math.random() * (rotationTransforms.length - 1)), I = l - Math.round(Math.random() * 1e3), F = Math.random() < CRAZY_PARTICLES_FREQUENCY, B = shouldBeCircle(v), W = F ? round(Math.random() * CRAZY_PARTICLE_CRAZINESS, 2) : 0, Z = W * -1, Q = W, re = round(Math.abs(mapRange(Math.abs(rotate(o.degree, 90) - 180), 0, 180, -1, 1)), 4), ne = round(Math.random() * BEZIER_MEDIAN, 4), oe = round(Math.random() * u * (coinFlip() ? 1 : -1), 4), ae = BEZIER_MEDIAN, se = round(Math.max(mapRange(Math.abs(o.degree - 180), 0, 180, u, -u), 0), 4); return d = {}, d["&#confetti-particle-".concat(p)] = { animation: "$x-axis-".concat(p, " ").concat(I, "ms forwards cubic-bezier(").concat(W, ", ").concat(Z, ", ").concat(Q, ", ").concat(re, ")"), "& > div": { width: B ? f : Math.round(Math.random() * 4) + f / 2, height: B ? f : Math.round(Math.random() * 2) + f, animation: "$y-axis ".concat(I, "ms forwards cubic-bezier(").concat(ne, ", ").concat(oe, ", ").concat(ae, ", ").concat(se, ")"), "&:after": __assign({ backgroundColor: o.color, animation: "$rotation-".concat(v, " ").concat(m, "ms infinite linear") }, B ? { borderRadius: "50%" } : {}) } }, d }, useStyles = function (o) { var l = o.particles, u = o.duration, f = o.height, p = o.width, d = o.force, m = o.particleSize, v = l.reduce(function (I, F, B) { return __assign(__assign({}, I), confettoStyle(F, u, d, m, B)) }, {}); return createUseStyles(__assign(__assign(__assign({}, rotationKeyframes), confettiKeyframes(l.map(function (I) { return I.degree }), f, p)), { container: { width: 0, height: 0, position: "relative" }, screen: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, overflow: "hidden", pointerEvents: "none" }, particle: __assign(__assign({}, v), { "& > div": { position: "absolute", left: 0, top: 0, "&:after": { content: "''", display: "block", width: "100%", height: "100%" } } }) }), { name: "confetti-explosion" }) }, FORCE = .5, SIZE = 12, HEIGHT = "120vh", WIDTH = 1e3, PARTICLE_COUNT = 100, DURATION = 2200, COLORS = ["#FFC700", "#FF0000", "#2E3191", "#41BBC7"], createParticles = function (o, l) { var u = 360 / o; return range(o).map(function (f) { return { color: l[f % l.length], degree: u * f } }) }; function ConfettiExplosion(o) { var l = o.particleCount, u = l === void 0 ? PARTICLE_COUNT : l, f = o.duration, p = f === void 0 ? DURATION : f, d = o.colors, m = d === void 0 ? COLORS : d, v = o.particleSize, I = v === void 0 ? SIZE : v, F = o.force, B = F === void 0 ? FORCE : F, W = o.height, Z = W === void 0 ? HEIGHT : W, Q = o.width, re = Q === void 0 ? WIDTH : Q, ne = o.zIndex, oe = o.onComplete, ae = __rest(o, ["particleCount", "duration", "colors", "particleSize", "force", "height", "width", "zIndex", "onComplete"]), se = reactExports.useState(), le = se[0], ue = se[1], he = createParticles(u, m), pe = useStyles({ particles: he, duration: p, particleSize: I, force: B, width: re, height: Z })(), ve = reactExports.useCallback(function (_e) { if (_e) { var Se = _e.getBoundingClientRect(), $e = Se.top, ie = Se.left; ue({ top: $e, left: ie }) } }, []); return reactExports.useEffect(function () { if (typeof oe == "function") { var _e = setTimeout(oe, p); return function () { return clearTimeout(_e) } } }, [p, oe]), jsxRuntimeExports.jsx("div", __assign({ ref: ve, className: pe.container }, ae, { children: le && reactDomExports.createPortal(jsxRuntimeExports.jsx("div", __assign({ className: pe.screen }, ne ? { style: { zIndex: ne } } : null, { children: jsxRuntimeExports.jsx("div", __assign({ style: { position: "absolute", top: le.top, left: le.left } }, { children: he.map(function (_e, Se) { return jsxRuntimeExports.jsx("div", __assign({ id: "confetti-particle-".concat(Se), className: pe.particle }, { children: jsxRuntimeExports.jsx("div", {}) }), _e.degree) }) })) })), document.body) })) } export { BrowserRouter as $, autorun as A, Buffer as B, observer as C, clsx as D, useTranslation as E, initReactI18next as F, useNavigate as G, reactDomExports as H, AnimatePresence as I, motion as J, useLocation as K, useAnimate as L, M, NavLink as N, useSearchParams as O, useEmblaCarousel as P, ConfettiExplosion as Q, Outlet as R, flowResult as S, Trans as T, useAnimationControls as U, useParams as V, Navigate as W, Routes as X, Route as Y, ReactDOM as Z, React as _, action as a, ErrorBoundary as a0, getDefaultExportFromCjs$1 as a1, requireNaclFast as a2, process$1 as a3, cn as a4, requireDist$2 as a5, requireCryptoBrowserify as a6, requireUtil$1 as a7, requireEvents as a8, requireStreamBrowserify as a9, requireShams$1 as aa, requireCallBound as ab, requireDefineDataProperty as ac, requireHasPropertyDescriptors as ad, requireCallBind as ae, camelcaseKeys as b, computed$1 as c, runInAction as d, captureException as e, flow as f, init as g, captureConsoleIntegration as h, instance as i, setContext as j, ky as k, onBecomeObserved as l, mobxLocalStorage as m, distExports as n, observable as o, pako as p, reactExports as q, reaction as r, snakeKeys as s, t$1 as t, jsxRuntimeExports as u, computedFn as v, when as w, lottie as x, onBecomeUnobserved as y, now$2 as z };
